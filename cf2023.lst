     1                                  ; cf2023.nasm 2023 Apr 04  MD5 "roomed-zebra"
     2                                  ; Fixing Magenta Variables
     3                                  ; Added "locate" - pressing the Enter key executes the red word or locates the green word at the cursor
     4                                  ; "chm" ( check MD5 ) in colorForth shows "ff" "la:rrr" "nos" "td"
     5                                  ; colorForth for 80x86 PC for NASM , with 1024x768 and 800x600 graphics options
     6                                  ; Adapted by Howerd Oakford from code by :
     7                                  ; Chuck Moore : inventor, MASM
     8                                  ; Mark Slicker : ported to GNU Assembler
     9                                  ; Peter Appelman : ported to NASM with qwerty keyboard
    10                                  ; Josh Grams : multitasker
    11                                  ; John Comeau : BIOS boot from ClusterFix
    12                                  ; Marco Nicola : 2drop and 2dup bug fix 
    13                                  ; Miroslav Popov : keyboard instead of keypad typos
    14                                  ; and others... Thanks to all!!!
    15                                  ; Feedback welcome : howerd@inventio.co.uk www.inventio.co.uk
    16                                  
    17                                  ; %define NOT_BOCHS ; Bochs cannot handle resetting of the PIT chips, so we disable this to allow operation in Bochs
    18                                  
    19                                  ; CPU 386 ; Assemble instructions for the 386 instruction set
    20                                  
    21                                  %define FORCE_800x600_VESA  0       ; true to force 800 x 600 x 16 bits for testing in  bochs
    22                                  
    23                                  %define START_BLOCK_NUMBER      64  ; must be an even number. Note: if you change this you must shift the blocks in cf2022Ref.img accordingly!
    24                                  
    25                                  %define SIZE_OF_FONT_IN_BLOCKS  12
    26                                  %define OFFSET_OF_FONT          ( ( START_BLOCK_NUMBER - SIZE_OF_FONT_IN_BLOCKS ) * 0x400 )
    27                                  %define LAST_BLOCK_NUMBER       511 ; must be an odd number
    28                                  
    29                                  %define SECTORS_TO_LOAD ( ( LAST_BLOCK_NUMBER + 1 ) * 2 )   ; number of 512 byte sectors
    30                                  
    31                                  %define BITS_PER_PIXEL  16  ; MUST BE 16 !!! display pixel sizes, colour depth = 16 bit ( 2 bytes )
    32                                  
    33                                  ; for the maximum supported screen : 1024 x 76go8 pixels :
    34                                  %define MAX_SCREEN_WIDTH ( 1024 )   ; maximum screen width in pixels
    35                                  %define MAX_SCREEN_HEIGHT ( 768 )   ; maximum screen height in pixels
    36                                  
    37                                  %define BYTES_PER_PIXEL ( BITS_PER_PIXEL / 8 )
    38                                  
    39                                  PIXEL_SHIFT equ 1           ; how many bits to shift to scale by BYTES_PER_PIXEL
    40                                  
    41                                  ; Memory Map
    42                                  ; start   length
    43                                  ; 0x100000 ....   RAM
    44                                  ; 0xC0000 0xFFFFF BIOS video ROM - its not RAM!
    45                                  ; 0xB8000 0x08000 BIOS video RAM
    46                                  ; 0x10000 0xA8000 cf2022.img file is copied here
    47                                  ; 0x0F000 0x01000 BIOS shadow RAM - its OK to use this if we do not call the video BIOS
    48                                  ; 0x0A000 0x05000 BIOS video RAM - do not use until we have changed video mode
    49                                  ; 0x07c00 0x00200 BPB Boot sector after loading by BIOS
    50                                  ; 0x07c0b <----- di points here, the BPB ( + offset )  and variables ( - offset ) are accessed via [di]
    51                                  ; 0x07b8c 0x00080 variables referenced via [di], followed by BPB variables referenced via [di]
    52                                  ; 0x07800         Stacks, size = 0x0200 each , growing downwards
    53                                  ; 0x02000 0x06800 SECTOR_BUFFER
    54                                  ; 0x00000 0x02000 BIOS RAM
    55                                  
    56                                  %define SECTOR_BUFFER        0x00002000                     ; buffer for disk reads and writes
    57                                  %define SECTOR_BUFFER_SIZE   0x4800                         ; 18 K bytes, 36 x 512 byte sectors
    58                                  %define INTERRUPT_VECTORS    ( SECTOR_BUFFER - 0x0400 )      ; the IDT register points to these interrupt vectors
    59                                  %define VESA_BUFFER          ( INTERRUPT_VECTORS - 0x0400 ) ; for the VESA mode information
    60                                  %define DAP_BUFFER           ( VESA_BUFFER   - 0x0020 )     ; 0x1BE0 for the Int 0x13 Disk Address Packet (DAP)
    61                                  %define DISK_INFO            ( DAP_BUFFER    - 0x0020 )     ; for the Int 0x13 AH=08h get info
    62                                  %define IDT_AND_PIC_SETTINGS ( DISK_INFO     - 0x0040 )     ; bytes 0x00 - 0x05 SIDT value, 0x06 PIC1 IMR , 0x07 PIC2 IMR values saved at startup
    63                                  %define V_REGS            ( IDT_AND_PIC_SETTINGS - 0x0020 ) ; test only - registers before and after thunk call
    64                                  %define MD5_OUTPUT_BUFFER    ( V_REGS - 0x0020 )            ; the MD5 hash result
    65                                  
    66                                  %define TRASH_BUFFER         ( (508 * 0x0400) + 0x10000 )   ; Block 508, saves words deleted while editing
    67                                  
    68                                  %define PIC_BIOS_IDT_SETTINGS   ( IDT_AND_PIC_SETTINGS )   ; bytes 0x00 - 0x05 SIDT value, 0x06 PIC1 IMR , 0x07 PIC2 IMR values saved at startup
    69                                  %define PIC_BIOS_IMR_SETTINGS   ( IDT_AND_PIC_SETTINGS + 6 ) ; bytes 0x00 - 0x05 SIDT value, 0x06 PIC1 IMR , 0x07 PIC2 IMR
    70                                  
    71                                  %define PIC_NEW_IDT_SETTINGS    ( IDT_AND_PIC_SETTINGS + 0x10 )   ; bytes 0x00 - 0x05 SIDT value, 0x08 new PIC1 IMR , 0x09 new PIC2 IMR
    72                                  %define PIC_NEW_IMR_SETTINGS    ( IDT_AND_PIC_SETTINGS + 0x16 )   ; bytes 0x00 - 0x05 SIDT value, 0x08 new PIC1 IMR , 0x09 new PIC2 IMR
    73                                  
    74                                  %define IDT_AND_PIC_SETTINGS_PAD ( IDT_AND_PIC_SETTINGS + 0x20 )
    75                                  
    76                                  %define vesa_BytesPerScanLine   ( VESA_BUFFER + 0x0E )  ; screen width ( number of horizontal pixels )
    77                                  %define vesa_XResolution        ( VESA_BUFFER + 0x12 )  ; screen width ( number of horizontal pixels )
    78                                  %define vesa_YResolution        ( VESA_BUFFER + 0x14 )  ; screen height ( number of vertical pixels )
    79                                  %define vesa_BitsPerPixel       ( VESA_BUFFER + 0x19 )  ; bits per pixel
    80                                  %define vesa_SavedMode          ( VESA_BUFFER + 0x1E )  ; "Reserved" - we save the VESA mode here
    81                                  %define vesa_PhysBasePtr        ( VESA_BUFFER + 0x28 )  ; address of linear frame buffer
    82                                  
    83                                  %define BOOTOFFSET      0x7C00
    84                                  
    85                                  %assign RELOC_BIT 16                            ; the relocation address must be a power of 2
    86                                  %assign RELOCATED 1 << RELOC_BIT                ; 0x10000
    87                                  
    88                                  ; *****************************************************************************
    89                                  ; Data and Return stack allocation, four pairs of data and return stacks
    90                                  ; Note : the return stack must be in the lowest 64K byte segment, for the BIOS calls to work
    91                                  ; *****************************************************************************
    92                                  %define DATA_STACK_SIZE_0   $0400   ; 
    93                                  %define DATA_STACK_SIZE_1   $0500   ; must be > $400 for colorForth "Life" program to work
    94                                  %define DATA_STACK_SIZE_2   $0100   ; 
    95                                  %define DATA_STACK_SIZE_3   $0100   ; 
    96                                  %define DATA_STACK_SIZE_GAP $0100   ; leave space under the last data stack to check for underflow 
    97                                        
    98                                  %define RETURN_STACK_SIZE   $0100   ; 
    99                                  
   100                                  ; return stacks
   101                                  %define RETURN_STACK_0      ( $7800 )         ; top of stack memory area 
   102                                  %define RETURN_STACK_1      ( RETURN_STACK_0 - RETURN_STACK_SIZE )
   103                                  %define RETURN_STACK_2      ( RETURN_STACK_1 - RETURN_STACK_SIZE )
   104                                  %define RETURN_STACK_3      ( RETURN_STACK_2 - RETURN_STACK_SIZE )
   105                                  
   106                                  ; data stacks
   107                                  %define DATA_STACK_0        ( RETURN_STACK_3 - RETURN_STACK_SIZE )      
   108                                  %define DATA_STACK_1        ( DATA_STACK_0   - DATA_STACK_SIZE_0 ) ; BIG data stack for the show task
   109                                  %define DATA_STACK_2        ( DATA_STACK_1   - DATA_STACK_SIZE_1 ) 
   110                                  %define DATA_STACK_3        ( DATA_STACK_2   - DATA_STACK_SIZE_2 ) 
   111                                  %define STACK_MEMORY_START  ( DATA_STACK_3   - DATA_STACK_SIZE_3 - DATA_STACK_SIZE_GAP )
   112                                  
   113                                  ; four pairs of stacks, one for each task   
   114                                  %define TOTAL_STACK_SIZE    ( RETURN_STACK_0 - STACK_MEMORY_START ) 
   115                                  
   116                                  %define STACK_ANALYSIS_BUFFER    ( STACK_MEMORY_START - 0x200 ) 
   117                                  
   118                                  ; *****************************************************************************
   119                                  ; *****************************************************************************
   120                                  
   121                                  %define _TOS_  eax
   122                                  %define _TOS_x_  ax
   123                                  %define _TOS_l_  al
   124                                  
   125                                  %define _SCRATCH_  ebx
   126                                  %define _SCRATCH_x_  bx
   127                                  %define _SCRATCH_l_  bl
   128                                  
   129                                  %define _MOV_TOS_LIT_  (0xB8)   ; the opcode for mov eax, 32_bit_literal  (in next 32 bit cell)
   130                                  
   131                                  %macro _DUP_  0                 ; Top Of Stack is in the  _TOS_  register
   132                                      lea esi, [ esi - 4 ]        ; pre-decrement the stack pointer, does not set the flags
   133                                      ; sub esi, byte 0x04        ; pre-decrement the stack pointer, also sets the flags
   134                                      mov [ esi ], _TOS_          ; copy the Top Of Stack ( TOS ) register to Second On Stack ( on the real stack )
   135                                  %endmacro
   136                                  
   137                                  %macro _SWAP_  0
   138                                      xchg _TOS_, [ esi ]
   139                                  %endmacro
   140                                  
   141                                  %macro _OVER_  0
   142                                      sub esi, byte 0x04          ; pre-decrement the stack pointer
   143                                      mov [ esi ], _TOS_          ; copy the Top Of Stack ( TOS ) register to Second On Stack ( on the real stack )
   144                                      mov _TOS_, [ esi + 4 ]
   145                                  %endmacro
   146                                  
   147                                  %macro _DROP_ 0
   148                                      lodsd  ; loads a 32 bit dword from [ds:esi] into  eax  then increments  esi  by 4
   149                                  %endmacro
   150                                  ; Note : stosd ; stores  eax  into the location pointed to by  edi  then increments  edi  by 4
   151                                  ; Note also : eax is used as  _TOS_  ( Top Of Stack )
   152                                  
   153                                  ; Define the location of the wordlists in RAM 
   154                                  %define START_OF_RAM    0x00468000
   155                                  %define WORDLIST_SIZE      0x2000
   156                                  %define ForthNames      START_OF_RAM                ; copied to RAM here from ROM ( i.e. boot program ) version
   157                                  %define ForthLocates    ( ForthNames     + WORDLIST_SIZE ) ; copied to RAM here from ROM ( i.e. boot program ) version
   158                                  %define ForthJumpTable  ( ForthLocates   + WORDLIST_SIZE ) ; copied to RAM here from ROM ( i.e. boot program ) version
   159                                  %define MacroNames      ( ForthJumpTable + WORDLIST_SIZE ) ; copied to RAM here from ROM ( i.e. boot program ) version
   160                                  %define MacroJumpTable  ( MacroNames     + WORDLIST_SIZE ) ; copied to RAM here from ROM ( i.e. boot program ) version
   161                                  %define MacroLocates    ( MacroJumpTable + WORDLIST_SIZE ) ; copied to RAM here from ROM ( i.e. boot program ) version
   162                                  ; some more room...
   163                                  %define H0              0x00480000 ;  ( MacroLocates + WORDLIST_SIZE )   ; initial value of the dictionary pointer   
   164                                  
   165                                  %define SECTOR  512     ; bytes per floppy sector
   166                                  %define HEADS   2       ; heads on 1.44M floppy drive
   167                                  %define SECTORS 18      ; floppy sectors per track
   168                                  %define CYLINDER (SECTOR * SECTORS * HEADS)
   169                                  %define CELL 4          ; bytes per cell
   170                                  %define DEBUGGER 0xe1   ; port to hardware debugger?
   171                                  
   172                                  ; int 0x13 Disk Address Packet (DAP) pointed to by  si  :
   173                                  %define o_Int13_DAP_size           ( 0x00 ) ; 2  0x0010
   174                                  %define o_Int13_DAP_num_sectors    ( 0x02 ) ; 2  0x0001
   175                                  %define o_Int13_DAP_address        ( 0x04 ) ; 2  0x2000
   176                                  %define o_Int13_DAP_segment        ( 0x06 ) ; 2  0x0000
   177                                  %define o_Int13_DAP_LBA_64_lo      ( 0x08 ) ; 4  0x00000028
   178                                  %define o_Int13_DAP_LBA_64_hi      ( 0x0C ) ; 4  0x00000000
   179                                  ; extended DAP values
   180                                  %define o_Int13_DAP_readwrite      ( 0x10 ) ; 2  0x0000
   181                                  %define o_Int13_DAP_saved_DX       ( 0x12 ) ; 2  0x0000
   182                                  %define o_Int13_DAP_returned_AX    ( 0x14 ) ; 2  0xHH00 see AH Return Code below
   183                                  %define o_Int13_DAP_returned_carry_flag ( 0x16 ) ; 2  0x0000
   184                                  %define o_Int13_DAP_saved_CHS_CX   ( 0x18 ) ; 2  0x0000
   185                                  %define o_Int13_DAP_saved_CHS_DX   ( 0x1A ) ; 2  0x0000
   186                                  
   187                                  %macro LOAD_RELATIVE_ADDRESS  1
   188                                      mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
   189                                  %endmacro
   190                                  
   191                                  ; emit the given following character
   192                                  %macro EMIT_IMM 1
   193                                  ;    push esi
   194                                      _DUP_
   195                                      mov _TOS_, %1
   196                                      call emit_
   197                                  ;    pop esi
   198                                  %endmacro
   199                                  
   200                                  ; *****************************************************************************
   201                                  ; Registers used
   202                                  ; *****************************************************************************
   203                                  ; _TOS_ is the top stack item ( eax --> ebx )
   204                                  ; esp the call ... ret  return stack pointer
   205                                  ; edi  dictionary pointer ( H --> : HERE ( -- a )   H @ ; )
   206                                  ; esi is the stack pointer, also needed by lods and movs
   207                                  ; e.g. lodsd  loads a 32 bit dword from [ds:esi] into _TOS_, increments  esi  by 4
   208                                  ; ebx  scratch register
   209                                  ; ecx  counter and scratch register
   210                                  ; edx  run-time pointer (?), "a register" used by  a!  , otherwise scratch register
   211                                  ; ebp  variable pointer register
   212                                  ; "ds" = selector 0x10 ==> 0x0000:0000
   213                                  ; "es" = selector 0x10 ==> 0x0000:0000
   214                                  ; "ss" = selector 0x10 ==> 0x0000:0000
   215                                  
   216                                  ; colours RGB in 16 bits
   217                                  colour_background   equ 0x0000
   218                                  colour_yellow       equ 0xFFE0
   219                                  colour_black        equ 0x0000
   220                                  colour_red          equ 0xF800
   221                                  colour_green        equ 0x0600
   222                                  colour_cyan         equ 0x07FF
   223                                  colour_white        equ 0xFFFF
   224                                  colour_light_blue   equ 0x841F
   225                                  colour_silver       equ 0xC618
   226                                  colour_magenta      equ 0xF81F
   227                                  colour_magentaData  equ 0xD010
   228                                  colour_blue         equ 0x001F
   229                                  colour_orange       equ 0xE200
   230                                  colour_dark_yellow  equ 0xFFE0
   231                                  colour_dark_green   equ 0x07C0
   232                                  colour_PacMan       equ 0xE200
   233                                  colour_blockNumber  equ 0xE200
   234                                  
   235                                  [BITS 16]                           ; Real Mode code (16 bit)
   236                                  
   237                                  org RELOCATED
   238                                  
   239                                  start:
   240                                  codeStart:
   241 00000000 E98100                      jmp  main_16bit    ; 0x03 bytes |  EB 58 90  00 Jump to boot code
   242                                      times 3 - ($ - $$) nop        ; fill with 1 or 0 no-ops to address 3
   243                                      ; BIOS boot parameter table = 0x25 bytes
   244 00000003 6366323032322030            db 'cf2022 0'      ; 03 Eight byte OEM name
   245 0000000B 0002                        dw 0x0200          ; 11 Number of Bytes Per Sector
   246 0000000D 08                          db 0x08            ; 13 Number of Sectors Per Cluster
   247 0000000E E005                        dw 0x05E0          ; 14 Number of Reserved Sectors until the FAT
   248 00000010 02                          db 0x02            ; 16 Number of Copies of FAT : always = 2
   249 00000011 0000                        dw 0x0000          ; 17 Maximum number of Root Directory Entries
   250 00000013 0000                        dw 0x0000          ; 19 Not used for FAT32
   251 00000015 F8                          db 0xF8            ; 21 Media type F0 = 1.44M 3.5 inch floppy disk, F8 = hard disk changes 2022 Mar14
   252 00000016 0000                        dw 0x0000          ; 22 Sectors Per FAT for FAT12 and FAT16 - not used for FAT32
   253 00000018 3F00                        dw 0x003F          ; 24 Sectors per Track
   254 0000001A FF00                        dw 0x00FF          ; 26 Number of heads
   255 0000001C 38000000                    dd 0x00000038      ; 28 Hidden sectors preceding the partition that contains this FAT volume
   256 00000020 C8777400                    dd 0x007477C8      ; 32
   257 00000024 101D0000                    dd 0x00001D10      ; 36 Sectors Per FAT for FAT32
   258 00000028 0000                        dw 0x0000          ; 40
   259 0000002A 0000                        dw 0x0000          ; 42
   260 0000002C 02000000                    dd 0x00000002      ; 44 Start of all directories, including root.
   261 00000030 0100                        dw 0x0001          ; 48
   262 00000032 0600                        dw 0x0006          ; 50 Offset in sectors from this sector to the backup BPB sector
   263                                  ;    times 12 db 0      ; 0x0C bytes |  00 00 00 00 00 00 00 00 00 00 00 00  52
   264                                  ;    db 0x00            ; 64
   265                                  ;    db 0x00            ; 65
   266                                  ;    db 0x29            ; 66 Extended Boot Signature
   267                                  ;    dd 0x44444444      ; 67 serial number
   268                                  ;    db 'colorForth '   ; 71 Eleven byte Volume Label
   269                                  ;    db 'cFblocks'      ; 82 Eight byte File System name
   270                                  
   271                                  ; ******************************************************************************
   272                                  ; ******************************************************************************
   273                                  
   274 00000034 90<rep 4h>              align 8, nop    ; has to be aligned to 8 for GDT
   275                                      ; Note : we are NOT using null descriptor as GDT descriptor, see: http://wiki.osdev.org/GDT_Tutorial
   276                                      ; "The null descriptor which is never referenced by the processor. Certain emulators, like Bochs, will complain about limit exceptions if you do not have one present.
   277                                      ; Some use this descriptor to store a pointer to the GDT itself (to use with the LGDT instruction).
   278                                      ; The null descriptor is 8 bytes wide and the pointer is 6 bytes wide so it might just be the perfect place for this."
   279                                  
   280                                  gdt:                                ; the GDT descriptor
   281 00000038 2F00                        dw gdt_end - gdt - 1            ; GDT limit
   282 0000003A [407C]                      dw gdt0 + BOOTOFFSET            ; pointer to start of table, low 16 bits
   283 0000003C 00000000                    dw 0 , 0                        ; the high bits of the longword pointer to gdt
   284                                  
   285                                  gdt0:                               ; null descriptor
   286 00000040 0000                        dw 0    ; 0,1 limit 15:0
   287 00000042 0000                            dw 0    ; 2,3 base  15:0
   288 00000044 00                              db 0    ; 4   base  23:16
   289 00000045 00                              db 0    ; 5   type
   290 00000046 00                              db 0    ; 6   limit 19:16, flags
   291 00000047 00                              db 0    ; 7   base  31:24
   292                                  code32p_SELECTOR_0x08 equ $ - gdt0
   293                                  ; bytes   1 0     3 2     5 4     7 6
   294 00000048 FFFF0000009ACF00            dw 0xFFFF, 0x0000, 0x9A00, 0x00CF   ; 32-bit protected-mode code, limit 0xFFFFF
   295                                  data32p_SELECTOR_0x10 equ $ - gdt0
   296 00000050 FFFF00000092CF00            dw 0xFFFF, 0x0000, 0x9200, 0x00CF   ; 32-bit protected-mode data, limit 0xFFFFF
   297                                  code16r_SELECTOR_0x18 equ $ - gdt0
   298 00000058 FFFF0000009A0000            dw 0xFFFF, 0x0000, 0x9A00, 0x0000   ; 16-bit real-mode code, limit 0xFFFFF
   299                                  data16r_SELECTOR_0x20 equ $ - gdt0
   300 00000060 FFFF000000920000            dw 0xFFFF, 0x0000, 0x9200, 0x0000   ; 16-bit real-mode data, limit 0xFFFFF
   301                                  gdt_end:
   302                                  
   303                                  ; ******************************************************************************
   304                                  ; ******************************************************************************
   305                                  
   306                                  ; align to 4 so we can access variables from high-level Forth
   307                                  align 4, nop
   308                                  
   309                                  data_area:   ; data area begins here
   310                                  
   311                                  bootsector:                         ; LBA of boot sector
   312 00000068 00000000                    dd 0
   313                                  
   314                                  ; save disk information, cylinder, sector, head and drive from BIOS call
   315                                  driveinfo_Drive_DX:                 ; use low byte to store boot Drive into from BIOS DL
   316 0000006C 0000                        dw 0
   317                                  
   318                                  driveinfo_CX:         ; [7:6] [15:8][7] logical last index of cylinders = number_of - 1 (because index starts with 0)
   319                                                        ; [5:0][7] logical last index of sectors per track = number_of (because index starts with 1)
   320 0000006E 0000                        dw 0
   321                                  
   322                                  ; cylinders, sectors, heads of boot drive
   323                                  ; low word: high byte is head
   324                                  ; high word: cylinder and sector: C76543210 C98S543210
   325                                  driveinfo_Cylinder:
   326 00000070 00                          db 0
   327                                  driveinfo_Head:
   328 00000071 00                          db 0
   329                                  driveinfo_SectorsPertrack:
   330 00000072 0000                        dw 0
   331                                  
   332                                  align 4, nop
   333                                  
   334                                  destination:
   335 00000074 00000100                    dd RELOCATED
   336                                  
   337                                  dispPtr:
   338 00000078 40010000                    dd 0x00000140
   339                                  
   340                                  v_bytesPerLine:
   341 0000007C 00000000                    dd 0x00
   342                                  
   343                                  v_scanCode:
   344 00000080 00000000                    dd 0x00
   345                                  
   346                                  align 4
   347                                  
   348                                  ; ******************************************************************************
   349                                  ; the main program called from initial 16 bit mode
   350                                  ; ******************************************************************************
   351                                  
   352                                  main_16bit:
   353                                  
   354 00000084 FA                          cli                         ; clear interrupts
   355                                                                  ; turns out we don't need interrupts at all, even when using BIOS routines
   356                                                                  ; but we need to turn them off after disk calls because BIOS leaves them on
   357                                  
   358 00000085 56                          push si                     ; need to transfer SI to unused register BX later
   359                                  
   360                                  ; note: cannot touch DX or BP registers until we've checked for partition boot
   361                                  ; (SI could be used as well as BP but we use SI for relocation)
   362                                  
   363                                   ;see mbrboot.nasm
   364                                                                  ; Note : relocate the bootblock before we do anything else
   365 00000086 5B                          pop bx                      ; we cannot use the current stack after changing SS or SP
   366                                                                  ; ... because mbrboot.nasm places stack at 0x7c00, in SECTOR_BUFFER
   367                                                                  ; and we cannot use BP because its default segment is SS
   368 00000087 31C0                        xor ax, ax
   369 00000089 8ED8                        mov ds, ax
   370 0000008B 8EC0                        mov es, ax
   371                                  
   372 0000008D BE007C                      mov si, BOOTOFFSET
   373 00000090 BF0020                      mov di, SECTOR_BUFFER
   374 00000093 89FC                        mov sp, di
   375 00000095 B90001                      mov cx, 0x100
   376 00000098 F3A5                        rep movsw                   ; note that this instruction doesn't change AX , it moves DS:SI to ES:DI and increments SI and DI
   377                                  
   378 0000009A 8ED0                        mov ss, ax                  ; stack segment also zero
   379 0000009C B4B8                        mov ah, 0xb8                ; video RAM
   380 0000009E 8EE8                        mov gs, ax                  ; store in unused segment register
   381                                  
   382 000000A0 0F0116387C                  lgdt [gdt - $$ + BOOTOFFSET]
   383                                  
   384 000000A5 E82E01                      call SetupUnrealMode     ; gs and ss must be initialized before going to Unreal Mode
   385                                  
   386                                  ; *****************************************************************************
   387                                  ; Enable the A20 address line, otherwise all odd 1 MByte pages are disabled
   388                                  ; Using the "PS/2 Controller" or 8042 "Keyboard controller"
   389                                  ; *****************************************************************************
   390                                      ; from  http://wiki.osdev.org/%228042%22_PS/2_Controller#Step_1:_Initialise_USB_Controllers
   391                                      ; Write a command to the on-board 8042 "Keyboard controller" port 0x64 :
   392                                      ; 0x20     Read "byte 0" from internal RAM     Controller Configuration Byte
   393                                      ; 0x21 to 0x3F    Read "byte N" from internal RAM (where 'N' is the command byte & 0x1F)
   394                                      ; 0x60    Write next byte to "byte 0" of internal RAM (Controller Configuration Byte)
   395                                      ; 0x61 to 0x7F    Write next byte to "byte N" of internal RAM (where 'N' is the command byte & 0x1F)
   396                                      ; 0xA7    Disable second PS/2 port
   397                                      ; 0xA8    Enable second PS/2 port
   398                                      ; 0xA9    Test second PS/2 port
   399                                      ;     0x00 test passed
   400                                      ;     0x01 clock line stuck low
   401                                      ;     0x02 clock line stuck high
   402                                      ;     0x03 data line stuck low
   403                                      ;     0x04 data line stuck high
   404                                      ; 0xAA    Test PS/2 Controller
   405                                      ;     0x55 test passed
   406                                      ;     0xFC test failed
   407                                      ; 0xAB    Test first PS/2 port
   408                                      ;     0x00 test passed
   409                                      ;     0x01 clock line stuck low
   410                                      ;     0x02 clock line stuck high
   411                                      ;     0x03 data line stuck low
   412                                      ;     0x04 data line stuck high
   413                                      ; 0xAC    Diagnostic dump (real all bytes of internal RAM)    Unknown
   414                                      ; 0xAD    Disable first PS/2 port     None
   415                                      ; 0xAE    Enable first PS/2 port  None
   416                                      ; 0xC0    Read controller input port  Unknown (none of these bits have a standard/defined purpose)
   417                                      ; 0xC1    Copy bits 0 to 3 of input port to status bits 4 to 7    None
   418                                      ; 0xC2    Copy bits 4 to 7 of input port to status bits 4 to 7    None
   419                                      ; 0xD0    Read Controller Output Port     Controller Output Port (see below)
   420                                      ; 0xD1    Write next byte to Keyboard Controller Output Port Note: Check if output buffer is empty first
   421                                      ; 0xD2    Write next byte to first PS/2 port output buffer
   422                                      ; 0xD3    Write next byte to second PS/2 port output buffer
   423                                      ; 0xD4    Write next byte to second PS/2 port input buffer
   424                                      ; 0xF0 to 0xFF  Pulse output line low for 6 ms.
   425                                      ;     Bits 0 to 3 are used as a mask (0 = pulse line, 1 = do not pulse line) and correspond to 4 different output lines.
   426                                      ;     Bit 0 is the "reset" line, active low.
   427 000000A8 B0D1                        mov al, 0xD1    ; 0xD1 = Write next byte to Keyboard Controller Output Port
   428 000000AA E664                        out 0x64, al    ; On-board controller Command Write
   429                                  .back:
   430 000000AC E464                        in al, 0x64
   431 000000AE 2402                        and al, 0x02
   432 000000B0 75FA                        jnz .back
   433 000000B2 B04B                        mov al, 0x4B
   434 000000B4 E660                        out 0x60, al
   435                                  
   436                                  ; *****************************************************************************
   437                                  ; Get disk drive parameters from the BIOS
   438                                  ; *****************************************************************************
   439                                  
   440 000000B6 BF687C                      mov di, (data_area - $$ + BOOTOFFSET)   ; setup the data index pointer
   441 000000B9 6631C0                      xor eax, eax
   442 000000BC 660FBAE810                  bts eax, 16                     ; in case NOT booted from partition: sector 1, head 0, cylinder 0
   443 000000C1 08F6                        or dh, dh                       ; booted from partition?
   444 000000C3 740B                        jz .forward3
   445 000000C5 668B4708                    mov eax, [ bx + 8 ]             ; SI (now BX) contains pointer to partition record
   446 000000C9 66894500                    mov [ byte di + (bootsector - data_area) ], eax     ; offset 8 was LBA of first absolute sector
   447 000000CD 668B07                      mov eax, [bx]                   ; CHS of first sector in partition
   448                                  .forward3:
   449 000000D0 88D0                        mov al, dl                      ; bootdrive into AL
   450 000000D2 6689850400                  mov [ word di + ( driveinfo_Drive_DX - data_area) ], eax    ; save the Drive info from BIOS
   451 000000D7 B408                        mov ah, 8                       ; get drive parameters
   452 000000D9 06                          push es                         ; this operation messes with ES
   453 000000DA 57                          push di                         ; and DI
   454 000000DB BFC017                      mov di, DISK_INFO               ; point di at the table returned by this software interrupt
   455 000000DE CD13                        int 0x13
   456 000000E0 72FE                        jc $                            ; stop here on error
   457                                  
   458 000000E2 E80601                      call ReSetupUnrealMode
   459 000000E5 5F                          pop di
   460 000000E6 07                          pop es
   461                                  
   462                                  ; ******************************************************************************
   463                                  ; load the bootdisk into both low and high RAM
   464                                  ; ******************************************************************************
   465                                  
   466 000000E7 895508                      mov [ byte di + ( driveinfo_Cylinder - data_area) ], dx             ; heads in high byte
   467 000000EA 80E13F                      and cl, 0x3F                    ; we don't care about two high bits of cylinder count
   468 000000ED 894D0A                      mov [ byte di + ( driveinfo_SectorsPertrack - data_area) ], cx     ; cylinders and sectors/track
   469 000000F0 8B5504                      mov dx, [ byte di + ( driveinfo_Drive_DX - data_area) ]         ; restore dl Drive value from BIOS, dh = 0
   470                                  ;    mov dl, 0x00    ; try this 2022 Mar 14
   471 000000F3 8B4D06                      mov cx, [ di + ( driveinfo_CX - data_area) ]               ; restore cl value, ch = 0
   472 000000F6 BE0004                      mov si, SECTORS_TO_LOAD
   473                                  
   474 000000F9 BB0020                      mov bx, SECTOR_BUFFER            ; relocate the sector we are running from
   475 000000FC E89800                      call relocate
   476                                  
   477 000000FF BB007C                      mov bx, BOOTOFFSET              ; we will fix this below by adding 0x200
   478                                                                      ; remember the sector is 1-based, head and cylinder both 0-based
   479                                  
   480                                  .nextsector:
   481 00000102 FEC1                        inc cl
   482 00000104 4E                          dec si
   483 00000105 747D                        jz setVideoMode    ; success, so setup the video now...
   484                                  
   485                                  .bootload:
   486 00000107 B80102                      mov ax, 0x201                   ; read 1 sector
   487 0000010A 80C702                      add bh, 0x02                    ; into next available slot in RAM
   488 0000010D 7503                        jnz .forward
   489 0000010F 80EF02                      sub bh, 0x02                    ; at 0x10000 we go back to 0xfe00
   490                                  .forward:
   491 00000112 CD13                        int 0x13
   492 00000114 E8D400                      call ReSetupUnrealMode
   493 00000117 72FE                        jc $                            ; stop here on error
   494 00000119 E87B00                      call relocate
   495 0000011C 88C8                        mov al, cl
   496 0000011E 243F                        and al, 0x3F                    ; low 6 bits
   497 00000120 3A450A                      cmp al, [ byte di + ( driveinfo_SectorsPertrack - data_area) ]
   498 00000123 75DD                        jnz .nextsector
   499 00000125 FEC6                        inc dh                          ; next head
   500 00000127 3A7509                      cmp dh, [ byte di + ( driveinfo_Head - data_area) ]
   501 0000012A 7609                        jna .forward2                   ; not JNZ, the head index is 1 less than head count
   502 0000012C 30F6                        xor dh, dh
   503 0000012E FEC5                        inc ch                          ; next cylinder
   504 00000130 7503                        jnz .forward2
   505 00000132 80C140                      add cl, 0x40                    ; bit 8 of cylinder count
   506                                  .forward2:
   507 00000135 80E1C0                      and cl, 0xC0                    ; clear sector count, low 6 bits of cl
   508 00000138 EBC8                        jmp short .nextsector
   509                                  
   510                                  ; ******************************************************************************
   511                                  ; ******************************************************************************
   512                                  ; Start here after loading the program
   513                                  ; ******************************************************************************
   514                                  ; ******************************************************************************
   515                                  
   516                                  ; From : VESA BIOS EXTENSION (VBE) Core Functions Standard Version: 3.0 Date: September 16, 1998
   517                                  ; Mandatory information for all VBE revisions
   518                                  ; dw ModeAttributes         ; 0x00 mode attributes
   519                                  ; db WinAAttributes         ; 0x02 window A attributes
   520                                  ; db WinBAttributes         ; 0x03 window B attributes
   521                                  ; dw WinGranularity         ; 0x04 window granularity
   522                                  ; dw WinSize                ; 0x06 window size
   523                                  ; dw WinASegment            ; 0x08 window A start segment
   524                                  ; dw WinBSegment            ; 0x0A window B start segment
   525                                  ; dd WinFuncPtr             ; 0x0C real mode pointer to window function
   526                                  ; dw BytesPerScanLine       ; 0x10 bytes per scan line               <--------------
   527                                  ; Mandatory information for VBE 1.2 and above
   528                                  ; dw XResolution            ; 0x12 horizontal resolution in pixels   <-------------- scrnw
   529                                  ; dw YResolution            ; 0x14 vertical resolution in pixels     <-------------- scrnh
   530                                  ; db XCharSize              ; 0x16 character cell width in pixels
   531                                  ; db YCharSize              ; 0x17 character cell height in pixels
   532                                  ; db NumberOfPlanes         ; 0x18 number of memory planes
   533                                  ; db BitsPerPixel           ; 0x19 bits per pixel                    <-------------- bpp
   534                                  ; db NumberOfBanks          ; 0x1A number of banks
   535                                  ; db MemoryModel            ; 0x1B memory model type
   536                                  ; db BankSize               ; 0x1C bank size in KB
   537                                  ; db NumberOfImagePages     ; 0x1D number of images
   538                                  ; db Reserved               ; 0x1E reserved for page function        <-------------- mode (we copy it here)
   539                                  ; Direct Color fields (required for direct/6 and YUV/7 memory models)
   540                                  ; db RedMaskSize            ; 0x1F size of direct color red mask in bits
   541                                  ; db RedFieldPosition       ; 0x20 bit position of lsb of red mask
   542                                  ; db GreenMaskSize          ; 0x21 size of direct color green mask in bits
   543                                  ; db GreenFieldPosition     ; 0x22 bit position of lsb of green mask
   544                                  ; db BlueMaskSize           ; 0x23 size of direct color blue mask in bits
   545                                  ; db BlueFieldPosition      ; 0x24 bit position of lsb of blue mask
   546                                  ; db RsvdMaskSize           ; 0x25 size of direct color reserved mask in bits
   547                                  ; db RsvdFieldPosition      ; 0x26 bit position of lsb of reserved mask
   548                                  ; db DirectColorModeInfo    ; 0x27 direct color mode attributes
   549                                  ; Mandatory information for VBE 2.0 and above
   550                                  ; dd PhysBasePtr            ; 0x28 physical address for flat memory frame buffer  <-------------- vframe
   551                                  ; dd Reserved               ; 0x2C Reserved - always set to 0
   552                                  ; dw Reserved               ; 0x30 Reserved - always set to 0
   553                                  ; Mandatory information for VBE 3.0 and above
   554                                  ; dw LinBytesPerScanLine    ; 0x32 bytes per scan line for linear modes
   555                                  ; db BnkNumberOfImagePages  ; 0x34 number of images for banked modes
   556                                  ; db LinNumberOfImagePages  ; 0x35 number of images for linear modes
   557                                  ; db LinRedMaskSize         ; 0x36 size of direct color red mask (linear modes)
   558                                  ; db LinRedFieldPosition    ; 0x37 bit position of lsb of red mask (linear modes)
   559                                  ; db LinGreenMaskSize       ; 0x38 size of direct color green mask  (linear modes)
   560                                  ; db LinGreenFieldPosition  ; 0x39 bit position of lsb of green mask (linear modes)
   561                                  ; db LinBlueMaskSize        ; 0x3A size of direct color blue mask  (linear modes)
   562                                  ; db LinBlueFieldPosition   ; 0x3B bit position of lsb of blue mask (linear modes)
   563                                  ; db LinRsvdMaskSize        ; 0x3C size of direct color reserved mask (linear modes)
   564                                  ; db LinRsvdFieldPosition   ; 0x3D bit position of lsb of reserved mask (linear modes)
   565                                  ; dd MaxPixelClock          ; 0x3E maximum pixel clock (in Hz) for graphics mode
   566                                  ; times 189 db 0            ; 0x42 remainder of ModeInfoBlock
   567                                  ; End                       ; 0xFF
   568                                  
   569                                  scanVESA:   ; ( w+h+b -- )  in ax
   570 0000013A 89C3                        mov bx, ax
   571 0000013C 57                          push di                         ; save di
   572 0000013D B91641                      mov cx, ( 0x4117 - 1 )          ; start scanning from the expected VESA mode 0x4117 ( the -1 is because of the  inc cx  below )
   573                                  .back:
   574 00000140 FEC1                        inc cl                          ; increment just the bottom byte, we test 0x41xx
   575 00000142 80F916                      cmp cl, 0x16                    ; scanned from 0x4117 to 0x4116, not found, so show error
   576 00000145 741B                        jz .failure
   577 00000147 BF0018                      mov di, VESA_BUFFER             ; buffer for the VESA mode information block
   578 0000014A B8014F                      mov ax, 0x4F01                  ; INT 0x10, AX=0x4F01, CX=mode Get Mode Info
   579 0000014D CD10                        int 0x10
   580 0000014F 3C4F                        cmp al, 0x4F                    ; success code = 0x4F
   581 00000151 75ED                        jne .back                       ; try the next VESA mode
   582 00000153 8B4512                      mov ax, [di + 0x12]             ; width
   583 00000156 034514                      add ax, [di + 0x14]             ; height
   584 00000159 024519                      add al, [di + 0x19]             ; bits per pixel
   585                                  ;    adc ah, 0                       ; should not be necessary for the expected result, 0x400+0x300+0x10
   586 0000015C 39D8                        cmp ax, bx                      ; width + height + bits per pixel
   587 0000015E 740A                        je .success
   588 00000160 75DE                        jne .back                       ; try the next VESA mode
   589                                  .failure:                           ; VESA mode not found, so continue
   590 00000162 5F                          pop di                          ; restore di
   591 00000163 B80000                      mov ax, 0                       ; return flag false
   592 00000166 050000                      add ax, 0                       ; set the zero flag
   593 00000169 C3                          ret
   594                                  .success:
   595 0000016A 894D1E                      mov [ di + ( vesa_SavedMode - VESA_BUFFER ) ], cx ; save the VESA mode in the VESA_BUFFER at offset 0x1E "Reserved"
   596 0000016D B80100                      mov ax, 1                       ; return flag true
   597 00000170 050000                      add ax, 0                       ; set the zero flag
   598 00000173 5F                          pop di                          ; restore di
   599 00000174 C3                          ret
   600                                  
   601                                  setVESA:    ; we found a valid VESA mode
   602                                  
   603 00000175 1E                          push ds                         ; clear all flags including Interrupt using DS, known to be zero
   604 00000176 9D                          popf                            ; this is necessary to clear T flag also, end register display
   605                                  
   606 00000177 E8E000                      call greet      ; show greeting message
   607                                  
   608 0000017A 89CB                        mov bx, cx
   609 0000017C B8024F                      mov ax, 0x4F02  ; INT 0x10, AX=0x4F02, BX=mode, ES:DI=CRTCInfoBlock Set Video Mode
   610 0000017F CD10                        int 0x10
   611                                  
   612 00000181 E9E400                      jmp main_32bit
   613                                  
   614                                  setVideoMode:
   615                                  %if ( FORCE_800x600_VESA == 0 )     ; test the 800x600 mode in bochs, which supports 1024x768
   616 00000184 B81007                      mov ax, ( 1024 + 768 + BITS_PER_PIXEL ) ; try the highest resolution first
   617 00000187 E8B0FF                      call scanVESA                   ; if VESA mode is found, jump to setVESA
   618 0000018A 75E9                        jnz setVESA                     ; success - we found the requested VESA mode
   619                                  %endif
   620 0000018C B88805                      mov ax, ( 800 + 600 + BITS_PER_PIXEL ) ; then try a lower resolution
   621 0000018F E8A8FF                      call scanVESA                   ; if VESA mode is found, jump to setVESA
   622 00000192 75E1                        jnz setVESA                     ; success - we found the requested VESA mode
   623                                  
   624                                  ;    mov ax, 640 + 480 + BITS_PER_PIXEL  ; then try an even lower resolution
   625                                  ;    call scanVESA                   ; if VESA mode is found, jump to setVESA
   626                                  ;    jnz setVESA                     ; success - we found the requested VESA mode
   627 00000194 E9B200                      jmp showVESAerror               ; we have tried all VESA modes without success, so report an error
   628                                  
   629                                  ; ******************************************************************************
   630                                  ; ******************************************************************************
   631                                  
   632                                  relocate:                   ; copy 512 bytes from  [bx]  to FS:[destination]
   633 00000197 60                          pusha
   634 00000198 B90001                      mov cx, 0x200 / 2
   635 0000019B 89DE                        mov si, bx
   636 0000019D 668B5D0C                    mov ebx, [ byte di + ( destination - data_area) ]
   637                                  .back:
   638 000001A1 AD                          lodsw               ; load the 16 bit value pointed to by SI into  ax
   639 000001A2 64678903                    mov [fs:ebx], ax    ; Note : the  fs:  uses the 32 bit FS value setup in Unreal Mode to move the data outside of the 1 Mbyte Real Mode address range
   640 000001A6 6683C302                    add ebx, byte +2
   641 000001AA E2F5                        loop .back
   642                                  
   643 000001AC 66895D0C                    mov [ byte di + ( destination - data_area) ], ebx
   644 000001B0 61                          popa
   645 000001B1 C3                          ret
   646                                  
   647                                      ; not used because it is very slow :
   648                                  ; now set up for trap displaying registers on screen during bootup
   649                                  ;    push cs
   650                                  ;    push showstate - $$ + BOOTOFFSET
   651                                  ;    pop dword [word +4]
   652                                  
   653                                  ; ******************************************************************************
   654                                  ; ******************************************************************************
   655                                  ;1. MasterBoot Record - MBR   at Sector     0 (decimal 0)        MBR
   656                                  ; Partition at offset 1BE
   657                                  ;   BootSignature                0
   658                                  ;   Start Head|Sector|Cylinder   1   1     0
   659                                  ;   Partition Type               B  DOS 7.1+
   660                                  ;   End   Head|Sector|Cylinder  FE  3F   3E5
   661                                  ;   BPBsectorNumber                   00  \ was 3F
   662                                  ;   Size of partition (decimal)  16035777 sectors,  8210317824 bytes,  8017889 Ki bytes,  7830 Mi bytes,  8 Gi bytes
   663                                  ; Partition at offset 1CE
   664                                  ;   BootSignature                0
   665                                  ;   Start Head|Sector|Cylinder   0   0     0
   666                                  ;   Partition Type               0  Empty partition
   667                                  ;   End   Head|Sector|Cylinder   0   0     0
   668                                  ;   BPBsectorNumber                    0
   669                                  ;   Size of partition (decimal)         0 sectors,           0 bytes,  0 Ki bytes,  0 Mi bytes,
   670                                  
   671                                  ; pretend to be a Master Boot Record so that the BIOS will load us
   672 000001B2 77<rep Ch>              times ( 0x000001BE - ( $ - $$ ) ) db 0x77
   673 000001BE 800101000BFEFFE500-         db 0x80, 0x01, 0x01, 0x00, 0x0B, 0xFE, 0xFF, 0xE5, 0x00, 0x00, 0x00, 0x00, 0xC1, 0xAF, 0xF4, 0x00 ; 0x1BE DOS partition 0  working on PC
   673 000001C7 000000C1AFF400     
   674 000001CE 0000000000000000            db 00, 00, 00, 00, 00, 00, 00, 00   ; 0x1CE first 8 bytes of empty partition 1
   675                                  
   676                                  SetupUnrealMode:
   677                                      ; set the FS segment in "unreal" mode, must be done before the Trap Flag is set in EFLAGS register
   678 000001D6 0F20C0                      mov eax, cr0
   679 000001D9 0C01                        or al, 1    ; set the "protected mode enable" bit => "unreal mode"
   680 000001DB 0F22C0                      mov cr0, eax
   681 000001DE 681000                      push word data32p_SELECTOR_0x10 ; set the FS segment
   682 000001E1 0FA1                        pop fs
   683 000001E3 FEC8                        dec al      ; clear the "protected mode enable" bit
   684 000001E5 0F22C0                      mov cr0, eax
   685 000001E8 1E                          push ds                         ; now set FS to 0
   686 000001E9 0FA1                        pop fs
   687                                  
   688                                  ReSetupUnrealMode:
   689 000001EB 0E                          push cs                         ; for iret
   690 000001EC 9C                          pushf                           ; for iret
   691 000001ED 60                          pusha
   692 000001EE 89E5                        mov bp, sp
   693 000001F0 8B4610                      mov ax, [bp + 16]               ; get flags
   694                                  ;    or ah, 0x01                    ; set Trap Flag, bit 8 in the EFLAGS register ; debug only - very slow!
   695 000001F3 80E4FD                      and ah, ~0x02                   ; reset interrupt flag
   696 000001F6 874614                      xchg ax, [ bp + 20 ]            ; swap flags with return address
   697 000001F9 894610                      mov [ bp + 16 ], ax             ; return address at top of stack after popa
   698 000001FC 61                          popa
   699 000001FD CF                          iret
   700                                  
   701                                  ; ******************************************************************************
   702                                  ; ******************************************************************************
   703                                  
   704                                  times 512 - 2 - ($ - $$) nop        ; fill with no-ops to 55AA at end of boot sector
   705 000001FE 55AA                        db 0x55 , 0xAA  ; boot sector terminating bytes
   706                                  
   707                                  ; ******************************************************************************
   708                                  ; End of Boot Sector
   709                                  ; ******************************************************************************
   710                                  
   711                                  ; ******************************************************************************
   712                                  ; Show the user a null terminated string - writes directly into video RAM
   713                                  ; ******************************************************************************
   714                                  
   715                                  displayString:
   716                                  
   717                                      ; restore the pointer to screen memory into di
   718 00000200 BF687C                      mov di, (data_area - $$ + BOOTOFFSET)
   719 00000203 8B4510                      mov ax, [ di + ( dispPtr - data_area) ]
   720 00000206 89C7                        mov di, ax
   721                                  
   722 00000208 06                          push es             ; save es
   723 00000209 B800B8                      mov ax, 0xb800      ; video RAM segment
   724 0000020C 8EC0                        mov es, ax
   725                                  
   726                                  backhere2:
   727 0000020E AC                          lodsb               ; loads a byte from [ds:si] into al, then increments  si
   728 0000020F 3C00                        cmp al, 0
   729 00000211 7406                        jz forward1         ; If al = 0 then leave the loop
   730 00000213 B40D                        mov ah, 0x0D        ; text colour, magenta on black background
   731 00000215 AB                          stosw               ; stores  ax  into  [es:di]  then increments  di
   732 00000216 E9F5FF                      jmp backhere2
   733                                  forward1:
   734                                      ; save the pointer to screen memory from di
   735 00000219 89F8                        mov ax, di
   736 0000021B BF687C                      mov di, (data_area - $$ + BOOTOFFSET)
   737 0000021E 894510                      mov [ di + ( dispPtr - data_area) ], ax
   738 00000221 07                          pop es          ; restore es
   739 00000222 C3                          ret
   740                                  
   741                                  ; display a string then Wait for a key press
   742                                  displayStringW:
   743                                  
   744 00000223 60                          pusha
   745 00000224 E8D9FF                      call displayString
   746                                  
   747 00000227 31C0                        xor  ax, ax     ; wait for and get a key press ( AX = 0 )
   748 00000229 CD16                        int  0x16       ; BIOS interrupt Read a Key From the Keyboard
   749 0000022B 61                          popa
   750 0000022C C3                          ret
   751                                  
   752                                  ; msg_greeting2:
   753                                  ;     db ' Press any key : ' , 0x00
   754                                  
   755                                  msg_VESAerror:
   756 0000022D 4E6F2076616C696420-         db 'No valid VESA mode found! ' , 0x02, 0x00
   756 00000236 56455341206D6F6465-
   756 0000023F 20666F756E64212002-
   756 00000248 00                 
   757                                  ;    db ' No VESA mode ' , 0x02, 0x00
   758                                  
   759                                  [BITS 16]                           ; Real Mode code (16 bit)
   760                                  
   761                                  showVESAerror:
   762 00000249 E80E00                      call greet
   763 0000024C 56                          push si
   764 0000024D C74510E001                  mov word [ di + ( dispPtr - data_area) ] , 0x000001E0    ; line 3 0x50 x 2 x 3 = 0x1E0
   765 00000252 BE2D7E                      mov si, ( msg_VESAerror - $$ + BOOTOFFSET )  ; string to display
   766 00000255 E8CBFF                      call displayStringW
   767 00000258 5E                          pop si
   768 00000259 C3                          ret
   769                                  
   770                                  greet:     ; jump here to show 16 bit version text
   771 0000025A 56                          push si
   772 0000025B C745104001                  mov word [ di + ( dispPtr - data_area) ] , 0x00000140    ; line 2 0x50 x 2 x 2 = 0x140
   773 00000260 BE0080                      mov si, ( version - $$ + BOOTOFFSET )  ; string to display
   774 00000263 E89AFF                      call displayString
   775                                  ;    mov si, ( msg_greeting2 - $$ + BOOTOFFSET )  ; string to display
   776                                  ;    call displayStringW
   777 00000266 5E                          pop si
   778 00000267 C3                          ret
   779                                  
   780                                  ; ******************************************************************************
   781                                  ; the main program in 32 bit ( protected ) mode
   782                                  ; ******************************************************************************
   783                                  
   784                                  main_32bit:
   785                                  
   786 00000268 E88200                      call setProtectedModeAPI        ; called from 16 bit code, returns in 32 bit code
   787                                  
   788                                  [BITS 32]                           ; Protected Mode code (32 bit) - assemble for 32 bit mode from now on
   789                                  
   790 0000026B BC00780000                  mov esp, RETURN_STACK_0         ; setup the return stack pointer
   791 00000270 BE04740000                  mov esi, ( DATA_STACK_0 + 4 )   ; setup our data stack pointer
   792                                  
   793 00000275 E877370000                  call save_BIOS_idt_and_pic      ; to be restored later, when making BIOS calls
   794 0000027A E8F8370000                  call init_default_PIC_IMRs      ; set the default values and copy the BIOS Interrupt Vectors to our new table
   795                                      _DUP_
   132 0000027F 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00000282 8906                <1>  mov [ esi ], _TOS_
   796 00000284 B8001C0000                  mov _TOS_, INTERRUPT_VECTORS
   797 00000289 E81D370000                  call lidt_                      ; Load the new Interrupt Descriptor Table
   798                                  
   799 0000028E E9C1300000                  jmp dword warm
   800                                  
   801                                  ; *****************************************************************************
   802                                  ; calculate Cylinder, Head and Sector from zero-based sector number
   803                                  ; see http://teaching.idallen.com/dat2343/00f/calculating_cylinder.htm
   804                                  ; Note : uses pushad to copy registers onto the ESP stack, stores the
   805                                  ; calculated values onto the stack at the correct offsets, then restores the
   806                                  ; stack back to the registers.
   807                                  ; *****************************************************************************
   808                                  
   809                                  sector_chs:  ; ( sector -- eax ) calculate CHS from a sector number in eax,
   810                                      ; returns with DX = HHDD, CX = CCSS where HH=head, DD=drive, CC=cylinder, SS=sector
   811                                      ; Note that the input sector number is zero based, and that the high 16 bits of EAX must be 0
   812 00000293 60                          pushad  ; Pushes all general purpose registers onto the stack in the following order:
   813                                          ; EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI. The value of ESP is the value before the actual push of ESP
   814                                          ;  7    6    5    4    3    2    1    0   offset in cells from ESP
   815 00000294 89E5                        mov ebp, esp    ; copy the original ESP stack pointer to EBP so we can access items on the stack easily
   816                                  
   817                                      ; save the register values in the DAP buffer for use later, via ESI
   818 00000296 BEE0170000                  mov esi, DAP_BUFFER
   819                                  
   820 0000029B 0305687C0000                add eax, [ bootsector - $$ + BOOTOFFSET]
   821 000002A1 50                          push eax                            ; save it while we calculate heads*sectors-per-track
   822 000002A2 A0717C0000                  mov al, [ driveinfo_Head - $$ + BOOTOFFSET]      ; index of highest-numbered head
   823 000002A7 FEC0                        inc al                              ; 1-base the number to make count of heads
   824 000002A9 F625727C0000                mul byte [ driveinfo_SectorsPertrack - $$ + BOOTOFFSET]     ; sectors per track
   825 000002AF 89C3                        mov ebx, eax
   826 000002B1 58                          pop eax
   827 000002B2 31D2                        xor edx, edx                        ; clear high 32 bits
   828 000002B4 F7F3                        div ebx                             ; leaves cylinder number in eax, remainder in edx
   829 000002B6 89C1                        mov ecx, eax                        ; store cylinder number in another register
   830 000002B8 89D0                        mov eax, edx                        ; get remainder into AX
   831 000002BA 8A1D727C0000                mov bl, [ driveinfo_SectorsPertrack - $$ + BOOTOFFSET]      ; number of sectors per track
   832 000002C0 F6F3                        div bl                              ; head number into AX, remainder into DX
   833 000002C2 88C3                        mov bl, al                          ; result must be one byte, so store it in BL
   834 000002C4 C1C108                      rol ecx, 8                          ; high 2 bits of cylinder number into high 2 bits of CL
   835 000002C7 C0E106                      shl cl, 6                           ; makes room for sector number
   836 000002CA 08E1                        or cl, ah                           ; merge cylinder number with sector number
   837 000002CC FEC1                        inc cl                              ; one-base sector number
   838 000002CE 894D18                      mov [ ebp + ( 6 * 4 ) ], ecx        ; store the result in ECX position on esp stack
   839 000002D1 66894E18                    mov word [ esi + o_Int13_DAP_saved_CHS_CX ], cx  ; also save the calculated CX value
   840 000002D5 668B0D6C7C0000              mov cx, [ driveinfo_Drive_DX - $$ + BOOTOFFSET]    ; drive number in low 8 bits
   841 000002DC 88DD                        mov ch, bl                          ; place head number in high bits
   842                                  ;    mov cl, 0x80
   843 000002DE 894D14                      mov [ ebp + ( 5 * 4 ) ], ecx    ; store the result in EDX position on esp stack
   844 000002E1 66894E1A                    mov word [ esi + o_Int13_DAP_saved_CHS_DX ], cx  ; also save the calculated DX value
   845 000002E5 61                          popad                           ; restore registers from esp stack
   846 000002E6 C3                          ret
   847                                  
   848                                  ; *****************************************************************************
   849                                  ; enter Protected Mode (32 bit) and Real Mode (16 bit)
   850                                  ; from http://ringzero.free.fr/os/protected%20mode/Pm/PM1.ASM
   851                                  ; *****************************************************************************
   852                                  
   853                                  [BITS 16]   ; Real Mode code (16 bit)
   854                                  
   855                                  enterProtectedMode:                 ; must come from a 'call' , can not be inlined
   856 000002E7 58                          pop ax
   857 000002E8 680800                      push code32p_SELECTOR_0x08
   858 000002EB 50                          push ax
   859 000002EC CB                          retf
   860                                  
   861                                  setProtectedModeAPI:                ; set protected mode from 'Real' mode. Called from 16 bit code, returns to 32 bit code
   862 000002ED 6660                        pushad                          ; save all registers as doublewords
   863 000002EF 0F20C0                      mov eax, cr0
   864 000002F2 0C01                        or al, 1
   865 000002F4 0F22C0                      mov cr0, eax                    ; set the Protected Mode bit in the Control Register
   866 000002F7 6631C0                      xor eax, eax                    ; clear high bits of eax
   867 000002FA E8EAFF                      call enterProtectedMode
   868                                  
   869                                  [BITS 32]                           ; Protected Mode code (32 bit)
   870                                  
   871 000002FD B810000000                  mov eax, data32p_SELECTOR_0x10  ; Protected Mode data segment
   872 00000302 668EC0                      mov es, ax
   873 00000305 668ED8                      mov ds, ax
   874 00000308 668ED0                      mov ss, ax                      ; this makes stack segment 32 bits
   875 0000030B 61                          popad
   876 0000030C 66C3                        o16 ret
   877                                  
   878                                  enter16bitProtectedMode:            ; 32 bit code. Must come from a 'call' , can not be inlined
   879 0000030E 58                          pop eax                         ; return address
   880 0000030F 6818000000                  push dword code16r_SELECTOR_0x18    ; select 16-bit Protected Mode AKA 'Real' Mode
   881 00000314 50                          push eax
   882 00000315 CB                          retf
   883                                  
   884                                  setRealModeAPI:                     ; set 'Real' mode from protected mode.
   885                                                                      ; Called from 32 bit code, returns to 16 bit code
   886                                                                      ; assumed that protected-mode stack is based at 0
   887                                                                      ; and that bits 16 through 19 will not change during time in realmode
   888 00000316 60                          pushad                          ; save 32-bit values of registers
   889 00000317 89E1                        mov ecx, esp                    ; do all possible 32-bit ops before going to 16 bits
   890 00000319 0F20C2                      mov edx, cr0
   891 0000031C E8EDFFFFFF                  call enter16bitProtectedMode
   892                                  
   893                                  [BITS 16]                           ; Real Mode code (16 bit)
   894                                  
   895 00000321 B82000                      mov ax, data16r_SELECTOR_0x20
   896 00000324 8ED8                        mov ds, ax
   897 00000326 8EC0                        mov es, ax
   898 00000328 8ED0                        mov ss, ax                      ; here the stack becomes 16 bits based at 0, and SP used not ESP
   899                                                                      ; *** consider stack to be invalid from here until we reach real mode ***
   900 0000032A 31C9                        xor cx, cx                      ; clear low 16 bits
   901 0000032C 66C1E904                    shr ecx, 4                      ; move high 4 bits into cl
   902 00000330 FECA                        dec dl                          ; leave protected mode, only works if we KNOW bit 0 is set
   903 00000332 0F22C2                      mov cr0, edx
   904 00000335 E80C00                      call enterRealMode
   905 00000338 31C0                        xor ax, ax
   906 0000033A 8ED8                        mov ds, ax
   907 0000033C 8EC0                        mov es, ax
   908 0000033E 8ED1                        mov ss, cx
   909                                      ; note we don't need to set SP to 8xxx if ESP is b8xxx, since
   910                                      ; the b000 is now in SS, and the b of b8xxx is ignored in real mode
   911 00000340 6661                        popad
   912 00000342 66C3                        o32 ret
   913                                  
   914                                  enterRealMode:                      ; 16 bit code. Must come from a 'call' , can not be inlined
   915 00000344 58                          pop ax
   916 00000345 0FA0                        push fs                         ; real-mode code segment
   917 00000347 50                          push ax
   918 00000348 CB                          retf
   919                                  
   920                                  [BITS 32]                           ; Protected Mode code (32 bit)
   921                                  
   922                                  ; *****************************************************************************
   923                                  ; *****************************************************************************
   924                                  
   925                                  ;%include "JCreadwrite.nasm"
   926                                  ; JCreadwrite.nasm 2012 Oct 23   read and write the disk using 16 bit BIOS calls
   927                                  ; BIOS read and write routines for colorForth
   928                                  
   929                                  [BITS 32]                           ; Protected Mode code (32 bit)
   930                                  
   931                                  bios_read:  ; ( a c -- a' c' )   \  read cylinder c into address a , leave next address and cylinder
   932                                                                      ; c is cylinder, we will use 1.44Mb floppy's idea of cylinder regardless
   933                                                                      ; a is byte address
   934                                                                      ; leave updated c and a on stack as c' and a'
   935                                                                      ; a cylinder is 36 tracks of 512 bytes each, 0x4800 bytes, 0x1200 cells (words)
   936                                  
   937 00000349 FA                          cli                             ; disable interrupts
   938 0000034A 60                          pushad                          ; push all registers ( except esp ) and flags onto the stack
   939 0000034B 89E5                        mov ebp, esp                    ; copy of stack pointer for use below ( * ), points to registers copied by pushad , above
   940                                  
   941 0000034D B924000000                  mov ecx, HEADS * SECTORS        ; sectors per track (both heads)
   942 00000352 F6E1                        mul cl                          ; sector number goes into AX
   943                                                                      ; note that resultant sector number is zero-based going into sector_chs!
   944                                                                      ; set up loop to read one floppy cylinder's worth
   945                                  
   946 00000354 50                          push eax                        ; absolute sector number to start
   947                                  .back:
   948 00000355 51                          push ecx
   949 00000356 E838FFFFFF                  call sector_chs                 ; convert to Cylinder-Head-Sector in CX-DX
   950 0000035B E81F000000                  call .readsector
   951                                  
   952 00000360 8B5D04                      mov ebx, [ ebp + ( 1 * 4 ) ]    ; ( * ) get ESI stored on stack, via stack pointer saved in ebp
   953 00000363 8B3B                        mov edi, [ebx]                  ; destination index address for movsd
   954 00000365 B980000000                  mov ecx, ( 512 >> 2 )           ; number of 32-bit words to move, 512 bytes
   955 0000036A BE00200000                  mov esi, SECTOR_BUFFER          ; source index for movsd
   956 0000036F F3A5                        rep  movsd                      ; copy ecx 32 bit words from ds:esi to es:edi
   957 00000371 893B                        mov [ebx], edi
   958 00000373 59                          pop ecx
   959 00000374 58                          pop eax
   960 00000375 40                          inc eax
   961 00000376 50                          push eax
   962 00000377 E2DC                        loop .back
   963 00000379 58                          pop eax
   964 0000037A FF451C                      inc dword [ebp + 7 * 4]         ; for updated cylinder number after return
   965 0000037D 61                          popad
   966 0000037E C3                          ret
   967                                  
   968                                  .readsector:                        ; no need to save registers because we take care of them in calling routine
   969 0000037F E892FFFFFF                  call setRealModeAPI
   970                                  [BITS 16]                           ; Real Mode code (16 bit)
   971 00000384 BB0020                      mov bx, SECTOR_BUFFER
   972 00000387 B80102                      mov ax, 0x0201                  ; read 1 sector
   973 0000038A CD13                        int 0x13
   974 0000038C FA                          cli                             ; BIOS might have left interrupts enabled
   975 0000038D E85DFF                      call setProtectedModeAPI        ; called from 16 bit code, returns to 32 bit code
   976                                  [BITS 32]                           ; Protected Mode code (32 bit)
   977 00000390 C3                          ret
   978                                  
   979                                  bios_write:     ; ( a c -- a' c' )   \  write cylinder c from address a , leave next address and cylinder
   980 00000391 FA                          cli                             ; disable interrupts
   981 00000392 60                          pushad
   982 00000393 89E5                        mov ebp, esp
   983                                                                      ; eax contains cylinder to start, the 'c' parameter
   984 00000395 B924000000                  mov ecx, HEADS * SECTORS        ; sectors per track (both heads)
   985 0000039A F6E1                        mul cl                          ; absolute sector number goes into AX
   986                                  
   987 0000039C 8B5D04                      mov ebx, [ebp + ( 1 * 4 ) ]     ; stored ESI on stack
   988 0000039F 8B33                        mov esi, [ebx]                  ; word address, 'a' parameter
   989                                  ;        shl esi, 2                 ; change word address into byte address
   990                                                                      ; set up loop to write one floppy cylinder's worth
   991 000003A1 50                          push eax                        ; absolute sector number to start
   992                                  
   993                                  .back:
   994 000003A2 51                          push ecx
   995                                                                      ; load sector data into buffer
   996                                                                      ; DO NOT take advantage of knowing ECX only has byte value
   997 000003A3 B980000000                  mov ecx, 128 ; ( 512 >> 2 )     ; number of 32-bit words to move
   998 000003A8 BF00200000                  mov edi, SECTOR_BUFFER
   999 000003AD F3A5                        rep  movsd                      ; copy ecx 32 bit words from ds:esi to es:edi
  1000 000003AF E8DFFEFFFF                  call sector_chs                 ; convert to Cylinder-Head-Sector in CX-DX
  1001 000003B4 E811000000                  call .writesector
  1002 000003B9 59                          pop ecx
  1003 000003BA 58                          pop eax
  1004 000003BB 40                          inc eax
  1005 000003BC 50                          push eax
  1006 000003BD E2E3                        loop .back
  1007 000003BF 58                          pop eax
  1008 000003C0 FF451C                      inc dword [ ebp + ( 7 * 4 ) ]   ; for updated cylinder after return (EAX)
  1009 000003C3 8B5D04                      mov ebx, [ ebp + ( 1 * 4 ) ]    ; stored ESI on stack
  1010 000003C6 8933                        mov [ebx], esi                  ; updated address
  1011 000003C8 61                          popad
  1012 000003C9 C3                          ret
  1013                                  
  1014                                  .writesector:                       ; no need to save registers because we take care of them in calling routine
  1015 000003CA E847FFFFFF                  call setRealModeAPI
  1016                                  [BITS 16]                           ; Real Mode code (16 bit)
  1017 000003CF BB0020                      mov bx, SECTOR_BUFFER
  1018 000003D2 B80103                      mov ax, 0x0301                  ; write 1 sector
  1019 000003D5 CD13                        int 0x13
  1020 000003D7 FA                          cli                             ; BIOS might have left interrupts enabled
  1021 000003D8 E812FF                      call setProtectedModeAPI        ; called from 16 bit code, returns to 32 bit code
  1022                                  [BITS 32]                           ; Protected Mode code (32 bit)
  1023 000003DB C3                          ret
  1024                                  
  1025 000003DC 90<rep 24h>              times (0x400 - ($ - $$)) nop
  1026                                  
  1027                                  ; *****************************************************************************
  1028                                  ; *****************************************************************************
  1029                                  ; After Two Sectors
  1030                                  ; *****************************************************************************
  1031                                  ; *****************************************************************************
  1032                                  
  1033                                  version:
  1034 00000400 636632303233203176-         db 'cf2023 1v0 2023Apr04 Chuck Moore' , 0x00    ; 0x20 + 1 bytes
  1034 00000409 302032303233417072-
  1034 00000412 303420436875636B20-
  1034 0000041B 4D6F6F726500       
  1035 00000421 20486F77657264204F-         db ' Howerd Oakford inventio.co.uk' ,  0x00     ; 0x1E + 1 bytes, total 0x40
  1035 0000042A 616B666F726420696E-
  1035 00000433 76656E74696F2E636F-
  1035 0000043C 2E756B00           
  1036                                  
  1037                                  nul:                ; do nothing...
  1038 00000440 C3                          ret
  1039                                  
  1040                                  ; *****************************************************************************
  1041                                  ; Co-operative multi-tasker with comments from code by Josh Grams
  1042                                  ; *****************************************************************************
  1043                                  
  1044                                  ; This version of colorforth has three tasks; main (the quit loop),
  1045                                  ; draw (user defined), and serve (also user defined).  Each has two
  1046                                  ; grows-down stacks.  A suffix of 's' indicates the return stack, 'd'
  1047                                  ; indicates the data stack.  Thus 'draws' and 'drawd' are the tops of
  1048                                  ; the return and data stacks, respectively, for the draw task.
  1049                                  
  1050                                  ; When we switch tasks, we need to switch stacks as well.  We do this
  1051                                  ; by pushing eax (cached top-of-stack) onto the data stack, pushing
  1052                                  ; the data stack pointer onto the return stack, and then saving the
  1053                                  ; return stack pointer into the save slot for the task.
  1054                                  
  1055                                  ; 'me' points to the save slot for the current task
  1056                                  me: 
  1057 00000441 [73040000]                  dd main
  1058                                  x_screenTask:
  1059 00000445 [40040000]                  dd nul
  1060                                  x_serverTask:
  1061 00000449 [40040000]                  dd nul
  1062                                  x_serverTask2:
  1063 0000044D [40040000]                  dd nul
  1064                                  
  1065                                  pause_:
  1066                                      _DUP_
   132 00000451 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00000454 8906                <1>  mov [ esi ], _TOS_
  1067 00000456 56                          push esi
  1068 00000457 A1[41040000]                mov _TOS_, [ me ]               ; points to main at startup
  1069 0000045C 8920                        mov [_TOS_], esp
  1070 0000045E 83C004                      add _TOS_, byte 0x04
  1071 00000461 FFE0                        jmp _TOS_
  1072                                  
  1073                                  resume:
  1074 00000463 58                          pop _TOS_
  1075 00000464 8B20                        mov esp, [_TOS_]
  1076 00000466 A3[41040000]                mov [ me ], _TOS_
  1077 0000046B 5E                          pop esi
  1078                                      _DROP_
   148 0000046C AD                  <1>  lodsd
  1079 0000046D C3                          ret
  1080                                  
  1081                                  ; these are the save slots - each is followed by code to resume the
  1082                                  ; next task - the last one jumps 'round to the first.
  1083                                  round:
  1084 0000046E E8F0FFFFFF                  call resume
  1085                                  main:                               ; main task
  1086 00000473 00000000                    dd 0                            ; new stack location
  1087 00000477 E8E7FFFFFF                  call resume
  1088                                  draw:                               ; screen draw task
  1089 0000047C 00000000                    dd 0                            ; new stack location
  1090 00000480 E8DEFFFFFF                  call resume
  1091                                  serv1:                               ; server task
  1092 00000485 00000000                    dd 0                            ; new stack location
  1093 00000489 E8D5FFFFFF                  call resume
  1094                                  serv2:                              ; server task 2
  1095 0000048E 00000000                    dd 0                            ; new stack location
  1096 00000492 EBDA                        jmp short round                 ; loop forever between 3 stacks 
  1097                                  
  1098                                  activate:   ; ( a -- )    \ activate the draw task to execute colorForth code at the given address
  1099 00000494 BAFC6F0000                  mov edx, DATA_STACK_1 - 4
  1100 00000499 890A                        mov [edx], ecx
  1101 0000049B B9FC760000                  mov ecx, RETURN_STACK_1 - 4
  1102 000004A0 8F01                        pop dword [ecx]
  1103 000004A2 8D49FC                      lea ecx, [ ecx - 0x04 ]
  1104 000004A5 8911                        mov [ecx], edx
  1105 000004A7 890D[7C040000]              mov dword [ draw ], ecx
  1106                                      _DROP_
   148 000004AD AD                  <1>  lodsd
  1107 000004AE C3                          ret
  1108                                  
  1109                                  show:   ; ( -- )    \ set the screen task to execute the code following  show
  1110 000004AF 8F05[45040000]              pop dword [ x_screenTask ]      ; copy the return address of the calling word into the screenTask variable
  1111                                      _DUP_
   132 000004B5 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000004B8 8906                <1>  mov [ esi ], _TOS_
  1112 000004BA 31C0                        xor _TOS_, _TOS_
  1113 000004BC E8D3FFFFFF                  call activate
  1114                                  .back:
  1115 000004C1 E840060000                  call graphAction                ; perform a graphical update
  1116 000004C6 FF15[45040000]              call [ x_screenTask ]           ; execute the code that called show, saved on entry
  1117 000004CC E8CB0A0000                  call switch                     ; copy the screen image to the VESA buffer
  1118 000004D1 31C0                        xor _TOS_, _TOS_
  1119 000004D3 E879FFFFFF                  call pause_
  1120 000004D8 40                          inc _TOS_
  1121 000004D9 EBE6                        jmp short .back
  1122                                  
  1123                                  initshow:                           ; called by warm
  1124 000004DB E8CFFFFFFF                  call show
  1125                                      ; <--- this address ( on the return stack from the preceding call ) goes into  x_screenTask
  1126 000004E0 C3                          ret                             ; makes this a no-op "show"
  1127                                  
  1128                                  freeze:
  1129 000004E1 8F05[45040000]              pop dword [ x_screenTask ]
  1130                                      _DUP_
   132 000004E7 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000004EA 8906                <1>  mov [ esi ], _TOS_
  1131 000004EC 31C0                        xor _TOS_, _TOS_
  1132 000004EE E8A1FFFFFF                  call activate
  1133                                  .back:
  1134                                      ; call graphAction                ; perform a graphical update
  1135 000004F3 FF15[45040000]              call [ x_screenTask ]           ; execute the code that called show, saved on entry
  1136                                      ; call switch                     ; copy the screen image to the VESA buffer
  1137 000004F9 31C0                        xor _TOS_, _TOS_
  1138 000004FB E851FFFFFF                  call pause_
  1139 00000500 40                          inc _TOS_
  1140 00000501 EBF0                        jmp short .back
  1141                                  
  1142                                  ; *****************************************************************************
  1143                                  ; ; Server task 1
  1144                                  ; *****************************************************************************
  1145                                  
  1146                                  activate1:  ; ( a -- )    \ activate the server task to execute colorForth code at the given address
  1147 00000503 BAFC6A0000                  mov edx, DATA_STACK_2 - 4
  1148 00000508 890A                        mov [edx], ecx
  1149 0000050A B9FC750000                  mov ecx, RETURN_STACK_2 - 4
  1150 0000050F 8F01                        pop dword [ecx]
  1151 00000511 8D49FC                      lea ecx, [ ecx - 0x04 ]
  1152 00000514 8911                        mov [ecx], edx
  1153 00000516 890D[85040000]              mov [ serv1 ], ecx
  1154                                      _DROP_
   148 0000051C AD                  <1>  lodsd
  1155 0000051D C3                          ret
  1156                                  
  1157                                  serv1_:
  1158 0000051E 8F05[49040000]              pop dword [ x_serverTask ]
  1159 00000524 E8DAFFFFFF                  call activate1
  1160                                  .back:
  1161                                      ; call graphAction                ; perform a graphical update
  1162 00000529 FF15[49040000]              call [ x_serverTask ]           ; execute the code that called show, saved on entry
  1163                                      ; call switch                     ; copy the screen image to the VESA buffer
  1164 0000052F 31C0                        xor _TOS_, _TOS_
  1165 00000531 E81BFFFFFF                  call pause_
  1166 00000536 40                          inc _TOS_
  1167 00000537 EBF0                        jmp short .back
  1168                                  
  1169                                  initserv1_:
  1170 00000539 E8E0FFFFFF                  call serv1_
  1171 0000053E C3                          ret
  1172                                  
  1173                                  ; *****************************************************************************
  1174                                  ; Server task 2
  1175                                  ; *****************************************************************************
  1176                                  
  1177                                  activate2:  ; ( a -- )    \ activate the server task to execute colorForth code at the given address
  1178 0000053F BAFC690000                  mov edx, DATA_STACK_3 - 4
  1179 00000544 890A                        mov [edx], ecx
  1180 00000546 B9FC740000                  mov ecx, RETURN_STACK_3 - 4
  1181 0000054B 8F01                        pop dword [ecx]
  1182 0000054D 8D49FC                      lea ecx, [ ecx - 0x04 ]
  1183 00000550 8911                        mov [ecx], edx
  1184 00000552 890D[8E040000]              mov [ serv2 ], ecx
  1185                                      _DROP_
   148 00000558 AD                  <1>  lodsd
  1186 00000559 C3                          ret  
  1187                                      
  1188                                  serv2_:
  1189 0000055A 8F05[4D040000]              pop dword [ x_serverTask2 ]
  1190 00000560 E8DAFFFFFF                  call activate2
  1191                                  .back:
  1192                                      ; call graphAction              ; perform a graphical update
  1193 00000565 FF15[4D040000]              call [ x_serverTask2 ]          ; execute the code that called show, saved on entry
  1194                                      ; call switch                   ; copy the screen image to the VESA buffer
  1195 0000056B 31C0                        xor _TOS_, _TOS_
  1196 0000056D E8DFFEFFFF                  call pause_
  1197 00000572 40                          inc _TOS_
  1198 00000573 EBF0                        jmp short .back
  1199                                  
  1200                                  initserv2_:
  1201 00000575 E8E0FFFFFF                  call serv2_
  1202 0000057A C3                          ret
  1203                                  
  1204                                  ; *****************************************************************************
  1205                                  ; *****************************************************************************
  1206                                  
  1207                                  c_:     ; ( -- )   \ clear the data stack for keyboard task
  1208 0000057B BE04740000                  mov esi, ( DATA_STACK_0 + 4 )
  1209 00000580 C3                          ret
  1210                                  
  1211                                  ; *****************************************************************************
  1212                                  ; *****************************************************************************
  1213                                  
  1214                                  mark:
  1215 00000581 8B0D[AC480000]              mov ecx, [ v_MacroWordCount]
  1216 00000587 890D[64480000]              mov [ mark_MacroWordCount], ecx
  1217 0000058D 8B0D[A8480000]              mov ecx, [ v_ForthWordCount ]
  1218 00000593 890D[68480000]              mov [ mark_v_ForthWordCount], ecx
  1219 00000599 8B0D[B0480000]              mov ecx, [ v_BlueWordCount ]
  1220 0000059F 890D[6C480000]              mov [ mark_v_BlueWordCount], ecx
  1221 000005A5 8B0D[74480000]              mov ecx, [ v_H ]
  1222 000005AB 890D[70480000]              mov [ mark_H ], ecx
  1223 000005B1 C3                          ret
  1224                                  
  1225                                  empty_:
  1226 000005B2 FA                          cli                             ; disable interrupts
  1227 000005B3 E881FFFFFF                  call initserv1_                 ; we must set the server tasks to their Nop loop 
  1228 000005B8 E8B8FFFFFF                  call initserv2_                 ; because the code that they might be running will soon be gone...
  1229 000005BD 8B0D[70480000]              mov ecx, [ mark_H ]
  1230 000005C3 890D[74480000]              mov [ v_H ], ecx
  1231 000005C9 8B0D[6C480000]              mov ecx, [ mark_v_BlueWordCount]
  1232 000005CF 890D[B0480000]              mov [ v_BlueWordCount ], ecx
  1233 000005D5 8B0D[68480000]              mov ecx, [ mark_v_ForthWordCount]
  1234 000005DB 890D[A8480000]              mov [ v_ForthWordCount ], ecx
  1235 000005E1 8B0D[64480000]              mov ecx, [ mark_MacroWordCount]
  1236 000005E7 890D[AC480000]              mov [ v_MacroWordCount ], ecx
  1237 000005ED C3                          ret
  1238                                  
  1239                                  ; *****************************************************************************
  1240                                  ; *****************************************************************************
  1241                                  
  1242                                  mfind:  ; ( sf -- )   \ ecx = index ; find the Shannon-Fano word sf in the Macro wordlist, return its index in ecx
  1243 000005EE 8B0D[AC480000]              mov ecx, [ v_MacroWordCount ]   ; count of Macro wordlist words
  1244 000005F4 57                          push edi
  1245 000005F5 8D3C8DFCDF4600              lea edi, [ ( ecx * 4 ) + MacroNames - 4 ]
  1246 000005FC EB0E                        jmp short ffind
  1247                                  
  1248                                  find_:   ; ( sf -- )   \ ecx = index ; find the Shannon-Fano word sf in the Forth wordlist, return its index in ecx
  1249 000005FE 8B0D[A8480000]              mov ecx, [ v_ForthWordCount ]   ; count of Forth wordlist words
  1250 00000604 57                          push edi
  1251 00000605 8D3C8DFC7F4600              lea edi, [ ( ecx * 4 ) + ForthNames - 4 ]   ; set edi to the top of the Forth name table
  1252                                  ffind:
  1253 0000060C FD                          std                    ; scan backwards
  1254 0000060D F2AF                        repne scasd            ; find the 32 bit Shanon-Fano encoded name, compare eax with doubleword at es:edi and set status flags.
  1255 0000060F FC                          cld                    ; reset the direction flag
  1256 00000610 5F                          pop edi
  1257 00000611 C3                          ret
  1258                                  
  1259                                  ; *****************************************************************************
  1260                                  ; *****************************************************************************
  1261                                  
  1262                                  abort_:
  1263 00000612 FF25[0C480000]              jmp dword [ x_abort ]
  1264                                  
  1265                                  ; *****************************************************************************
  1266                                  ; compile drop - inline compilation of a single byte 'lodsd' :
  1267                                  ;   loads a 32 bit dword from [ds:esi] into  eax  then increments  esi  by 4
  1268                                  ; *****************************************************************************
  1269                                  
  1270                                  cdrop:
  1271 00000618 8B15[74480000]              mov edx, [ v_H ]                ; HERE into edx
  1272 0000061E 8915[A0480000]              mov [ v_lastAddress ], edx      ; save HERE into v_lastAddress
  1273 00000624 C602AD                      mov byte [edx], 0xAD            ; 0xAD is the opcode for 'lodsd' = _DROP_
  1274 00000627 FF05[74480000]              inc dword [ v_H ]               ; increment HERE
  1275 0000062D C3                          ret
  1276                                  
  1277                                  ; *****************************************************************************
  1278                                  ; adup , dup and qdup
  1279                                  ; *****************************************************************************
  1280                                  
  1281                                  ;  1147                                      _DUP_
  1282                                  ;  1148 000004E7 8D76FC              <1>  lea esi, [ esi - 4 ]
  1283                                  ;  1150 000004EA 8906                <1>  mov [ esi ], _TOS_
  1284                                  adup:
  1285                                      _DUP_   ; runtime action of the  _DUP_  macro_
   132 0000062E 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00000631 8906                <1>  mov [ esi ], _TOS_
  1286 00000633 C3                          ret
  1287                                  
  1288                                  cdup:   ; compile the action of the  _DUP_  macro_
  1289 00000634 8B15[74480000]              mov edx, [ v_H ]
  1290                                  ; this code sets the flags
  1291                                  ;    mov dword [edx], 0x8904EE83     ; assemble the instruction sequence for  DUP  "sub esi, byte 0x04" , "mov [esi], eax"
  1292                                  ; this code does not set the flags
  1293 0000063A C7028D76FC89                mov dword [edx], 0x89FC768D     ; assemble the instruction sequence for  DUP  "lea esi, [ esi - 4 ]" , "mov [esi], eax"
  1294 00000640 C6420406                    mov byte [ edx + 4 ], 0x06      ;  "8d 76 fc" , "89 06" ( the first 4 are expressed in little endian format above )
  1295 00000644 8305[74480000]05            add dword [ v_H ], byte 0x05    ; update HERE by the 5 bytes we have just compiled
  1296 0000064B C3                          ret
  1297                                  
  1298                                  ; qdup is a Macro word that optimises what would be a compiled sequence of  DROP  DUP  into doing nothing
  1299                                  qdup:   ; compile a DUP unless we have just compiled a  DROP  , in which case just delete the  DROP. 
  1300 0000064C 8B15[74480000]              mov edx, [ v_H ]                ; look at HERE
  1301 00000652 4A                          dec edx                         ; step back one byte
  1302 00000653 3915[A0480000]              cmp dword [ v_lastAddress ], edx ; test if we have just compiled one byte in the current word
  1303 00000659 75D9                        jnz cdup                        ; if we have just compiled one byte, compile in the runtime code for  DUP  after this one byte
  1304 0000065B 803AAD                      cmp byte [edx], 0xAD            ; test if we have just compiled a DROP, 0xAD is the opcode for 'lodsd' = _DROP_
  1305 0000065E 75D4                        jnz cdup                        ; if we have not just compiled a DROP, compile in the runtime code for  DUP  after this one byte
  1306 00000660 8915[74480000]              mov [ v_H ], edx                ; update HERE to remove the DROP that was just compiled
  1307 00000666 C3                          ret
  1308                                  
  1309                                  
  1310                                  ; *****************************************************************************
  1311                                  ; *****************************************************************************
  1312                                  
  1313                                  select_define:      ; select how to define the word
  1314 00000667 8F05[1C490000]              pop dword [ adefine ]   
  1315 0000066D C3                          ret
  1316                                  
  1317                                  macro_:     ; select the Macro wordlist
  1318 0000066E E8F4FFFFFF                  call select_define
  1319                                  macrod:
  1320 00000673 50                          push _TOS_
  1321 00000674 8B0D[AC480000]              mov ecx, [ v_MacroWordCount]                ; save the word count into ecx
  1322 0000067A FF05[AC480000]              inc dword [ v_MacroWordCount]               ; increment the word count for the next time around
  1323                                  
  1324                                      ; save the source address in the locate table                    
  1325 00000680 C1E702                      shl edi, 2                                  ; convert to an address in bytes
  1326 00000683 893C8D00204700              mov dword [ ( MacroLocates ) + ( ecx * 4 ) ], edi
  1327 0000068A C1EF02                      shr edi, 2   
  1328                                  
  1329 0000068D 8D0C8D00E04600              lea ecx, [ ( ecx * 4 ) + MacroNames ]       ; ecx contains the address to store the new token name in the wordlist
  1330 00000694 B800200000                  mov _TOS_, ( MacroJumpTable - MacroNames )  ; _TOS_ contains the relative address of the jump table
  1331 00000699 EB2B                        jmp short add_word_to_wordlist
  1332                                  
  1333                                  forth_:      ; select the Forth wordlist
  1334 0000069B E8C7FFFFFF                  call select_define
  1335                                  forthd:
  1336 000006A0 50                          push _TOS_
  1337 000006A1 8B0D[A8480000]              mov ecx, [ v_ForthWordCount ]               ; save the word count into ecx  
  1338 000006A7 FF05[A8480000]              inc dword [ v_ForthWordCount ]              ; increment the word count for the next time around  
  1339                                     
  1340                                      ; save the source address in the locate table                    
  1341 000006AD C1E702                      shl edi, 2                                  ; convert to an address in bytes
  1342 000006B0 893C8D00A04600              mov dword [ ( ForthLocates ) + ( ecx * 4 ) ], edi
  1343 000006B7 C1EF02                      shr edi, 2                                  ; convert back to an address in 32 bit cells  
  1344                                      
  1345 000006BA 8D0C8D00804600              lea ecx, [ ( ecx * 4 ) + ForthNames ]       ; ecx contains the address to store the new token name in the wordlist
  1346 000006C1 B800400000                  mov _TOS_, ( ForthJumpTable - ForthNames )  ; _TOS_ contains the relative address of the jump table
  1347                                      ; Note : falls through to add_word_to_wordlist
  1348                                  
  1349                                  add_word_to_wordlist:
  1350 000006C6 8B14BDFCFFFFFF              mov edx, [ ( edi * 4 ) - 0x04 ]     ; edi points to the source token in the block, edx contains the token Shannon-Fano token name to compile
  1351 000006CD 81E2F0FFFFFF                and edx, dword 0xFFFFFFF0           ; 'and' out the token colour. Tokens in a wordlist of token names have a 'colour' of 0
  1352 000006D3 8911                        mov [ecx], edx                      ; ecx contains the address to store the new token name in the wordlist
  1353 000006D5 8B15[74480000]              mov edx, [ v_H ]
  1354 000006DB 891401                      mov [ecx+_TOS_], edx
  1355 000006DE 8D1401                      lea edx, [ecx+_TOS_]
  1356 000006E1 C1EA02                      shr edx, 0x02
  1357 000006E4 8915[88480000]              mov [ v_lastToken ], edx
  1358 000006EA 58                          pop _TOS_
  1359 000006EB 8925[A0480000]              mov [ v_lastAddress ], esp
  1360 000006F1 C705[50480000]-             mov dword [ lit ], adup
  1360 000006F7 [2E060000]         
  1361 000006FB C3                          ret
  1362                                  
  1363                                  ; *****************************************************************************
  1364                                  ; *****************************************************************************
  1365                                  
  1366                                  alit:
  1367 000006FC C705[50480000]-             mov dword [ lit ], adup
  1367 00000702 [2E060000]         
  1368                                  
  1369                                  literal:
  1370 00000706 E841FFFFFF                  call qdup                       ; compile the runtime action for  DUP , unless we have just compiled a  DROP , in which case do nothing
  1371 0000070B 8B15[A0480000]              mov edx, [ v_lastAddress ]      ; select the wordlist to add the literal to
  1372 00000711 8915[A4480000]              mov [ v_lastAddress_copy ], edx
  1373 00000717 8B15[74480000]              mov edx, [ v_H ]
  1374 0000071D 8915[A0480000]              mov [ v_lastAddress ], edx
  1375 00000723 C602B8                      mov byte [edx], _MOV_TOS_LIT_   ; the opcode for mov eax, 32_bit_literal  (in next 32 bit cell)
  1376 00000726 894201                      mov [ edx + 0x01 ], _TOS_       ; the literal value follows in the next 4 bytes in the dictionary
  1377 00000729 8305[74480000]05            add dword [ v_H ], byte 0x05    ; move the dictionary pointer forward 5 bytes
  1378 00000730 C3                          ret
  1379                                  
  1380                                  ; *****************************************************************************
  1381                                  ; *****************************************************************************
  1382                                  
  1383                                  cnum:
  1384 00000731 FF15[50480000]              call [ lit ]
  1385 00000737 8B04BD00000000              mov _TOS_, [ ( edi * 4 ) + 0x00 ]
  1386 0000073E 47                          inc edi
  1387 0000073F EB10                        jmp short cshrt
  1388                                  
  1389                                  cshort:
  1390 00000741 FF15[50480000]              call [ lit]
  1391 00000747 8B04BDFCFFFFFF              mov _TOS_, [ ( edi * 4 ) - 0x04 ]
  1392 0000074E C1F805                      sar _TOS_, 0x05
  1393                                  cshrt:
  1394 00000751 E8B0FFFFFF                  call literal
  1395                                      _DROP_
   148 00000756 AD                  <1>  lodsd
  1396 00000757 C3                          ret
  1397                                  
  1398                                  %if 1
  1399                                  ; new improved code
  1400                                  ; *****************************************************************************
  1401                                  ; Magenta Variables run time code
  1402                                  ; ecx contains the token number of the new Magenta Variable in the wordlist
  1403                                  ;    This is found by searching the rodlist for the variable's name
  1404                                  ; *****************************************************************************
  1405                                  
  1406                                  m_var_forth_action:             ; code field for a magenta variable in the Forth wordist - return the variable's address
  1407                                      _DUP_                       ; runtime code to duplicate the TOS
   132 00000758 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000075B 8906                <1>  mov [ esi ], _TOS_
  1408 0000075D 890D[B4480000]              mov [ v_test1 ], ecx
  1409 00000763 89C8                        mov _TOS_, ecx              ; the offset in 32 bit cells of the Name of the current word being executed
  1410 00000765 C1E002                      shl _TOS_, 2                ; the offset in bytes of the Name of the current word being defined
  1411 00000768 0500A04600                  add _TOS_, ForthLocates     ; the address in bytes of the Name of the current word being defined
  1412 0000076D 8B00                        mov _TOS_, [ _TOS_ ]        ; fetch the address in 32 bit cells of the data
  1413                                  ;    shl _TOS_, 2                ; convert to an address in bytes
  1414 0000076F C3                          ret
  1415                                  
  1416                                  m_var_macro_action:             ; code field for a magenta variable in the Macro wordist - compile a literal that returns the variable's address
  1417 00000770 FF15[50480000]              call [ lit ]
  1418 00000776 890D[B8480000]              mov [ v_test2 ], ecx
  1419 0000077C 89C8                        mov _TOS_, ecx              ; the offset in 32 bit cells of the Name of the current word being defined
  1420 0000077E C1E002                      shl _TOS_, 2                ; the offset in bytes of the Name of the current word being defined
  1421 00000781 0500204700                  add _TOS_, MacroLocates     ; the address in bytes of the Name of the current word being defined
  1422 00000786 8B00                        mov _TOS_, [ _TOS_ ]        ; fetch the address in 32 bit cells of the data
  1423                                      ; shl _TOS_, 2                ; convert to an address in bytes
  1424 00000788 EBC7                        jmp short cshrt
  1425                                  
  1426                                  ; *****************************************************************************
  1427                                  ; Create a Magenta Variable
  1428                                  ; ecx contains the token number of the new Magenta Variable in the wordlist
  1429                                  ;    i.e. where the variable name is stored, set by forthd or macrod
  1430                                  ; *****************************************************************************
  1431                                  
  1432                                  m_variable:                     ; create a magenta variable
  1433                                      
  1434 0000078A E811FFFFFF                  call forthd                 ; select the Forth wordlist
  1435 0000078F C78100400000-               mov dword [ ( ForthJumpTable - ForthNames ) + ecx ], m_var_forth_action
  1435 00000795 [58070000]         
  1436 00000799 C1E702                      shl edi, 2                  ; convert to an address in bytes
  1437 0000079C 89B900200000                mov dword [ ( ForthLocates   - ForthNames ) + ecx ], edi
  1438 000007A2 C1EF02                      shr edi, 2                  ; convert back to an address in 32 bit cells
  1439                                      
  1440 000007A5 E8C9FEFFFF                  call macrod                 ; select the Macro wordlist
  1441 000007AA C78100200000-               mov dword [ ( MacroJumpTable - MacroNames ) + ecx ], m_var_macro_action
  1441 000007B0 [70070000]         
  1442 000007B4 C1E702                      shl edi, 2                  ; convert to an address in bytes
  1443 000007B7 89B900400000                mov dword [ ( MacroLocates   - MacroNames ) + ecx ], edi
  1444 000007BD C1EF02                      shr edi, 2                  ; convert back to an address in 32 bit cells
  1445                                  
  1446 000007C0 47                          inc edi
  1447 000007C1 C3                          ret
  1448                                  
  1449                                  %else
  1450                                  
  1451                                  ; original code
  1452                                  
  1453                                  ; *****************************************************************************
  1454                                  ; magenta variables
  1455                                  ; ecx contains the address to store the new token name in the wordlist
  1456                                  ;   set by forthd or macrod
  1457                                  ; *****************************************************************************
  1458                                  
  1459                                  m_var_forth_action:           ; code field for a magenta variable in the Forth wordist
  1460                                      _DUP_               ; runtime code to duplicate the TOS
  1461                                      mov _TOS_, [ 4 + ForthNames + ( ecx * 4 ) ]
  1462                                      shl _TOS_, 2
  1463                                      ret
  1464                                  
  1465                                  m_variable:     ; define a magenta variable
  1466                                      call forthd         ; select the Forth wordlist
  1467                                      mov dword [ ForthJumpTable - ForthNames + ecx ], m_var_forth_action
  1468                                      inc dword [ v_ForthWordCount ]
  1469                                      mov [ ecx + 4 ], edi
  1470                                      call macrod         ; select the Macro wordlist
  1471                                      mov dword [ MacroJumpTable - MacroNames + ecx ], m_var_macro_action
  1472                                      inc dword [ v_MacroWordCount ]
  1473                                      mov [ ecx + 4 ], edi
  1474                                      inc edi
  1475                                      ret
  1476                                  
  1477                                  m_var_macro_action:           ; code field for a magenta variable in the Macro wordist
  1478                                      call [ lit ]
  1479                                      mov _TOS_, [ 4 + MacroNames + ( ecx * 4 ) ]
  1480                                      shl _TOS_, 2
  1481                                      jmp short cshrt
  1482                                  
  1483                                  %endif
  1484                                  
  1485                                  ; *****************************************************************************
  1486                                  ; *****************************************************************************
  1487                                  
  1488                                  ex1:
  1489 000007C2 31FF                        xor edi, edi
  1490                                  .back:
  1491 000007C4 FF0D[44480000]              dec dword [ v_words ]
  1492 000007CA 741C                        jz ex2
  1493                                      _DROP_
   148 000007CC AD                  <1>  lodsd
  1494 000007CD EBF5                        jmp short .back
  1495                                  
  1496                                  execute_lit:    ; ( -- )
  1497 000007CF C705[50480000]-             mov dword [ lit ], alit
  1497 000007D5 [FC060000]         
  1498                                      _DUP_
   132 000007D9 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000007DC 8906                <1>  mov [ esi ], _TOS_
  1499 000007DE 8B04BDFCFFFFFF              mov _TOS_, [ ( edi * 4 ) - 0x04 ]
  1500                                  execute_:    ; ( name -- )
  1501 000007E5 83E0F0                      and _TOS_, byte -0x10 ; (saves 2 bytes compared to 'and _TOS_, 0xFFFFFFF0' )
  1502                                  ex2:
  1503 000007E8 E811FEFFFF                  call find_
  1504 000007ED 0F851FFEFFFF                jnz abort_
  1505                                      _DROP_
   148 000007F3 AD                  <1>  lodsd
  1506 000007F4 FF248D00C04600              jmp dword [ ( ecx * 4 ) + ForthJumpTable ]
  1507                                  
  1508                                  ; *****************************************************************************
  1509                                  ; *****************************************************************************
  1510                                  
  1511                                  qcompile:
  1512 000007FB FF15[50480000]              call [ lit ]
  1513 00000801 8B04BDFCFFFFFF              mov _TOS_, [ ( edi * 4 ) - 0x04 ]
  1514 00000808 83E0F0                      and _TOS_, byte -0x10 ; (saves 2 bytes compared to 'and _TOS_, 0xFFFFFFF0' )
  1515 0000080B E8DEFDFFFF                  call mfind
  1516 00000810 7508                        jnz .forward
  1517                                      _DROP_
   148 00000812 AD                  <1>  lodsd
  1518 00000813 FF248D00004700              jmp dword [ ( ecx * 4 ) + MacroJumpTable ]
  1519                                  .forward:
  1520 0000081A E8DFFDFFFF                  call find_
  1521 0000081F 8B048D00C04600              mov _TOS_, [ ( ecx * 4 ) + ForthJumpTable ]
  1522                                  
  1523                                  qcom1:
  1524 00000826 0F85E6FDFFFF                jnz abort_
  1525                                  call_:
  1526 0000082C 8B15[74480000]              mov edx, [ v_H ]
  1527 00000832 8915[A0480000]              mov [ v_lastAddress ], edx
  1528 00000838 C602E8                      mov byte [edx], 0xE8        ; 0xE8 is the opcode for 'call immediate'
  1529 0000083B 83C205                      add edx, byte 0x05
  1530 0000083E 29D0                        sub _TOS_, edx
  1531 00000840 8942FC                      mov [ edx - 0x04 ], _TOS_
  1532 00000843 8915[74480000]              mov [ v_H ], edx
  1533                                      _DROP_
   148 00000849 AD                  <1>  lodsd
  1534 0000084A C3                       ret
  1535                                  
  1536                                  ; *****************************************************************************
  1537                                  ; *****************************************************************************
  1538                                  
  1539                                  compile:
  1540 0000084B FF15[50480000]              call [ lit]
  1541 00000851 8B04BDFCFFFFFF              mov _TOS_, [ ( edi * 4 ) - 0x04 ]
  1542 00000858 83E0F0                      and _TOS_, byte -0x10 ; (saves 2 bytes compared to 'and _TOS_, 0xFFFFFFF0' )
  1543 0000085B E88EFDFFFF                  call mfind
  1544 00000860 8B048D00004700              mov _TOS_, [ ( ecx * 4 ) + MacroJumpTable ]
  1545 00000867 EBBD                        jmp short qcom1
  1546                                  
  1547                                  ; *****************************************************************************
  1548                                  ; *****************************************************************************
  1549                                  
  1550                                  short_:
  1551 00000869 C705[50480000]-             mov dword [ lit], alit
  1551 0000086F [FC060000]         
  1552                                      _DUP_
   132 00000873 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00000876 8906                <1>  mov [ esi ], _TOS_
  1553 00000878 8B04BDFCFFFFFF              mov _TOS_, [ ( edi * 4 ) - 0x04 ]
  1554 0000087F C1F805                      sar _TOS_, 0x05
  1555 00000882 C3                          ret
  1556                                  
  1557                                  ; *****************************************************************************
  1558                                  ; *****************************************************************************
  1559                                  
  1560                                  num:
  1561 00000883 C705[50480000]-             mov dword [ lit], alit
  1561 00000889 [FC060000]         
  1562                                      _DUP_
   132 0000088D 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00000890 8906                <1>  mov [ esi ], _TOS_
  1563 00000892 8B04BD00000000              mov _TOS_, [ ( edi * 4 ) + 0x00 ]
  1564 00000899 47                          inc edi
  1565 0000089A C3                          ret
  1566                                  
  1567                                  ; *****************************************************************************
  1568                                  ; *****************************************************************************
  1569                                  
  1570                                  comma_:          ; 4 byte  ,
  1571 0000089B B904000000                  mov ecx, 0x04
  1572                                  dcomma:     ; c,  performed n times ( n in ecx )
  1573 000008A0 8B15[74480000]              mov edx, [ v_H ]
  1574 000008A6 8902                        mov [edx], _TOS_
  1575 000008A8 8B06                        mov _TOS_, [ esi ]
  1576 000008AA 8D1411                      lea edx, [ ecx + edx ]
  1577 000008AD 8D7604                      lea esi, [ esi + 0x04 ]
  1578 000008B0 8915[74480000]              mov [ v_H ], edx
  1579 000008B6 C3                          ret
  1580                                  
  1581                                  comma1_:     ; 1 byte  c,
  1582 000008B7 B901000000                  mov ecx, 0x01
  1583 000008BC EBE2                        jmp short dcomma
  1584                                  
  1585                                  comma2_:     ; 2 byte  w,
  1586 000008BE B902000000                  mov ecx, 0x02
  1587 000008C3 EBDB                        jmp short dcomma
  1588                                  
  1589                                  comma3_:     ; 3 byte  c, c, c,
  1590 000008C5 B903000000                  mov ecx, 0x03
  1591 000008CA EBD4                        jmp short dcomma
  1592                                  
  1593                                  ; *****************************************************************************
  1594                                  ; *****************************************************************************
  1595                                  
  1596                                  semicolon:
  1597 000008CC 8B15[74480000]              mov edx, [ v_H ]
  1598 000008D2 83EA05                      sub edx, byte 0x05
  1599 000008D5 3915[A0480000]              cmp [ v_lastAddress ], edx
  1600 000008DB 7508                        jnz .forward
  1601 000008DD 803AE8                      cmp byte [edx], 0xE8            ; 0xE8 is the opcode for 'call immediate'
  1602 000008E0 7503                        jnz .forward
  1603 000008E2 FE02                        inc byte [edx]
  1604 000008E4 C3                          ret
  1605                                  .forward:
  1606 000008E5 C64205C3                    mov byte [ edx + 0x05 ], 0xC3   ; 0xC3 is the opcode for 'ret'
  1607 000008E9 FF05[74480000]              inc dword [ v_H ]
  1608 000008EF C3                          ret
  1609                                  
  1610                                  ; *****************************************************************************
  1611                                  ; *****************************************************************************
  1612                                  
  1613                                  then:
  1614 000008F0 8925[A0480000]              mov [ v_lastAddress ], esp
  1615 000008F6 8B15[74480000]              mov edx, [ v_H ]
  1616 000008FC 29C2                        sub edx, _TOS_
  1617 000008FE 8850FF                      mov [ _TOS_ - 0x01 ], dl
  1618                                      _DROP_
   148 00000901 AD                  <1>  lodsd
  1619 00000902 C3                          ret
  1620                                  
  1621                                  begin_:
  1622 00000903 8925[A0480000]              mov [ v_lastAddress ], esp
  1623                                  here_:
  1624                                      _DUP_
   132 00000909 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000090C 8906                <1>  mov [ esi ], _TOS_
  1625 0000090E A1[74480000]                mov _TOS_, [ v_H ]
  1626 00000913 C3                          ret
  1627                                  
  1628                                  ; *****************************************************************************
  1629                                  ; *****************************************************************************
  1630                                  
  1631                                  qlit:  ; ?lit
  1632 00000914 8B15[74480000]              mov edx, [ v_H ]
  1633 0000091A 8D52FB                      lea edx, [ edx - 0x05 ]
  1634 0000091D 3915[A0480000]              cmp [ v_lastAddress ], edx
  1635 00000923 7533                        jnz .forward
  1636 00000925 803AB8                      cmp byte [edx], _MOV_TOS_LIT_   ; the opcode for mov eax, 32_bit_literal  (in next 32 bit cell)
  1637 00000928 752E                        jnz .forward
  1638                                      _DUP_
   132 0000092A 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000092D 8906                <1>  mov [ esi ], _TOS_
  1639 0000092F A1[A4480000]                mov _TOS_, [ v_lastAddress_copy ]
  1640 00000934 A3[A0480000]                mov [ v_lastAddress ], _TOS_
  1641 00000939 8B4201                      mov _TOS_, [ edx + 0x01 ]
  1642 0000093C 817AFB8D76FC89              cmp dword [ edx - 5 ], 0x89FC768D   ; assemble code 8D 76 FC 89 rr => lea esi, [ esi - 0x04 ] ;  mov [ esi ], register
  1643                                      ; like dup but with the register value still to follow in the next byte
  1644 00000943 740B                        jz .forward2
  1645 00000945 8915[74480000]              mov [ v_H ], edx
  1646 0000094B E9C8FCFFFF                  jmp dword cdrop
  1647                                  .forward2:
  1648 00000950 8305[74480000]F6            add dword [ v_H ], byte -0x0A
  1649 00000957 C3                          ret
  1650                                  .forward:
  1651 00000958 31D2                        xor edx, edx
  1652 0000095A C3                          ret
  1653                                  
  1654                                  less:
  1655 0000095B 3906                        cmp [ esi ], _TOS_
  1656 0000095D 7802                        js .forward
  1657 0000095F 31C9                        xor ecx, ecx
  1658                                  .forward:
  1659 00000961 C3                          ret
  1660                                  
  1661                                  qignore:
  1662 00000962 F704BDFCFFFFFFF0FF-         test dword [ ( edi * 4 ) - 0x04 ], 0xFFFFFFF0
  1662 0000096B FFFF               
  1663 0000096D 7502                        jnz .forward
  1664 0000096F 5F                          pop edi
  1665 00000970 5F                          pop edi
  1666                                  .forward:
  1667 00000971 C3                          ret
  1668                                  
  1669                                  jump:
  1670 00000972 5A                          pop edx
  1671 00000973 01C2                        add edx, _TOS_
  1672 00000975 8D548205                    lea edx, [ edx + ( _TOS_ * 4 ) + 0x05 ]
  1673 00000979 0352FC                      add edx, [ edx - 0x04 ]
  1674                                      _DROP_
   148 0000097C AD                  <1>  lodsd
  1675 0000097D FFE2                        jmp edx
  1676                                  
  1677                                  ; convert block start address to cell address, add the RELOCATED colorForth system base
  1678                                  blockToCellAddress:  ; ( blk -- a' )   \ add the RELOCATED offset and convert to cell address
  1679 0000097F 0305[E8470000]              add _TOS_, [ v_offset ]   ; add the RELOCATED block number offset
  1680 00000985 C1E008                      shl _TOS_, 0x08           ; convert to cell address
  1681 00000988 C3                          ret
  1682                                  
  1683                                  cellAddressToBlock:   ; ( a -- blk )  \ convert cell address to block number and subtract the RELOCATED block number offset
  1684 00000989 C1E808                      shr _TOS_, 0x08           ;  convert cell address to block number
  1685 0000098C 2B05[E8470000]              sub _TOS_, [ v_offset ]   ; subtract the block number of block 0
  1686 00000992 C3                          ret
  1687                                  
  1688                                  _load_:   ; ( blk -- )    \ load the given block number
  1689 00000993 E8E7FFFFFF                  call blockToCellAddress   ; add the RELOCATED block number offset and convert to cell address
  1690 00000998 57                          push edi
  1691 00000999 89C7                        mov edi, _TOS_
  1692                                      _DROP_
   148 0000099B AD                  <1>  lodsd
  1693                                  interpret:
  1694 0000099C 8B14BD00000000              mov edx, [ ( edi * 4 ) + 0x00 ]
  1695 000009A3 47                          inc edi
  1696 000009A4 83E20F                      and edx, byte 0x0F
  1697 000009A7 FF1495[10490000]            call [ ( edx * 4 ) + tokenActions ]
  1698 000009AE EBEC                        jmp short interpret
  1699                                  
  1700                                      align 4, db 0   ; fill the gap with 0's
  1701                                  
  1702                                  ; : r@ qdup $8B 1, $C7 1, ;    \ mov _TOS_, edi  also db 0x89, 0xF8
  1703                                  ; : nload r@ $0100 / #2 + load ;
  1704                                  ; : +load ( n -- ) r@ $0100 / + load ;
  1705                                  nload:  ; ( -- )    \ load the next source block following the one currently being loaded
  1706 000009B0 E867000000                  call cblk_
  1707 000009B5 0502000000                  add _TOS_, 0x02
  1708 000009BA E9D4FFFFFF                  jmp _load_
  1709                                  
  1710                                  plusLoad:   ; ( n -- )    \ load the n'th source block following the one currently being loaded
  1711 000009BF 89C3                        mov _SCRATCH_, _TOS_    ; save the required offset
  1712                                      _DROP_
   148 000009C1 AD                  <1>  lodsd
  1713 000009C2 E855000000                  call cblk_
  1714 000009C7 01D8                        add _TOS_, _SCRATCH_
  1715 000009C9 E9C5FFFFFF                  jmp _load_
  1716                                  
  1717                                  ; : THRU ( f l -- )   1+ SWAP DO  I LOAD  LOOP ;
  1718                                  thru_:  ; ( first last -- )   \ load from the first to the last block
  1719 000009CE 0502000000                  add _TOS_, 0x02
  1720 000009D3 89C3                        mov _SCRATCH_, _TOS_
  1721                                      _DROP_                          ; TOS = first, SCRATCH = last
   148 000009D5 AD                  <1>  lodsd
  1722 000009D6 89D9                        mov ecx, _SCRATCH_
  1723 000009D8 29C1                        sub ecx, _TOS_                  ; ecx = count
  1724 000009DA 741F                        jz .end                         ; exit if count is zero
  1725 000009DC 721D                        jc .end                         ; exit if count is negative
  1726 000009DE D1E9                        shr ecx, 1                      ; divide by 2, as we skip 2 blocks each time round the loop
  1727                                  .back:
  1728                                      _DUP_
   132 000009E0 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000009E3 8906                <1>  mov [ esi ], _TOS_
  1729                                      _DUP_   ; just to be safe...
   132 000009E5 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000009E8 8906                <1>  mov [ esi ], _TOS_
  1730 000009EA 51                          push ecx
  1731 000009EB 53                          push _SCRATCH_
  1732 000009EC E8A2FFFFFF                  call _load_
  1733 000009F1 5B                          pop _SCRATCH_
  1734 000009F2 59                          pop ecx
  1735                                      _DROP_  ; just to be safe...
   148 000009F3 AD                  <1>  lodsd
  1736 000009F4 0502000000                  add _TOS_, 0x02
  1737 000009F9 E2E5                        loop .back
  1738                                  .end:
  1739                                      _DROP_
   148 000009FB AD                  <1>  lodsd
  1740 000009FC C3                          ret
  1741                                  
  1742                                  v_temp:
  1743 000009FD 00000000                    dd 0
  1744                                  
  1745                                  plusThru_:  ; ( first+ last+ -- )   \ load from the first to the last block relative to the current block being loaded
  1746 00000A01 E816000000                  call cblk_
  1747 00000A06 A3[FD090000]                mov [ v_temp ], _TOS_
  1748                                      _DROP_
   148 00000A0B AD                  <1>  lodsd
  1749 00000A0C 8B1D[FD090000]              mov _SCRATCH_, [ v_temp ]
  1750 00000A12 011E                        add [ esi ], _SCRATCH_          ; add current block to second on stack
  1751 00000A14 01D8                        add _TOS_, _SCRATCH_            ; add current block to top of stack
  1752 00000A16 E8B3FFFFFF                  call thru_
  1753 00000A1B C3                          ret
  1754                                  
  1755                                  cblk_:   ; ( -- n )  \ return the currently compiling block number - only valid while compiling
  1756                                      _DUP_
   132 00000A1C 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00000A1F 8906                <1>  mov [ esi ], _TOS_
  1757 00000A21 89F8                        mov _TOS_, edi            ; edi  contains the cell address in the block currently being compiled
  1758 00000A23 E861FFFFFF                  call cellAddressToBlock   ; convert to block number relative to block 0
  1759 00000A28 C3                          ret
  1760                                  
  1761                                  rblk_:   ; ( -- n )  \ return the block number offset of the RELOCATED address
  1762                                      _DUP_
   132 00000A29 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00000A2C 8906                <1>  mov [ esi ], _TOS_
  1763 00000A2E B840000000                  mov _TOS_, ( RELOCATED >> ( 2 + 8 ) )
  1764 00000A33 C3                          ret
  1765                                  
  1766                                  ablk_:   ; ( a -- n )  \ convert byte address to block number
  1767 00000A34 C1E802                      shr _TOS_, 0x02
  1768 00000A37 E84DFFFFFF                  call cellAddressToBlock
  1769 00000A3C C3                          ret
  1770                                  
  1771                                  erase_:   ; ( a n -- )  \ erase n bytes starting at address a
  1772 00000A3D 89C1                        mov ecx, eax
  1773                                      _DROP_
   148 00000A3F AD                  <1>  lodsd
  1774 00000A40 57                          push edi
  1775 00000A41 89C7                        mov edi, eax
  1776 00000A43 31C0                        xor eax, eax
  1777 00000A45 F3AA                        rep stosb
  1778 00000A47 5F                          pop edi
  1779                                      _DROP_
   148 00000A48 AD                  <1>  lodsd
  1780 00000A49 C3                          ret
  1781                                  
  1782                                  v_curs_to_source:   ; ( n -- a32 )   \ return the cell address of the current cursor position in the current block being edited
  1783 00000A4A 89C3                        mov _SCRATCH_, _TOS_
  1784 00000A4C A1[A8470000]                mov _TOS_, [ v_blk ]            ; get the currently edited block number
  1785 00000A51 E829FFFFFF                  call blockToCellAddress
  1786 00000A56 01D8                        add _TOS_, _SCRATCH_            ; add the cursor position (cell address) in the block
  1787 00000A58 C3                          ret
  1788                                  
  1789                                  nth_to_token:   ; ( n -- tok )   \ return the token at the n'th cursor position in the current block being edited
  1790 00000A59 E8ECFFFFFF                  call v_curs_to_source
  1791 00000A5E C1E002                      shl _TOS_, 0x02                 ; convert cell address to byte address
  1792 00000A61 8B00                        mov _TOS_, [ _TOS_ ]            ; fetch the token
  1793 00000A63 C3                          ret
  1794                                  
  1795                                  v_curs_to_token:   ; ( -- tok )   \ return the token at the current cursor position in the current block being edited
  1796                                      _DUP_
   132 00000A64 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00000A67 8906                <1>  mov [ esi ], _TOS_
  1797 00000A69 A1[A8470000]                mov _TOS_, [ v_blk ]            ; get the currently edited block number
  1798 00000A6E E8E6FFFFFF                  call nth_to_token
  1799 00000A73 C3                          ret
  1800                                  
  1801                                  ; : ?f $C021 2, ;
  1802                                  ;qf:
  1803                                  ;    db 0x21, 0xC0   ; and _TOS_, _TOS_
  1804                                  ;    ret
  1805                                  
  1806                                  ; *****************************************************************************
  1807                                  ; *****************************************************************************
  1808                                  
  1809                                  top_:   ; ( -- )   \ set the cursor to the left margin horizontally and 3 pixels down from the top vertically
  1810 00000A74 8B0D[54490000]              mov ecx, [ v_leftMargin ]
  1811 00000A7A C1E110                      shl ecx, 0x10
  1812 00000A7D 83C103                      add ecx, byte 0x03
  1813 00000A80 890D[50490000]              mov [ v_gr_xy ], ecx
  1814                                      ; mov [ xycr], ecx
  1815 00000A86 C3                          ret
  1816                                  
  1817                                  qcr: ; ( -- )   \ ?cr  do a  CR  if the cursor has gone past the right margin
  1818 00000A87 668B0D[52490000]            mov cx, [ v_gr_x ]
  1819 00000A8E 663B0D[58490000]            cmp cx, [ v_rightMargin ]
  1820 00000A95 781D                        js cr_forward
  1821                                  cr_:  ; ( -- )
  1822 00000A97 8B0D[54490000]              mov ecx, [ v_leftMargin ]
  1823 00000A9D C1E110                      shl ecx, 0x10
  1824 00000AA0 668B0D[50490000]            mov cx, [ v_gr_xy ]
  1825 00000AA7 66030D[F4470000]            add cx, [ v_iconh ]
  1826 00000AAE 890D[50490000]              mov [ v_gr_xy ], ecx
  1827                                  cr_forward:
  1828 00000AB4 C3                          ret
  1829                                  
  1830                                  green:  ; ( -- )
  1831                                      _DUP_
   132 00000AB5 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00000AB8 8906                <1>  mov [ esi ], _TOS_
  1832 00000ABA B800060000                  mov _TOS_, colour_green
  1833 00000ABF E919000000                  jmp set_color_
  1834                                  
  1835                                  yellow:  ; ( -- )
  1836                                      _DUP_
   132 00000AC4 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00000AC7 8906                <1>  mov [ esi ], _TOS_
  1837 00000AC9 B8E0FF0000                  mov _TOS_, colour_yellow
  1838 00000ACE E90A000000                  jmp set_color_
  1839                                  
  1840                                  ; red:  ; ( -- )    ; see redWord:
  1841                                  ;    _DUP_
  1842                                  ;    mov _TOS_, colour_red
  1843                                  ;    jmp set_color_
  1844                                  
  1845                                  white:  ; ( -- )
  1846                                      _DUP_
   132 00000AD3 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00000AD6 8906                <1>  mov [ esi ], _TOS_
  1847 00000AD8 B8FFFF0000                  mov _TOS_, colour_white
  1848                                  set_color_:  ; ( rgb16 -- )
  1849 00000ADD A3[64490000]                mov [ v_foregroundColour ], _TOS_
  1850                                      _DROP_
   148 00000AE2 AD                  <1>  lodsd
  1851 00000AE3 C3                          ret
  1852                                  
  1853                                  rgb:    ; ( rgb32 -- rgb16 )    ; convert from 32 bit ( 8:8:8:8 _RGB ) colour to 16 bit ( 5:6:5 RGB ) colour value
  1854 00000AE4 C1C808                      ror _TOS_, 8
  1855 00000AE7 66C1E802                    shr ax, 2
  1856 00000AEB C1C806                      ror _TOS_, 6
  1857 00000AEE C0E803                      shr al, 3
  1858 00000AF1 C1C00B                      rol _TOS_, ( 6 + 5 )
  1859 00000AF4 25FFFF0000                  and _TOS_, 0x0000FFFF
  1860 00000AF9 C3                          ret
  1861                                  
  1862                                  bye_:  ; ( -- )   \ exit colorForth
  1863 00000AFA E817F8FFFF                  call setRealModeAPI
  1864                                  [BITS 16]                           ; Real Mode code (16 bit)
  1865 00000AFF CD19                        int 0x19    ; reboot the computer
  1866                                      ; should never get past this point.... but in case we do...
  1867 00000B01 FA                          cli                             ; BIOS might have left interrupts enabled
  1868 00000B02 E8E8F7                      call setProtectedModeAPI        ; called from 16 bit code, returns to 32 bit code
  1869                                  [BITS 32]                           ; Protected Mode code (32 bit)
  1870 00000B05 C3                          ret
  1871                                  
  1872                                  %if 0
  1873                                  pci:
  1874                                      mov edx, 0x0CF8
  1875                                      out dx, _TOS_
  1876                                      lea edx, [ edx + 0x04 ]
  1877                                      in _TOS_, dx
  1878                                      ret
  1879                                  
  1880                                  device:
  1881                                      times ( 0x93a - ( $ - $$ ) ) nop  ; fill with nops to find_display ???
  1882                                  
  1883                                  find_display:                       ; called by warm
  1884                                      mov _TOS_, 0x3000000            ; PCI class code 3 = display controller
  1885                                      call device                     ; returns header address
  1886                                      lea _TOS_, [ _TOS_ + 0x10 ]     ; point to Base Address #0 (BAR0)
  1887                                      mov cl, 0x06
  1888                                  .next:
  1889                                      _DUP_
  1890                                      call pci
  1891                                      and al, 0xFB
  1892                                      xor al, 0x08
  1893                                      jz .forward
  1894                                      _DROP_
  1895                                      lea _TOS_, [ _TOS_ + 0x04 ]
  1896                                      loop .next
  1897                                      lea _TOS_, [ _TOS_ - 0x18 ]
  1898                                      _DUP_
  1899                                      call pci
  1900                                      and al, 0xF0
  1901                                  .forward:
  1902                                      mov [ v_frameBuffer ], _TOS_     ; set framebuffer address
  1903                                      _DROP_
  1904                                      ret
  1905                                  
  1906                                  fifo:
  1907                                      _DROP_
  1908                                      ret
  1909                                  
  1910                                  %endif
  1911                                  
  1912                                  graphAction:
  1913 00000B06 C3                          ret
  1914                                  
  1915                                  ; *****************************************************************************
  1916                                  ; *****************************************************************************
  1917                                  ; grapics mode dependent code
  1918                                  ; *****************************************************************************
  1919                                  ; *****************************************************************************
  1920                                  
  1921                                  ; *****************************************************************************
  1922                                  ; 1024x768 display
  1923                                  ; *****************************************************************************
  1924                                  
  1925                                  scrnw1 equ 1024              ; screen width in pixels
  1926                                  scrnh1 equ 768               ; screen height in pixels
  1927                                  iconw1 equ ( 16 + 4 )        ; icon width
  1928                                  iconh1 equ ( 24 + 4 )        ; icon height for 768 pixel high screen
  1929                                  
  1930                                  keypadY1 equ 4               ; location of keyboard display vertically in lines from the bottom
  1931                                  
  1932                                  initIconSize1:
  1933 00000B07 C705[F0470000]1400-         mov dword [ v_iconw ], iconw1
  1933 00000B0F 0000               
  1934 00000B11 C705[FC470000]B400-         mov dword [ v_nine_iconw ], ( iconw1 * 9 )
  1934 00000B19 0000               
  1935 00000B1B C705[00480000]B801-         mov dword [ v_twentytwo_iconw ], ( iconw1 * ( 13 + 9 ) )
  1935 00000B23 0000               
  1936 00000B25 C705[04480000]0000-         mov dword [ v_10000_iconw ], ( iconw1 * 0x10000 )
  1936 00000B2D 1400               
  1937 00000B2F C705[F4470000]1C00-         mov dword [ v_iconh ], iconh1
  1937 00000B37 0000               
  1938 00000B39 C705[F8470000]7000-         mov dword [ v_keypadY_iconh ], keypadY1 * iconh1
  1938 00000B41 0000               
  1939 00000B43 C3                          ret
  1940                                  
  1941                                  switch1:     ; copy our created image to the real display buffer
  1942 00000B44 56                          push esi
  1943 00000B45 57                          push edi
  1944 00000B46 8B35[60490000]              mov  esi, dword [ vframe ]      ; vframe  points to where we create our image
  1945 00000B4C 8B3D28180000                mov  edi, [ vesa_PhysBasePtr ]  ; VESA frame buffer, saved by VESA BIOS call, the address in RAM that is displayed by the hardware
  1946 00000B52 B900000600                  mov  ecx, ( ( scrnw1 * scrnh1 ) / 4 ) * BYTES_PER_PIXEL   ; the / 4 is because we are moving doubles = 4 bytes each
  1947 00000B57 F3A5                        rep  movsd                      ; copy ecx 32 bit words from ds:esi to es:edi
  1948 00000B59 5F                          pop  edi
  1949 00000B5A 5E                          pop  esi
  1950 00000B5B C3                          ret
  1951                                  
  1952                                  clip1:
  1953 00000B5C 8B3D[50490000]              mov  edi, [ v_gr_xy ]
  1954 00000B62 89F9                        mov  ecx, edi
  1955 00000B64 6685C9                      test cx, cx
  1956 00000B67 7902                        jns  .forward
  1957 00000B69 31C9                        xor  ecx, ecx
  1958                                  .forward:
  1959 00000B6B 81E1FFFF0000                and  ecx, 0x0000FFFF
  1960 00000B71 890D[6C490000]              mov  [ v_yc ], ecx
  1961 00000B77 69C900080000                imul ecx, ( scrnw1 * BYTES_PER_PIXEL )
  1962 00000B7D C1FF10                      sar  edi, 16
  1963 00000B80 7902                        jns  .forward2
  1964 00000B82 31FF                        xor  edi, edi
  1965                                  .forward2:
  1966 00000B84 893D[68490000]              mov  [ v_xc ], edi
  1967 00000B8A 8D3C79                      lea  edi, [ edi * BYTES_PER_PIXEL + ecx ]
  1968 00000B8D 033D[60490000]              add  edi, [ vframe ]
  1969 00000B93 C3                          ret
  1970                                  
  1971                                  bit16:                              ; write a 16 x 24 glyph to the graphic screen
  1972 00000B94 66AD                        lodsw                           ; load the 16 bit value pointed to by SI into  ax
  1973 00000B96 86C4                        xchg al, ah                     ; eax_TOS_
  1974                                  .back:
  1975 00000B98 66D1E0                      shl ax, 0x01                    ; eax_TOS_
  1976 00000B9B 7308                        jnc  .forward
  1977 00000B9D 668917                      mov  [ edi ], dx                ;
  1978 00000BA0 E906000000                  jmp .forward2
  1979                                  .forward:
  1980 00000BA5 C1CA10                      ror edx, 0x10                   ; use the background colour, in the high 16 bits
  1981                                  ;    mov [ edi ], dx                ;
  1982 00000BA8 C1CA10                      ror edx, 0x10                   ; return to the foreground colour, in the low 16 bits
  1983                                  .forward2:
  1984 00000BAB 83C702                      add edi, byte BYTES_PER_PIXEL
  1985 00000BAE E2E8                        loop .back
  1986 00000BB0 C3                          ret
  1987                                  
  1988                                  ; write the background after the glyph
  1989                                  bit16Background:          ; number of pixels to write in  ecx ,  screen address in  edi , colours in edx
  1990 00000BB1 C1CA10                      ror edx, 0x10           ; use the background colour, in the high 16 bits
  1991                                  .back:
  1992                                  ;    mov [ edi ], dx        ;
  1993 00000BB4 83C702                      add edi, byte BYTES_PER_PIXEL
  1994 00000BB7 E2FB                        loop .back
  1995 00000BB9 C1CA10                      ror edx, 0x10           ; return to the foreground colour, in the low 16 bits
  1996 00000BBC C3                          ret
  1997                                  
  1998                                  bit32:                          ; write a 32 x 48 double size glyph to the graphic screen
  1999 00000BBD 66AD                        lodsw                   ; load the 16 bit value pointed to by SI into  ax
  2000 00000BBF 86C4                        xchg al, ah             ; eax_TOS_
  2001 00000BC1 B910000000                  mov ecx, 0x10
  2002                                  .back:
  2003 00000BC6 D1E0                        shl  _TOS_, 1           ; eax_TOS_
  2004 00000BC8 7331                        jnc  .forward
  2005 00000BCA 668917                      mov  [ edi ], dx
  2006 00000BCD 66895702                    mov  [ edi + BYTES_PER_PIXEL ], dx
  2007                                  
  2008 00000BD1 803D[860F0000]00            cmp byte [ displayMode ], 0
  2009 00000BD8 7513                        jnz .width2
  2010 00000BDA 66899700080000              mov  [ edi + ( scrnw1 * BYTES_PER_PIXEL ) ], dx
  2011 00000BE1 66899702080000              mov  [ edi + ( scrnw1 * BYTES_PER_PIXEL ) + BYTES_PER_PIXEL ], dx
  2012 00000BE8 E90E000000                  jmp .widthEnd
  2013                                  .width2:
  2014 00000BED 66899740060000              mov  [ edi + ( scrnw2 * BYTES_PER_PIXEL ) ], dx
  2015 00000BF4 66899742060000              mov  [ edi + ( scrnw2 * BYTES_PER_PIXEL ) + BYTES_PER_PIXEL ], dx
  2016                                  .widthEnd:
  2017                                  .forward:
  2018 00000BFB 83C704                      add edi, byte ( BYTES_PER_PIXEL * 2 )
  2019 00000BFE E2C6                        loop .back
  2020 00000C00 C3                          ret
  2021                                  
  2022                                  ; Table that maps the three levels of Shannon-Fano codes to ASCII, followed by a copy in Capitalised or larger form
  2023                                  ; The original colorForth font has "capital numbers" - larger bold versions, all offset by 0x30 from the normal ones.
  2024                                  ; The new font maps the "larger forms" to offset 0x80, i.e. $30 --> $B0, two forms of '0'.
  2025                                  ShannonFano:
  2026                                  ;       000000001111111122222222222222222222222222222222                         <- levels
  2027                                  ;       0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF01234567 <- index
  2028 00000C01 00                          db 0x00     ; a space in the cf font
  2029                                      ;  0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF01234567 <- index
  2030 00000C02 72746F65616E69736D-         db "rtoeanismcylgfwdvpbhxuq0123456789j-k.z/;'!+@*,? RTOEANISMCYLGFWDVPBHXUQ" ; ASCII equivalents
  2030 00000C0B 63796C676677647670-
  2030 00000C14 626878757130313233-
  2030 00000C1D 3435363738396A2D6B-
  2030 00000C26 2E7A2F3B27212B402A-
  2030 00000C2F 2C3F2052544F45414E-
  2030 00000C38 49534D43594C474657-
  2030 00000C41 4456504248585551   
  2031                                       ; 89ABCDEF01
  2032 00000C49 B0B1B2B3B4B5B6B7B8-         db 0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9; larger "capital"forms of "0123456789"
  2032 00000C52 B9                 
  2033                                      ;   23456
  2034 00000C53 4A5F4B2E5A                  db "J_K.Z"  ; normal capitals
  2035                                      ; 789ABCDEF
  2036 00000C58 AFBBA7A1ABC0AAACBF          db 0xAF,0xBB,0xA7,0xA1,0xAB,0xC0,0xAA,0xAC,0xBF; larger "capital" forms of "/;'!+@*,?"
  2037                                      ; 0123456789ABCDEF0123456789ABCDEF
  2038 00000C61 10111213231415165B-         db 0x10,0x11,0x12,0x13,0x23,0x14,0x15,0x16,0x5B,0x5D,0x17,0x18,0x19,0x28,0x29,0x24 ; $60 ....#...[]...()$
  2038 00000C6A 5D171819282924     
  2039                                  
  2040                                  emit1:      ; ( c -- )   \ display a single width and height character
  2041 00000C71 E811FEFFFF                  call qcr
  2042 00000C76 56                          push esi
  2043 00000C77 57                          push edi
  2044 00000C78 52                          push edx
  2045 00000C79 6BC030                      imul _TOS_, byte 16*24/8
  2046 00000C7C 8B35[8C480000]              mov esi, [ v_font ]
  2047 00000C82 01C6                        add esi, _TOS_
  2048 00000C84 E8D3FEFFFF                  call clip1
  2049 00000C89 8B15[64490000]              mov edx, [ v_foregroundColour ]
  2050 00000C8F B918000000                  mov ecx, 0x18   ; 24 lines
  2051                                  .back:
  2052 00000C94 51                          push ecx
  2053 00000C95 B910000000                  mov ecx, 0x10
  2054 00000C9A E8F5FEFFFF                  call bit16
  2055 00000C9F B904000000                  mov ecx, 0x04
  2056 00000CA4 57                          push edi
  2057 00000CA5 E807FFFFFF                  call bit16Background
  2058 00000CAA 5F                          pop edi
  2059 00000CAB 59                          pop ecx
  2060 00000CAC 81C7E0070000                add edi, ( scrnw1 - 16 ) * BYTES_PER_PIXEL  ; address of the next line of the glyph
  2061 00000CB2 E2E0                        loop .back      ; next horizontal line
  2062                                  
  2063 00000CB4 B904000000                  mov ecx, 0x04   ; 4 background lines
  2064                                  .back2:
  2065 00000CB9 51                          push ecx
  2066 00000CBA B910000000                  mov ecx, 0x10
  2067 00000CBF E8EDFEFFFF                  call bit16Background
  2068 00000CC4 B904000000                  mov ecx, 0x04
  2069 00000CC9 57                          push edi
  2070 00000CCA E8E2FEFFFF                  call bit16Background
  2071 00000CCF 5F                          pop edi
  2072 00000CD0 59                          pop ecx
  2073 00000CD1 81C7E0070000                add edi, ( scrnw1 - 16 ) * BYTES_PER_PIXEL  ; address of the next line of the glyph
  2074 00000CD7 E2E0                        loop .back2      ; next horizontal line
  2075                                  
  2076 00000CD9 5A                          pop edx
  2077 00000CDA 5F                          pop edi
  2078 00000CDB 5E                          pop esi
  2079                                      _DROP_
   148 00000CDC AD                  <1>  lodsd
  2080                                  space1:
  2081 00000CDD 8105[50490000]0000-         add dword [ v_gr_xy ], iconw1 * 0x10000 ; 22 horizontal pixels
  2081 00000CE5 1400               
  2082 00000CE7 C3                          ret
  2083                                  
  2084                                  two_emit1:  ; double width and height character
  2085 00000CE8 56                          push esi
  2086 00000CE9 57                          push edi
  2087 00000CEA 52                          push edx
  2088 00000CEB 6BC030                      imul _TOS_, byte 16*24/8
  2089 00000CEE 8B35[8C480000]              mov esi, [ v_font ]
  2090 00000CF4 01C6                        add esi, _TOS_
  2091 00000CF6 E861FEFFFF                  call clip1
  2092 00000CFB 8B15[64490000]              mov edx, [ v_foregroundColour ]
  2093 00000D01 B918000000                  mov ecx, 0x18   ; 24 lines
  2094                                  .back:
  2095 00000D06 51                          push ecx
  2096 00000D07 E8B1FEFFFF                  call bit32
  2097 00000D0C 81C7C00F0000                add edi, (2*scrnw1-16*2)*BYTES_PER_PIXEL
  2098 00000D12 59                          pop ecx
  2099 00000D13 E2F1                        loop .back
  2100 00000D15 5A                          pop edx
  2101 00000D16 5F                          pop edi
  2102 00000D17 5E                          pop esi
  2103 00000D18 8105[50490000]0000-         add dword [ v_gr_xy ], iconw1 * 2 * 0x10000 ; 44 horizontal pixels
  2103 00000D20 2800               
  2104                                      _DROP_
   148 00000D22 AD                  <1>  lodsd
  2105 00000D23 C3                          ret
  2106                                  
  2107                                  setupText__1:   ; setup for full screen text window display
  2108 00000D24 E8AAFDFFFF                  call white
  2109 00000D29 C705[54490000]0300-         mov dword [ v_leftMargin ], 0x03
  2109 00000D31 0000               
  2110 00000D33 C705[58490000]EC03-         mov dword [ v_rightMargin ], ( scrnw1 - iconw1 )
  2110 00000D3B 0000               
  2111 00000D3D E932FDFFFF                  jmp dword top_
  2112                                  
  2113                                  box1: ; ( width height -- )
  2114 00000D42 E815FEFFFF                  call clip1
  2115 00000D47 3D01030000                  cmp _TOS_, scrnh1+1
  2116 00000D4C 7805                        js .forward
  2117 00000D4E B800030000                  mov _TOS_, scrnh1
  2118                                  .forward:
  2119 00000D53 89C1                        mov ecx, _TOS_
  2120 00000D55 2B0D[6C490000]              sub ecx, [ v_yc ]
  2121 00000D5B 7E30                        jng .forward3
  2122 00000D5D 813E01040000                cmp dword [esi], scrnw1+1
  2123 00000D63 7806                        js .forward2
  2124 00000D65 C70600040000                mov dword [esi], scrnw1
  2125                                  .forward2:
  2126 00000D6B A1[68490000]                mov _TOS_, [ v_xc ]
  2127 00000D70 2906                        sub [esi], _TOS_
  2128 00000D72 7E19                        jng .forward3
  2129 00000D74 BA00040000                  mov edx, scrnw1
  2130 00000D79 2B16                        sub edx, [esi]
  2131 00000D7B D1E2                        shl edx, PIXEL_SHIFT
  2132 00000D7D A1[64490000]                mov _TOS_, [ v_foregroundColour ]
  2133                                  .back:
  2134 00000D82 51                          push ecx
  2135 00000D83 8B0E                        mov ecx, [esi]
  2136 00000D85 F366AB                      rep stosw   ; stosw depends on BYTES_PER_PIXEL, either stosw or stosd
  2137 00000D88 01D7                        add edi, edx
  2138 00000D8A 59                          pop ecx
  2139 00000D8B E2F5                        loop .back
  2140                                  .forward3:
  2141                                      _DROP_
   148 00000D8D AD                  <1>  lodsd
  2142                                      _DROP_
   148 00000D8E AD                  <1>  lodsd
  2143 00000D8F C3                          ret
  2144                                  
  2145                                  wash1:   ; ( colour -- )   \ fill the full screeen with the given colour
  2146 00000D90 E848FDFFFF                  call set_color_
  2147                                      _DUP_
   132 00000D95 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00000D98 8906                <1>  mov [ esi ], _TOS_
  2148                                  
  2149 00000D9A 31C0                        xor _TOS_, _TOS_     ; x,y = 0,0 top left corner
  2150 00000D9C A3[50490000]                mov [ v_gr_xy ], _TOS_
  2151                                  
  2152 00000DA1 B800040000                  mov _TOS_, scrnw1
  2153                                      _DUP_
   132 00000DA6 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00000DA9 8906                <1>  mov [ esi ], _TOS_
  2154 00000DAB B800030000                  mov _TOS_, scrnh1
  2155 00000DB0 E9AD020000                  jmp dword box_
  2156                                  
  2157                                  ; *****************************************************************************
  2158                                  ; 800x600 screen
  2159                                  ; *****************************************************************************
  2160                                  
  2161                                  scrnw2 equ 800               ; screen width in pixels
  2162                                  scrnh2 equ 600               ; screen height in pixels
  2163                                  iconw2 equ ( 16 + 1 )        ; icon width
  2164                                  iconh2 equ ( 24 - 1 )        ; icon height for NC10 600 pixel high screen
  2165                                  
  2166                                  keypadY2 equ 4               ; location of keyboard display vertically in lines from the bottom
  2167                                  
  2168                                  initIconSize2:
  2169 00000DB5 C705[F0470000]1100-         mov dword [ v_iconw ], iconw2
  2169 00000DBD 0000               
  2170 00000DBF C705[FC470000]9900-         mov dword [ v_nine_iconw ], ( iconw2 * 9 )
  2170 00000DC7 0000               
  2171 00000DC9 C705[00480000]7601-         mov dword [ v_twentytwo_iconw ], ( iconw2 * ( 13 + 9 ) )
  2171 00000DD1 0000               
  2172 00000DD3 C705[04480000]0000-         mov dword [ v_10000_iconw ], ( iconw2 * 0x10000 )
  2172 00000DDB 1100               
  2173 00000DDD C705[F4470000]1700-         mov dword [ v_iconh ], iconh2
  2173 00000DE5 0000               
  2174 00000DE7 C705[F8470000]5C00-         mov dword [ v_keypadY_iconh ], keypadY2 * iconh2
  2174 00000DEF 0000               
  2175 00000DF1 C3                          ret
  2176                                  
  2177                                  switch2:     ; copy our created image to the real display buffer
  2178 00000DF2 56                          push esi
  2179 00000DF3 57                          push edi
  2180 00000DF4 8B35[60490000]              mov  esi, dword [ vframe ]      ; vframe  points to where we create our image
  2181 00000DFA 8B3D28180000                mov  edi, [ vesa_PhysBasePtr ]  ; VESA frame buffer, saved by VESA BIOS call, the address in RAM that is displayed by the hardware
  2182 00000E00 B980A90300                  mov  ecx, ( ( scrnw2 * scrnh2 ) / 4 ) * BYTES_PER_PIXEL   ; the / 4 is because we are moving doubles = 4 bytes each
  2183 00000E05 F3A5                        rep  movsd                      ; copy ecx 32 bit words from ds:esi to es:edi
  2184 00000E07 5F                          pop  edi
  2185 00000E08 5E                          pop  esi
  2186 00000E09 C3                          ret
  2187                                  
  2188                                  clip2:
  2189 00000E0A 8B3D[50490000]              mov  edi, [ v_gr_xy ]
  2190 00000E10 89F9                        mov  ecx, edi
  2191 00000E12 6685C9                      test cx, cx
  2192 00000E15 7902                        jns  .forward
  2193 00000E17 31C9                        xor  ecx, ecx
  2194                                  .forward:
  2195 00000E19 81E1FFFF0000                and  ecx, 0x0000FFFF
  2196 00000E1F 890D[6C490000]              mov  [ v_yc ], ecx
  2197 00000E25 69C940060000                imul ecx, ( scrnw2 * BYTES_PER_PIXEL )
  2198 00000E2B C1FF10                      sar  edi, 16
  2199 00000E2E 7902                        jns  .forward2
  2200 00000E30 31FF                        xor  edi, edi
  2201                                  .forward2:
  2202 00000E32 893D[68490000]              mov  [ v_xc ], edi
  2203 00000E38 8D3C79                      lea  edi, [ edi * BYTES_PER_PIXEL + ecx ]
  2204 00000E3B 033D[60490000]              add  edi, [ vframe ]
  2205 00000E41 C3                          ret
  2206                                  
  2207                                  emit2:      ; ( c -- )   \ display a single width and height character
  2208 00000E42 E840FCFFFF                  call qcr
  2209 00000E47 56                          push esi
  2210 00000E48 57                          push edi
  2211 00000E49 52                          push edx
  2212 00000E4A 6BC030                      imul _TOS_, byte 16*24/8
  2213 00000E4D 8B35[8C480000]              mov esi, [ v_font ]
  2214 00000E53 01C6                        add esi, _TOS_
  2215 00000E55 E8B0FFFFFF                  call clip2
  2216 00000E5A 8B15[64490000]              mov edx, [ v_foregroundColour ]
  2217 00000E60 B918000000                  mov ecx, 0x18   ; 24 lines
  2218                                  .back:
  2219 00000E65 51                          push ecx
  2220 00000E66 B910000000                  mov ecx, 0x10
  2221 00000E6B E824FDFFFF                  call bit16
  2222 00000E70 B904000000                  mov ecx, 0x04
  2223 00000E75 57                          push edi
  2224 00000E76 E836FDFFFF                  call bit16Background
  2225 00000E7B 5F                          pop edi
  2226 00000E7C 59                          pop ecx
  2227 00000E7D 81C720060000                add edi, ( scrnw2 - 16 ) * BYTES_PER_PIXEL  ; address of the next line of the glyph
  2228 00000E83 E2E0                        loop .back      ; next horizontal line
  2229                                  
  2230 00000E85 B904000000                  mov ecx, 0x04   ; 4 background lines
  2231                                  .back2:
  2232 00000E8A 51                          push ecx
  2233 00000E8B B910000000                  mov ecx, 0x10
  2234 00000E90 E81CFDFFFF                  call bit16Background
  2235 00000E95 B904000000                  mov ecx, 0x04
  2236 00000E9A 57                          push edi
  2237 00000E9B E811FDFFFF                  call bit16Background
  2238 00000EA0 5F                          pop edi
  2239 00000EA1 59                          pop ecx
  2240 00000EA2 81C720060000                add edi, ( scrnw2 - 16 ) * BYTES_PER_PIXEL  ; address of the next line of the glyph
  2241 00000EA8 E2E0                        loop .back2      ; next horizontal line
  2242                                  
  2243 00000EAA 5A                          pop edx
  2244 00000EAB 5F                          pop edi
  2245 00000EAC 5E                          pop esi
  2246                                      _DROP_
   148 00000EAD AD                  <1>  lodsd
  2247                                  space2:
  2248 00000EAE 8105[50490000]0000-         add dword [ v_gr_xy ], iconw2 * 0x10000 ; 22 horizontal pixels
  2248 00000EB6 1100               
  2249 00000EB8 C3                          ret
  2250                                  
  2251                                  two_emit2:  ; double width and height character
  2252 00000EB9 56                          push esi
  2253 00000EBA 57                          push edi
  2254 00000EBB 52                          push edx
  2255 00000EBC 6BC030                      imul _TOS_, byte 16*24/8
  2256 00000EBF 8B35[8C480000]              mov esi, [ v_font ]
  2257 00000EC5 01C6                        add esi, _TOS_
  2258 00000EC7 E83EFFFFFF                  call clip2
  2259 00000ECC 8B15[64490000]              mov edx, [ v_foregroundColour ]
  2260 00000ED2 B918000000                  mov ecx, 0x18   ; 24 lines
  2261                                  .back:
  2262 00000ED7 51                          push ecx
  2263 00000ED8 E8E0FCFFFF                  call bit32
  2264 00000EDD 81C7400C0000                add edi, (2*scrnw2-16*2)*BYTES_PER_PIXEL
  2265 00000EE3 59                          pop ecx
  2266 00000EE4 E2F1                        loop .back
  2267 00000EE6 5A                          pop edx
  2268 00000EE7 5F                          pop edi
  2269 00000EE8 5E                          pop esi
  2270 00000EE9 8105[50490000]0000-         add dword [ v_gr_xy ], iconw2 * 2 * 0x10000 ; 44 horizontal pixels
  2270 00000EF1 2200               
  2271                                      _DROP_
   148 00000EF3 AD                  <1>  lodsd
  2272 00000EF4 C3                          ret
  2273                                  
  2274                                  setupText__2:   ; setup for full screen text window display
  2275 00000EF5 E8D9FBFFFF                  call white
  2276 00000EFA C705[54490000]0300-         mov dword [ v_leftMargin ], 0x03
  2276 00000F02 0000               
  2277 00000F04 C705[58490000]0F03-         mov dword [ v_rightMargin ], ( scrnw2 - iconw2 )
  2277 00000F0C 0000               
  2278 00000F0E E961FBFFFF                  jmp dword top_
  2279                                  
  2280                                  box2: ; ( width height -- )
  2281 00000F13 E8F2FEFFFF                  call clip2
  2282 00000F18 3D59020000                  cmp _TOS_, scrnh2+1
  2283 00000F1D 7805                        js .forward
  2284 00000F1F B858020000                  mov _TOS_, scrnh2
  2285                                  .forward:
  2286 00000F24 89C1                        mov ecx, _TOS_
  2287 00000F26 2B0D[6C490000]              sub ecx, [ v_yc ]
  2288 00000F2C 7E30                        jng .forward3
  2289 00000F2E 813E21030000                cmp dword [esi], scrnw2+1
  2290 00000F34 7806                        js .forward2
  2291 00000F36 C70620030000                mov dword [esi], scrnw2
  2292                                  .forward2:
  2293 00000F3C A1[68490000]                mov _TOS_, [ v_xc ]
  2294 00000F41 2906                        sub [esi], _TOS_
  2295 00000F43 7E19                        jng .forward3
  2296 00000F45 BA20030000                  mov edx, scrnw2
  2297 00000F4A 2B16                        sub edx, [esi]
  2298 00000F4C D1E2                        shl edx, PIXEL_SHIFT
  2299 00000F4E A1[64490000]                mov _TOS_, [ v_foregroundColour ]
  2300                                  .back:
  2301 00000F53 51                          push ecx
  2302 00000F54 8B0E                        mov ecx, [esi]
  2303 00000F56 F366AB                      rep stosw   ; stosw depends on BYTES_PER_PIXEL, either stosw or stosd
  2304 00000F59 01D7                        add edi, edx
  2305 00000F5B 59                          pop ecx
  2306 00000F5C E2F5                        loop .back
  2307                                  .forward3:
  2308                                      _DROP_
   148 00000F5E AD                  <1>  lodsd
  2309                                      _DROP_
   148 00000F5F AD                  <1>  lodsd
  2310 00000F60 C3                          ret
  2311                                  
  2312                                  wash2:    ; ( colour -- )   \ fill the full screeen with the given colour
  2313 00000F61 E877FBFFFF                  call set_color_
  2314                                      _DUP_
   132 00000F66 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00000F69 8906                <1>  mov [ esi ], _TOS_
  2315                                  
  2316 00000F6B 31C0                        xor _TOS_, _TOS_     ; x,y = 0,0 top left corner
  2317 00000F6D A3[50490000]                mov [ v_gr_xy ], _TOS_
  2318                                  
  2319 00000F72 B820030000                  mov _TOS_, scrnw2
  2320                                      _DUP_
   132 00000F77 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00000F7A 8906                <1>  mov [ esi ], _TOS_
  2321 00000F7C B858020000                  mov _TOS_, scrnh2
  2322 00000F81 E9DC000000                  jmp dword box_
  2323                                  
  2324                                  ; *****************************************************************************
  2325                                  ; select which display mode code to use
  2326                                  ; *****************************************************************************
  2327                                  
  2328                                  displayMode:
  2329 00000F86 01000000                    dd 1    ; 0 = 1024x768x16, 1 = 800x600x16
  2330                                  
  2331                                  initIconSize: ; sets up the size of an icon (glyph) according to the 800x600 or 1024x768 display size
  2332 00000F8A 803D[860F0000]00            cmp byte [ displayMode ], 0
  2333 00000F91 0F8470FBFFFF                jz initIconSize1
  2334 00000F97 E919FEFFFF                  jmp initIconSize2
  2335                                  
  2336                                  switch:
  2337 00000F9C 803D[860F0000]00            cmp byte [ displayMode ], 0
  2338 00000FA3 0F849BFBFFFF                jz switch1
  2339 00000FA9 E944FEFFFF                  jmp switch2
  2340                                  
  2341                                  clip:
  2342 00000FAE 803D[860F0000]00            cmp byte [ displayMode ], 0
  2343 00000FB5 0F84A1FBFFFF                jz clip1
  2344 00000FBB E94AFEFFFF                  jmp clip2
  2345                                  
  2346                                  emitSF_:
  2347 00000FC0 8A80[010C0000]              mov al, [ ShannonFano + _TOS_ ]
  2348                                  emit_:      ; ( c -- )   display byte c on the screen
  2349 00000FC6 803D[860F0000]00            cmp byte [ displayMode ], 0
  2350 00000FCD 0F849EFCFFFF                jz emit1
  2351 00000FD3 E96AFEFFFF                  jmp emit2
  2352                                  
  2353                                  space_:
  2354 00000FD8 803D[860F0000]00            cmp byte [ displayMode ], 0
  2355 00000FDF 0F84F8FCFFFF                jz space1
  2356 00000FE5 E9C4FEFFFF                  jmp space2
  2357                                  
  2358                                  type_:      ; ( a n -- )   display n bytes at address a on the screen
  2359 00000FEA 89C1                        mov ecx, _TOS_
  2360                                      _DROP_
   148 00000FEC AD                  <1>  lodsd
  2361 00000FED 89C3                        mov _SCRATCH_, _TOS_
  2362                                      .back:
  2363 00000FEF 60                              pusha
  2364                                          _DUP_
   132 00000FF0 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00000FF3 8906                <1>  mov [ esi ], _TOS_
  2365 00000FF5 8A03                            mov al, [ _SCRATCH_ ]
  2366 00000FF7 25FF000000                      and _TOS_, 0x000000FF
  2367 00000FFC E8C5FFFFFF                      call emit_
  2368 00001001 61                              popa
  2369 00001002 43                              inc _SCRATCH_
  2370 00001003 E2EA                        loop .back
  2371                                      _DROP_
   148 00001005 AD                  <1>  lodsd
  2372 00001006 C3                          ret
  2373                                  
  2374                                  ; double size versions of emit, 32 x 48 pixels per glyph
  2375                                  two_emit_SF:
  2376 00001007 8A80[010C0000]              mov al, [ ShannonFano + _TOS_ ]
  2377                                  two_emit:
  2378 0000100D 803D[860F0000]00            cmp byte [ displayMode ], 0
  2379 00001014 0F84CEFCFFFF                jz two_emit1
  2380 0000101A E99AFEFFFF                  jmp two_emit2
  2381                                  
  2382                                  setupText_:     ; setup for full screen text window display
  2383 0000101F 803D[860F0000]00            cmp byte [ displayMode ], 0
  2384 00001026 0F84F8FCFFFF                jz setupText__1
  2385 0000102C E9C4FEFFFF                  jmp setupText__2
  2386                                  
  2387                                  line_:  ; ( startX length -- )   \ draw a horizontal line in the current colour, from startX relative to current clip window, of given length in pixels
  2388 00001031 803D[860F0000]00            cmp byte [ displayMode ], 0
  2389 00001038 750A                        jnz .forward
  2390 0000103A E81DFBFFFF                  call clip1
  2391 0000103F E905000000                  jmp .common
  2392                                  .forward:
  2393 00001044 E8C1FDFFFF                  call clip2
  2394                                  .common:
  2395 00001049 8B0E                        mov ecx, [esi]
  2396 0000104B D1E1                        shl ecx, PIXEL_SHIFT
  2397 0000104D 29CF                        sub edi, ecx
  2398 0000104F 89C1                        mov ecx, _TOS_
  2399 00001051 A1[64490000]                mov _TOS_, [ v_foregroundColour ]
  2400 00001056 F366AB                      rep stosw   ;
  2401 00001059 FF05[50490000]              inc dword [ v_gr_xy ]
  2402                                      _DROP_
   148 0000105F AD                  <1>  lodsd
  2403                                      _DROP_
   148 00001060 AD                  <1>  lodsd
  2404 00001061 C3                          ret
  2405                                  
  2406                                  box_:
  2407 00001062 803D[860F0000]00            cmp byte [ displayMode ], 0
  2408 00001069 0F84D3FCFFFF                jz box1
  2409 0000106F E99FFEFFFF                  jmp box2
  2410                                  
  2411                                  page_:    ; ( -- )    \ fill the full screen with the current background colour
  2412                                      _DUP_
   132 00001074 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00001077 8906                <1>  mov [ esi ], _TOS_
  2413 00001079 B800000000                  mov _TOS_, colour_background   ;
  2414 0000107E E90A000000                  jmp wash_
  2415                                  
  2416                                  screen_:    ; ( -- )   \ fill the full screen with the current foreground colour
  2417                                      _DUP_
   132 00001083 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00001086 8906                <1>  mov [ esi ], _TOS_
  2418 00001088 A1[64490000]                mov _TOS_, [ v_foregroundColour ]  ;     ; select the foreground colour in the low 16 bits
  2419                                  ;    jmp wash_                      ; fall through to wash1
  2420                                  
  2421                                  wash_:  ; ( colour -- )   \ fill the full screeen with the given colour
  2422 0000108D A3[54480000]                mov [ v_washColour ], _TOS_
  2423 00001092 803D[860F0000]00            cmp byte [ displayMode ], 0
  2424 00001099 0F84F1FCFFFF                jz wash1
  2425 0000109F E9BDFEFFFF                  jmp wash2
  2426                                  
  2427                                  ; *****************************************************************************
  2428                                  ; *****************************************************************************
  2429                                  ; *****************************************************************************
  2430                                  
  2431                                  setCyan:    ; ( -- )
  2432                                      _DUP_
   132 000010A4 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000010A7 8906                <1>  mov [ esi ], _TOS_
  2433 000010A9 B8FF070000                  mov _TOS_, colour_cyan
  2434 000010AE E92AFAFFFF                  jmp dword set_color_
  2435                                  
  2436                                  setMagenta:    ; ( -- )
  2437                                      _DUP_
   132 000010B3 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000010B6 8906                <1>  mov [ esi ], _TOS_
  2438 000010B8 B81FF80000                  mov _TOS_, colour_magenta
  2439 000010BD E91BFAFFFF                  jmp dword set_color_
  2440                                  
  2441                                  setMagentaData:    ; ( -- )
  2442                                      _DUP_
   132 000010C2 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000010C5 8906                <1>  mov [ esi ], _TOS_
  2443 000010C7 B810D00000                  mov _TOS_, colour_magentaData
  2444 000010CC E90CFAFFFF                  jmp dword set_color_
  2445                                  
  2446                                  setBlue:    ; ( -- )
  2447                                      _DUP_
   132 000010D1 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000010D4 8906                <1>  mov [ esi ], _TOS_
  2448 000010D6 B81F000000                  mov _TOS_, colour_blue
  2449 000010DB E9FDF9FFFF                  jmp dword set_color_
  2450                                  
  2451                                  setRed:    ; ( -- )
  2452                                      _DUP_
   132 000010E0 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000010E3 8906                <1>  mov [ esi ], _TOS_
  2453 000010E5 B800F80000                  mov _TOS_, colour_red
  2454 000010EA E9EEF9FFFF                  jmp dword set_color_
  2455                                  
  2456                                  setGreen:    ; ( -- )
  2457                                      _DUP_
   132 000010EF 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000010F2 8906                <1>  mov [ esi ], _TOS_
  2458 000010F4 B800060000                  mov _TOS_, colour_green
  2459 000010F9 E9DFF9FFFF                  jmp dword set_color_
  2460                                  
  2461                                  setSilver:    ; ( -- )         \ AKA grAy
  2462                                      _DUP_
   132 000010FE 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00001101 8906                <1>  mov [ esi ], _TOS_
  2463 00001103 B818C60000                  mov _TOS_, colour_silver
  2464 00001108 E9D0F9FFFF                  jmp dword set_color_
  2465                                  
  2466                                  history:
  2467 0000110D 00<rep Bh>                  times 11 db 0
  2468                                  
  2469                                  echo_:
  2470 00001118 56                          push esi
  2471 00001119 B90A000000                  mov ecx, 11-1
  2472 0000111E 8D3D[0D110000]              lea edi, [ history ]
  2473 00001124 8D7701                      lea esi, [ edi + 1 ]
  2474 00001127 F3A4                        rep movsb
  2475 00001129 5E                          pop esi
  2476 0000112A A2[17110000]                mov byte [ history+11-1 ], al
  2477                                      _DROP_
   148 0000112F AD                  <1>  lodsd
  2478 00001130 C3                          ret
  2479                                  
  2480                                  right:
  2481                                      _DUP_
   132 00001131 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00001134 8906                <1>  mov [ esi ], _TOS_
  2482 00001136 B90B000000                  mov ecx, 11
  2483 0000113B 8D3D[0D110000]              lea edi, [history]
  2484 00001141 31C0                        xor _TOS_, _TOS_
  2485 00001143 F3AA                        rep stosb
  2486                                      _DROP_
   148 00001145 AD                  <1>  lodsd
  2487 00001146 C3                          ret
  2488                                  
  2489                                  down:
  2490                                      _DUP_
   132 00001147 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000114A 8906                <1>  mov [ esi ], _TOS_
  2491 0000114C 31D2                        xor edx, edx
  2492 0000114E 8B0D[F4470000]              mov ecx, [ v_iconh ]
  2493 00001154 F7F1                        div ecx
  2494 00001156 89D0                        mov _TOS_, edx
  2495 00001158 2B15[F4470000]              sub edx, [ v_iconh ]
  2496 0000115E 81C203800300                add edx, ( 3 * 0x10000 )+ 0x8000 + 3
  2497 00001164 8915[50490000]              mov [ v_gr_xy ], edx
  2498                                  ; zero:
  2499 0000116A 85C0                        test _TOS_, _TOS_
  2500 0000116C B800000000                  mov _TOS_, 0
  2501 00001171 7501                        jnz .dw
  2502 00001173 40                          inc _TOS_
  2503                                  .dw:
  2504 00001174 C3                          ret
  2505                                  
  2506                                  lm:     ; ( leftMargin -- )
  2507 00001175 A3[54490000]                mov [ v_leftMargin ], _TOS_
  2508                                      _DROP_
   148 0000117A AD                  <1>  lodsd
  2509 0000117B C3                          ret
  2510                                  
  2511                                  rm:     ; ( rightMargin -- )
  2512 0000117C A3[58490000]                mov [ v_rightMargin ], _TOS_
  2513                                      _DROP_
   148 00001181 AD                  <1>  lodsd
  2514 00001182 C3                          ret
  2515                                  
  2516                                  _at:    ; ( y x -- )
  2517 00001183 66A3[50490000]              mov word [ v_gr_y ], ax
  2518                                      _DROP_
   148 00001189 AD                  <1>  lodsd
  2519 0000118A 66A3[52490000]              mov word [ v_gr_x ], ax
  2520                                      _DROP_
   148 00001190 AD                  <1>  lodsd
  2521 00001191 C3                          ret
  2522                                  
  2523                                  plus_at:    ; ( y x -- )
  2524 00001192 660105[50490000]            add word [ v_gr_y ], ax
  2525                                      _DROP_
   148 00001199 AD                  <1>  lodsd
  2526 0000119A 660105[52490000]            add word [ v_gr_x ], ax
  2527                                      _DROP_
   148 000011A1 AD                  <1>  lodsd
  2528 000011A2 C3                          ret
  2529                                  
  2530                                  storew_:    ; ( w a -- ) \  ; : !w a! $00028966 3, drop ;
  2531 000011A3 8BD0                        db 0x8B, 0xD0           ; mov edx,eax       a! $D08B 2,   ( ?lit not true )
  2532 000011A5 668902                      db 0x66, 0x89, 0x02     ; mov [edx],ax      $00028966 3,
  2533                                      _DROP_                  ; lodsd
   148 000011A8 AD                  <1>  lodsd
  2534 000011A9 C3                          ret                     ; ret
  2535                                  
  2536                                  storeu_:    ; ( u a -- ) \  ; : !l a! $0289 2, drop ; forth
  2537 000011AA 8BD0                        db 0x8B, 0xD0           ; mov edx,eax       a! $D08B 2,   ( ?lit not true )
  2538 000011AC 8902                        db 0x89, 0x02           ; mov [edx],eax     $0289 2,
  2539                                      _DROP_                  ; lodsd
   148 000011AE AD                  <1>  lodsd
  2540 000011AF C3                          ret                     ; ret
  2541                                  
  2542                                  uplus_: ; ( u u -- u )   \ : u+ ?lit if $0681 2, , ; then $00044601 3, drop ;
  2543 000011B0 014604                      db 0x01, 0x46, 0x04     ; add [esi+0x4],eax   $00044601 3,   ( ?lit not true )
  2544                                      _DROP_                  ; lodsd
   148 000011B3 AD                  <1>  lodsd
  2545 000011B4 C3                          ret                     ; ret
  2546                                  
  2547                                  %if 1
  2548                                  ; the various pieces of code used by a! and +! in colorForth blocks 22 and 24
  2549                                   plusStore:  ; ( n a -- )
  2550                                      ;  : a! ?lit if $BA 1, , ; then $D08B 2, drop ;
  2551 000011B5 BA78563412                   mov dword edx, 0x12345678                  ; db 0xBA, 0x78, 0x56, 0x34, 0x12
  2552 000011BA 89C2                         mov edx, _TOS_                               ; db 0x8B, 0xD0 == db 0x89, 0xC2
  2553                                      ;  : +! ?lit if ?lit if $0581 2, swap a, , ; then $0501 2, a, drop ; then a! $0201 2, drop ;
  2554 000011BC 010578563412                 add [ dword 0x12345678 ], _TOS_              ; db 0x01, 0x05, 0x78, 0x56, 0x34, 0x12
  2555 000011C2 810578563412325476-          add dword [ dword 0x12345678 ], 0x98765432 ; db 0x81, 0x05, 0x78, 0x56, 0x34, 0x12, 0x32, 0x54, 0x76, 0x98
  2555 000011CB 98                 
  2556 000011CC 0102                         add [ edx ], _TOS_                           ; db 0x01, 0x02
  2557 000011CE C3                           ret
  2558                                  %endif
  2559                                  
  2560                                  octant:
  2561                                      _DUP_
   132 000011CF 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000011D2 8906                <1>  mov [ esi ], _TOS_
  2562 000011D4 B843000000                  mov _TOS_, 0x43
  2563 000011D9 8B5604                      mov edx, [ esi + 0x04 ]
  2564 000011DC 85D2                        test edx, edx
  2565 000011DE 7907                        jns .forward
  2566 000011E0 F7DA                        neg edx
  2567 000011E2 895604                      mov [ esi + 0x04 ], edx
  2568 000011E5 3401                        xor al, 0x01
  2569                                  .forward:
  2570 000011E7 3B16                        cmp edx, [ esi ]
  2571 000011E9 7902                        jns .forward2
  2572 000011EB 3404                        xor al, 0x04
  2573                                  .forward2:
  2574 000011ED C3                          ret
  2575                                  
  2576                                  hicon:
  2577 000011EE 30313233                   db 0x30, 0x31, 0x32, 0x33
  2578 000011F2 34353637                   db 0x34, 0x35, 0x36, 0x37
  2579 000011F6 38396162                   db 0x38, 0x39, 0x61, 0x62
  2580 000011FA 63646566                   db 0x63, 0x64, 0x65, 0x66
  2581                                  ;  db 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F
  2582                                  ;  db 0x20, 0x21, 0x05, 0x13, 0x0A, 0x10, 0x04, 0x0E
  2583                                  
  2584                                  edig1:
  2585                                      _DUP_
   132 000011FE 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00001201 8906                <1>  mov [ esi ], _TOS_
  2586                                  digit:
  2587 00001203 51                          push ecx
  2588 00001204 8A80[EE110000]              mov al, [ _TOS_ + hicon ]
  2589 0000120A E8B7FDFFFF                  call emit_
  2590 0000120F 59                          pop ecx
  2591 00001210 C3                          ret
  2592                                  
  2593                                  odig:
  2594 00001211 C1C004                      rol _TOS_, 0x04
  2595                                      _DUP_
   132 00001214 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00001217 8906                <1>  mov [ esi ], _TOS_
  2596 00001219 83E00F                      and _TOS_, byte 0x0F
  2597 0000121C C3                          ret
  2598                                  
  2599                                  h_dot_n:
  2600 0000121D 89C2                        mov edx, _TOS_
  2601 0000121F F7D8                        neg _TOS_
  2602 00001221 8D0C8520000000              lea ecx, [ ( _TOS_ * 4 ) + 0x20 ]
  2603                                      _DROP_
   148 00001228 AD                  <1>  lodsd
  2604 00001229 D3C0                        rol _TOS_, cl
  2605 0000122B 89D1                        mov ecx, edx
  2606 0000122D EB05                        jmp short h_dot_one
  2607                                  
  2608                                  dotHex8_: ; ( u -- )   \ display a hexadecimal number with leading zeros, 8 .hex
  2609 0000122F B908000000                  mov ecx, 0x08
  2610                                  h_dot_one:
  2611 00001234 E8D8FFFFFF                  call odig
  2612 00001239 E8C5FFFFFF                  call digit
  2613 0000123E E2F4                        loop h_dot_one
  2614                                      _DROP_
   148 00001240 AD                  <1>  lodsd
  2615 00001241 C3                          ret
  2616                                  
  2617                                  dotHex2_: ; ( c -- )   \ display a hexadecimal number with leading zeros, 2 .hex
  2618 00001242 C1E018                      shl _TOS_, 24
  2619 00001245 B902000000                  mov ecx, 0x02
  2620 0000124A E8E5FFFFFF                  call h_dot_one
  2621 0000124F C3                          ret
  2622                                  
  2623                                  dotHex4_: ; ( w -- )   \ display a hexadecimal number with leading zeros, 4 .hex
  2624 00001250 C1E010                      shl _TOS_, 16
  2625 00001253 B904000000                  mov ecx, 0x04
  2626 00001258 E8D7FFFFFF                  call h_dot_one
  2627 0000125D C3                          ret
  2628                                  
  2629                                  dotHex:     ; ( u -- )   \ display a hexadecimal number
  2630                                      EMIT_IMM('$')
   193                              <1> 
   194                              <1>  _DUP_
   132 0000125E 8D76FC              <2>  lea esi, [ esi - 4 ]
   133                              <2> 
   134 00001261 8906                <2>  mov [ esi ], _TOS_
   195 00001263 B824000000          <1>  mov _TOS_, %1
   196 00001268 E859FDFFFF          <1>  call emit_
   197                              <1> 
  2631 0000126D B907000000                  mov ecx, 0x07
  2632                                  .back:
  2633 00001272 E89AFFFFFF                  call odig
  2634 00001277 7517                        jnz .forward
  2635                                      _DROP_
   148 00001279 AD                  <1>  lodsd
  2636 0000127A E2F6                        loop .back
  2637 0000127C 41                          inc ecx
  2638                                  .back2:
  2639 0000127D E88FFFFFFF                  call odig
  2640                                  .back3:
  2641 00001282 E87CFFFFFF                  call digit
  2642 00001287 E2F4                        loop .back2
  2643 00001289 E84AFDFFFF                  call space_
  2644                                      _DROP_
   148 0000128E AD                  <1>  lodsd
  2645 0000128F C3                          ret
  2646                                  .forward:
  2647 00001290 41                          inc ecx
  2648 00001291 EBEF                        jmp short .back3
  2649                                  
  2650                                  qdot:   ; ( u -- )   \ display a decimal or hexadecimal number, depending on base
  2651 00001293 833D[2C480000]0A            cmp dword [ base ], byte 10
  2652 0000129A 75C2                        jnz dotHex
  2653                                  dotDecimal:                         ; display a decimal number
  2654                                  ;    EMIT_IMM('#')
  2655 0000129C 89C2                        mov edx, _TOS_
  2656 0000129E 85D2                        test edx, edx
  2657 000012A0 7911                        jns .forward
  2658 000012A2 F7DA                        neg edx                         ; negate the value and display a minus sign if required
  2659                                      EMIT_IMM('-')
   193                              <1> 
   194                              <1>  _DUP_
   132 000012A4 8D76FC              <2>  lea esi, [ esi - 4 ]
   133                              <2> 
   134 000012A7 8906                <2>  mov [ esi ], _TOS_
   195 000012A9 B82D000000          <1>  mov _TOS_, %1
   196 000012AE E813FDFFFF          <1>  call emit_
   197                              <1> 
  2660                                  .forward:
  2661 000012B3 B908000000                  mov ecx, 0x08
  2662                                  .back:
  2663 000012B8 89D0                        mov _TOS_, edx
  2664 000012BA 31D2                        xor edx, edx
  2665 000012BC F7348D[70470000]            div dword [ ecx * 4 + tens ]
  2666 000012C3 85C0                        test _TOS_, _TOS_
  2667 000012C5 7510                        jnz .forward2
  2668 000012C7 49                          dec ecx
  2669 000012C8 79EE                        jns .back
  2670 000012CA EB13                        jmp short .forward3
  2671                                  .back2:
  2672 000012CC 89D0                        mov _TOS_, edx
  2673 000012CE 31D2                        xor edx, edx
  2674 000012D0 F7348D[70470000]            div dword [ ecx * 4 + tens ]
  2675                                  .forward2:
  2676 000012D7 E822FFFFFF                  call edig1
  2677 000012DC 49                          dec ecx
  2678 000012DD 79ED                        jns .back2
  2679                                  .forward3:
  2680 000012DF 89D0                        mov _TOS_, edx
  2681 000012E1 E818FFFFFF                  call edig1
  2682 000012E6 E8EDFCFFFF                  call space_
  2683                                      _DROP_
   148 000012EB AD                  <1>  lodsd
  2684 000012EC C3                          ret
  2685                                  
  2686                                  eight:  ; display eight characters for one long line in a keypad mnemonic, with a space between the groups of four
  2687 000012ED 83C70C                      add edi, byte 0x0C
  2688 000012F0 E808000000                  call four
  2689 000012F5 E8DEFCFFFF                  call space_
  2690 000012FA 83EF10                      sub edi, byte 0x10
  2691                                  four:       ; display four characters for one line in a keypad mnemonic
  2692 000012FD B904000000                  mov ecx, 0x04
  2693                                  four1:      ; set ecx to the required number of characters to display
  2694 00001302 51                          push ecx
  2695                                      _DUP_
   132 00001303 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00001306 8906                <1>  mov [ esi ], _TOS_
  2696 00001308 31C0                        xor _TOS_, _TOS_
  2697 0000130A 8A4704                      mov al, [edi+0x04]
  2698 0000130D 47                          inc edi
  2699 0000130E E8B3FCFFFF                  call emit_
  2700                                  ;    call emitSF_    ; Note : The characters returned by a keypad are Shannon-Fano encoded
  2701 00001313 59                          pop ecx
  2702 00001314 E2EC                        loop four1
  2703 00001316 C3                          ret
  2704                                  
  2705                                  displayTheStack:  ; display the stack
  2706 00001317 BFFC730000                  mov edi, ( DATA_STACK_0 - 4 )   ; save empty stack pointer, plus one ( stack grows downwards )
  2707                                  .back:
  2708 0000131C 8B15[73040000]              mov edx, [ main ]        ; copy the current stack pointer
  2709 00001322 393A                        cmp [edx], edi
  2710 00001324 7311                        jnc .forward            ; test for empty stack, meaning done
  2711                                      _DUP_
   132 00001326 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00001329 8906                <1>  mov [ esi ], _TOS_
  2712 0000132B 8B07                        mov _TOS_, [edi]          ; fetch the value of the current stack item
  2713 0000132D 83EF04                      sub edi, byte 0x04      ;
  2714 00001330 E85EFFFFFF                  call qdot               ; display one stack item
  2715 00001335 EBE5                        jmp short .back         ; next stack item
  2716                                  .forward:
  2717 00001337 C3                          ret
  2718                                  
  2719                                  yShift equ 3
  2720                                  
  2721                                  displayBlockNumber:    ;  ( -- )     ; in the top right corner of the screen
  2722                                      _DUP_
   132 00001338 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000133B 8906                <1>  mov [ esi ], _TOS_
  2723 0000133D A1[64490000]                mov _TOS_, [ v_foregroundColour ]
  2724                                      _DUP_
   132 00001342 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00001345 8906                <1>  mov [ esi ], _TOS_
  2725 00001347 A112180000                  mov _TOS_, [ vesa_XResolution ]   ; was this  : mov _TOS_, ( scrnw )
  2726 0000134C 25FFFF0000                  and _TOS_, 0xFFFF
  2727 00001351 2B05[FC470000]              sub _TOS_, [ v_nine_iconw ]
  2728 00001357 89C3                        mov _SCRATCH_, _TOS_                ; save for later
  2729 00001359 A3[54490000]                mov [ v_leftMargin ], _TOS_
  2730 0000135E 6667A3[5049]                mov [ word v_gr_y ], ax
  2731 00001363 0305[FC470000]              add _TOS_, [ v_nine_iconw ]
  2732 00001369 A3[58490000]                mov [ v_rightMargin ], _TOS_
  2733 0000136E 89D8                        mov _TOS_, _SCRATCH_
  2734 00001370 C1E010                      shl _TOS_, 16
  2735 00001373 0503000000                  add _TOS_, yShift
  2736 00001378 A3[50490000]                mov [ v_gr_xy ], _TOS_
  2737                                      _DUP_
   132 0000137D 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00001380 8906                <1>  mov [ esi ], _TOS_
  2738 00001382 A1[54480000]                mov _TOS_, [ v_washColour ]  ; so we do not see the number yet, just measure its width
  2739                                  ;    mov _TOS_, colour_blockNumber
  2740                                  ;    shr _TOS_, 16                 ; select the background colour in the high 16 bits
  2741 00001387 E851F7FFFF                  call set_color_
  2742                                      _DUP_
   132 0000138C 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000138F 8906                <1>  mov [ esi ], _TOS_
  2743 00001391 A1[A8470000]                mov _TOS_, [ v_blk ]
  2744 00001396 E8F8FEFFFF                  call qdot
  2745 0000139B 8B1D[50490000]              mov _SCRATCH_, [ v_gr_xy ]            ; current x,y coordinate, x in high 16 bits
  2746 000013A1 C1EB10                      shr _SCRATCH_, 16
  2747 000013A4 2B1D[54490000]              sub _SCRATCH_, [ v_leftMargin ]   ; _SCRATCH_ is now the width of number string, in pixels
  2748 000013AA 2B1D[F0470000]              sub _SCRATCH_, [ v_iconw ]        ; correction...
  2749 000013B0 C1E310                      shl _SCRATCH_, 16
  2750 000013B3 A112180000                  mov _TOS_, [ vesa_XResolution ]   ; screen width in pixels
  2751                                      ; and _TOS_, 0xFFFF   ; not needed because of the  shl  below
  2752 000013B8 C1E010                      shl _TOS_, 16
  2753 000013BB 0503000000                  add _TOS_, yShift
  2754 000013C0 29D8                        sub _TOS_, _SCRATCH_
  2755 000013C2 A3[50490000]                mov [ v_gr_xy ], _TOS_
  2756                                  
  2757                                      _DUP_
   132 000013C7 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000013CA 8906                <1>  mov [ esi ], _TOS_
  2758 000013CC B800E20000                  mov _TOS_, colour_blockNumber
  2759 000013D1 C1C810                      ror _TOS_, 16
  2760 000013D4 E804F7FFFF                  call set_color_
  2761                                      _DUP_
   132 000013D9 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000013DC 8906                <1>  mov [ esi ], _TOS_
  2762 000013DE A1[F0470000]                mov _TOS_, [ v_iconw ]
  2763 000013E3 01C0                        add _TOS_, _TOS_
  2764                                      _DUP_
   132 000013E5 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000013E8 8906                <1>  mov [ esi ], _TOS_
  2765 000013EA A1[F4470000]                mov _TOS_, [ v_iconh ]
  2766 000013EF E86EFCFFFF                  call box_
  2767 000013F4 A3[50490000]                mov [ v_gr_xy ], _TOS_
  2768                                  
  2769 000013F9 B800E20000                  mov _TOS_, colour_blockNumber
  2770                                      _DUP_
   132 000013FE 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00001401 8906                <1>  mov [ esi ], _TOS_
  2771 00001403 E8D5F6FFFF                  call set_color_
  2772                                      _DUP_
   132 00001408 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000140B 8906                <1>  mov [ esi ], _TOS_
  2773 0000140D A1[A8470000]                mov _TOS_, [ v_blk ]
  2774                                  ;    mov _TOS_, [ v_numberOfMagentas ]
  2775                                  
  2776 00001412 E87CFEFFFF                  call qdot
  2777                                      _DROP_
   148 00001417 AD                  <1>  lodsd
  2778 00001418 A3[64490000]                mov [ v_foregroundColour ], _TOS_
  2779                                      _DROP_
   148 0000141D AD                  <1>  lodsd
  2780 0000141E C3                      ret
  2781                                  
  2782                                  ; *****************************************************************************
  2783                                  ; keyboard displays
  2784                                  ; *****************************************************************************
  2785                                  
  2786                                  showEditBox:    ; v_at set up for start coordinate of box, width and height on stack
  2787 0000141F 812D[50490000]0400-         sub dword [ v_gr_xy ], 0x000C0004   ; move the start position left  and up   by 0xXXXXYYYY
  2787 00001427 0C00               
  2788 00001429 8B1D[64490000]              mov dword _SCRATCH_, [ v_foregroundColour ]
  2789 0000142F C705[64490000]00E2-         mov dword [ v_foregroundColour ], colour_orange
  2789 00001437 0000               
  2790 00001439 B902000000                  mov ecx, 2
  2791                                  .loop:
  2792 0000143E 51                          push ecx
  2793                                      _DUP_
   132 0000143F 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00001442 8906                <1>  mov [ esi ], _TOS_
  2794 00001444 B800000000                  mov _TOS_, 0            ; SOS = x start position in pixels, relative to current clip "window"
  2795                                      _DUP_
   132 00001449 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000144C 8906                <1>  mov [ esi ], _TOS_
  2796 0000144E A1[F0470000]                mov _TOS_, [ v_iconw ]
  2797 00001453 C1E003                      shl _TOS_, 3            ; multiply by 8
  2798 00001456 0305[F0470000]              add _TOS_, [ v_iconw ]  ; multiply by 9
  2799 0000145C 0305[F0470000]              add _TOS_, [ v_iconw ]  ; multiply by 10
  2800                                      ; TOS = length of horizontal line in pixels
  2801 00001462 E8CAFBFFFF                  call line_
  2802 00001467 8B0D[F4470000]              mov ecx, [ v_iconh ]
  2803 0000146D C1E102                      shl ecx, 2              ; multiply by 4
  2804 00001470 81C104000000                add ecx, 4              ; draw the lower line below the text
  2805 00001476 010D[50490000]              add dword [ v_gr_xy ], ecx ; move the start position down by 4 character heights
  2806 0000147C 59                          pop ecx
  2807 0000147D E2BF                        loop .loop
  2808                                  
  2809 0000147F 891D[64490000]              mov dword [ v_foregroundColour ], _SCRATCH_
  2810 00001485 C3                          ret
  2811                                  
  2812                                  ; keypa (d)
  2813                                  displayTheKeypad_:   ; the Keypad is the mnemonic at the bottom right of the display, showing the actions of each of the 27 keys used
  2814 00001486 E894FBFFFF                  call setupText_
  2815 0000148B 8B3D[24480000]              mov edi, [ dword currentKeypadIcons ]
  2816                                      _DUP_
   132 00001491 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00001494 8906                <1>  mov [ esi ], _TOS_
  2817 00001496 A1[34480000]                mov _TOS_, [ keypad_colour ]
  2818 0000149B E83DF6FFFF                  call set_color_
  2819 000014A0 A112180000                  mov _TOS_, [ vesa_XResolution ] ; was this  : mov _TOS_, ( scrnw )
  2820 000014A5 25FFFF0000                  and _TOS_, 0xFFFF
  2821 000014AA 2B05[FC470000]              sub _TOS_, [ v_nine_iconw ]
  2822 000014B0 2D10000000                  sub _TOS_, 16
  2823 000014B5 A3[54490000]                mov [ v_leftMargin ], _TOS_     ; x coordinate of left margin of keypad display
  2824 000014BA 89C2                        mov edx, _TOS_                  ;
  2825 000014BC 0315[FC470000]              add edx, [ v_nine_iconw ]       ; x coordinate of right margin of keypad display
  2826 000014C2 8915[58490000]              mov [ v_rightMargin ], edx
  2827 000014C8 C1E010                      shl _TOS_, 0x10
  2828 000014CB 8B1514180000                mov edx, [ vesa_YResolution ]   ; was this  : mov _TOS_, ( scrnw )
  2829 000014D1 81E2FFFF0000                and edx, 0x0000FFFF
  2830 000014D7 53                          push _SCRATCH_
  2831 000014D8 8B1D[F8470000]              mov _SCRATCH_, [ v_keypadY_iconh ]
  2832 000014DE 81C30A000000                add _SCRATCH_, 10
  2833 000014E4 29DA                        sub edx, _SCRATCH_              ; ( ( keypadY * iconh ) + 10 )
  2834 000014E6 01D0                        add _TOS_, edx
  2835                                  
  2836 000014E8 A3[50490000]                mov [ v_gr_xy ], _TOS_
  2837                                  
  2838 000014ED F605[17480000]FF            test byte [ v_quitMode ], 0xFF
  2839 000014F4 740C                        jz .forward
  2840 000014F6 60                          pusha
  2841 000014F7 E823FFFFFF                  call showEditBox
  2842 000014FC 61                          popa
  2843 000014FD A3[50490000]                mov [ v_gr_xy ], _TOS_
  2844                                  .forward:
  2845                                  
  2846 00001502 5B                          pop _SCRATCH_
  2847 00001503 E8E5FDFFFF                  call eight
  2848 00001508 E8E0FDFFFF                  call eight
  2849 0000150D E8DBFDFFFF                  call eight
  2850 00001512 E880F5FFFF                  call cr_
  2851                                  ;    add dword [ v_gr_xy ],  ( 4 * iconw * 0x10000 )        ; shift horizontal pixels to the right
  2852 00001517 8B1D[F0470000]              mov _SCRATCH_, [ v_iconw ]
  2853 0000151D C1E312                      shl _SCRATCH_, ( 2 + 16 ) ; ( 4 * iconw * 0x10000 )  ; shift horizontal pixels to the right
  2854 00001520 011D[50490000]              add dword [ v_gr_xy ], _SCRATCH_
  2855 00001526 8B3D[28480000]              mov edi, [ shiftAction ]
  2856 0000152C 83C70C                      add edi, byte 0x0C
  2857 0000152F B903000000                  mov ecx, 0x03
  2858 00001534 E8C9FDFFFF                  call four1
  2859                                  
  2860 00001539 E89AFAFFFF                  call space_
  2861                                      _DUP_
   132 0000153E 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00001541 8906                <1>  mov [ esi ], _TOS_
  2862 00001543 A1[18480000]                mov _TOS_, [ v_hintChar ]
  2863 00001548 E879FAFFFF                  call emit_
  2864                                  
  2865 0000154D C705[54490000]0300-         mov dword [ v_leftMargin ], 0x03
  2865 00001555 0000               
  2866 00001557 66C705[52490000]03-         mov word [ v_gr_x ], 0x03
  2866 0000155F 00                 
  2867 00001560 E8B2FDFFFF                  call displayTheStack
  2868 00001565 A112180000                  mov _TOS_, [ vesa_XResolution ]   ; was this  : mov _TOS_, ( scrnw )
  2869 0000156A 25FFFF0000                  and _TOS_, 0xFFFF
  2870 0000156F 2B05[00480000]              sub _TOS_, [ v_twentytwo_iconw ]
  2871 00001575 0503000000                  add _TOS_, 3
  2872 0000157A 66A3[52490000]              mov word [ v_gr_x ], ax
  2873 00001580 8D3D[09110000]              lea edi, [ ( history - 4 )]     ; the text entered so far
  2874 00001586 B90B000000                  mov ecx, 0x0B
  2875 0000158B E972FDFFFF                  jmp dword four1
  2876                                  
  2877                                  ; *****************************************************************************
  2878                                  ; Tables of keys to return when each of the 24 main keypad positions are pressed
  2879                                  ; Note : The keypad key lists below use Shannon-Fano encoded characters
  2880                                  ; *****************************************************************************
  2881                                  alphaKeypad:        ; the 'alpha' character keypad keys, the start screen for key entry
  2882 00001590 6763726C                    db 'gcrl' ;  
  2883 00001594 68746E73                    db 'htns' ;  
  2884 00001598 626D7776                    db 'bmwv' ;  
  2885 0000159C 70796669                    db 'pyfi' ;  
  2886 000015A0 616F6575                    db 'aoeu' ;  
  2887 000015A4 716B7864                    db 'qkxd' ;  
  2888                                  
  2889                                  graphicsKeypad:     ; the 'graphics' character keypad icons (Note: not numbers, just characters)
  2890 000015A8 31323320                    db '123 ' ;     Note : these are Capital (larger) numbers
  2891 000015AC 34353630                    db '4560' ; 
  2892 000015B0 3738393F                    db '789?' ; 
  2893 000015B4 3A3B2140                    db ':;!@' ; 
  2894 000015B8 7A6A2E2C                    db 'zj.,' ; 
  2895 000015BC 2A2F2B2D                    db '*/+-' ; 
  2896                                  
  2897                                  decimalKeypad:      ; the decimal number entry keypad icons
  2898 000015C0 31323320                    db '123 ' ;
  2899 000015C4 34353630                    db '4560' ;
  2900 000015C8 37383920                    db '789 ' ;
  2901 000015CC 20202020                    db '    ' ;
  2902 000015D0 20202020                    db '    ' ;
  2903 000015D4 20202020                    db '    ' ;
  2904                                  
  2905                                  hexadecimalKeypad:  ; the hexadecimal number entry keypad icons
  2906 000015D8 31323320                    db '123 ' ;
  2907 000015DC 34353630                    db '4560' ;
  2908 000015E0 37383920                    db '789 ' ;
  2909 000015E4 20616263                    db ' abc' ;
  2910 000015E8 20646566                    db ' def' ;
  2911 000015EC 20202020                    db '    ' ;
  2912                                  
  2913                                  ; *****************************************************************************
  2914                                  ; get keyboard keys
  2915                                  ; *****************************************************************************
  2916                                  
  2917                                  letter:
  2918 000015F0 3C04                        cmp al, 0x04  ; ignore 0 to 3, NOP, N, spacebar, AltGr
  2919 000015F2 7809                        js .forward
  2920 000015F4 8B15[24480000]              mov edx, [ currentKeypadIcons ]
  2921 000015FA 8A0410                      mov al, [ _TOS_ + edx ]
  2922                                  .forward:
  2923 000015FD C3                          ret
  2924                                  
  2925                                  key_map_table:   ; map 8042 scan type 1 keycode to colorForth character values
  2926 000015FE 1011121300000405            db 16, 17, 18, 19,  0,  0,  4,  5 ; 0x10 - 0x17
  2927 00001606 0607000000001415            db  6,  7,  0,  0,  0,  0, 20, 21 ; 0x18 - 0x1F
  2928 0000160E 1617000008090A0B            db 22, 23,  0,  0,  8,  9, 10, 11 ; 0x20 - 0x27
  2929 00001616 0000000018191A1B            db  0,  0,  0,  0, 24, 25, 26, 27 ; 0x28 - 0x2F
  2930 0000161E 00010C0D0E0F0000            db  0,  1, 12, 13, 14, 15,  0,  0 ; 0x30 - 0x37 N
  2931 00001626 0302                        db  3,  2                         ; 0x38 - 0x39 alt space
  2932                                  
  2933                                  ; ToDo: add a timeout to the loop
  2934                                  WaitToReceiveKey:      ; Wait until there is byte to receive from the keyboard controller
  2935                                  .back:
  2936 00001628 E464                        in al, 0x64     ; On-board controller status read
  2937 0000162A A801                        test al, 1      ; OBF (Output Buffer Full)
  2938 0000162C 750C                        jnz .forward    ; exit when bit 0 = 1 the On-board controller has a new character for us
  2939 0000162E 31C0                        xor _TOS_, _TOS_
  2940 00001630 E81CEEFFFF                  call pause_    ; not ready yet, so let the other task(s) have a turn
  2941 00001635 E9EEFFFFFF                  jmp  .back      ; jump back and try again
  2942                                  .forward:
  2943                                  ;    call pause_    ; not ready yet, so let the other task(s) have a turn
  2944 0000163A C3                          ret
  2945                                  
  2946                                  v_lineOffsetTablePtr:
  2947 0000163B 00000000                    dd 0 ; times 16 dd 0
  2948                                  
  2949                                  lineOffsetZero:
  2950 0000163F C705[56250000]0000-         mov dword [ v_lineOffset ], 0x00
  2950 00001647 0000               
  2951 00001649 C3                          ret
  2952                                  
  2953                                  lineOffsetPlus:
  2954 0000164A 8105[56250000]0C00-         add dword [ v_lineOffset ], 0x0C
  2954 00001652 0000               
  2955 00001654 C3                          ret
  2956                                  
  2957                                  lineOffsetMinus:
  2958 00001655 812D[56250000]0C00-         sub dword [ v_lineOffset ], 0x0C
  2958 0000165D 0000               
  2959 0000165F 7905                        jns .forward
  2960 00001661 E8D9FFFFFF                  call lineOffsetZero
  2961                                  .forward:
  2962 00001666 C3                          ret
  2963                                  
  2964                                  ; *****************************************************************************
  2965                                  ; F1 Help screens
  2966                                  ; *****************************************************************************
  2967                                  
  2968                                  help0:  ; save  v_blk , display the first help screen
  2969                                      _DUP_
   132 00001667 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000166A 8906                <1>  mov [ esi ], _TOS_
  2970 0000166C 813D[A8470000]FF01-         cmp dword [ v_blk ], LAST_BLOCK_NUMBER     ; we are displaying the first Help screen
  2970 00001674 0000               
  2971 00001676 740A                        je .forward
  2972 00001678 A1[A8470000]                mov _TOS_, [ v_blk ]
  2973 0000167D A3[9C470000]                mov [ v_saved_v_blk ], _TOS_
  2974                                  .forward:
  2975 00001682 C705[A8470000]FF01-         mov dword [ v_blk ], LAST_BLOCK_NUMBER
  2975 0000168A 0000               
  2976                                      _DROP_
   148 0000168C AD                  <1>  lodsd
  2977 0000168D C3                          ret
  2978                                  
  2979                                  help1:  ; display the second help screen
  2980 0000168E C705[A8470000]4100-         mov dword [ v_blk ], ( START_BLOCK_NUMBER + 1 )
  2980 00001696 0000               
  2981 00001698 C3                          ret
  2982                                  
  2983                                  help2:  ; display the second third screen
  2984 00001699 C705[A8470000]4000-         mov dword [ v_blk ], ( START_BLOCK_NUMBER )
  2984 000016A1 0000               
  2985 000016A3 C3                          ret
  2986                                  
  2987                                  help3:  ; restore the original screen being edited
  2988                                      _DUP_
   132 000016A4 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000016A7 8906                <1>  mov [ esi ], _TOS_
  2989 000016A9 A1[9C470000]                mov _TOS_, [ v_saved_v_blk ]
  2990 000016AE A3[A8470000]                mov [ v_blk ], _TOS_
  2991                                      _DROP_
   148 000016B3 AD                  <1>  lodsd
  2992 000016B4 C3                          ret
  2993                                  
  2994                                  HelpTable:
  2995 000016B5 [67160000]                  dd help0
  2996 000016B9 [8E160000]                  dd help1
  2997 000016BD [99160000]                  dd help2
  2998 000016C1 [A4160000]                  dd help3
  2999                                  
  3000                                  help:
  3001                                      _DUP_
   132 000016C5 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000016C8 8906                <1>  mov [ esi ], _TOS_
  3002 000016CA A1[98470000]                mov _TOS_, [ v_help_counter ]
  3003 000016CF 2503000000                  and _TOS_, 0x03
  3004 000016D4 FF1485[B5160000]            call dword [ ( _TOS_ * 4 ) + HelpTable ]
  3005                                      _DROP_
   148 000016DB AD                  <1>  lodsd
  3006 000016DC FE05[98470000]              inc byte [ v_help_counter ]
  3007 000016E2 C3                          ret
  3008                                  
  3009                                  ; *****************************************************************************
  3010                                  ; Editor
  3011                                  ; *****************************************************************************
  3012                                  
  3013                                  e_plus:
  3014 000016E3 E8D21F0000                  call colourBlindModeToggle
  3015 000016E8 E900000000                  jmp abort_e
  3016                                  
  3017                                  abort_e:
  3018                                      ; call abort
  3019 000016ED E889EEFFFF                  call c_
  3020                                  abort_e2:
  3021 000016F2 BC00780000                  mov esp, RETURN_STACK_0
  3022 000016F7 E8DA150000                  call e_
  3023 000016FC C3                          ret
  3024                                  
  3025                                  EnterKeyAction:   ; ( -- )    \ action when the keyboard enter key is pressed
  3026                                      ; mov byte [ v_quitMode ], 0x00     ; turn off the edit mode orange lines around the keypad
  3027                                      ; _DUP_
  3028 000016FD A1[D8470000]                mov _TOS_, [ v_cad ]
  3029 00001702 2D01000000                  sub _TOS_, 1                ; step to before the token before the cursor
  3030 00001707 C1E002                      shl _TOS_, 2                ; convert cell address to byte address
  3031 0000170A 8B00                        mov _TOS_, [ _TOS_ ]
  3032 0000170C 89C3                        mov _SCRATCH_, _TOS_
  3033 0000170E 81E30F000000                and _SCRATCH_, 0x0F         ; check the token type = 3 == red
  3034                                      
  3035 00001714 81FB03000000                cmp _SCRATCH_, 0x03
  3036 0000171A 7424                        je  .redEnterAction
  3037                                      
  3038 0000171C 81FB0C000000                cmp _SCRATCH_, 0x0C         ; check the token type = 12 == magenta.  NOT WORKING YET ToDo: fix this
  3039 00001722 7426                        je  .magentaEnterAction
  3040                                    
  3041 00001724 81FB04000000                cmp _SCRATCH_, 0x04
  3042 0000172A 7405                        je  .greenEnterAction       ; check the token type = 4 == green
  3043                                  
  3044 0000172C E944000000                  jmp .skip
  3045                                  
  3046                                  .greenEnterAction:
  3047                                      ; and _TOS_, byte -0x10 ; (saves 2 bytes compared to 'and _TOS_, 0xFFFFFFF0' )
  3048 00001731 E8F7200000                  call fnd_
  3049 00001736 E8D6200000                  call loc_
  3050 0000173B E935000000                  jmp .skip
  3051                                      
  3052                                  .redEnterAction:
  3053                                      ; and _TOS_, byte -0x10 ; (saves 2 bytes compared to 'and _TOS_, 0xFFFFFFF0' )
  3054 00001740 E8A0F0FFFF                  call execute_
  3055 00001745 E92B000000                  jmp .skip
  3056                                  
  3057                                  .magentaEnterAction:    ; ToDo: make this work!!!
  3058                                      ; and _TOS_, byte -0x10 ; (saves 2 bytes compared to 'and _TOS_, 0xFFFFFFF0' )
  3059                                      _DUP_
   132 0000174A 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000174D 8906                <1>  mov [ esi ], _TOS_
  3060 0000174F A1[D8470000]                mov _TOS_, [ v_cad ]
  3061                                      _DUP_
   132 00001754 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00001757 8906                <1>  mov [ esi ], _TOS_
  3062                                  
  3063 00001759 E917000000                  jmp .skip
  3064                                  
  3065 0000175E A1[D8470000]                mov _TOS_, [ v_cad ]
  3066 00001763 2D02000000                  sub _TOS_, 2                ; step to before two tokens before the cursor
  3067 00001768 C1E002                      shl _TOS_, 2                ; convert cell address to byte address
  3068                                      ; mov _TOS_, [ _TOS_ ]
  3069                                      ; call execute_
  3070                                      _DUP_
   132 0000176B 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000176E 8906                <1>  mov [ esi ], _TOS_
  3071 00001770 E900000000                  jmp .skip
  3072                                  
  3073                                  .skip:
  3074                                      _DROP_
   148 00001775 AD                  <1>  lodsd
  3075 00001776 C3                          ret
  3076                                  
  3077                                  %define FirstFkey  (59)     ; F1 = 59
  3078                                  
  3079                                  FkeyTable:  ; ( c -- a )   \ function key action table
  3080                                  ;    dd nul              ; 57
  3081                                  ;    dd nul              ; 58
  3082 00001777 [C5160000]                  dd help             ; 59 F1
  3083 0000177B [3B1C0000]                  dd toggleBase0      ; 60 F2 decimal/hex number display
  3084 0000177F [B3360000]                  dd seeb             ; 61 F3 show/hide blue words
  3085 00001783 [E3160000]                  dd e_plus           ; 62 F4 editor
  3086 00001787 [F0280000]                  dd tog_show_ASCII   ; 63 F5 show/hide the ASCII keyboard entry field at the cursor
  3087 0000178B [EA280000]                  dd otherBlock       ; 64 F6 display the previously edited block
  3088 0000178F [9A2B0000]                  dd locate           ; 65 F7 locate the definition of the word under the cursor
  3089 00001793 [40040000]                  dd nul              ; 66 F8
  3090 00001797 [531C0000]                  dd toggleBase       ; 67 F9
  3091 0000179B [7B050000]                  dd c_               ; 68 F10
  3092 0000179F [40040000]                  dd nul              ; 69 Num Lock
  3093 000017A3 [40040000]                  dd nul              ; 70
  3094 000017A7 [A0280000]                  dd cursorHome       ; 71 Home
  3095 000017AB [51280000]                  dd cursorUp         ; 72 Up arrow
  3096 000017AF [C7280000]                  dd nextBlock        ; 73 PgUp
  3097 000017B3 [40040000]                  dd nul              ; 74 -
  3098 000017B7 [AC260000]                  dd cursorLeft       ; 75 Left arrow
  3099 000017BB [EA280000]                  dd otherBlock       ; 76    display the previously edited block
  3100 000017BF [CF260000]                  dd cursorRight      ; 77 Right arrow
  3101 000017C3 [40040000]                  dd nul              ; 78 +
  3102 000017C7 [89280000]                  dd cursorEnd        ; 79 End
  3103 000017CB [69280000]                  dd cursorDown       ; 80 Down arrow
  3104 000017CF [D4280000]                  dd previousBlock    ; 81 PgDn
  3105 000017D3 [652B0000]                  dd destack          ; 82 Insert
  3106 000017D7 [812A0000]                  dd deleteAction     ; 83 Delete
  3107 000017DB [40040000]                  dd nul              ; 84
  3108 000017DF [40040000]                  dd nul              ; 85
  3109 000017E3 [40040000]                  dd nul              ; 86
  3110 000017E7 [3B1C0000]                  dd toggleBase0      ; 87 F11
  3111 000017EB [40040000]                  dd nul              ; 88 F12
  3112 000017EF [FD160000]                  dd EnterKeyAction   ; 89 really 121 Enter
  3113 000017F3 [ED160000]                  dd abort_e          ; 90 really 123 Escape
  3114                                  
  3115                                  processFkey:    ; ( n -- )   \ process the given function key code
  3116                                  ;    cmp _TOS_, 121
  3117                                  ;    jne .forward1
  3118                                  ;    sub _TOS_, ( 121 - 89 )
  3119                                  ;.forward1:
  3120 000017F7 2D3B000000                  sub _TOS_, FirstFkey   ; convert Fn key value to index from 0
  3121 000017FC 251F000000                  and _TOS_, 0x1F
  3122 00001801 FF1485[77170000]            call dword [ ( _TOS_ * 4 ) + FkeyTable ]
  3123                                  ;    _DROP_
  3124                                      ; call e_
  3125 00001808 C3                          ret
  3126                                  
  3127                                  get_key_:    ; ( -- c )   \ waits for and returns a character from the keyboard, assumes Scan Code Set 1, set up by the BIOS
  3128                                      _DUP_
   132 00001809 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000180C 8906                <1>  mov [ esi ], _TOS_
  3129 0000180E 31C0                        xor _TOS_, _TOS_
  3130                                  .back:
  3131                                      ; check if the key is a function key
  3132 00001810 3D3B000000                  cmp _TOS_, FirstFkey  ; F1 key
  3133 00001815 780C                        js .forward4
  3134 00001817 3D5B000000                  cmp _TOS_, FirstFkey + 32  ; Fxx key + 1
  3135 0000181C 7905                        jns .forward4
  3136 0000181E E8D4FFFFFF                  call processFkey
  3137                                  .forward4:
  3138                                      _DROP_
   148 00001823 AD                  <1>  lodsd
  3139 00001824 E87D000000                  call get_qwerty_key_
  3140                                  ;    call WaitToReceiveKey  ; Wait until there is a byte to receive from the keyboard controller
  3141                                  ;    in   al, 0x60       ; read the key value from the Keyboard data port
  3142 00001829 A0[80000000]                mov al, [ v_scanCode ]
  3143                                  ;    test al, 0xF0       ; we are only interested in certain key codes (?)
  3144                                  ;    jz   .back
  3145 0000182E 3C3A                        cmp  al, 0x3A       ; exclude keycodes greater than 0x39,  cmp  is like  sub  but only affects the flags
  3146 00001830 73DE                        jnc  .back
  3147 00001832 8A80[EE150000]              mov  al, [ key_map_table - 0x10 + EAX ] ; convert to the colorForth value using the 'key_map_table' table
  3148 00001838 C3                          ret
  3149                                  
  3150                                  ; *****************************************************************************
  3151                                  ; get qwerty keys
  3152                                  ; *****************************************************************************
  3153                                  
  3154 00001839 00<rep 3h>              align 4, db 0   ; fill the gap with 0's
  3155                                  
  3156                                  ; times 0x40 db 0x00,
  3157                                  
  3158                                  qwerty_key_map_table:
  3159                                  ;         0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F
  3160 0000183C 0B180219031A041B05-         db 0x0B, 0x18, 0x02, 0x19, 0x03, 0x1A, 0x04, 0x1B, 0x05, 0x1C, 0x06, 0x1D, 0x07, 0x1E, 0x08, 0x1F ; 0x00
  3160 00001845 1C061D071E081F     
  3161 0000184C 09200A211E0530132E-         db 0x09, 0x20, 0x0A, 0x21, 0x1e, 0x05, 0x30, 0x13, 0x2E, 0x0A, 0x20, 0x10, 0x12, 0x04, 0x21, 0x0E ; 0x10
  3161 00001855 0A20101204210E     
  3162 0000185C 220D23141707242225-         db 0x22, 0x0D, 0x23, 0x14, 0x17, 0x07, 0x24, 0x22, 0x25, 0x24, 0x26, 0x0C, 0x32, 0x09, 0x31, 0x06 ; 0x20
  3162 00001865 24260C32093106     
  3163 0000186C 18031912101713011F-         db 0x18, 0x03, 0x19, 0x12, 0x10, 0x17, 0x13, 0x01, 0x1F, 0x08, 0x14, 0x02, 0x16, 0x16, 0x2F, 0x11 ; 0x30
  3163 00001875 08140216162F11     
  3164 0000187C 110F2D15150B2C260C-         db 0x11, 0x0F, 0x2D, 0x15, 0x15, 0x0B, 0x2C, 0x26, 0x0C, 0x23, 0x34, 0x25, 0x35, 0x27, 0x27, 0x28 ; 0x40
  3164 00001885 23342535272728     
  3165 0000188C 2829822A8D2B832C89-         db 0x28, 0x29, 0x82, 0x2A, 0x8D, 0x2B, 0x83, 0x2C, 0x89, 0x2D, 0x33, 0x2E, 0xB5, 0x2F, 0x39, 0x80 ; 0x50
  3165 00001895 2D332EB52F3980     
  3166 0000189C 1C810E8201833B8429-         db 0x1C, 0x81, 0x0E, 0x82, 0x01, 0x83, 0x3B, 0x84, 0x29, 0x30
  3166 000018A5 30                 
  3167                                      ; test only
  3168                                  ; times 0x40 db 0x00,
  3169                                  
  3170                                  get_qwerty_key_:           ; get a qwerty key character
  3171                                      _DUP_
   132 000018A6 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000018A9 8906                <1>  mov [ esi ], _TOS_
  3172                                  .back:
  3173 000018AB E878FDFFFF                  call WaitToReceiveKey
  3174 000018B0 E460                        in al, 0x60
  3175                                  
  3176 000018B2 3D1C000000                  cmp _TOS_, 0x1C     ; the Enter key scan code
  3177 000018B7 7505                        jne .forward1
  3178                                      ; add _TOS_, ( 89 - 0x1C ) ; convert the code for the Enter key to 89
  3179 000018B9 B859000000                  mov _TOS_, 89
  3180                                  .forward1:
  3181                                  
  3182 000018BE 3D81000000                  cmp _TOS_, 0x81     ; the Escape key scan code
  3183 000018C3 7505                        jne .forward2
  3184 000018C5 05D9FFFFFF                  add _TOS_, ( 90 - 0x81 ) ; convert the code for the Escape key to 90
  3185                                  .forward2:
  3186                                  
  3187                                  ;    cmp _TOS_, 0x03     ; the Left Alt key scan code
  3188                                  ;    jne .forward3
  3189                                  ;    add _TOS_, 0x02 ; convert the code for the Left Alt key to a space key
  3190                                  ; .forward3:
  3191                                  
  3192 000018CA A2[80000000]                mov [ v_scanCode ], al
  3193 000018CF 89C1                        mov ecx, _TOS_              ; copy keycode into cl
  3194 000018D1 80E17F                      and cl, 0x7F                ; filter out key-up bit 7
  3195 000018D4 80F92A                      cmp cl, 0x2A                ; g?
  3196 000018D7 7405                        jz .got_c_or_g
  3197 000018D9 80F936                      cmp cl, 0x36                ; c?
  3198 000018DC 750B                        jnz .not_c_or_g
  3199                                  .got_c_or_g:
  3200 000018DE 2480                        and al, 0x80                ; extract key-up bit
  3201 000018E0 3480                        xor al, 0x80                ; complement it
  3202 000018E2 A3[48480000]                mov [ v_qwerty_key ], _TOS_
  3203 000018E7 EBC2                        jmp short .back
  3204                                  .not_c_or_g:
  3205 000018E9 08C0                        or al, al                   ; check if key-up
  3206 000018EB 78BE                        js .back                    ; if so, try again to get keydown event
  3207 000018ED 247F                        and al, 0x7F                ; filter out key-up bit
  3208 000018EF 0B05[48480000]              or _TOS_, [ v_qwerty_key ]
  3209 000018F5 BA[3C180000]                mov edx, qwerty_key_map_table
  3210 000018FA B935000000                  mov ecx, 0x35
  3211                                  .back2:
  3212 000018FF 3802                        cmp [edx], al
  3213 00001901 7408                        jz .forward
  3214 00001903 83C202                      add edx, byte 0x02
  3215 00001906 E2F7                        loop .back2
  3216 00001908 31C0                        xor _TOS_, _TOS_
  3217 0000190A C3                          ret
  3218                                  .forward:
  3219 0000190B 8A4201                      mov al, [edx+0x01]
  3220 0000190E 81EA[3C180000]              sub edx, qwerty_key_map_table
  3221 00001914 D1EA                        shr edx, 1
  3222 00001916 8915[4C480000]              mov [ v_digin ], edx
  3223 0000191C 3D3B000000                  cmp _TOS_, 59  ; F1 key
  3224                                  ;    jnz .forward4
  3225                                  ;    ; jmp dword [ _TOS_ * 4 + qwertyActionTable - 0x200 ]
  3226                                  ;    xor dword [ current], ((setBase_decimal - $$) ^ (setBase_hex - $$))
  3227                                  ;    call toggleBase
  3228                                  ;.forward4:
  3229 00001921 C3                          ret
  3230                                  
  3231                                  ; *****************************************************************************
  3232                                  ; keypad jump tables
  3233                                  ; actions for the three editor state change keys : N spacebar AltGr
  3234                                  ; *****************************************************************************
  3235                                  
  3236                                  graph0:
  3237 00001922 [641C0000]-                 dd nul0, nul0, nul0, alph0
  3237 00001926 [641C0000]-        
  3237 0000192A [641C0000]-        
  3237 0000192E [C21C0000]         
  3238 00001932 20206120                    db '  a ' ; _ _ a _ '  a ' ;
  3239                                  
  3240                                  graph1:
  3241 00001936 [6E1A0000]-                 dd word0, exit_, lj, alph
  3241 0000193A [011A0000]-        
  3241 0000193E [A7190000]-        
  3241 00001942 [E71C0000]         
  3242 00001946 782E6120                    db 'x.a ' ;
  3243                                  
  3244                                  alpha0:
  3245 0000194A [641C0000]-                 dd nul0, nul0, number, star0
  3245 0000194E [641C0000]-        
  3245 00001952 [9E1B0000]-        
  3245 00001956 [D41C0000]         
  3246 0000195A 20392A20                    db ' 9* ' ;
  3247                                  
  3248                                  alpha1:
  3249 0000195E [6E1A0000]-                 dd word0, exit_, lj, graph
  3249 00001962 [011A0000]-        
  3249 00001966 [A7190000]-        
  3249 0000196A [F91C0000]         
  3250 0000196E 782E2A20                    db 'x.* ' ;
  3251                                  
  3252                                  numb0:  ; the number keypad before the '-' key has been pressed ???
  3253 00001972 [641C0000]-                 dd nul0, minusSign, alphn, toggleBase
  3253 00001976 [921B0000]-        
  3253 0000197A [C11C0000]-        
  3253 0000197E [531C0000]         
  3254 00001982 2D616620                    db '-af ' ; 0x23, 0x05, 0x0E, 0x00       ; - a f _ '-af ' ;
  3255                                  
  3256                                  numb1:  ; the number keypad after the '-' key has been pressed ???
  3257 00001986 [9B1B0000]-                 dd number0, minusSign, endn, toggleBase
  3257 0000198A [921B0000]-        
  3257 0000198E [F11B0000]-        
  3257 00001992 [531C0000]         
  3258 00001996 2D616620                    db '-af ' ; 0x15, 0x25, 0x00, 0x00       ; x . _ _ 'x.  ' ;
  3259                                  
  3260                                  ; *****************************************************************************
  3261                                  ; Shannon-Fano compression
  3262                                  ; *****************************************************************************
  3263                                  
  3264                                  bits_:
  3265 0000199A 1C                          db 0x1C
  3266                                  
  3267                                  lj0:
  3268 0000199B 8A0D[9A190000]              mov cl, [ bits_ ]
  3269 000019A1 80C104                      add cl, 0x04
  3270 000019A4 D326                        shl dword [ esi ],cl
  3271 000019A6 C3                          ret
  3272                                  
  3273                                  lj:
  3274 000019A7 E8EFFFFFFF                  call lj0
  3275                                      _DROP_
   148 000019AC AD                  <1>  lodsd
  3276 000019AD C3                          ret
  3277                                  
  3278                                  full:
  3279 000019AE E8E8FFFFFF                  call lj0
  3280 000019B3 FF05[44480000]              inc dword [ v_words ]
  3281 000019B9 C605[9A190000]1C            mov byte [ bits_ ], 0x1C
  3282 000019C0 282D[9A190000]              sub [ bits_ ], ch
  3283 000019C6 89D0                        mov _TOS_, edx
  3284                                      _DUP_
   132 000019C8 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000019CB 8906                <1>  mov [ esi ], _TOS_
  3285 000019CD C3                          ret
  3286                                  
  3287                                  pack0:
  3288 000019CE 83C050                      add _TOS_, byte  0x50
  3289 000019D1 B107                        mov cl, 0x07
  3290 000019D3 EB0D                        jmp short pack1
  3291                                  
  3292                                  pack_:
  3293 000019D5 3C10                        cmp al, 0x10
  3294 000019D7 73F5                        jnc pack0
  3295 000019D9 B104                        mov cl, 0x04
  3296 000019DB A808                        test al, 0x08
  3297 000019DD 7403                        jz pack1
  3298 000019DF 41                          inc ecx
  3299 000019E0 3418                        xor al, 0x18
  3300                                  pack1:
  3301 000019E2 89C2                        mov edx, _TOS_
  3302 000019E4 88CD                        mov ch,cl
  3303                                  .back:
  3304 000019E6 380D[9A190000]              cmp [ bits_ ], cl
  3305 000019EC 7308                        jnc .forward
  3306 000019EE D0E8                        shr al,1
  3307 000019F0 72BC                        jc full
  3308 000019F2 FEC9                        dec cl
  3309 000019F4 EBF0                        jmp short .back
  3310                                  .forward:
  3311 000019F6 D326                        shl dword [ esi ],cl
  3312 000019F8 3106                        xor [ esi ], _TOS_
  3313 000019FA 280D[9A190000]              sub [ bits_ ], cl
  3314 00001A00 C3                          ret
  3315                                  
  3316                                  exit_:      ; exit to the quit loop
  3317 00001A01 E82BF7FFFF                  call right
  3318 00001A06 A1[44480000]                mov _TOS_, [ v_words ]
  3319 00001A0B 8D3486                      lea esi, [ esi + (_TOS_ * 4 ) ]
  3320                                      _DROP_
   148 00001A0E AD                  <1>  lodsd
  3321 00001A0F E95F020000                  jmp quit_
  3322                                  
  3323                                  word_:
  3324 00001A14 E818F7FFFF                  call right
  3325 00001A19 C705[44480000]0100-         mov dword [ v_words ], 0x01
  3325 00001A21 0000               
  3326 00001A23 C705[38480000]0100-         mov dword [ chars ], 0x01
  3326 00001A2B 0000               
  3327                                      _DUP_
   132 00001A2D 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00001A30 8906                <1>  mov [ esi ], _TOS_
  3328 00001A32 C70600000000                mov dword [ esi ], 0x00
  3329 00001A38 C605[9A190000]1C            mov byte [ bits_ ], 0x1C
  3330                                  word1:
  3331 00001A3F E8ACFBFFFF                  call letter
  3332 00001A44 7909                        jns .forward
  3333 00001A46 8B15[28480000]              mov edx, [ shiftAction ]
  3334 00001A4C FF2482                      jmp dword [edx+_TOS_*4]
  3335                                  .forward:
  3336 00001A4F 84C0                        test al,al
  3337 00001A51 741B                        jz word0
  3338                                      _DUP_
   132 00001A53 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00001A56 8906                <1>  mov [ esi ], _TOS_
  3339 00001A58 E8BBF6FFFF                  call echo_
  3340 00001A5D 8A80[111B0000]              mov al, [ _TOS_ + ASCII_to_SF_table ]
  3341 00001A63 E86DFFFFFF                  call pack_
  3342 00001A68 FF05[38480000]              inc dword [ chars ]
  3343                                  word0:
  3344                                      _DROP_
   148 00001A6E AD                  <1>  lodsd
  3345 00001A6F E895FDFFFF                  call get_key_
  3346 00001A74 EBC9                        jmp short word1
  3347                                  
  3348                                  ; *****************************************************************************
  3349                                  ; number display
  3350                                  ; *****************************************************************************
  3351                                  
  3352                                  digitTable:                         ; convert a keypad key value to a number
  3353 00001A76 00<rep 30h>                 times 0x30 db 0x00                                       ; 
  3354 00001AA6 000102030405060708-         db 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09   ; '0123456789' ; 0x30 to 0x39
  3354 00001AAF 09                 
  3355 00001AB0 00<rep 27h>                 times 0x27 db 0x00
  3356 00001AD7 0A0B0C0D0E0F                db 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F                           ; 'abcdef'
  3357 00001ADD 00<rep 34h>                 times 0x34 db 0x00
  3358                                  
  3359                                  ASCII_to_SF_table:                  ; to convert ASCII value to ShannonFano number
  3360                                     ;  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
  3361 00001B11 000000000000000000-        db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ; 0x00
  3361 00001B1A 00000000000000     
  3362 00001B21 000000000000000000-        db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ; 0x10
  3362 00001B2A 00000000000000     
  3363 00001B31 002A00000000005900-        db 0x00, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x59,  0x00, 0x00, 0x2D, 0x2B, 0x2E, 0x23, 0x25, 0x27 ; 0x20
  3363 00001B3A 002D2B2E232527     
  3364 00001B41 18191A1B1C1D1E1F20-        db 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,  0x20, 0x21, 0x29, 0x28, 0x00, 0x00, 0x00, 0x2F ; 0x30
  3364 00001B4A 2129280000002F     
  3365 00001B51 2C35433A40343E3D44-        db 0x2C, 0x35, 0x43, 0x3A, 0x40, 0x34, 0x3E, 0x3D,  0x44, 0x37, 0x52, 0x54, 0x3C, 0x39, 0x36, 0x33 ; 0x40
  3365 00001B5A 3752543C393633     
  3366 00001B61 424731383246413F45-        db 0x42, 0x47, 0x31, 0x38, 0x32, 0x46, 0x41, 0x3F,  0x45, 0x3B, 0x56, 0x00, 0x00, 0x00, 0x00, 0x53 ; 0x50
  3366 00001B6A 3B560000000053     
  3367 00001B71 0005130A10040E0D14-        db 0x00, 0x05, 0x13, 0x0A, 0x10, 0x04, 0x0E, 0x0D,  0x14, 0x07, 0x22, 0x24, 0x0C, 0x09, 0x06, 0x03 ; 0x60
  3367 00001B7A 0722240C090603     
  3368 00001B81 121701080216110F15-        db 0x12, 0x17, 0x01, 0x08, 0x02, 0x16, 0x11, 0x0F,  0x15, 0x0B, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00 ; 0x70
  3368 00001B8A 0B260000000000     
  3369                                  
  3370                                  v_sign:                             ; set to 0xXX when the '-'key is pressed on the keypad
  3371 00001B91 00                          db 0x00
  3372                                  
  3373                                  minusSign:
  3374                                      ; not byte [ v_sign ]
  3375 00001B92 C605[911B0000]2D            mov byte [ v_sign ], '-'
  3376 00001B99 EB49                        jmp short number2
  3377                                  
  3378                                  number0:
  3379                                      _DROP_
   148 00001B9B AD                  <1>  lodsd
  3380 00001B9C EB0F                        jmp short number3
  3381                                  
  3382                                  number:
  3383 00001B9E FF15[30480000]              call [ setCurrentBase ]
  3384 00001BA4 C605[911B0000]00            mov byte [ v_sign ] , 0x00
  3385 00001BAB 31C0                        xor _TOS_, _TOS_
  3386                                  number3:
  3387 00001BAD E857FCFFFF                  call get_key_
  3388 00001BB2 E839FAFFFF                  call letter
  3389 00001BB7 7909                        jns .forward
  3390 00001BB9 8B15[28480000]              mov edx, [ shiftAction ]
  3391 00001BBF FF2482                      jmp dword [edx+_TOS_*4]
  3392                                  .forward:
  3393 00001BC2 84C0                        test al,al
  3394 00001BC4 74D5                        jz number0
  3395 00001BC6 8A80[761A0000]              mov al, [ _TOS_ + digitTable ]
  3396 00001BCC F605[911B0000]2D            test byte [ v_sign ], '-'
  3397 00001BD3 7402                        jz .forward2
  3398 00001BD5 F7D8                        neg _TOS_
  3399                                  .forward2:
  3400 00001BD7 8B16                        mov edx, [ esi ]
  3401 00001BD9 0FAF15[2C480000]            imul edx, [ base ]
  3402 00001BE0 01C2                        add edx, _TOS_
  3403 00001BE2 8916                        mov [ esi ], edx
  3404                                  number2:
  3405                                      _DROP_
   148 00001BE4 AD                  <1>  lodsd
  3406 00001BE5 C705[28480000]-             mov dword [ shiftAction ], numb1
  3406 00001BEB [86190000]         
  3407 00001BEF EBBC                        jmp short number3
  3408                                  
  3409                                  endn:
  3410                                      _DROP_
   148 00001BF1 AD                  <1>  lodsd
  3411 00001BF2 FF15[40480000]              call [ anumber]
  3412 00001BF8 E976000000                  jmp quit_
  3413                                  
  3414                                  setBase_decimal:                     ; set the system base to decimal
  3415 00001BFD C705[2C480000]0A00-         mov dword [ base ], 0x0A
  3415 00001C05 0000               
  3416 00001C07 C705[28480000]-             mov dword [ shiftAction ], numb0
  3416 00001C0D [72190000]         
  3417 00001C11 C705[24480000]-             mov dword [ currentKeypadIcons ], ( decimalKeypad - 4 )
  3417 00001C17 [BC150000]         
  3418 00001C1B C3                          ret
  3419                                  
  3420                                  setBase_hex:                         ; set the system base to hexadecimal
  3421 00001C1C C705[2C480000]1000-         mov dword [ base ], 0x10
  3421 00001C24 0000               
  3422 00001C26 C705[28480000]-             mov dword [ shiftAction ], numb0
  3422 00001C2C [72190000]         
  3423 00001C30 C705[24480000]-             mov dword [ currentKeypadIcons ], ( hexadecimalKeypad - 4 )
  3423 00001C36 [D4150000]         
  3424 00001C3A C3                          ret
  3425                                  
  3426                                  toggleBase0:
  3427                                      ; the 'xor's below change the content of 'setCurrentBase_base' and the keypad icon
  3428 00001C3B 8135[30480000]E107-         xor dword [ setCurrentBase], ((setBase_decimal - $$) ^ (setBase_hex - $$))
  3428 00001C43 0000               
  3429 00001C45 8035[84190000]5F            xor byte [ numb0 + 18 ], ( 0x39 ^ 0x66 ) ;  0x39 = '9' , 0x66 = 'f' toggle '9' and 'f' on keypad display line
  3430 00001C4C FF15[30480000]              call [ setCurrentBase ]
  3431 00001C52 C3                          ret
  3432                                  
  3433                                  toggleBase:
  3434 00001C53 E8E3FFFFFF                  call toggleBase0
  3435 00001C58 E93EFFFFFF                  jmp dword number0
  3436                                  
  3437                                  ; *****************************************************************************
  3438                                  ; text entry
  3439                                  ; *****************************************************************************
  3440                                  
  3441                                  exitn_:
  3442                                      _DROP_
   148 00001C5D AD                  <1>  lodsd
  3443                                      _DROP_
   148 00001C5E AD                  <1>  lodsd
  3444 00001C5F E90F000000                  jmp quit_
  3445                                  
  3446                                  nul0:
  3447                                      _DROP_
   148 00001C64 AD                  <1>  lodsd
  3448 00001C65 EB22                        jmp short quit2
  3449                                  
  3450                                  clearHintChar:
  3451 00001C67 50                          push _TOS_
  3452 00001C68 31C0                        xor _TOS_, _TOS_
  3453 00001C6A C605[18480000]00            mov byte [ v_hintChar ], 0x00   ; clear the hint character
  3454 00001C71 58                          pop _TOS_
  3455 00001C72 C3                          ret
  3456                                  
  3457                                  quit_:                               ; get a word from keypad and interpret it
  3458 00001C73 C705[28480000]-             mov dword [ shiftAction ], alpha0
  3458 00001C79 [4A190000]         
  3459 00001C7D 8D3D[8C150000]              lea edi, [ alphaKeypad - 4]
  3460                                  quit1:
  3461 00001C83 893D[24480000]              mov [ dword currentKeypadIcons ], edi
  3462                                  quit2:
  3463 00001C89 F705[08480000]FFFF-         test dword [ x_qwerty ], 0xFFFFFFFF
  3463 00001C91 FFFF               
  3464 00001C93 7406                        jz .forward
  3465 00001C95 FF25[08480000]              jmp dword [ x_qwerty ]          ; jump to the address in x_qwerty if it is non-zero
  3466                                  .forward:
  3467 00001C9B E869FBFFFF                  call get_key_                   ; calls pause_ while waiting for a character
  3468 00001CA0 3C04                        cmp al, 0x04                    ;
  3469 00001CA2 7909                        jns .forward2
  3470 00001CA4 8B15[28480000]              mov edx, [ shiftAction ]
  3471 00001CAA FF2482                      jmp dword [ edx + _TOS_ * 4 ]   ; alpha0 jump table element
  3472                                  .forward2:
  3473 00001CAD 8305[28480000]14            add dword [ shiftAction ], byte +0x14
  3474 00001CB4 E85BFDFFFF                  call word_
  3475 00001CB9 FF15[3C480000]              call [ aword ]
  3476 00001CBF EBB2                        jmp short quit_                ; endless loop
  3477                                  
  3478                                  alphn:
  3479                                   _DROP_
   148 00001CC1 AD                  <1>  lodsd
  3480                                  
  3481                                  alph0:
  3482 00001CC2 C705[28480000]-             mov dword [ shiftAction ], alpha0
  3482 00001CC8 [4A190000]         
  3483 00001CCC 8D3D[8C150000]              lea edi, [ alphaKeypad - 4 ]
  3484 00001CD2 EB10                        jmp short Xstar0
  3485                                  
  3486                                  star0:
  3487 00001CD4 C705[28480000]-             mov dword [ shiftAction ], graph0
  3487 00001CDA [22190000]         
  3488 00001CDE 8D3D[A4150000]              lea edi, [ ( graphicsKeypad - 4 ) ]
  3489                                      Xstar0:
  3490                                      _DROP_
   148 00001CE4 AD                  <1>  lodsd
  3491 00001CE5 EB9C                        jmp short quit1
  3492                                  
  3493                                  alph:
  3494 00001CE7 C705[28480000]-             mov dword [ shiftAction ], alpha1
  3494 00001CED [5E190000]         
  3495 00001CF1 8D3D[8C150000]              lea edi, [ alphaKeypad - 4]
  3496 00001CF7 EB10                        jmp short Xgraph
  3497                                  
  3498                                  graph:
  3499 00001CF9 C705[28480000]-             mov dword [ shiftAction ], graph1
  3499 00001CFF [36190000]         
  3500 00001D03 8D3D[A4150000]              lea edi, [ ( graphicsKeypad - 4 ) ]
  3501                                      Xgraph:
  3502 00001D09 893D[24480000]              mov [ currentKeypadIcons ], edi
  3503 00001D0F E95AFDFFFF                  jmp dword word0
  3504                                  
  3505                                  ; Note: defining drawTheCursor as a sub-routine and calling it produces a strange bug :
  3506                                  ; moving left 24 times using the left arrow key, from the end of the block, crashes the editor.
  3507                                  ; I suspect that the use of the stack to store (and later replace) deleted tokens gets confused
  3508                                  ; if a call to drawTheCursor happens occasionally...
  3509                                  ; This code should be re-worked. It is just too delicate...
  3510                                  ; drawTheCursor:
  3511                                  ;     mov [ v_cad ], edi
  3512                                  ;     push _SCRATCH_
  3513                                  ;     mov _SCRATCH_, [ v_10000_iconw ]
  3514                                  ;     sub dword [ v_gr_xy ], _SCRATCH_   ; move one icon's worth of horizontal pixels to the left
  3515                                  ;     _DUP_
  3516                                  ;     mov _SCRATCH_, [ v_foregroundColour ]   ; save the current colour
  3517                                  ;     mov _TOS_, colour_PacMan        ; for the "PacMan" cursor
  3518                                  ;     call set_color_
  3519                                  ;     mov _TOS_, 0x04                 ; display the "PacMan" cursor
  3520                                  ;     mov cx, [ v_gr_x ]
  3521                                  ;     cmp cx, [ v_rightMargin ]
  3522                                  ;     js .forward5
  3523                                  ;     ; the cursor is too far to the right on the screen
  3524                                  ;     call emit_
  3525                                  ;     mov [ v_10000_iconw ], _SCRATCH_
  3526                                  ;     sub dword [ v_gr_xy ], _SCRATCH_  ; move one icon's worth of horizontal pixels to the left
  3527                                  ;     jmp .forward6
  3528                                  ; .forward5:
  3529                                  ;     ; the cursor can be drawn
  3530                                  ;     call emit_
  3531                                  ; .forward6:
  3532                                  ;     call doShowASCII                ; optionally show the ASCII entry field
  3533                                  ;     mov dword [ v_foregroundColour ], _SCRATCH_     ; restore the current colour
  3534                                  ;     pop _SCRATCH_
  3535                                  ;     ret
  3536                                  
  3537                                  ; *****************************************************************************
  3538                                  ; Shannon-Fano decompression and display
  3539                                  ; *****************************************************************************
  3540                                  
  3541                                  unpack:     ; ( token -- token' nextCharacter )
  3542                                      _DUP_   ; copy TOS to our data stack SOS
   132 00001D14 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00001D17 8906                <1>  mov [ esi ], _TOS_
  3543 00001D19 85C0                        test _TOS_, _TOS_
  3544 00001D1B 780A                        js .forward
  3545 00001D1D C12604                      shl dword [ esi ], 0x04
  3546 00001D20 C1C004                      rol _TOS_, 0x04
  3547 00001D23 83E007                      and _TOS_, byte 0x07
  3548 00001D26 C3                          ret
  3549                                  .forward:
  3550 00001D27 D1E0                        shl _TOS_,1
  3551 00001D29 780C                        js .forward2
  3552 00001D2B C12605                      shl dword [ esi ], 0x05
  3553 00001D2E C1C004                      rol _TOS_, 0x04
  3554 00001D31 83E007                      and _TOS_, byte 0x07
  3555 00001D34 3408                        xor al, 0x08
  3556 00001D36 C3                          ret
  3557                                  .forward2:
  3558 00001D37 C12607                      shl dword [ esi ], 0x07
  3559 00001D3A C1C006                      rol _TOS_, 0x06
  3560 00001D3D 83E03F                      and _TOS_, byte 0x3F
  3561 00001D40 2C10                        sub al, 0x10
  3562 00001D42 C3                          ret
  3563                                  
  3564                                  ; show the PacMan-like cursor
  3565                                  show_cursor:  ; ( a cursor -- a' )  edi  contains pointer to current address to display
  3566                                      _DUP_
   132 00001D43 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00001D46 8906                <1>  mov [ esi ], _TOS_
  3567 00001D48 FF06                        inc dword [ esi ]
  3568 00001D4A 393D[AC470000]              cmp [ v_curs ], edi
  3569 00001D50 7505                        jnz .forward                    ; address to display = cursor address?
  3570 00001D52 A3[AC470000]                mov [ v_curs ], _TOS_           ; yes,
  3571                                  .forward:
  3572 00001D57 3B05[AC470000]              cmp _TOS_, [ v_curs ]           ; time to draw the cursor?
  3573 00001D5D 740A                        jz .forward2
  3574 00001D5F 7906                        jns .forward4                   ; time to draw the cursor?
  3575 00001D61 893D[DC470000]              mov [ v_pcad ], edi             ; no, so exit
  3576                                  .forward4:
  3577                                      _DROP_
   148 00001D67 AD                  <1>  lodsd
  3578 00001D68 C3                          ret                             ; exit here
  3579                                  
  3580                                  .forward2:
  3581                                      ; call drawTheCursor ; Note: do not do this!!! See notes for drawTheCursor:
  3582 00001D69 893D[D8470000]              mov [ v_cad ], edi
  3583 00001D6F 53                          push _SCRATCH_
  3584 00001D70 8B1D[04480000]              mov _SCRATCH_, [ v_10000_iconw ]
  3585 00001D76 291D[50490000]              sub dword [ v_gr_xy ], _SCRATCH_  ; move the graphic position one icon's worth of horizontal pixels to the left
  3586                                      _DUP_
   132 00001D7C 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00001D7F 8906                <1>  mov [ esi ], _TOS_
  3587 00001D81 8B1D[64490000]              mov _SCRATCH_, [ v_foregroundColour ]   ; save the current colour
  3588 00001D87 B800E20000                  mov _TOS_, colour_PacMan
  3589 00001D8C E84CEDFFFF                  call set_color_
  3590 00001D91 B804000000                  mov _TOS_, 0x04   ; display the "PacMan" cursor
  3591 00001D96 668B0D[52490000]            mov cx, [ v_gr_x ]
  3592 00001D9D 663B0D[58490000]            cmp cx, [ v_rightMargin ]
  3593 00001DA4 7816                        js .forward5
  3594 00001DA6 E81BF2FFFF                  call emit_
  3595 00001DAB 8B1D[04480000]              mov _SCRATCH_, [ v_10000_iconw ]
  3596 00001DB1 291D[50490000]              sub dword [ v_gr_xy ], _SCRATCH_  ; move one icon's worth of horizontal pixels to the left
  3597 00001DB7 E905000000                  jmp .forward6
  3598                                  .forward5:
  3599 00001DBC E805F2FFFF                  call emit_
  3600                                  .forward6:
  3601 00001DC1 891D[64490000]              mov dword [ v_foregroundColour ], _SCRATCH_     ; restore the current colour
  3602 00001DC7 5B                          pop _SCRATCH_
  3603 00001DC8 C3                          ret
  3604 00001DC9 C3                          ret
  3605                                  
  3606                                  ; *****************************************************************************
  3607                                  ; Conventional Forth display (does not require colours) - colour-blind mode
  3608                                  ; *****************************************************************************
  3609                                  
  3610                                  currentState:   ; the current token colour
  3611 00001DCA 00000000                    dd 0
  3612                                  
  3613                                  lastState:      ; the last token colour
  3614 00001DCE 00000000                    dd 0
  3615                                  
  3616                                  txt0:
  3617 00001DD2 E8FCECFFFF                  call white
  3618                                      EMIT_IMM('(')
   193                              <1> 
   194                              <1>  _DUP_
   132 00001DD7 8D76FC              <2>  lea esi, [ esi - 4 ]
   133                              <2> 
   134 00001DDA 8906                <2>  mov [ esi ], _TOS_
   195 00001DDC B828000000          <1>  mov _TOS_, %1
   196 00001DE1 E8E0F1FFFF          <1>  call emit_
   197                              <1> 
  3619 00001DE6 E8EDF1FFFF                  call space_
  3620 00001DEB C3                          ret
  3621                                  
  3622                                  txt1:
  3623 00001DEC E8E2ECFFFF                  call white
  3624                                      EMIT_IMM(')')
   193                              <1> 
   194                              <1>  _DUP_
   132 00001DF1 8D76FC              <2>  lea esi, [ esi - 4 ]
   133                              <2> 
   134 00001DF4 8906                <2>  mov [ esi ], _TOS_
   195 00001DF6 B829000000          <1>  mov _TOS_, %1
   196 00001DFB E8C6F1FFFF          <1>  call emit_
   197                              <1> 
  3625 00001E00 E8D3F1FFFF                  call space_
  3626 00001E05 C3                          ret
  3627                                  
  3628                                  imm0:
  3629 00001E06 E8B9ECFFFF                  call yellow
  3630                                      EMIT_IMM('[')
   193                              <1> 
   194                              <1>  _DUP_
   132 00001E0B 8D76FC              <2>  lea esi, [ esi - 4 ]
   133                              <2> 
   134 00001E0E 8906                <2>  mov [ esi ], _TOS_
   195 00001E10 B85B000000          <1>  mov _TOS_, %1
   196 00001E15 E8ACF1FFFF          <1>  call emit_
   197                              <1> 
  3631 00001E1A E8B9F1FFFF                  call space_
  3632 00001E1F C3                          ret
  3633                                  
  3634                                  imm1:
  3635 00001E20 E89FECFFFF                  call yellow
  3636                                      EMIT_IMM(']')
   193                              <1> 
   194                              <1>  _DUP_
   132 00001E25 8D76FC              <2>  lea esi, [ esi - 4 ]
   133                              <2> 
   134 00001E28 8906                <2>  mov [ esi ], _TOS_
   195 00001E2A B85D000000          <1>  mov _TOS_, %1
   196 00001E2F E892F1FFFF          <1>  call emit_
   197                              <1> 
  3637 00001E34 E89FF1FFFF                  call space_
  3638 00001E39 C3                          ret
  3639                                  
  3640                                  mvar0:
  3641 00001E3A E885ECFFFF                  call yellow
  3642                                      EMIT_IMM('[')
   193                              <1> 
   194                              <1>  _DUP_
   132 00001E3F 8D76FC              <2>  lea esi, [ esi - 4 ]
   133                              <2> 
   134 00001E42 8906                <2>  mov [ esi ], _TOS_
   195 00001E44 B85B000000          <1>  mov _TOS_, %1
   196 00001E49 E878F1FFFF          <1>  call emit_
   197                              <1> 
  3643 00001E4E E885F1FFFF                  call space_
  3644                                      EMIT_IMM('m')
   193                              <1> 
   194                              <1>  _DUP_
   132 00001E53 8D76FC              <2>  lea esi, [ esi - 4 ]
   133                              <2> 
   134 00001E56 8906                <2>  mov [ esi ], _TOS_
   195 00001E58 B86D000000          <1>  mov _TOS_, %1
   196 00001E5D E864F1FFFF          <1>  call emit_
   197                              <1> 
  3645                                      EMIT_IMM('v')
   193                              <1> 
   194                              <1>  _DUP_
   132 00001E62 8D76FC              <2>  lea esi, [ esi - 4 ]
   133                              <2> 
   134 00001E65 8906                <2>  mov [ esi ], _TOS_
   195 00001E67 B876000000          <1>  mov _TOS_, %1
   196 00001E6C E855F1FFFF          <1>  call emit_
   197                              <1> 
  3646                                      EMIT_IMM('a')
   193                              <1> 
   194                              <1>  _DUP_
   132 00001E71 8D76FC              <2>  lea esi, [ esi - 4 ]
   133                              <2> 
   134 00001E74 8906                <2>  mov [ esi ], _TOS_
   195 00001E76 B861000000          <1>  mov _TOS_, %1
   196 00001E7B E846F1FFFF          <1>  call emit_
   197                              <1> 
  3647                                      EMIT_IMM('r')
   193                              <1> 
   194                              <1>  _DUP_
   132 00001E80 8D76FC              <2>  lea esi, [ esi - 4 ]
   133                              <2> 
   134 00001E83 8906                <2>  mov [ esi ], _TOS_
   195 00001E85 B872000000          <1>  mov _TOS_, %1
   196 00001E8A E837F1FFFF          <1>  call emit_
   197                              <1> 
  3648 00001E8F E844F1FFFF                  call space_
  3649 00001E94 C3                          ret
  3650                                  
  3651                                  mvar1:
  3652 00001E95 E82AECFFFF                  call yellow
  3653                                      EMIT_IMM(']')
   193                              <1> 
   194                              <1>  _DUP_
   132 00001E9A 8D76FC              <2>  lea esi, [ esi - 4 ]
   133                              <2> 
   134 00001E9D 8906                <2>  mov [ esi ], _TOS_
   195 00001E9F B85D000000          <1>  mov _TOS_, %1
   196 00001EA4 E81DF1FFFF          <1>  call emit_
   197                              <1> 
  3654 00001EA9 E82AF1FFFF                  call space_
  3655 00001EAE C3                          ret
  3656                                  
  3657                                  ; unfortunately we need to display the ':' after the CR, so must do this in  redWord , not here
  3658                                  ; colon0:
  3659                                  ;     call red
  3660                                  ;     EMIT_IMM(':')
  3661                                  ;     call space_
  3662                                  ;     ret
  3663                                  ;
  3664                                  ;     dd nul, imm0, nul, colon0, nul, nul, nul, nul, nul, txt0, nul, nul, mvar0, nul, nul, nul
  3665                                  
  3666                                  txts:
  3667 00001EAF 000101030405060701-         db 0, 1, 1, 3, 4, 5, 6, 7, 1, 9, 9, 9, 12, 13, 14, 15
  3667 00001EB8 0909090C0D0E0F     
  3668                                  
  3669                                  tx:     ; ( c -- c )   \ return the value in the given offset in  txts
  3670 00001EBF 25FF000000                  and _TOS_, 0xFF
  3671 00001EC4 8B80[AF1E0000]              mov _TOS_, [ _TOS_ + txts ]
  3672 00001ECA 25FF000000                  and _TOS_, 0xFF
  3673 00001ECF C3                          ret
  3674                                  
  3675                                  newActions:
  3676 00001ED0 [40040000]-                 dd nul, imm0, nul, nul, nul, nul, nul, nul, nul, txt0, nul, nul, mvar0, nul, nul, nul
  3676 00001ED4 [061E0000]-        
  3676 00001ED8 [40040000]-        
  3676 00001EDC [40040000]-        
  3676 00001EE0 [40040000]-        
  3676 00001EE4 [40040000]-        
  3676 00001EE8 [40040000]-        
  3676 00001EEC [40040000]-        
  3676 00001EF0 [40040000]-        
  3676 00001EF4 [D21D0000]-        
  3676 00001EF8 [40040000]-        
  3676 00001EFC [40040000]-        
  3676 00001F00 [3A1E0000]-        
  3676 00001F04 [40040000]-        
  3676 00001F08 [40040000]-        
  3676 00001F0C [40040000]         
  3677                                  
  3678                                  dotNew:     ; ( state -- )
  3679 00001F10 FF1485[D01E0000]            call [ ( _TOS_ * 4 ) + newActions ]
  3680 00001F17 C3                          ret
  3681                                  
  3682                                  oldActions:
  3683 00001F18 [40040000]-                 dd nul, imm1, nul, nul, nul, nul, nul, nul, nul, txt1, nul, nul, mvar1, nul, nul, nul
  3683 00001F1C [201E0000]-        
  3683 00001F20 [40040000]-        
  3683 00001F24 [40040000]-        
  3683 00001F28 [40040000]-        
  3683 00001F2C [40040000]-        
  3683 00001F30 [40040000]-        
  3683 00001F34 [40040000]-        
  3683 00001F38 [40040000]-        
  3683 00001F3C [EC1D0000]-        
  3683 00001F40 [40040000]-        
  3683 00001F44 [40040000]-        
  3683 00001F48 [951E0000]-        
  3683 00001F4C [40040000]-        
  3683 00001F50 [40040000]-        
  3683 00001F54 [40040000]         
  3684                                  
  3685                                  dotOld:     ; ( state -- )
  3686 00001F58 FF1485[181F0000]            call [ ( _TOS_ * 4 ) + oldActions ]
  3687 00001F5F C3                          ret
  3688                                  
  3689                                  colourBlindAction:  ; ( state -- state )    \ perform the required action on change of state
  3690 00001F60 53                          push _SCRATCH_
  3691                                      _DUP_
   132 00001F61 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00001F64 8906                <1>  mov [ esi ], _TOS_
  3692 00001F66 E854FFFFFF                  call tx
  3693 00001F6B 3D00000000                  cmp _TOS_, 0x00
  3694 00001F70 743F                        jz .end                             ; no action on extension tokens, value 0
  3695 00001F72 8B1D[CA1D0000]              mov _SCRATCH_, [ currentState ]
  3696 00001F78 A3[CA1D0000]                mov [ currentState ], _TOS_
  3697 00001F7D 3B1D[CA1D0000]              cmp _SCRATCH_, [ currentState ]     ; compare the new state on TOS to the last one saved in currentState
  3698 00001F83 742C                        jz .end                             ; exit if there has been no change of state
  3699                                      _DUP_
   132 00001F85 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00001F88 8906                <1>  mov [ esi ], _TOS_
  3700 00001F8A 89D8                        mov _TOS_, _SCRATCH_
  3701 00001F8C E8C7FFFFFF                  call dotOld                         ;
  3702 00001F91 A1[CA1D0000]                mov _TOS_, [ currentState ]
  3703 00001F96 E875FFFFFF                  call dotNew
  3704                                      _DROP_
   148 00001F9B AD                  <1>  lodsd
  3705 00001F9C 803D[CA1D0000]00            cmp byte [ currentState ], 0x0000
  3706 00001FA3 740C                        jz .end
  3707 00001FA5 8B1D[CA1D0000]              mov _SCRATCH_, [ currentState ]
  3708 00001FAB 891D[CE1D0000]              mov [ lastState ], _SCRATCH_
  3709                                   .end:
  3710                                      _DROP_
   148 00001FB1 AD                  <1>  lodsd
  3711 00001FB2 5B                          pop _SCRATCH_
  3712 00001FB3 C3                          ret
  3713                                  
  3714                                  ; \ Block 70
  3715                                  ; ( Colourblind Editor Display )
  3716                                  ; #1 MagentaV currentState $01 MagentaV lastState
  3717                                  ; : +txt white $6D emit space ;
  3718                                  ; : -txt white $6E emit space ;
  3719                                  ; : +imm yellow $58 emit space ;
  3720                                  ; : -imm yellow $59 emit space ;
  3721                                  ; : +mvar yellow $09 emit $11 emit $05 emit $01 emit space ;
  3722                                  ; : txts string $03010100 , $07060504 , $09090901 , $0F0E0D0C , ( ; )
  3723                                  ; : tx ( c-c ) $0F and txts + 1@ $0F and ;
  3724                                  ; : .new currentState @ $0F and jump nul +imm nul nul nul nul nul nul nul +txt nul nul +mvar nul nul nul ;
  3725                                  ; : .old lastState @ $0F and jump nul -imm nul nul nul nul nul nul nul -txt nul nul nul nul nul nul ;
  3726                                  ; here
  3727                                  ; : cb ( n-n ) #0 + 0if ; then tx
  3728                                  ;    currentState @ swap dup currentState ! - drop if .old .new
  3729                                  ;    currentState @ #0 + if dup lastState ! then then ;
  3730                                  ; : cbs ( -- here ) #0 + $00 + cblind ! ;
  3731                                  
  3732                                  ; colourBlind:    ; ( state -- state )    \ vectored colorForth to display colourBlind extra characters ( e.g. ':' for red words )
  3733                                  ;    call dword [ x_colourBlind ]
  3734                                  ;    ret
  3735                                  
  3736                                  ; *****************************************************************************
  3737                                  ; Show an ASCII editable entry field at the cursor
  3738                                  ; *****************************************************************************
  3739                                  
  3740                                  ShowASCIIAction:    ; ( -- )
  3741                                  ;    call white
  3742 00001FB4 E81FF0FFFF                  call space_
  3743                                      EMIT_IMM('U')
   193                              <1> 
   194                              <1>  _DUP_
   132 00001FB9 8D76FC              <2>  lea esi, [ esi - 4 ]
   133                              <2> 
   134 00001FBC 8906                <2>  mov [ esi ], _TOS_
   195 00001FBE B855000000          <1>  mov _TOS_, %1
   196 00001FC3 E8FEEFFFFF          <1>  call emit_
   197                              <1> 
  3744                                      EMIT_IMM('U')
   193                              <1> 
   194                              <1>  _DUP_
   132 00001FC8 8D76FC              <2>  lea esi, [ esi - 4 ]
   133                              <2> 
   134 00001FCB 8906                <2>  mov [ esi ], _TOS_
   195 00001FCD B855000000          <1>  mov _TOS_, %1
   196 00001FD2 E8EFEFFFFF          <1>  call emit_
   197                              <1> 
  3745                                      EMIT_IMM('U')
   193                              <1> 
   194                              <1>  _DUP_
   132 00001FD7 8D76FC              <2>  lea esi, [ esi - 4 ]
   133                              <2> 
   134 00001FDA 8906                <2>  mov [ esi ], _TOS_
   195 00001FDC B855000000          <1>  mov _TOS_, %1
   196 00001FE1 E8E0EFFFFF          <1>  call emit_
   197                              <1> 
  3746                                      EMIT_IMM('U')
   193                              <1> 
   194                              <1>  _DUP_
   132 00001FE6 8D76FC              <2>  lea esi, [ esi - 4 ]
   133                              <2> 
   134 00001FE9 8906                <2>  mov [ esi ], _TOS_
   195 00001FEB B855000000          <1>  mov _TOS_, %1
   196 00001FF0 E8D1EFFFFF          <1>  call emit_
   197                              <1> 
  3747 00001FF5 E8DEEFFFFF                  call space_
  3748 00001FFA C3                          ret
  3749 00001FFB C3                          ret
  3750                                  
  3751                                  ; *****************************************************************************
  3752                                  ; *****************************************************************************
  3753                                  
  3754                                  lowercase:   ; display a white text word in normal lower-case letters
  3755 00001FFC E8D2EAFFFF                  call white
  3756                                  showSF_EDI_:  ; ( -- )   \ display a Shanon-Fano encoded token pointed to by  edi  in the current colour
  3757                                      _DUP_
   132 00002001 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00002004 8906                <1>  mov [ esi ], _TOS_
  3758 00002006 8B04BDFCFFFFFF              mov _TOS_, [ ( edi * 4 ) - 0x04 ]   ; fetch the next token - drops through to showShannonFano
  3759                                  
  3760                                  showShannonFano:    ; ( token -- ) \ display the Shannon-Fano encoded token on TOS
  3761                                      ; ASCII / UTF8 support. If the first Shannon-Fano encoded letter is a 4 bit NULL, 
  3762                                      ; display the next 24 bits as three ASCII characters.
  3763 0000200D 89C3                        mov _SCRATCH_, _TOS_            ; save the token value
  3764 0000200F 81E3000000F0                and _SCRATCH_, 0xF0000000
  3765 00002015 81FB00000000                cmp _SCRATCH_, 0x00000000
  3766 0000201B 754B                        jnz .forward
  3767                                          ; display as three ASCII characters
  3768 0000201D 89C3                            mov _SCRATCH_, _TOS_
  3769                                  
  3770 0000201F 89D8                            mov _TOS_, _SCRATCH_
  3771 00002021 C1E814                          shr _TOS_, 20
  3772 00002024 25FF000000                      and _TOS_, 0x000000FF
  3773 00002029 7436                            jz .null_terminator
  3774                                              _DUP_
   132 0000202B 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000202E 8906                <1>  mov [ esi ], _TOS_
  3775 00002030 E891EFFFFF                          call emit_
  3776                                  
  3777 00002035 89D8                            mov _TOS_, _SCRATCH_
  3778 00002037 C1E80C                          shr _TOS_, 12
  3779 0000203A 25FF000000                      and _TOS_, 0x000000FF
  3780 0000203F 7420                            jz .null_terminator
  3781                                              _DUP_
   132 00002041 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00002044 8906                <1>  mov [ esi ], _TOS_
  3782 00002046 E87BEFFFFF                          call emit_
  3783                                  
  3784 0000204B 89D8                            mov _TOS_, _SCRATCH_
  3785 0000204D C1E804                          shr _TOS_, 4
  3786 00002050 25FF000000                      and _TOS_, 0x000000FF
  3787 00002055 740A                            jz .null_terminator
  3788                                              _DUP_
   132 00002057 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000205A 8906                <1>  mov [ esi ], _TOS_
  3789 0000205C E865EFFFFF                          call emit_
  3790                                  
  3791                                          ; arrive here if an ASCII character is an ASCII NULL, or if all three have been emitted
  3792                                          .null_terminator:
  3793 00002061 E872EFFFFF                      call space_                 ; display a space character at the end of the word
  3794                                          _DROP_
   148 00002066 AD                  <1>  lodsd
  3795 00002067 C3                              ret
  3796                                             
  3797                                      .forward:
  3798                                      
  3799                                      ; display as Shannon-Fano encoded token name
  3800 00002068 83E0F0                      and _TOS_, byte -0x10 ; (saves 2 bytes compared to 'and _TOS_, 0xFFFFFFF0' )  ignore the token colour when displaying the letters
  3801                                  lowercasePrimitive:  ; ( token -- ) \ display the given Shanon-Fano encoded word in the current colour
  3802 0000206B E8A4FCFFFF                  call unpack
  3803 00002070 740A                        jz lowercasePrimitiveEnd
  3804 00002072 E849EFFFFF                  call emitSF_
  3805 00002077 E9EFFFFFFF                  jmp lowercasePrimitive
  3806                                  lowercasePrimitiveEnd:
  3807 0000207C E857EFFFFF                  call space_
  3808                                      _DROP_
   148 00002081 AD                  <1>  lodsd
  3809                                      _DROP_
   148 00002082 AD                  <1>  lodsd
  3810 00002083 C3                          ret
  3811                                  
  3812                                  typeNumber32tok:     ; ( token -- ) \ display the given Shanon-Fano encoded word as a number in the current colour
  3813                                      _DROP_ ; call dotHex8_
   148 00002084 AD                  <1>  lodsd
  3814 00002085 C705[A9200000]FFFF-         mov dword [ lastTokenWasLiteral ], 0xFFFFFFF
  3814 0000208D FF0F               
  3815 0000208F C3                          ret
  3816                                  
  3817                                  typeNumber32:     ; ( token -- ) \ display the given Shanon-Fano encoded word as a hex number in the current colour
  3818 00002090 E89AF1FFFF                  call dotHex8_
  3819 00002095 C705[A9200000]0000-         mov dword [ lastTokenWasLiteral ], 0x00000000
  3819 0000209D 0000               
  3820 0000209F C3                          ret
  3821                                  
  3822                                  typeNumber27:     ; ( token -- ) \ display the given Shanon-Fano encoded word as a 27 bit hex number in the current colour
  3823 000020A0 C1E805                      shr _TOS_, 5
  3824 000020A3 E8B6F1FFFF                  call dotHex
  3825 000020A8 C3                          ret
  3826                                  
  3827                                  lastTokenWasLiteral:
  3828 000020A9 00000000                    dd 0x00
  3829                                  
  3830                                  lastShannonFanoToken:
  3831 000020AD 00000000                    dd 0x00
  3832                                  
  3833                                  magentaPrimitive:   ; ( token -- )
  3834 000020B1 E857FFFFFF                  call showShannonFano
  3835 000020B6 C705[A9200000]FFFF-         mov dword [ lastTokenWasLiteral ], 0xFFFFFFF
  3835 000020BE FF0F               
  3836 000020C0 C3                          ret
  3837                                  
  3838                                  displayOneShannonFanoActions:   ;    * = number
  3839 000020C1 [0D200000]                  dd showShannonFano          ; 0     extension token, remove space from previous word, do not change the colour
  3840 000020C5 [0D200000]                  dd showShannonFano          ; 1     yellow "immediate" word
  3841 000020C9 [84200000]                  dd typeNumber32tok          ; 2  *  yellow "immediate" 32 bit number in the following pre-parsed cell
  3842 000020CD [0D200000]                  dd showShannonFano          ; 3     red forth wordlist "colon" word
  3843 000020D1 [0D200000]                  dd showShannonFano          ; 4     green compiled word
  3844 000020D5 [84200000]                  dd typeNumber32tok          ; 5  *  green compiled 32 bit number in the following pre-parsed cell
  3845 000020D9 [A0200000]                  dd typeNumber27             ; 6  *  green compiled 27 bit number in the high bits of the token
  3846 000020DD [0D200000]                  dd showShannonFano          ; 7     cyan macro wordlist "colon" word
  3847 000020E1 [A0200000]                  dd typeNumber27             ; 8  *  yellow "immediate" 27 bit number in the high bits of the token
  3848 000020E5 [0D200000]                  dd showShannonFano          ; 9     white lower-case comment
  3849 000020E9 [4F220000]                  dd camelcasePrimitive       ; A     first letter capital comment
  3850 000020ED [84220000]                  dd uppercasePrimitive       ; B     white upper-case comment
  3851 000020F1 [B1200000]                  dd magentaPrimitive         ; C     magenta variable
  3852 000020F5 [0D200000]                  dd showShannonFano          ; D
  3853 000020F9 [0D200000]                  dd showShannonFano          ; E     editor formatting commands
  3854 000020FD [0D200000]                  dd showShannonFano          ; F
  3855                                  
  3856 00002101 55<rep 20h>             times 0x20 db 0x55
  3857                                  testme:
  3858 00002121 FF0C2475                    dd 0x75240CFF ; 0xFF, 0x0C, 0x24, 0x75
  3859 00002125 56341200                    dd 0x123456
  3860 00002129 C3                          ret
  3861 0000212A 77<rep 20h>             times 0x20 db 0x77
  3862                                  
  3863                                  leave_:     ; terminate a  for ... next  loop
  3864 0000214A C744240401000000            mov dword [ esp + 4 ], 0x01
  3865 00002152 C3                          ret
  3866                                  
  3867                                  dotsf_:  ; ( token -- )   \ display the given Shannon-Fano encoded word in the token's colour
  3868 00002153 57                          push edi
  3869 00002154 89C2                        mov edx , _TOS_
  3870 00002156 83E0F0                      and _TOS_, byte -0x10 ; (saves 2 bytes compared to 'and _TOS_, 0xFFFFFFF0' )
  3871                                      _DUP_
   132 00002159 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000215C 8906                <1>  mov [ esi ], _TOS_
  3872 0000215E 8B3D[A9200000]              mov edi, [ lastTokenWasLiteral ]
  3873 00002164 F7C700000000                test edi, 0x00000000
  3874 0000216A 7405                        jz .forward3
  3875 0000216C BA00000000                  mov edx, 0
  3876                                  .forward3:
  3877 00002171 83E20F                      and edx, byte 0x0F
  3878 00002174 7533                        jnz .forward     ; do not change the colour if this is an extension token
  3879                                          ; this is an extension token
  3880 00002176 8B15[AD200000]                  mov edx, [ lastShannonFanoToken ]
  3881                                          ; if the colour is Camelcase 0x0A, make it lowercase 0x09
  3882                                          ; e.g. Interrupt would be shown as InterrUpt if the exension token is displayed with an initial Capital
  3883 0000217C 89D3                            mov _SCRATCH_, edx
  3884 0000217E 81E30F000000                    and _SCRATCH_, 0x0F     ; just the colour
  3885 00002184 81EB0A000000                    sub _SCRATCH_, 0x0A
  3886 0000218A 750C                            jne .foward4
  3887 0000218C 81E2F0FFFFFF                        and edx, 0xFFFFFFF0     ; remove the colour
  3888 00002192 81CA09000000                        or edx, 0x00000009      ; make it lowercase
  3889                                          .foward4:
  3890 00002198 8B1D[04480000]                  mov _SCRATCH_, [ v_10000_iconw ]
  3891 0000219E 291D[50490000]                  sub dword [ v_gr_xy ], _SCRATCH_   ; move iconw horizontal pixels back, to remove the space at the end of the last word
  3892 000021A4 E906000000                  jmp .forward2
  3893                                      .forward:
  3894                                          ; this is not an extension token
  3895 000021A9 8915[AD200000]                  mov [ lastShannonFanoToken ], edx
  3896                                      .forward2:
  3897 000021AF 50                          push _TOS_
  3898 000021B0 8B0495[64260000]            mov _TOS_, [ ( edx * 4 ) + actionColourTable ]
  3899 000021B7 E821E9FFFF                  call set_color_
  3900 000021BC 58                          pop _TOS_
  3901 000021BD FF1495[C1200000]            call [ ( edx * 4 ) + displayOneShannonFanoActions ]
  3902 000021C4 5F                          pop edi
  3903 000021C5 C3                          ret
  3904                                  
  3905                                  redWord:     ; display a red word
  3906 000021C6 668B0D[52490000]            mov cx, [ v_gr_x ]
  3907 000021CD 663B0D[54490000]            cmp cx, [ v_leftMargin ]
  3908 000021D4 7410                        jz .forward     ; do not do a  cr  if we are already at the left margin
  3909 000021D6 8A0D[16480000]              mov cl, [ v_not_cr ]
  3910 000021DC 80F900                      cmp cl, 0
  3911 000021DF 7505                        jnz .forward    ; do not do a  cr  if it has been disabled by a blue  -cr  token
  3912 000021E1 E8B1E8FFFF                  call cr_
  3913                                  .forward:
  3914 000021E6 C605[16480000]00            mov byte [ v_not_cr ], 0
  3915 000021ED E8EEEEFFFF                  call setRed
  3916                                  
  3917 000021F2 803D[15480000]00            cmp byte [ v_colourBlindMode ], 0x00
  3918 000021F9 741D                        jz .forward2
  3919 000021FB F605[A8470000]01            test byte [ v_blk ], 0x01   ; do not display colour-blind characters in odd numbered shadow blocks
  3920 00002202 7514                        jnz .forward2
  3921                                      EMIT_IMM(':')   ; emit a ':' if in colour-blind mode
   193                              <1> 
   194                              <1>  _DUP_
   132 00002204 8D76FC              <2>  lea esi, [ esi - 4 ]
   133                              <2> 
   134 00002207 8906                <2>  mov [ esi ], _TOS_
   195 00002209 B83A000000          <1>  mov _TOS_, %1
   196 0000220E E8B3EDFFFF          <1>  call emit_
   197                              <1> 
  3922 00002213 E8C0EDFFFF                  call space_
  3923                                  .forward2:
  3924 00002218 E9E4FDFFFF                  jmp showSF_EDI_
  3925                                  
  3926                                  greenWord:     ; display a green word
  3927 0000221D E8CDEEFFFF                  call setGreen
  3928 00002222 E9DAFDFFFF                  jmp showSF_EDI_
  3929                                  
  3930                                  cyanWord:     ; display a cyan word
  3931 00002227 E878EEFFFF                  call setCyan
  3932 0000222C E9D0FDFFFF                  jmp showSF_EDI_
  3933                                  
  3934                                  yellowWord:     ; display a yellow word
  3935 00002231 E88EE8FFFF                  call yellow
  3936 00002236 E9C6FDFFFF                  jmp showSF_EDI_
  3937                                  
  3938                                  ; Note : Camelcase tokens do not support ASCII output 
  3939                                  camelcase:    ; display a white word with the first letter Capitalised
  3940 0000223B E893E8FFFF                  call white
  3941                                      _DUP_
   132 00002240 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00002243 8906                <1>  mov [ esi ], _TOS_
  3942 00002245 8B04BDFCFFFFFF              mov _TOS_, [ ( edi * 4 ) - 0x04 ]
  3943 0000224C 83E0F0                      and _TOS_, byte -0x10 ; (saves 2 bytes compared to 'and _TOS_, 0xFFFFFFF0' )
  3944                                  camelcasePrimitive:
  3945 0000224F E8C0FAFFFF                  call unpack
  3946 00002254 0430                        add al, 0x30                    ; make the first character upper case
  3947 00002256 E865EDFFFF                  call emitSF_                    ; display it
  3948                                  camelcasePrimitive_2:               ; display the rest of the word
  3949 0000225B E8B4FAFFFF                  call unpack
  3950 00002260 0F8416FEFFFF                jz lowercasePrimitiveEnd
  3951 00002266 E855EDFFFF                  call emitSF_
  3952 0000226B E9EBFFFFFF                  jmp camelcasePrimitive_2
  3953                                               
  3954                                  ; Note : UPPERCASE tokens do not support ASCII output 
  3955                                  uppercase:   ; display a white word with all letters CAPITALISED
  3956 00002270 E85EE8FFFF                  call white
  3957                                      _DUP_
   132 00002275 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00002278 8906                <1>  mov [ esi ], _TOS_
  3958 0000227A 8B04BDFCFFFFFF              mov _TOS_, [ ( edi * 4 ) - 0x04 ]
  3959 00002281 83E0F0                      and _TOS_, byte -0x10 ; (saves 2 bytes compared to 'and _TOS_, 0xFFFFFFF0' )
  3960                                  uppercasePrimitive:
  3961 00002284 E88BFAFFFF                  call unpack
  3962 00002289 0F84EDFDFFFF                jz lowercasePrimitiveEnd
  3963 0000228F 0430                        add al, 0x30
  3964 00002291 E82AEDFFFF                  call emitSF_
  3965 00002296 E9E9FFFFFF                  jmp uppercasePrimitive
  3966                                  
  3967                                  extension:  ; display an extension token, do not change the colour
  3968 0000229B 8B1D[04480000]              mov _SCRATCH_, [ v_10000_iconw ]
  3969 000022A1 291D[50490000]              sub dword [ v_gr_xy ], _SCRATCH_   ; move iconw horizontal pixels back, to remove the space at the end of the last word
  3970 000022A7 F704BDFCFFFFFFF0FF-         test dword [ ( edi * 4 ) - 0x04 ], 0xFFFFFFF0
  3970 000022B0 FFFF               
  3971 000022B2 0F8549FDFFFF                jnz showSF_EDI_
  3972 000022B8 4F                          dec edi
  3973 000022B9 893D[E0470000]              mov [ v_lcad ], edi
  3974 000022BF E814EDFFFF                  call space_
  3975 000022C4 E87AFAFFFF                  call show_cursor                ; show the PacMan-like cursor
  3976 000022C9 5A                          pop edx                         ; EXIT from calling word
  3977                                      _DROP_                          ; the ret below will return to the word that called  extension
   148 000022CA AD                  <1>  lodsd
  3978 000022CB C3                          ret                             ; so it looks like it never happened
  3979                                  
  3980                                  greenShortNumber:    ; display the green compiled 27 bit number in the high bits of the token
  3981 000022CC 8B14BDFCFFFFFF              mov edx, [ ( edi * 4 ) - 0x04 ]
  3982 000022D3 C1FA05                      sar edx, 0x05
  3983 000022D6 EB3E                        jmp short greenNumber1
  3984                                  
  3985                                  magentaVariable:    ; display a magenta variable using the 32 bit number in the following pre-parsed cell
  3986 000022D8 C705[94470000]-             mov dword [ x_numberDisplay ], dotDecimal
  3986 000022DE [9C120000]         
  3987 000022E2 833D[2C480000]0A            cmp dword [ base ], byte 0x0A   ; check the current BASE value ( 10 or 16 for decimal or hex)
  3988 000022E9 740A                        jz .forward
  3989 000022EB C705[94470000]-             mov dword [ x_numberDisplay ], dotHex
  3989 000022F1 [5E120000]         
  3990                                  .forward:
  3991 000022F5 E8B9EDFFFF                  call setMagenta
  3992 000022FA E802FDFFFF                  call showSF_EDI_              ; display the name of the variable
  3993 000022FF 8B14BD00000000              mov edx, [ ( edi * 4 ) + 0x00 ]    ; load the value of the variable from the pre-parsed source
  3994 00002306 47                          inc edi                 ; step over the variable value in the pre-parsed source
  3995 00002307 E8B6EDFFFF                  call setMagentaData
  3996 0000230C EB28                        jmp short displayNumber
  3997                                  
  3998                                  greenNumber:                ; display the value of a hexadecimal/decimal number in green
  3999 0000230E 8B14BD00000000              mov edx, [ ( edi * 4 ) + 0x00 ]    ; load the value of the variable from the pre-parsed source
  4000 00002315 47                          inc edi                 ; step over the variable value in the pre-parsed source
  4001                                  greenNumber1:
  4002 00002316 E89AE7FFFF                  call green
  4003 0000231B EB19                        jmp short displayNumber
  4004                                  
  4005                                  yellowShortNumber:
  4006 0000231D 8B14BDFCFFFFFF              mov edx, [ ( edi * 4 ) - 0x04 ] ; load the value of the number from the current token in the pre-parsed source
  4007 00002324 C1FA05                      sar edx, 0x05                   ; remove the token colour bits
  4008 00002327 EB08                        jmp short yellowNumber1
  4009                                  
  4010                                  yellowNumber:     ; ( -- ) display a number word, constant value following in the pre-parsed source
  4011 00002329 8B14BD00000000              mov edx, [ ( edi * 4 ) + 0x00 ]    ; load the value of the number from the pre-parsed source
  4012 00002330 47                          inc edi                 ; step over the number value in the pre-parsed source
  4013                                  yellowNumber1:    ; ( -- ) display a yellow number word
  4014 00002331 E88EE7FFFF                  call yellow
  4015                                  displayNumber: ; ( rgb -- )   display the number in edx  with the given colour, using the base implied in  x_numberDisplay
  4016                                      _DUP_
   132 00002336 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00002339 8906                <1>  mov [ esi ], _TOS_
  4017 0000233B 89D0                        mov _TOS_, edx
  4018                                      ; jmp qdot
  4019 0000233D FF25[94470000]              jmp dword [ x_numberDisplay ]
  4020                                  
  4021                                  ; *****************************************************************************
  4022                                  ; Blue words - formatting the editor display
  4023                                  ; *****************************************************************************
  4024                                  
  4025                                  get_x:  ; ( -- c )  \ return the current x character position
  4026 00002343 52                          push edx
  4027                                      _DUP_
   132 00002344 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00002347 8906                <1>  mov [ esi ], _TOS_
  4028 00002349 31C0                        xor _TOS_, _TOS_
  4029 0000234B 66A1[52490000]              mov ax, word [ v_gr_x ]
  4030 00002351 31D2                        xor edx, edx                    ; clear high 32 bits of dividend
  4031 00002353 F735[F0470000]              div dword [ v_iconw ]           ; EDX:EAX divided by the icon width , EAX now contains the current character position, EDX the remainder
  4032 00002359 5A                          pop edx
  4033 0000235A C3                          ret
  4034                                  
  4035                                  set_x:  ; ( c -- )  \ set the current x character position
  4036 0000235B 52                          push edx
  4037 0000235C 31D2                        xor edx, edx
  4038 0000235E F725[F0470000]              mul dword [ v_iconw ]
  4039 00002364 66A3[52490000]              mov word [ v_gr_x ], ax
  4040 0000236A 5A                          pop edx
  4041                                      _DROP_
   148 0000236B AD                  <1>  lodsd
  4042 0000236C C3                          ret
  4043                                  
  4044                                  tab_n:    ; ( n -- )    \ align to the next n character column
  4045 0000236D 89C1                        mov ecx, _TOS_ 
  4046 0000236F 60                          pusha
  4047 00002370 E8CEFFFFFF                  call get_x
  4048 00002375 31D2                        xor edx, edx                    ; clear high 32 bits of dividend
  4049 00002377 89CB                        mov _SCRATCH_, ecx
  4050 00002379 F7F3                        div _SCRATCH_
  4051 0000237B F7E3                        mul _SCRATCH_
  4052 0000237D 01C8                        add _TOS_, ecx
  4053 0000237F E8D7FFFFFF                  call set_x
  4054 00002384 61                          popa
  4055                                      _DROP_
   148 00002385 AD                  <1>  lodsd
  4056 00002386 C3                          ret
  4057                                  
  4058                                  tab3:       ; ( -- )
  4059                                     _DUP_
   132 00002387 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000238A 8906                <1>  mov [ esi ], _TOS_
  4060 0000238C B803000000                 mov _TOS_, 0x03
  4061 00002391 E8D7FFFFFF                 call tab_n
  4062 00002396 C3                         ret
  4063                                     
  4064                                  tab4:       ; ( -- )
  4065                                     _DUP_
   132 00002397 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000239A 8906                <1>  mov [ esi ], _TOS_
  4066 0000239C B804000000                 mov _TOS_, 0x04
  4067 000023A1 E8C7FFFFFF                 call tab_n
  4068 000023A6 C3                         ret
  4069                                  
  4070                                  tab5:       ; ( -- )
  4071                                     _DUP_
   132 000023A7 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000023AA 8906                <1>  mov [ esi ], _TOS_
  4072 000023AC B805000000                 mov _TOS_, 0x05
  4073 000023B1 E8B7FFFFFF                 call tab_n
  4074 000023B6 C3                         ret
  4075                                     
  4076                                  tab6:       ; ( -- )
  4077                                     _DUP_
   132 000023B7 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000023BA 8906                <1>  mov [ esi ], _TOS_
  4078 000023BC B806000000                 mov _TOS_, 0x06
  4079 000023C1 E8A7FFFFFF                 call tab_n
  4080 000023C6 C3                         ret
  4081                                  
  4082                                  tab7:       ; ( -- )
  4083                                     _DUP_
   132 000023C7 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000023CA 8906                <1>  mov [ esi ], _TOS_
  4084 000023CC B807000000                 mov _TOS_, 0x07
  4085 000023D1 E897FFFFFF                 call tab_n
  4086 000023D6 C3                         ret
  4087                                  
  4088                                  tab8:       ; ( -- )
  4089                                     _DUP_
   132 000023D7 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000023DA 8906                <1>  mov [ esi ], _TOS_
  4090 000023DC B808000000                 mov _TOS_, 0x08
  4091 000023E1 E887FFFFFF                 call tab_n
  4092 000023E6 C3                         ret
  4093                                  
  4094                                  %define TAB_SIZE  24
  4095                                  
  4096                                  tab:        ; ( -- )
  4097                                     _DUP_
   132 000023E7 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000023EA 8906                <1>  mov [ esi ], _TOS_
  4098 000023EC B818000000                 mov _TOS_, TAB_SIZE
  4099 000023F1 E877FFFFFF                 call tab_n
  4100 000023F6 C3                         ret
  4101                                  
  4102                                  ; tab:    ; ( -- )    \ align to the next n character column
  4103                                  ;     pusha
  4104                                  ;     call get_x
  4105                                  ;     xor edx, edx                    ; clear high 32 bits of dividend
  4106                                  ;     mov _SCRATCH_, TAB_SIZE
  4107                                  ;     div _SCRATCH_
  4108                                  ;     mul _SCRATCH_
  4109                                  ;     add _TOS_, TAB_SIZE
  4110                                  ;     call set_x
  4111                                  ;     popa
  4112                                  ;     ret
  4113                                  
  4114                                  ; tab3:
  4115                                  ;     pusha
  4116                                  ;     call get_x
  4117                                  ;     xor edx, edx                    ; clear high 32 bits of dividend
  4118                                  ;     mov _SCRATCH_, 0x03
  4119                                  ;     div _SCRATCH_
  4120                                  ;     mul _SCRATCH_
  4121                                  ;     add _TOS_, 0x03
  4122                                  ;     call set_x
  4123                                  ;     popa
  4124                                  ;     ret
  4125                                  ; 
  4126                                  ; tab6:
  4127                                  ;     pusha
  4128                                  ;     call get_x
  4129                                  ;     xor edx, edx                    ; clear high 32 bits of dividend
  4130                                  ;     mov _SCRATCH_, 0x06
  4131                                  ;     div _SCRATCH_
  4132                                  ;     mul _SCRATCH_
  4133                                  ;     add _TOS_, 0x06
  4134                                  ;     call set_x
  4135                                  ;     popa
  4136                                  ;     ret
  4137                                  ; 
  4138                                  ; tab7:
  4139                                  ;     pusha
  4140                                  ;     call get_x
  4141                                  ;     xor edx, edx                    ; clear high 32 bits of dividend
  4142                                  ;     mov _SCRATCH_, 0x07
  4143                                  ;     div _SCRATCH_
  4144                                  ;     mul _SCRATCH_
  4145                                  ;     add _TOS_, 0x07
  4146                                  ;     call set_x
  4147                                  ;     popa
  4148                                  ;     ret
  4149                                  ; 
  4150                                  ; tab8:
  4151                                  ;     pusha
  4152                                  ;     call get_x
  4153                                  ;     xor edx, edx                    ; clear high 32 bits of dividend
  4154                                  ;     mov _SCRATCH_, 0x08
  4155                                  ;     div _SCRATCH_
  4156                                  ;     mul _SCRATCH_
  4157                                  ;     add _TOS_, 0x08
  4158                                  ;     call set_x
  4159                                  ;     popa
  4160                                  ;     ret
  4161                                  
  4162                                  br:         ; ( -- )
  4163 000023F7 E89BE6FFFF                  call cr_
  4164 000023FC E896E6FFFF                  call cr_
  4165 00002401 C3                          ret
  4166                                  
  4167                                  not_cr:     ; ( -- )
  4168 00002402 F615[16480000]              not byte [ v_not_cr ]
  4169 00002408 C3                          ret
  4170                                  
  4171                                  not_tab:    ; ( -- )
  4172 00002409 E8F4FFFFFF                  call not_cr
  4173 0000240E E8D4FFFFFF                  call tab
  4174 00002413 C3                          ret
  4175                                  
  4176                                  cr_plus:    ; ( -- )
  4177 00002414 E87EE6FFFF                  call cr_
  4178 00002419 E8BAEBFFFF                  call space_
  4179 0000241E E8B5EBFFFF                  call space_
  4180 00002423 E8B0EBFFFF                  call space_
  4181 00002428 C3                          ret
  4182                                  
  4183                                  four_spaces:       ; ( -- )   
  4184 00002429 E8AAEBFFFF                  call space_
  4185                                  three_spaces:      ; ( -- )
  4186 0000242E E8A5EBFFFF                  call space_
  4187                                  two_spaces:        ; ( -- )
  4188 00002433 E8A0EBFFFF                  call space_
  4189 00002438 E89BEBFFFF                  call space_
  4190 0000243D C3                          ret
  4191                                  
  4192                                  BlueNames:   ; name   routine      comment
  4193 0000243E 0E008090                    dd 0x9080000E  ; cr     cr_          move to the next line
  4194 00002442 0E8C4BE6                    dd 0xE64B8C0E  ; -tab   not_tab      prevent the next CR
  4195 00002446 0E00C625                    dd 0x25C6000E  ; tab    tab          align to next TAB_SIZE space column
  4196 0000244A 0E0020C6                    dd 0xC620000E  ; br     br           cr cr
  4197 0000244E 0E0021E7                    dd 0xE721000E  ; -cr    not_cr       prevent the next CR
  4198 00002452 0E00FB90                    dd 0x90FB000E  ; cr+    cr_plus      cr and 3 spaces  
  4199 00002456 0EACC725                    dd 0x25C7AC0E  ; tab3   tab3         align to next 3 space column
  4200 0000245A 0EB0C725                    dd 0x25C7B00E  ; tab4   tab4         align to next 4 space column
  4201 0000245E 0EB4C725                    dd 0x25C7B40E  ; tab5   tab5         align to next 5 space column
  4202 00002462 0EB8C725                    dd 0x25C7B80E  ; tab6   tab6         align to next 6 space column
  4203 00002466 0EBCC725                    dd 0x25C7BC0E  ; tab7   tab7         align to next 7 space column
  4204 0000246A 0EC0C725                    dd 0x25C7C00E  ; tab8   tab8         align to next 8 space column
  4205 0000246E 0E0000EA                    dd 0xEA00000E  ; .      space_       
  4206 00002472 0E00D4EB                    dd 0xEBD4000E  ; ..     two_spaces   
  4207 00002476 0EA8D7EB                    dd 0xEBD7A80E  ; ...    three_spaces 
  4208 0000247A 5EAFD7EB                    dd 0xEBD7AF5E  ; ....   four_spaces  
  4209                                                                           
  4210                                  BlueJumpTableROM:  ; name_SF     name    comment
  4211 0000247E [970A0000]                  dd cr_          ; 0x9080000E  cr      move to the next line
  4212 00002482 [09240000]                  dd not_tab      ; 0xE64B8C0E  -tab    prevent the next CR
  4213 00002486 [E7230000]                  dd tab          ; 0x25C6000E  tab     align to next TAB_SIZE space column
  4214 0000248A [F7230000]                  dd br           ; 0xC620000E  br      cr cr
  4215 0000248E [02240000]                  dd not_cr       ; 0xE721000E  -cr     prevent the next CR
  4216 00002492 [14240000]                  dd cr_plus      ; 0x90FB000E  cr+     cr and 3 spaces  
  4217 00002496 [87230000]                  dd tab3         ; 0x25C7AC0E  tab3    align to next 3 space column
  4218 0000249A [97230000]                  dd tab4         ; 0x25C7B00E  tab4    align to next 4 space column
  4219 0000249E [A7230000]                  dd tab5         ; 0x25C7B40E  tab5    align to next 5 space column
  4220 000024A2 [B7230000]                  dd tab6         ; 0x25C7B80E  tab6    align to next 6 space column
  4221 000024A6 [C7230000]                  dd tab7         ; 0x25C7BC0E  tab7    align to next 7 space column
  4222 000024AA [D7230000]                  dd tab8         ; 0x25C7C00E  tab8    align to next 8 space column
  4223 000024AE [D80F0000]                  dd space_       ; 0xEA00000E  .       space_       
  4224 000024B2 [33240000]                  dd two_spaces   ; 0xEBD4000E  ..      two_spaces   
  4225 000024B6 [2E240000]                  dd three_spaces ; 0xEBD7A80E  ...     three_spaces 
  4226 000024BA [29240000]                  dd four_spaces  ; 0xEBD7AF5E  ....    four_spaces  
  4227                                  BlueJumpTableROM_end:
  4228                                  
  4229                                  find_Blue_word_:   ; ( sf -- index )   \ ecx = index ; find the Shannon-Fano word sf in the Blue wordlist, return its index in ecx
  4230 000024BE 57                          push edi
  4231 000024BF B910000000                  mov ecx, 16   ; count of Blue wordlist words
  4232 000024C4 8D3C8D[3A240000]            lea edi, [ ( ecx * 4 ) + BlueNames - 4 ]   ; set edi to the top of the Blue name table
  4233 000024CB FD                          std                    ; scan backwards
  4234 000024CC F2AF                        repne scasd            ; find the 32 bit Shanon-Fano encoded name, compare eax with doubleword at es:edi and set status flags.
  4235 000024CE FC                          cld                    ; reset the direction flag
  4236 000024CF 89C8                        mov _TOS_, ecx
  4237 000024D1 5F                          pop edi
  4238 000024D2 C3                          ret
  4239                                  
  4240                                  blueWord:   ; ( -- )    \ format the editor display screen using certain blue tokens. ToDo: This should ba a table... 
  4241                                      _DUP_
   132 000024D3 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000024D6 8906                <1>  mov [ esi ], _TOS_
  4242 000024D8 A0[14480000]                mov al, [ v_seeb ]
  4243 000024DD 3C00                        cmp al, 0
  4244 000024DF 8B04BDFCFFFFFF              mov _TOS_, [ ( edi * 4 ) - 0x04 ]   ; fetch the next token - then calls showShannonFano
  4245 000024E6 740F                        jz .forward
  4246 000024E8 E8E4EBFFFF                  call setBlue
  4247                                      _DUP_
   132 000024ED 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000024F0 8906                <1>  mov [ esi ], _TOS_
  4248 000024F2 E816FBFFFF                  call showShannonFano
  4249                                  .forward:
  4250 000024F7 8B04BDFCFFFFFF              mov _TOS_, [ ( edi * 4 ) - 0x04 ]
  4251 000024FE E8BBFFFFFF                  call find_Blue_word_             ; returns the index TOS
  4252 00002503 FF1485[7E240000]            call [ ( _TOS_ * 4 ) + BlueJumpTableROM ]
  4253                                      _DROP_
   148 0000250A AD                  <1>  lodsd
  4254 0000250B C3                          ret    
  4255                                  
  4256                                  ; silverWord:   ; ( -- )    ; ToDo: find out what this is for (GreenArrays gray token?)
  4257                                  ;     mov edx, [ ( edi * 4 ) - 0x04 ] ; load the value of the action from the current token in the pre-parsed source
  4258                                  ;     sar edx, 0x05                   ; remove the token colour bits
  4259                                  ;     _DUP_
  4260                                  ;     mov _TOS_, colour_white
  4261                                  ;     cmp dword [ x_numberDisplay ], dotDecimal
  4262                                  ;     jz .forward
  4263                                  ;     mov _TOS_, colour_silver
  4264                                  ; .forward:
  4265                                  ;    jmp short displayNumber
  4266                                  ;    ret
  4267                                  
  4268                                  silverWord:     ; display a silver word
  4269 0000250C E8EDEBFFFF                  call setSilver
  4270 00002511 E9EBFAFFFF                  jmp showSF_EDI_
  4271                                  
  4272                                  displayShannonFanoActions:  ;    * = number
  4273 00002516 [9B220000]                  dd extension            ; 0     extension token, remove space from previous word, do not change the colour
  4274 0000251A [31220000]                  dd yellowWord           ; 1     yellow "immediate" word
  4275 0000251E [29230000]                  dd yellowNumber         ; 2  *  yellow "immediate" 32 bit number in the following pre-parsed cell
  4276 00002522 [C6210000]                  dd redWord              ; 3     red forth wordlist "colon" word
  4277 00002526 [1D220000]                  dd greenWord            ; 4     green compiled word
  4278 0000252A [0E230000]                  dd greenNumber          ; 5  *  green compiled 32 bit number in the following pre-parsed cell
  4279 0000252E [CC220000]                  dd greenShortNumber     ; 6  *  green compiled 27 bit number in the high bits of the token
  4280 00002532 [27220000]                  dd cyanWord             ; 7     cyan macro wordlist "colon" word
  4281 00002536 [1D230000]                  dd yellowShortNumber    ; 8  *  yellow "immediate" 27 bit number in the high bits of the token
  4282 0000253A [FC1F0000]                  dd lowercase            ; 9     white lower-case comment
  4283 0000253E [3B220000]                  dd camelcase            ; A     first letter capital comment
  4284 00002542 [70220000]                  dd uppercase            ; B     white upper-case comment
  4285 00002546 [D8220000]                  dd magentaVariable      ; C     magenta variable
  4286 0000254A [0C250000]                  dd silverWord           ; D
  4287 0000254E [D3240000]                  dd blueWord             ; E     editor formatting commands
  4288 00002552 [40040000]                  dd nul                  ; F
  4289                                  
  4290                                  v_lineOffset:
  4291 00002556 01000000                    dd 1    ; the top line of the display
  4292                                  
  4293                                  doColourBlind:  ; ( state -- )   \ add conventional Forth punctuation based on the new and last states
  4294 0000255A 803D[15480000]00            cmp byte [ v_colourBlindMode ], 0x00
  4295 00002561 740E                        jz .forward3
  4296 00002563 F605[A8470000]01            test byte [ v_blk ], 0x01       ; do not display colour-blind characters in odd numbered shadow blocks
  4297 0000256A 7505                        jnz .forward3
  4298 0000256C E8EFF9FFFF                  call dword colourBlindAction    ; pass the new state to colourBlind so that extra characters can be added to the display
  4299                                      .forward3:
  4300                                      _DROP_
   148 00002571 AD                  <1>  lodsd
  4301 00002572 C3                          ret
  4302                                  
  4303                                  doShowASCII:    ;
  4304 00002573 803D[20480000]00            cmp byte [ v_show_ASCII ], 0x00
  4305 0000257A 7405                        jz .forward4
  4306                                  
  4307 0000257C E833FAFFFF                  call dword ShowASCIIAction    ; pass the new state to colourBlind so that extra characters can be added to the display
  4308                                      .forward4:
  4309 00002581 C3                          ret
  4310                                  
  4311                                  plusList:   ; ( -- ) display the current colorForth block
  4312                                      _DUP_
   132 00002582 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00002585 8906                <1>  mov [ esi ], _TOS_
  4313 00002587 31C0                        xor _TOS_, _TOS_                        ; set Top Of Stack to 0
  4314 00002589 A3[CA1D0000]                mov [ currentState ], _TOS_             ; initialise the colour-blind state machine
  4315 0000258E A3[CE1D0000]                mov [ lastState ], _TOS_                ; initialise the colour-blind state machine
  4316 00002593 A3[C4470000]                mov [ v_display_token_number ], _TOS_   ; initialise the displayed token nunber             
  4317                                      _DROP_
   148 00002598 AD                  <1>  lodsd
  4318                                  
  4319 00002599 E881EAFFFF                  call setupText_                 ; setup the clip window for this display
  4320                                      _DUP_
   132 0000259E 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000025A1 8906                <1>  mov [ esi ], _TOS_
  4321 000025A3 A1[E0470000]                mov _TOS_, [ v_lcad ]
  4322 000025A8 A3[D8470000]                mov [ v_cad ], _TOS_
  4323 000025AD A1[A8470000]                mov _TOS_, [ v_blk ]                    ; get the current block number to be edited
  4324 000025B2 E8C8E3FFFF                  call blockToCellAddress                 ; add the RELOCATED block number offset and convert to cell address
  4325 000025B7 89C7                        mov edi, _TOS_
  4326 000025B9 31C0                        xor _TOS_, _TOS_
  4327 000025BB 033D[56250000]              add edi, [ v_lineOffset ]
  4328 000025C1 893D[DC470000]              mov [ v_pcad ], edi
  4329                                  .back:
  4330 000025C7 8B14BD00000000              mov edx, dword [ ( edi * 4 ) + 0x00 ]   ; edi is the display pointer and is a cell address
  4331 000025CE E870F7FFFF                  call show_cursor                        ; show the PacMan-like cursor
  4332 000025D3 47                          inc edi
  4333                                      
  4334 000025D4 66FF05[C4470000]            inc word [ v_display_token_number ]     ; count up the number of tokens displayed 
  4335 000025DB 66813D[C4470000]E0-         cmp word [ v_display_token_number ], 0xE0   ; save the last 128 bytes for version information
  4335 000025E3 00                 
  4336 000025E4 7524                        jne .forward4
  4337 000025E6 E8E6EAFFFF                      call setBlue
  4338                                          EMIT_IMM('<')   ; warm the user that we have hit the limit of the block display "<<"
   193                              <1> 
   194                              <1>  _DUP_
   132 000025EB 8D76FC              <2>  lea esi, [ esi - 4 ]
   133                              <2> 
   134 000025EE 8906                <2>  mov [ esi ], _TOS_
   195 000025F0 B83C000000          <1>  mov _TOS_, %1
   196 000025F5 E8CCE9FFFF          <1>  call emit_
   197                              <1> 
  4339                                          EMIT_IMM('<')
   193                              <1> 
   194                              <1>  _DUP_
   132 000025FA 8D76FC              <2>  lea esi, [ esi - 4 ]
   133                              <2> 
   134 000025FD 8906                <2>  mov [ esi ], _TOS_
   195 000025FF B83C000000          <1>  mov _TOS_, %1
   196 00002604 E8BDE9FFFF          <1>  call emit_
   197                              <1> 
  4340 00002609 C3                              ret     ; we have displayed enough tokens now
  4341                                  .forward4:
  4342                                  
  4343                                      ; adjust the number base according to bit 5 of the token value, only used by number display words
  4344                                      ; this section of code displays numbers in the base that they were defined as, not according to the current base
  4345 0000260A C705[94470000]-             mov dword [ x_numberDisplay ], dotDecimal   ; set the display base to decimal
  4345 00002610 [9C120000]         
  4346 00002614 F6C210                      test dl, 0x10
  4347 00002617 740A                        jz .forward2
  4348 00002619 C705[94470000]-             mov dword [ x_numberDisplay ], dotHex       ; set the display base to hexadecimal (overwrites dotDecimal that was just set)
  4348 0000261F [5E120000]         
  4349                                  .forward2:
  4350                                  
  4351 00002623 83E20F                      and edx, byte 0x0F
  4352                                      _DUP_
   132 00002626 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00002629 8906                <1>  mov [ esi ], _TOS_
  4353 0000262B 89D0                        mov _TOS_, edx
  4354 0000262D E828FFFFFF                  call doColourBlind
  4355 00002632 FF1495[16250000]            call [ ( edx * 4 ) + displayShannonFanoActions ]
  4356 00002639 EB8C                        jmp short .back
  4357                                  
  4358                                  refresh:                            ; refresh the editor display
  4359 0000263B E86FDEFFFF                  call show                       ; set the screen task to execute the code following (in a repeating loop) :
  4360 00002640 E82FEAFFFF                  call page_                      ; clear the screen
  4361 00002645 E8EEECFFFF                  call displayBlockNumber         ; display the current block number on the screen, top right corner
  4362 0000264A E833FFFFFF                  call plusList                   ; list the contents of the block
  4363                                      _DUP_
   132 0000264F 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00002652 8906                <1>  mov [ esi ], _TOS_
  4364 00002654 B80F000000                  mov _TOS_, 0x0F
  4365 00002659 E8FCFEFFFF                  call doColourBlind             ; display the final colour-blind punctuation, set up for next call of plusList
  4366 0000265E E923EEFFFF                  jmp dword displayTheKeypad_
  4367                                  
  4368 00002663 00                      align 4, db 0   ; fill the gap with 0's
  4369                                  
  4370                                  actionColourTable:          ;    * = number
  4371 00002664 00E20000                    dd colour_orange        ; 0     extension token, remove space from previous word, do not change the colour
  4372 00002668 E0FF0000                    dd colour_yellow        ; 1     yellow "immediate" word
  4373 0000266C E0FF0000                    dd colour_yellow        ; 2  *  yellow "immediate" 32 bit number in the following pre-parsed cell
  4374 00002670 00F80000                    dd colour_red           ; 3     red forth wordlist "colon" word
  4375 00002674 00060000                    dd colour_green         ; 4     green compiled cf2022
  4376 00002678 00060000                    dd colour_green         ; 5  *  green compiled 32 bit number in the following pre-parsed cell
  4377 0000267C 00060000                    dd colour_green         ; 6  *  green compiled 27 bit number in the high bits of the token
  4378 00002680 FF070000                    dd colour_cyan          ; 7     cyan macro wordlist "colon" word
  4379 00002684 E0FF0000                    dd colour_yellow        ; 8  *  yellow "immediate" 27 bit number in the high bits of the token
  4380 00002688 FFFF0000                    dd colour_white         ; 9     white lower-case comment
  4381 0000268C FFFF0000                    dd colour_white         ; A     first letter capital comment
  4382 00002690 FFFF0000                    dd colour_white         ; B     white upper-case comment
  4383 00002694 1FF80000                    dd colour_magenta       ; C     magenta variable
  4384 00002698 18C60000                    dd colour_silver        ; D
  4385 0000269C 1F000000                    dd colour_blue          ; E     editor formatting commands
  4386 000026A0 00000000                    dd colour_black         ; F
  4387                                  
  4388                                  vector:
  4389 000026A4 00000000                    dd 0  ; pointer to call table for keypad ( see keypd )
  4390                                  
  4391                                  action:
  4392 000026A8 01                          db 1
  4393                                  
  4394 000026A9 00<rep 3h>              align 4, db 0   ; fill the gap with 0's
  4395                                  
  4396                                  cursorLeft:     ; ( -- )
  4397 000026AC FF0D[AC470000]              dec dword [ v_curs ]
  4398 000026B2 7906                        jns .forward
  4399 000026B4 FF05[AC470000]                  inc dword [ v_curs ]
  4400                                      .forward:
  4401 000026BA C3                          ret
  4402                                  
  4403                                  limitToEndOfBlock:
  4404 000026BB E8BF000000                  call countTokens
  4405 000026C0 3B05[AC470000]              cmp _TOS_, dword [ v_curs ]
  4406 000026C6 7905                        jns .forward
  4407 000026C8 A3[AC470000]                    mov dword [ v_curs ], _TOS_
  4408                                      .forward:
  4409                                      _DROP_
   148 000026CD AD                  <1>  lodsd
  4410 000026CE C3                          ret
  4411                                  
  4412                                  cursorRight:
  4413 000026CF FF05[AC470000]              inc dword [ v_curs ]
  4414 000026D5 E8E1FFFFFF                  call limitToEndOfBlock
  4415 000026DA C3                          ret
  4416                                  
  4417                                  countAllTokens:     ; ( -- x ) \ counts red and magenta tokens and all tokens in the current block
  4418                                      _DUP_
   132 000026DB 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000026DE 8906                <1>  mov [ esi ], _TOS_
  4419 000026E0 31C0                        xor _TOS_, _TOS_
  4420 000026E2 A3[C8470000]                mov dword [ v_numberOfMagentas ], _TOS_
  4421 000026E7 A3[D0470000]                mov dword [ v_numberOfRedAndMagentas ], _TOS_   ; count up Red and Magenta tokens
  4422 000026EC A3[D4470000]                mov dword [ v_numberOfTokens ], _TOS_           ; count all tokens
  4423 000026F1 A3[CC470000]                mov dword [ v_numberOfBigConstants ], _TOS_     ; count of 32 bit literal tokens
  4424                                  
  4425 000026F6 B900010000                  mov ecx, 0x00100      ; 256 x 4 byte cells = 1 block
  4426                                  .loop:
  4427                                  
  4428                                      _DUP_
   132 000026FB 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000026FE 8906                <1>  mov [ esi ], _TOS_
  4429 00002700 A1[D4470000]                mov _TOS_, [ v_numberOfTokens ]
  4430 00002705 E84FE3FFFF                  call nth_to_token
  4431 0000270A 89C3                        mov _SCRATCH_, _TOS_
  4432                                      _DROP_
   148 0000270C AD                  <1>  lodsd
  4433 0000270D 81FB00000000                cmp _SCRATCH_, 0x00
  4434 00002713 745E                        je .forward         ; exit if the token value is 0, means end of block
  4435                                  
  4436 00002715 FF05[D4470000]              inc dword [ v_numberOfTokens ]
  4437                                  
  4438 0000271B 81E30F000000                and _SCRATCH_, 0x0F     ; look at the token type
  4439                                  
  4440 00002721 81FB03000000                cmp _SCRATCH_, 0x03     ; red token
  4441 00002727 7506                        jne .forwardRed
  4442 00002729 FF05[D0470000]                  inc dword [ v_numberOfRedAndMagentas ]
  4443                                      .forwardRed:
  4444                                  
  4445 0000272F 81FB0C000000                cmp _SCRATCH_, 0x0C     ; magenta token
  4446 00002735 7512                        jne .forwardMagenta
  4447 00002737 FF05[D0470000]                  inc dword [ v_numberOfRedAndMagentas ]
  4448 0000273D FF05[C8470000]                  inc dword [ v_numberOfMagentas ]    ; correction for magenta variables
  4449 00002743 FF05[D4470000]                  inc dword [ v_numberOfTokens ]      ; step over the Magenta variable data cell
  4450                                      .forwardMagenta:
  4451                                  
  4452 00002749 81FB02000000                cmp _SCRATCH_, 0x02     ; yellow 32 bit literal
  4453 0000274F 750C                        jne .forwardBig
  4454 00002751 FF05[CC470000]                  inc dword [ v_numberOfBigConstants ]    ; correction for literal constants
  4455 00002757 FF05[D4470000]                  inc dword [ v_numberOfTokens ]          ; step over the data cell
  4456                                      .forwardBig:
  4457                                  
  4458 0000275D 81FB05000000                cmp _SCRATCH_, 0x05     ; green 32 bit literal
  4459 00002763 750C                        jne .forwardBig2
  4460 00002765 FF05[CC470000]                  inc dword [ v_numberOfBigConstants ]    ; correction for literal constants
  4461 0000276B FF05[D4470000]                  inc dword [ v_numberOfTokens ]          ; step over the data cell
  4462                                      .forwardBig2:
  4463                                  
  4464 00002771 E288                        loop .loop
  4465                                  .forward:               ; found the end of the block
  4466                                  ;    mov _TOS_, dword [ v_numberOfRedAndMagentas ]
  4467 00002773 C3                          ret
  4468                                  
  4469                                  countRedAndMagentaTokens:     ; ( -- n ) \ counts red and magenta tokens in the current block
  4470 00002774 E862FFFFFF                  call countAllTokens
  4471 00002779 A1[D0470000]                mov _TOS_, dword [ v_numberOfRedAndMagentas ]
  4472 0000277E C3                          ret
  4473                                  
  4474                                  countTokens:     ; ( -- n ) \ counts all tokens up to the end of the current block
  4475 0000277F E857FFFFFF                  call countAllTokens
  4476 00002784 A1[D4470000]                mov _TOS_, dword [ v_numberOfTokens ]
  4477 00002789 2B05[C8470000]              sub _TOS_, dword [ v_numberOfMagentas ]
  4478 0000278F 2B05[CC470000]              sub _TOS_, dword [ v_numberOfBigConstants ]
  4479 00002795 25FF030000                  and _TOS_, 0x00003FF   ; limit the maximum numer of tokens, just in case
  4480 0000279A C3                          ret
  4481                                  
  4482                                  ; *****************************************************************************
  4483                                  
  4484                                  cursorDownToNth:     ; ( -- ) \ step down to after the v_cursLine'th red or magenta token
  4485                                      _DUP_
   132 0000279B 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000279E 8906                <1>  mov [ esi ], _TOS_
  4486 000027A0 31C0                        xor _TOS_, _TOS_
  4487 000027A2 A3[C8470000]                mov dword [ v_numberOfMagentas ], _TOS_
  4488 000027A7 A3[AC470000]                mov dword [ v_curs ], _TOS_
  4489 000027AC A3[CC470000]                mov dword [ v_numberOfBigConstants ], _TOS_
  4490                                  
  4491 000027B1 A1[BC470000]                mov dword _TOS_, [ v_cursLine ]
  4492 000027B6 A3[C0470000]                mov dword [ v_curs_number_down ], _TOS_
  4493                                  
  4494 000027BB B900010000                  mov ecx, 0x00100      ; 256 x 4 byte cells = 1 block
  4495                                  .loop:
  4496                                  
  4497 000027C0 813D[C0470000]0000-         cmp dword [ v_curs_number_down ], 0x00  ; test for zero
  4497 000027C8 0000               
  4498 000027CA 746C                        je .forward     ; jump to the end if  v_curs_number_down  reaches zero
  4499                                  
  4500                                      _DUP_
   132 000027CC 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000027CF 8906                <1>  mov [ esi ], _TOS_
  4501 000027D1 A1[AC470000]                mov _TOS_, [ v_curs ]
  4502 000027D6 E87EE2FFFF                  call nth_to_token
  4503 000027DB 89C3                        mov _SCRATCH_, _TOS_
  4504                                      _DROP_
   148 000027DD AD                  <1>  lodsd
  4505 000027DE 81FB00000000                cmp _SCRATCH_, 0x00
  4506 000027E4 7464                        je .endOfBlock         ; exit if the token value is 0, means end of block
  4507                                  
  4508 000027E6 FF05[AC470000]              inc dword [ v_curs ]
  4509                                  
  4510 000027EC 81E30F000000                and _SCRATCH_, 0x0F     ; look at the token type
  4511                                  
  4512 000027F2 81FB03000000                cmp _SCRATCH_, 0x03     ; red token
  4513 000027F8 7506                        jne .forwardRed
  4514 000027FA FF0D[C0470000]                  dec dword [ v_curs_number_down ]
  4515                                      .forwardRed:
  4516                                  
  4517                                   ;   cmp _SCRATCH_, 0x0E     ; blue token
  4518                                   ;   jne .forwardBlue
  4519                                   ;       dec dword [ v_curs_number_down ]
  4520                                   ;   .forwardBlue:
  4521                                  
  4522 00002800 81FB0C000000                cmp _SCRATCH_, 0x0C     ; magenta token
  4523 00002806 7512                        jne .forwardMagenta
  4524 00002808 FF0D[C0470000]                  dec dword [ v_curs_number_down ]
  4525 0000280E FF05[C8470000]                  inc dword [ v_numberOfMagentas ]    ; correction for magenta variables
  4526 00002814 FF05[AC470000]                  inc dword [ v_curs ]                ; step over the Magenta variable data cell
  4527                                      .forwardMagenta:
  4528                                  
  4529 0000281A 81FB02000000                cmp _SCRATCH_, 0x02     ; yellow 32 bit literal
  4530 00002820 7408                        je .forwardBig
  4531                                  
  4532 00002822 81FB05000000                cmp _SCRATCH_, 0x05     ; green 32 bit literal
  4533 00002828 750C                        jne .forwardBig2
  4534                                      .forwardBig:
  4535 0000282A FF05[CC470000]                  inc dword [ v_numberOfBigConstants ]    ; correction for literal constants
  4536 00002830 FF05[AC470000]                  inc dword [ v_curs ]                    ; step over the data cell
  4537                                      .forwardBig2:
  4538                                  
  4539 00002836 E288                        loop .loop
  4540                                  .forward:               ; found the right number of red or magenta tokens, so exit
  4541 00002838 8B1D[C8470000]              mov _SCRATCH_, dword [ v_numberOfMagentas ]
  4542 0000283E 031D[CC470000]              add _SCRATCH_, dword [ v_numberOfBigConstants ]
  4543 00002844 291D[AC470000]              sub dword [ v_curs ], _SCRATCH_  ; the correction for magenta variables
  4544                                  .endOfBlock:
  4545 0000284A E86CFEFFFF                  call limitToEndOfBlock
  4546                                      _DROP_
   148 0000284F AD                  <1>  lodsd
  4547 00002850 C3                          ret
  4548                                  
  4549                                  cursorUp:     ; ( -- ) \ step down to after the next red token, or after 0x16 steps, or until the end of the block
  4550 00002851 FF0D[BC470000]              dec dword [ v_cursLine ]
  4551 00002857 750A                        jnz .forward
  4552 00002859 C705[BC470000]0000-         mov dword [ v_cursLine ], 0x00
  4552 00002861 0000               
  4553                                  .forward:
  4554                                  ;    mov dword [ v_cursLine ], 0x03
  4555 00002863 E833FFFFFF                  call cursorDownToNth
  4556 00002868 C3                          ret
  4557                                  
  4558                                  cursorDown:     ; ( -- ) \ step down to after the next red token, or after 0x16 steps, or until the end of the block
  4559 00002869 FF05[BC470000]              inc dword [ v_cursLine ]
  4560 0000286F E800FFFFFF                  call countRedAndMagentaTokens
  4561 00002874 40                          inc dword _TOS_     ; add one so that we can go past the last token to the end of the block
  4562 00002875 3905[BC470000]              cmp dword [ v_cursLine ], _TOS_
  4563 0000287B 7805                        js .forward
  4564 0000287D A3[BC470000]                mov dword [ v_cursLine ], _TOS_
  4565                                  .forward:
  4566                                      _DROP_
   148 00002882 AD                  <1>  lodsd
  4567                                   ;   mov dword [ v_cursLine ], 0x02
  4568 00002883 E813FFFFFF                  call cursorDownToNth
  4569 00002888 C3                          ret
  4570                                  
  4571                                  cursorEnd:     ; ( -- )
  4572 00002889 E8E6FEFFFF                  call countRedAndMagentaTokens
  4573 0000288E 40                          inc dword _TOS_     ; add one so that we can go past the last token to the end of the block
  4574 0000288F A3[BC470000]                mov dword [ v_cursLine ], _TOS_
  4575                                      _DROP_
   148 00002894 AD                  <1>  lodsd
  4576 00002895 E801FFFFFF                  call cursorDownToNth
  4577 0000289A E81CFEFFFF                  call limitToEndOfBlock
  4578 0000289F C3                          ret
  4579                                  
  4580                                  cursorHome:     ; ( -- )
  4581 000028A0 31DB                        xor _SCRATCH_, _SCRATCH_
  4582 000028A2 891D[C8470000]              mov dword [ v_numberOfMagentas ], _SCRATCH_
  4583 000028A8 891D[AC470000]              mov dword [ v_curs ], _SCRATCH_                 ; the graphics cursor for drawing the block
  4584 000028AE 891D[56250000]              mov dword [ v_lineOffset ], _SCRATCH_           ; the cursor position to start drawing the block
  4585 000028B4 891D[3B160000]              mov dword [ v_lineOffsetTablePtr ], _SCRATCH_   ; a pointer to the cursor for each line in the display
  4586 000028BA 891D[C8470000]              mov dword [ v_numberOfMagentas ], _SCRATCH_     ; count of Magenta variables displayed so far in the edited block
  4587 000028C0 891D[BC470000]              mov dword [ v_cursLine ], _SCRATCH_
  4588 000028C6 C3                          ret
  4589                                  
  4590                                  nextBlock:     ; ( -- )
  4591 000028C7 8305[A8470000]02            add dword [ v_blk ], byte 0x02
  4592 000028CE E86CEDFFFF                  call lineOffsetZero
  4593 000028D3 C3                          ret
  4594                                  
  4595                                  previousBlock:
  4596 000028D4 833D[A8470000]42            cmp dword [ v_blk ], byte ( START_BLOCK_NUMBER + 2 )
  4597 000028DB 7807                        js .forward
  4598 000028DD 832D[A8470000]02            sub dword [ v_blk ], byte 0x02
  4599                                  .forward:
  4600 000028E4 E856EDFFFF                  call lineOffsetZero
  4601 000028E9 C3                          ret
  4602                                  
  4603                                  otherBlock:
  4604 000028EA E8BB030000                  call swap_with_other_
  4605 000028EF C3                          ret
  4606                                  
  4607                                  tog_show_ASCII:
  4608 000028F0 F615[20480000]              not byte [ v_show_ASCII ]
  4609 000028F6 C3                          ret
  4610                                  
  4611                                  shadow:     ; alternate between source and shadow blocks
  4612 000028F7 8335[A8470000]01            xor dword [ v_blk ], byte 0x01
  4613 000028FE C3                          ret
  4614                                  
  4615                                  insert0:    ; ( ... -- )
  4616 000028FF 8B0D[E0470000]              mov ecx, [ v_lcad ]
  4617 00002905 030D[44480000]              add ecx, [ v_words ]
  4618 0000290B 330D[E0470000]              xor ecx, [ v_lcad ]
  4619 00002911 81E100FFFFFF                and ecx, 0xFFFFFF00
  4620 00002917 740A                        jz insert1
  4621 00002919 8B0D[44480000]              mov ecx, [ v_words ]
  4622                                  .back:
  4623                                      _DROP_
   148 0000291F AD                  <1>  lodsd
  4624 00002920 E2FD                        loop .back
  4625 00002922 C3                          ret
  4626                                  
  4627                                  insert1:
  4628 00002923 56                          push esi
  4629 00002924 8B35[E0470000]              mov esi, [ v_lcad ]
  4630 0000292A 89F1                        mov ecx, esi
  4631 0000292C 4E                          dec esi
  4632 0000292D 89F7                        mov edi, esi
  4633 0000292F 033D[44480000]              add edi, [ v_words ]
  4634 00002935 C1E702                      shl edi, 0x02
  4635 00002938 2B0D[D8470000]              sub ecx, [ v_cad ]
  4636 0000293E 7807                        js .forward
  4637 00002940 C1E602                      shl esi, 0x02
  4638 00002943 FD                          std
  4639 00002944 F3A5                        rep  movsd                  ; copy ecx 32 bit words from ds:esi to es:edi
  4640 00002946 FC                          cld
  4641                                  .forward:
  4642 00002947 5E                          pop esi
  4643 00002948 C1EF02                      shr edi, 0x02
  4644 0000294B 47                          inc edi
  4645 0000294C 893D[AC470000]              mov [ v_curs ], edi
  4646 00002952 8B0D[44480000]              mov ecx, [ v_words ]
  4647                                  .back:
  4648 00002958 4F                          dec edi
  4649 00002959 8904BD00000000              mov [ ( edi * 4 ) + 0x00 ], _TOS_
  4650                                      _DROP_
   148 00002960 AD                  <1>  lodsd
  4651 00002961 E2F5                        loop .back
  4652 00002963 C3                          ret
  4653                                  
  4654                                  insert:
  4655 00002964 E896FFFFFF                  call insert0
  4656 00002969 8A0D[A8260000]              mov cl, [ action ]
  4657 0000296F 300CBD00000000              xor [ edi * 4 + 0x00 ],cl
  4658 00002976 80F903                      cmp cl, 0x03                    ; if we are a red token
  4659 00002979 751A                        jnz .forward
  4660 0000297B C605[A8260000]04            mov byte [ action ], 0x04       ; switch to green
  4661 00002982 C705[34480000]0006-         mov dword [ keypad_colour ], colour_green
  4661 0000298A 0000               
  4662 0000298C 66C705[18480000]67-         mov word [ v_hintChar ], 'g'    ; mark the green keypad with a 'g'
  4662 00002994 00                 
  4663                                      .forward:
  4664 00002995 C3                          ret
  4665                                  
  4666                                  _word1:
  4667 00002996 8F05[3C480000]              pop dword [ aword ]
  4668 0000299C C705[3C480000]-             mov dword [ aword ], ex1
  4668 000029A2 [C2070000]         
  4669 000029A6 C3                          ret
  4670                                  
  4671                                  _word:
  4672 000029A7 C705[3C480000]-             mov dword [ aword ], _word1
  4672 000029AD [96290000]         
  4673 000029B1 E9BDF2FFFF                  jmp dword quit_
  4674                                  
  4675                                  tokenAction_1:
  4676                                      _DUP_
   132 000029B6 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000029B9 8906                <1>  mov [ esi ], _TOS_
  4677 000029BB B801000000                  mov _TOS_, 0x01
  4678 000029C0 803D[A8260000]04            cmp byte [ action ], 0x04
  4679 000029C7 7402                        jz .forward2
  4680 000029C9 B003                        mov al, 0x03
  4681                                  .forward2:
  4682 000029CB 833D[2C480000]0A            cmp dword [ base ], byte 0x0A
  4683 000029D2 7402                        jz .forward
  4684 000029D4 3410                        xor al, 0x10
  4685                                  .forward:
  4686                                      _SWAP_
   138 000029D6 8706                <1>  xchg _TOS_, [ esi ]
  4687 000029D8 C705[44480000]0200-         mov dword [ v_words ], 0x02
  4687 000029E0 0000               
  4688 000029E2 EB80                        jmp short insert
  4689                                  
  4690                                  tokenAction:
  4691 000029E4 F605[A8260000]0A            test byte [ action ], 0x0A
  4692 000029EB 753C                        jnz .forward
  4693 000029ED 89C2                        mov edx, _TOS_
  4694 000029EF 81E2000000FC                and edx, 0xFC000000
  4695 000029F5 7408                        jz .forward2
  4696 000029F7 81FA000000FC                cmp edx, 0xFC000000
  4697 000029FD 75B7                        jnz tokenAction_1
  4698                                  .forward2:
  4699 000029FF C1E005                      shl _TOS_, 0x05
  4700 00002A02 3402                        xor al, 0x02
  4701 00002A04 803D[A8260000]04            cmp byte [ action ], 0x04
  4702 00002A0B 7402                        jz .forwardBack
  4703 00002A0D 340B                        xor al, 0x0B
  4704                                  .forwardBack:
  4705 00002A0F 833D[2C480000]0A            cmp dword [ base ], byte 0x0A
  4706 00002A16 7402                        jz .forward4
  4707 00002A18 3410                        xor al, 0x10
  4708                                  .forward4:
  4709 00002A1A C705[44480000]0100-         mov dword [ v_words ], 0x01
  4709 00002A22 0000               
  4710 00002A24 E93BFFFFFF                  jmp insert
  4711                                  .forward:
  4712 00002A29 803D[A8260000]09            cmp byte [ action ],  0x09
  4713 00002A30 750C                        jnz .forward3
  4714 00002A32 89C2                        mov edx, _TOS_
  4715 00002A34 C1E205                      shl edx, 0x05
  4716 00002A37 C1FA05                      sar edx, 0x05
  4717 00002A3A 39C2                        cmp edx, _TOS_
  4718 00002A3C 7402                        jz .forward5
  4719                                  .forward3:
  4720                                      _DROP_
   148 00002A3E AD                  <1>  lodsd
  4721 00002A3F C3                          ret
  4722                                  .forward5:
  4723 00002A40 C1E005                      shl _TOS_, 0x05
  4724 00002A43 3406                        xor al, 0x06
  4725 00002A45 EBC8                        jmp short .forwardBack
  4726                                  
  4727                                  enstack: ; ( ... n -- )   ; ctrlY action, delete the token at the cursor and put it into the trash buffer
  4728                                      _DUP_
   132 00002A47 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00002A4A 8906                <1>  mov [ esi ], _TOS_
  4729 00002A4C A1[D8470000]                mov _TOS_, [ v_cad ]
  4730 00002A51 2B05[DC470000]              sub _TOS_, [ v_pcad ]
  4731 00002A57 7426                        jz .forward
  4732 00002A59 89C1                        mov ecx, _TOS_
  4733 00002A5B 92                          xchg _TOS_, edx
  4734 00002A5C 56                          push esi
  4735 00002A5D 8B35[D8470000]              mov esi, [ v_cad ]
  4736 00002A63 8D34B5FCFFFFFF              lea esi, [ (esi * 4) - 0x04 ]
  4737 00002A6A 8B3D[E4470000]              mov edi, [ v_trash ]    ; setup EDI to point to the current trash buffer address
  4738                                  .back:
  4739 00002A70 FD                          std
  4740 00002A71 AD                          lodsd ; _DROP_          ; loads EAX with the value pointed to by EDI = [ v_trash ]
  4741 00002A72 FC                          cld
  4742 00002A73 AB                          stosd                   ; stores EAX into the location pointed to by EDI = [ v_trash ] and increments EDI
  4743 00002A74 E2FA                        loop .back
  4744 00002A76 92                          xchg _TOS_, edx         ;
  4745 00002A77 AB                          stosd                   ; stores EAX into the location pointed to by EDI and increments EDI
  4746 00002A78 893D[E4470000]              mov [ v_trash], edi     ; update the current trash buffer address
  4747 00002A7E 5E                          pop esi
  4748                                  .forward:
  4749                                      _DROP_
   148 00002A7F AD                  <1>  lodsd
  4750 00002A80 C3                          ret
  4751                                  
  4752                                  deleteAction:
  4753 00002A81 E8C1FFFFFF                  call enstack
  4754 00002A86 8B3D[DC470000]              mov edi, [ v_pcad ]
  4755 00002A8C 8B0D[E0470000]              mov ecx, [ v_lcad ]
  4756 00002A92 29F9                        sub ecx, edi
  4757 00002A94 C1E702                      shl edi, 0x02
  4758 00002A97 56                          push esi
  4759 00002A98 8B35[D8470000]              mov esi, [ v_cad ]
  4760 00002A9E C1E602                      shl esi, 0x02
  4761 00002AA1 F3A5                        rep  movsd                  ; copy ecx 32 bit words from ds:esi to es:edi
  4762 00002AA3 5E                          pop esi
  4763 00002AA4 E903FCFFFF                  jmp dword cursorLeft
  4764                                  
  4765                                  act0:
  4766 00002AA9 E899FFFFFF                  call enstack
  4767 00002AAE E9F9FBFFFF                  jmp dword cursorLeft
  4768                                  
  4769                                  yellowAction:
  4770 00002AB3 B001                        mov al, 0x01
  4771 00002AB5 EB1E                        jmp short actt
  4772                                  
  4773                                  redAction:  ; red : start creating a new definition
  4774 00002AB7 B003                        mov al, 0x03
  4775 00002AB9 EB1A                        jmp short actt
  4776                                  
  4777                                  greenAction:   ; green, start compiling an existing definition
  4778 00002ABB B004                        mov al, 0x04
  4779 00002ABD EB16                        jmp short actt
  4780                                  
  4781                                  textAction:
  4782 00002ABF B009                        mov al, 0x09
  4783 00002AC1 EB12                        jmp short actt
  4784                                  
  4785                                  CapitalAction:
  4786 00002AC3 B00A                        mov al, 0x0A
  4787 00002AC5 EB0E                        jmp short actt
  4788                                  
  4789                                  capitalS_Action:
  4790 00002AC7 B00B                        mov al, 0x0B
  4791 00002AC9 EB0A                        jmp short actt
  4792                                  
  4793                                  grayAction:
  4794 00002ACB B00D                        mov al, 0x0D
  4795 00002ACD EB06                        jmp short actt
  4796                                  
  4797                                  blueAction:
  4798 00002ACF B00E                        mov al, 0x0E
  4799 00002AD1 EB02                        jmp short actt
  4800                                  
  4801                                  cyanAction:
  4802 00002AD3 B007                        mov al, 0x07
  4803                                  
  4804                                  actt:   ; ( action -- )
  4805 00002AD5 A2[A8260000]                mov [ action ], al
  4806 00002ADA C705[3C480000]-             mov dword [ aword ], insert
  4806 00002AE0 [64290000]         
  4807 00002AE4 8B0485[64260000]            mov _TOS_, [ ( _TOS_ * 4 ) + actionColourTable ]
  4808                                  actn:
  4809 00002AEB A3[34480000]                mov [ keypad_colour ], _TOS_
  4810 00002AF0 58                          pop _TOS_
  4811                                      _DROP_
   148 00002AF1 AD                  <1>  lodsd
  4812 00002AF2 E97CF1FFFF                  jmp dword quit_
  4813                                  
  4814                                  magentaAction:   ; magenta variable action
  4815 00002AF7 C605[A8260000]0C            mov byte [ action ], 0x0C
  4816 00002AFE B81FF80000                  mov _TOS_, colour_magenta
  4817 00002B03 C705[3C480000]-             mov dword [ aword ], .forward
  4817 00002B09 [0F2B0000]         
  4818 00002B0D EBDC                        jmp short actn
  4819                                      .forward:
  4820                                      _DUP_
   132 00002B0F 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00002B12 8906                <1>  mov [ esi ], _TOS_
  4821 00002B14 31C0                        xor _TOS_, _TOS_
  4822 00002B16 FF05[44480000]              inc dword [ v_words ]
  4823 00002B1C E943FEFFFF                  jmp dword insert
  4824                                  
  4825                                  editorExit:       ; ( -- )   \ leave the editor
  4826 00002B21 58                          pop _TOS_
  4827                                      _DROP_
   148 00002B22 AD                  <1>  lodsd
  4828 00002B23 C705[3C480000]-             mov dword [ aword ], ex1
  4828 00002B29 [C2070000]         
  4829 00002B2D C705[40480000]-             mov dword [ anumber ], nul
  4829 00002B33 [40040000]         
  4830 00002B37 C605[5A190000]00            mov byte [ alpha0 + ( 4 * 4 ) ], 0x00
  4831 00002B3E C705[4E190000]-             mov dword [ alpha0 + 4 ], nul0
  4831 00002B44 [641C0000]         
  4832 00002B48 C705[34480000]E0FF-         mov dword [ keypad_colour ], colour_yellow
  4832 00002B50 0000               
  4833 00002B52 C605[17480000]00            mov byte [ v_quitMode ], 0x00
  4834 00002B59 C605[18480000]00            mov byte [ v_hintChar ], 0x00   ; no hint chararacter
  4835 00002B60 E90EF1FFFF                  jmp dword quit_
  4836                                  
  4837                                  destack:                    ; ctrlZ action, insert the next token from the trash buffer
  4838 00002B65 8B15[E4470000]              mov edx, [ v_trash ]
  4839 00002B6B 81FA00F00800                cmp edx, TRASH_BUFFER   ; do not insert if we have emptied the trash buffer
  4840 00002B71 7501                        jnz .forward
  4841 00002B73 C3                          ret
  4842                                  .forward:
  4843 00002B74 83EA08                      sub edx, byte 0x08
  4844 00002B77 8B4A04                      mov ecx, [edx+0x04]
  4845 00002B7A 890D[44480000]              mov [ v_words ], ecx
  4846                                  .back:
  4847                                      _DUP_
   132 00002B80 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00002B83 8906                <1>  mov [ esi ], _TOS_
  4848 00002B85 8B02                        mov _TOS_, [edx]
  4849 00002B87 83EA04                      sub edx, byte 0x04
  4850 00002B8A E2F4                        loop .back
  4851 00002B8C 83C204                      add edx, byte 0x04
  4852 00002B8F 8915[E4470000]              mov [ v_trash ], edx
  4853 00002B95 E965FDFFFF                  jmp dword insert0
  4854                                  
  4855                                  ; *****************************************************************************
  4856                                  ; Locate
  4857                                  ; *****************************************************************************
  4858                                  
  4859                                  locate:
  4860 00002B9A 8B0D[A8470000]              mov ecx, [ v_blk ]
  4861 00002BA0 870D[A0470000]              xchg ecx, [ v_locatedBlock ]
  4862 00002BA6 890D[A8470000]              mov [ v_blk ], ecx
  4863                                  
  4864 00002BAC 8B0D[AC470000]              mov ecx, [ v_curs ]
  4865 00002BB2 870D[A4470000]              xchg ecx, [ v_locatedCurs ]
  4866 00002BB8 890D[AC470000]              mov [ v_curs ], ecx
  4867                                      
  4868 00002BBE C3                          ret
  4869                                  
  4870                                  ; *****************************************************************************
  4871                                  ; Editor keypad and action table
  4872                                  ; *****************************************************************************
  4873                                  
  4874                                  editorActionTable:
  4875 00002BBF [40040000]-                 dd nul           , deleteAction    , editorExit    , destack      ;
  4875 00002BC3 [812A0000]-        
  4875 00002BC7 [212B0000]-        
  4875 00002BCB [652B0000]         
  4876 00002BCF [B32A0000]-                 dd yellowAction  , redAction       , greenAction   , shadow       ; y r g *
  4876 00002BD3 [B72A0000]-        
  4876 00002BD7 [BB2A0000]-        
  4876 00002BDB [F7280000]         
  4877 00002BDF [AC260000]-                 dd cursorLeft    , cursorUp        , cursorDown    , cursorRight  ; l u d r
  4877 00002BE3 [51280000]-        
  4877 00002BE7 [69280000]-        
  4877 00002BEB [CF260000]         
  4878 00002BEF [D4280000]-                 dd previousBlock , magentaAction   , cyanAction    , nextBlock    ; - m c +
  4878 00002BF3 [F72A0000]-        
  4878 00002BF7 [D32A0000]-        
  4878 00002BFB [C7280000]         
  4879 00002BFF [40040000]-                 dd nul           , capitalS_Action , CapitalAction , textAction   ; _ S C t
  4879 00002C03 [C72A0000]-        
  4879 00002C07 [C32A0000]-        
  4879 00002C0B [BF2A0000]         
  4880 00002C0F [40040000]-                 dd nul           , locate          , nul           , otherBlock   ; _ L _ j
  4880 00002C13 [9A2B0000]-        
  4880 00002C17 [40040000]-        
  4880 00002C1B [EA280000]         
  4881                                  ekbd0:
  4882 00002C1F [CB2A0000]-                 dd grayAction    , blueAction      , nul           , act0         ; a b _ _
  4882 00002C23 [CF2A0000]-        
  4882 00002C27 [40040000]-        
  4882 00002C2B [A92A0000]         
  4883 00002C2F 782E6900                    db 'x'           , '.'             , 'i'           , 0x00         ; four characters to display on the bottom line of the keyboard
  4884                                  
  4885                                  editorKeyTableHintChars:    ; display the current edit colour and mode in the bottom right hand corner of the keyboard
  4886 00002C33 20202020                    db '    '   ;
  4887 00002C37 79726720                    db 'yrg '   ; y r g _
  4888 00002C3B 20202020                    db '    '   ; l u d r
  4889 00002C3F 206D632B                    db ' mc+'   ; - m c +
  4890 00002C43 20534374                    db ' SCt'   ; _ S C t
  4891 00002C47 206C2020                    db ' l  '   ; _ _ _ j
  4892 00002C4B 61622020                    db 'ab  '   ; a b _ _
  4893                                  
  4894                                  ; Editor keypad display
  4895                                  ; _ S C t  y r g *
  4896                                  ; < l > j  l u d r      
  4897                                  ; a b _ k  - m c +
  4898                                  ;     x . i
  4899                                  
  4900                                  editorKeypad:			; the main editor keyboard icons
  4901 00002C4F 7972672A                    db 'yrg*'  			; yellow, red, green, shadow
  4902 00002C53 10111213                    db 0x10, 0x11, 0x12, 0x13   ; 'ludr' arrow glyphs (left, up, down, right)
  4903 00002C57 2D6D632B                    db '-mc+'			; previous block, magenta, cyan, next block                    
  4904 00002C5B 20534374                    db ' SCt'			; ALL CAPITALS, Capital start, lower case text                    
  4905 00002C5F 146C176A                    db 0x14,'l', 0x17, 'j'      ; left glyph, "locate", right glyph, j = other block
  4906 00002C63 61622020                    db 'ab  '			; grAy, blue                   
  4907                                  
  4908                                  set_e_main:
  4909 00002C67 C705[28480000]-             mov dword [ shiftAction ], ekbd0
  4909 00002C6D [1F2C0000]         
  4910 00002C71 C705[24480000]-             mov dword [ currentKeypadIcons ], ( editorKeypad - 4 )
  4910 00002C77 [4B2C0000]         
  4911 00002C7B C705[34480000]E0FF-         mov dword [ keypad_colour ], colour_yellow
  4911 00002C83 0000               
  4912 00002C85 C3                          ret
  4913                                  
  4914                                  edit0:
  4915                                      _DROP_
   148 00002C86 AD                  <1>  lodsd
  4916 00002C87 EB74                        jmp short edit2
  4917                                  
  4918                                  save_edit_state:   ; ( n -- )   \ save edit block n
  4919 00002C89 51                          push ecx
  4920 00002C8A 8B0D[A8470000]              mov ecx, [ v_blk ]
  4921 00002C90 890D[B0470000]              mov [ v_otherBlock ], ecx       ; save the current edit block to the "other" block variable
  4922 00002C96 8B0D[AC470000]              mov ecx, [ v_curs ]
  4923 00002C9C 890D[B4470000]              mov [ v_otherCursor ], ecx      ; save the current edit block cursor to the "other" cursor variable    
  4924 00002CA2 59                          pop ecx
  4925 00002CA3 A3[A8470000]                mov [ v_blk ], _TOS_            ; set the new edit block
  4926                                      _DROP_                          ; discard n
   148 00002CA8 AD                  <1>  lodsd
  4927 00002CA9 C3                          ret
  4928                                  
  4929                                  swap_with_other_:
  4930 00002CAA 51                          push ecx
  4931 00002CAB 8B0D[A8470000]              mov ecx, [ v_blk ]
  4932 00002CB1 870D[B0470000]              xchg ecx, [ v_otherBlock ]
  4933 00002CB7 890D[A8470000]              mov [ v_blk ], ecx
  4934 00002CBD 8B0D[AC470000]              mov ecx, [ v_curs ]
  4935 00002CC3 870D[B4470000]              xchg [ v_otherCursor ], ecx      ; save the current edit block cursor to the "other" cursor variable   
  4936 00002CC9 890D[AC470000]              mov [ v_curs ], ecx    
  4937 00002CCF 59                          pop ecx
  4938 00002CD0 C3                          ret
  4939                                  
  4940                                  edit_:   ; ( n -- )   \ edit block n
  4941 00002CD1 E8B3FFFFFF                  call save_edit_state
  4942                                  e_:
  4943 00002CD6 C605[17480000]FF            mov byte [ v_quitMode ], 0xFF
  4944 00002CDD E859F9FFFF                  call refresh
  4945                                  plus_e:
  4946 00002CE2 C705[40480000]-             mov dword [ anumber ], tokenAction
  4946 00002CE8 [E4290000]         
  4947 00002CEC C605[5A190000]25            mov byte [ alpha0+4*4 ], 0x25
  4948 00002CF3 C705[4E190000]-             mov dword [ alpha0 + 4 ], edit0
  4948 00002CF9 [862C0000]         
  4949                                  edit2:
  4950 00002CFD E865FFFFFF                  call set_e_main
  4951                                      .back:
  4952 00002D02 E860EFFFFF                  call clearHintChar
  4953 00002D07 E8FDEAFFFF                  call get_key_
  4954 00002D0C 50                          push _TOS_
  4955 00002D0D 8A80[332C0000]              mov al, [ editorKeyTableHintChars + _TOS_ ]
  4956 00002D13 A3[18480000]                mov [ v_hintChar ], _TOS_
  4957 00002D18 58                          pop _TOS_
  4958 00002D19 FF1485[BF2B0000]            call [ ( _TOS_ * 4 ) + editorActionTable ]
  4959                                      _DROP_
   148 00002D20 AD                  <1>  lodsd
  4960 00002D21 EBDF                        jmp short .back
  4961                                  
  4962                                  convertAddress:     ; ( a32 -- )    set up the block at the given 32 bit cell address, including the cursor position
  4963 00002D23 89C3                        mov _SCRATCH_, _TOS_
  4964 00002D25 81E3FF000000                and _SCRATCH_, 0x00FF
  4965 00002D2B 891D[AC470000]              mov [ v_curs ], _SCRATCH_           ; cell offset in block
  4966 00002D31 E853DCFFFF                  call cellAddressToBlock
  4967 00002D36 A3[A8470000]                mov [ v_blk ], _TOS_
  4968                                      _DROP_
   148 00002D3B AD                  <1>  lodsd
  4969 00002D3C C3                          ret
  4970                                  
  4971                                  editAddress_:    ; ( a32 -- )    edit the block at the given 32 bit byte address, including the cursor position
  4972 00002D3D 89C3                        mov _SCRATCH_, _TOS_
  4973 00002D3F C1EB02                      shr _SCRATCH_, 2
  4974 00002D42 81E3FF000000                and _SCRATCH_, 0x00FF
  4975 00002D48 891D[AC470000]              mov [ v_curs ], _SCRATCH_           ; cell offset in block
  4976 00002D4E 2D00000100                  sub _TOS_, RELOCATED                ; subtract the addess of block 0
  4977 00002D53 C1E80A                      shr _TOS_, 10                       ;
  4978 00002D56 E876FFFFFF                  call edit_
  4979 00002D5B C3                          ret
  4980                                  
  4981                                  keypd_:    ; display the keypad vectors and display characters at the address on top of the return stack
  4982 00002D5C 5A                          pop edx                             ; keypd_ is followed by call table then keymap
  4983 00002D5D 8915[A4260000]              mov [ vector ], edx                 ; edx points to the next colorForth word to be executed
  4984 00002D63 81C28C000000                add edx, ( 28 * 5 )                 ; 28 keys, 5 bytes per compiled call
  4985 00002D69 8915[24480000]              mov [ currentKeypadIcons ], edx
  4986 00002D6F 83EA10                      sub edx, byte +16
  4987 00002D72 8915[28480000]              mov [ shiftAction ], edx
  4988                                  .back:
  4989 00002D78 E88CEAFFFF                  call get_key_                       ; calls pause_ while waiting for a character
  4990 00002D7D 8B15[A4260000]              mov edx, [ vector ]
  4991 00002D83 01C2                        add edx, _TOS_
  4992 00002D85 8D548205                    lea edx, [ ( _TOS_ * 4 ) + edx + 0x05 ]
  4993 00002D89 0352FC                      add edx, [ edx - 0x04 ]
  4994                                      _DROP_
   148 00002D8C AD                  <1>  lodsd
  4995                                  keypd1:
  4996 00002D8D FFD2                        call edx
  4997 00002D8F EBE7                        jmp short keypd_.back
  4998                                  
  4999                                  ; *****************************************************************************
  5000                                  ; QWERTY support
  5001                                  ; *****************************************************************************
  5002                                  
  5003                                  qwertyKeyboard:
  5004 00002D91 00000000                    dd 0
  5005 00002D95 00000000                    dd 0
  5006 00002D99 00000000                    dd 0
  5007 00002D9D 170F0401                    dd 0x01040f17       ; 'qwer'
  5008 00002DA1 00000000                    dd 0
  5009 00002DA5 00000000                    dd 0
  5010                                  
  5011                                  qwertToggleBase:
  5012 00002DA9 8135[30480000]E107-         xor dword [ setCurrentBase ], ((setBase_decimal - $$) ^ (setBase_hex - $$))
  5012 00002DB1 0000               
  5013 00002DB3 8035[7E190000]2F            xor byte [ ( numb0 + 12 ) ], 0x2F
  5014                                  qwertToggleBase1:
  5015                                  ;    call [ setCurrentBase ]
  5016                                  ;    mov dword [ qwertyKeyboard ], 0x00           ; '' => decimal
  5017                                  ;    cmp dword [ base ], byte +0x10
  5018                                  ;    jnz .forward
  5019                                  ;    mov dword [ qwertyKeyboard ], 0x00150414     ; 'hex'
  5020                                  ; .forward:
  5021                                  ;    mov dword [ currentKeypadIcons ], keypd1
  5022                                  ;    mov dword [ shiftAction ], qwertyKeyboard
  5023 00002DBA C3                          ret
  5024                                  
  5025                                  qwertyAction4:
  5026 00002DBB E8E9FFFFFF                  call qwertToggleBase
  5027 00002DC0 E979000000                  jmp qwertyAction3
  5028                                  
  5029                                  qwertyActionTable:
  5030 00002DC5 [F11B0000]-                 dd endn, endn, exitn_, qwertyAction3, qwertyAction4
  5030 00002DC9 [F11B0000]-        
  5030 00002DCD [5D1C0000]-        
  5030 00002DD1 [3E2E0000]-        
  5030 00002DD5 [BB2D0000]         
  5031                                  
  5032                                  qwertFunction1:
  5033 00002DD9 E853E3FFFF                  call right
  5034 00002DDE C7                          db 0xC7
  5035 00002DDF 05[952D0000]                add _TOS_, ( qwertyKeyboard + 4 )
  5036 00002DE4 06                          push es
  5037 00002DE5 16                          push ss
  5038 00002DE6 0900                        or [_TOS_], _TOS_
  5039 00002DE8 E8CDFFFFFF                  call qwertToggleBase1
  5040 00002DED C605[911B0000]00            mov byte [ v_sign ], 0x00
  5041 00002DF4 A1[4C480000]                mov _TOS_, [ v_digin ]
  5042                                  qwertyAction5:
  5043 00002DF9 E8A8EAFFFF                  call get_qwerty_key_
  5044 00002DFE 7407                        jz .forward4
  5045 00002E00 FF2485[C52B0000]            jmp dword [ _TOS_ * 4 + qwertyActionTable - 0x200 ]
  5046                                  .forward4:
  5047 00002E07 85C0                        test _TOS_, _TOS_
  5048 00002E09 7E33                        jng qwertyAction3
  5049 00002E0B 3C23                        cmp al, 0x23
  5050 00002E0D 7427                        jz .forward3
  5051 00002E0F A1[4C480000]                mov _TOS_, [ v_digin ]
  5052 00002E14 3B05[2C480000]              cmp _TOS_, [ base ]
  5053 00002E1A 7918                        jns .forward2
  5054 00002E1C F605[911B0000]FF            test byte [ v_sign ], 0xFF
  5055 00002E23 7402                        jz .forward
  5056 00002E25 F7D8                        neg _TOS_
  5057                                  .forward:
  5058 00002E27 8B16                        mov edx, [ esi ]
  5059 00002E29 0FAF15[2C480000]            imul edx, [ base]
  5060 00002E30 01C2                        add edx, _TOS_
  5061 00002E32 8916                        mov [ esi ], edx
  5062                                  .forward2:
  5063 00002E34 EB08                        jmp short qwertyAction3
  5064                                  .forward3:
  5065 00002E36 3105[911B0000]              xor [ v_sign ], _TOS_
  5066 00002E3C F71E                        neg dword [ esi ]
  5067                                  
  5068                                  qwertyAction3:
  5069                                      _DROP_
   148 00002E3E AD                  <1>  lodsd
  5070 00002E3F EBB8                        jmp short qwertyAction5
  5071                                  
  5072                                  qwertToggleBaseTable2:
  5073 00002E41 [A7190000]-                 dd lj, lj, exit_
  5073 00002E45 [A7190000]-        
  5073 00002E49 [011A0000]         
  5074                                  
  5075                                  qwertyFunction2:
  5076 00002E4D C705[952D0000]0204-         mov dword [ ( qwertyKeyboard + 4 ) ], 0x02150402  ; 'text'
  5076 00002E55 1502               
  5077 00002E57 E8D5E2FFFF                  call right
  5078 00002E5C C705[44480000]0100-         mov dword [ v_words ], 0x01
  5078 00002E64 0000               
  5079 00002E66 C705[38480000]0100-         mov dword [ chars], 0x01
  5079 00002E6E 0000               
  5080                                      _DUP_
   132 00002E70 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00002E73 8906                <1>  mov [ esi ], _TOS_
  5081 00002E75 C70600000000                mov dword [ esi ], 0x00
  5082 00002E7B C605[9A190000]1C            mov byte [ bits_ ], 0x1C
  5083                                  .back:
  5084 00002E82 740E                        jz .forward
  5085 00002E84 3D83000000                  cmp _TOS_, 0x83
  5086 00002E89 7907                        jns .forward
  5087 00002E8B FF2485[412C0000]            jmp dword [ _TOS_*4 + qwertToggleBaseTable2 - 0x200 ]
  5088                                  .forward:
  5089 00002E92 85C0                        test _TOS_, _TOS_
  5090 00002E94 7E1C                        jng .forward2
  5091 00002E96 3D30000000                  cmp _TOS_, 0x30
  5092 00002E9B 7915                        jns .forward2
  5093                                      _DUP_
   132 00002E9D 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00002EA0 8906                <1>  mov [ esi ], _TOS_
  5094 00002EA2 E871E2FFFF                  call echo_
  5095 00002EA7 E829EBFFFF                  call pack_
  5096 00002EAC FF05[38480000]              inc dword [ chars]
  5097                                  .forward2:
  5098                                      _DROP_
   148 00002EB2 AD                  <1>  lodsd
  5099 00002EB3 E8EEE9FFFF                  call get_qwerty_key_
  5100 00002EB8 EBC8                        jmp short .back
  5101                                  
  5102                                  qwertyAction2:
  5103 00002EBA E8EAFEFFFF                  call qwertToggleBase
  5104 00002EBF E9A0EDFFFF                  jmp dword nul0
  5105                                  
  5106                                  qwertyAction1:
  5107 00002EC4 FF25[4E190000]              jmp dword [ alpha0 + 4 ]
  5108                                  
  5109                                  qwertyTable1:
  5110 00002ECA [641C0000]                  dd nul0
  5111 00002ECE [641C0000]                  dd nul0
  5112 00002ED2 [641C0000]                  dd nul0
  5113 00002ED6 [C42E0000]                  dd qwertyAction1
  5114 00002EDA [BA2E0000]                  dd qwertyAction2
  5115                                  
  5116                                  qwertyDoAction:
  5117 00002EDE C705[952D0000]0000-         mov dword [ ( qwertyKeyboard + 4 ) ], 0x00   ; clear the 'text' string
  5117 00002EE6 0000               
  5118 00002EE8 C705[28480000]-             mov dword [ shiftAction ], qwertyKeyboard
  5118 00002EEE [912D0000]         
  5119 00002EF2 C705[24480000]-             mov dword [ currentKeypadIcons ], keypd1
  5119 00002EF8 [8D2D0000]         
  5120                                  
  5121                                  .back2:
  5122 00002EFC E8A5E9FFFF                  call get_qwerty_key_
  5123 00002F01 7407                        jz .forward
  5124 00002F03 FF2485[CA2C0000]            jmp dword [ ( _TOS_ * 4 ) + qwertyTable1 - 0x0200 ]
  5125                                  
  5126                                  .forward:
  5127 00002F0A 3C30                        cmp al, 0x30
  5128 00002F0C 750D                        jnz .back
  5129 00002F0E C705[952D0000]0204-         mov dword [ ( qwertyKeyboard + 4 ) ], 0x02150402  ; 'text'
  5129 00002F16 1502               
  5130                                      _DROP_
   148 00002F18 AD                  <1>  lodsd
  5131 00002F19 EBE1                        jmp short .back2
  5132                                  .back:
  5133 00002F1B 85C0                        test _TOS_, _TOS_
  5134 00002F1D 7E30                        jng .forward3
  5135 00002F1F F705[952D0000]FFFF-         test dword [ ( qwertyKeyboard + 4 ) ], 0xFFFFFFFF
  5135 00002F27 FFFF               
  5136 00002F29 750D                        jnz .forward2
  5137 00002F2B 803D[4C480000]0A            cmp byte [ v_digin ], 0x0A
  5138 00002F32 0F88A1FEFFFF                js qwertFunction1
  5139                                  .forward2:
  5140 00002F38 3D30000000                  cmp _TOS_, 0x30
  5141 00002F3D 7910                        jns .forward3
  5142 00002F3F E809FFFFFF                  call qwertyFunction2
  5143 00002F44 FF15[3C480000]              call [ aword ]
  5144                                      _DUP_
   132 00002F4A 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00002F4D 8906                <1>  mov [ esi ], _TOS_
  5145                                  .forward3:
  5146                                      _DROP_
   148 00002F4F AD                  <1>  lodsd
  5147 00002F50 E91EEDFFFF                  jmp dword quit_
  5148                                  
  5149                                  qwert:      ; selects QWERTY keyboard entry
  5150 00002F55 C705[08480000]-             mov dword [ x_qwerty ], qwertyDoAction
  5150 00002F5B [DE2E0000]         
  5151 00002F5F C3                          ret
  5152                                  
  5153                                  ; *****************************************************************************
  5154                                  
  5155                                  abort_action:
  5156 00002F60 81FF00400000                cmp edi, ( RELOCATED / 4 )  ; if we are compiling a block, show the location of the error
  5157                                      ; edi is a cell address, so divide by 4
  5158 00002F66 7216                        jc .forward
  5159                                      _DUP_
   132 00002F68 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00002F6B 8906                <1>  mov [ esi ], _TOS_
  5160 00002F6D A1[A8470000]                mov _TOS_, [ v_blk ]
  5161 00002F72 A3[B0470000]                mov [ v_otherBlock ], _TOS_ ; save the last block to be edited
  5162 00002F77 89F8                        mov _TOS_, edi
  5163 00002F79 E8A5FDFFFF                  call convertAddress
  5164                                  .forward:
  5165 00002F7E BC00780000                  mov esp, RETURN_STACK_0
  5166 00002F83 81FE04740000                cmp esi, ( DATA_STACK_0 + 4 )
  5167 00002F89 7205                        jc .forward2
  5168 00002F8B BE04740000                  mov esi, ( DATA_STACK_0 + 4 )
  5169                                  .forward2:
  5170 00002F90 C705[1C490000]-             mov dword [ tokenActions + ( 3 * 4 ) ], forthd
  5170 00002F96 [A0060000]         
  5171 00002F9A C705[20490000]-             mov dword [ tokenActions + ( 4 * 4 ) ], qcompile
  5171 00002FA0 [FB070000]         
  5172 00002FA4 C705[24490000]-             mov dword [ tokenActions + ( 5 * 4 ) ], cnum
  5172 00002FAA [31070000]         
  5173 00002FAE C705[28490000]-             mov dword [ tokenActions + ( 6 * 4 ) ], cshort
  5173 00002FB4 [41070000]         
  5174 00002FB8 B83F000000                  mov _TOS_, 0x3F     ; '?' character to follow the display of the unknown word
  5175 00002FBD E856E1FFFF                  call echo_
  5176                                  ;    jmp abort_e2
  5177 00002FC2 E9ACECFFFF                  jmp dword quit_
  5178                                  
  5179                                  ; *****************************************************************************
  5180                                  
  5181                                  rquery: ; r?
  5182                                      _DUP_
   132 00002FC7 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00002FCA 8906                <1>  mov [ esi ], _TOS_
  5183 00002FCC B800780000                  mov _TOS_, RETURN_STACK_0
  5184 00002FD1 29E0                        sub _TOS_, esp
  5185 00002FD3 D1E8                        shr _TOS_,1
  5186 00002FD5 D1E8                        shr _TOS_,1
  5187 00002FD7 C3                          ret
  5188                                  
  5189                                  boot:
  5190                                      ; see http://wiki.osdev.org/PS2_Keyboard#CPU_Reset
  5191 00002FD8 B0FE                        mov al, 0xFE
  5192 00002FDA E664                        out 0x64, al
  5193 00002FDC EBFE                        jmp short $         ; we should never get here, because the processor will be rebooted... stop here just in case
  5194                                  
  5195                                  wipe:  ; ( -- )    \ wipe the currently edited block
  5196                                      _DUP_
   132 00002FDE 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00002FE1 8906                <1>  mov [ esi ], _TOS_
  5197 00002FE3 A1[A8470000]                mov _TOS_, [ v_blk ]
  5198 00002FE8 B940000000                  mov ecx, 0x40
  5199                                  wipe2:
  5200 00002FED 57                          push edi
  5201 00002FEE E88CD9FFFF                  call blockToCellAddress     ; add the RELOCATED block number offset and convert to cell address
  5202 00002FF3 C1E002                      shl _TOS_, 2                ; convert to byte address
  5203 00002FF6 89C7                        mov edi, _TOS_
  5204 00002FF8 31C0                        xor _TOS_, _TOS_
  5205 00002FFA F3AB                        rep stosd  ; stores  eax  into the location pointed to by  edi  then increments  edi  by 4, does this  ecx  times
  5206 00002FFC 5F                          pop edi
  5207                                      _DROP_
   148 00002FFD AD                  <1>  lodsd
  5208 00002FFE C3                          ret
  5209                                  
  5210                                  wipes:  ; ( startblock# #blocks -- )    \ wipes #blocks starting from block startblock#   ( was erase )
  5211 00002FFF 89C1                        mov ecx, _TOS_
  5212 00003001 C1E106                      shl ecx, 0x06               ;  convert blocks to cells, multiply by 64
  5213                                      _DROP_
   148 00003004 AD                  <1>  lodsd
  5214 00003005 E9E3FFFFFF                  jmp wipe2
  5215                                  
  5216                                  copy_:   ; ( blk -- )    \ copy the given block (and shadow) to the currently displayed block (and shadow)
  5217 0000300A 83F80C                      cmp _TOS_, byte 0x0C        ; below block 12 is machine code
  5218 0000300D 0F82FFD5FFFF                jc abort_
  5219 00003013 57                          push edi
  5220 00003014 56                          push esi
  5221 00003015 51                          push ecx
  5222 00003016 E864D9FFFF                  call blockToCellAddress     ; source block
  5223 0000301B C1E002                      shl _TOS_, 0x02             ; convert cell address to byte address
  5224 0000301E 89C6                        mov esi, _TOS_
  5225 00003020 A1[A8470000]                mov _TOS_, [ v_blk ]
  5226 00003025 E855D9FFFF                  call blockToCellAddress     ; destination block
  5227 0000302A C1E002                      shl _TOS_, 0x02             ; convert cell address to byte address
  5228 0000302D 89C7                        mov edi, _TOS_
  5229 0000302F B900020000                  mov ecx, 0x0200
  5230 00003034 F3A5                        rep  movsd                  ; copy ecx 32 bit words from ds:esi to es:edi
  5231 00003036 59                          pop ecx
  5232 00003037 5E                          pop esi
  5233 00003038 5F                          pop edi
  5234                                      _DROP_
   148 00003039 AD                  <1>  lodsd
  5235 0000303A C3                          ret
  5236                                  
  5237                                  debug:
  5238 0000303B C705[50490000]B502-         mov dword [ v_gr_xy ], 0x302B5
  5238 00003043 0300               
  5239                                      _DUP_
   132 00003045 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003048 8906                <1>  mov [ esi ], _TOS_
  5240 0000304A A1[73040000]                mov _TOS_, [ main ]
  5241 0000304F FF30                        push dword [_TOS_]
  5242 00003051 E808E2FFFF                  call dotHex
  5243                                      _DUP_
   132 00003056 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003059 8906                <1>  mov [ esi ], _TOS_
  5244 0000305B 58                          pop _TOS_
  5245 0000305C E8FDE1FFFF                  call dotHex
  5246                                      _DUP_
   132 00003061 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003064 8906                <1>  mov [ esi ], _TOS_
  5247 00003066 A1[7C040000]                mov _TOS_, [ draw ]
  5248 0000306B E8EEE1FFFF                  call dotHex
  5249                                      _DUP_
   132 00003070 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003073 8906                <1>  mov [ esi ], _TOS_
  5250 00003075 89F0                        mov _TOS_, esi
  5251 00003077 E9E2E1FFFF                  jmp dword dotHex
  5252                                  
  5253                                  ; *****************************************************************************
  5254                                  
  5255                                  tic0:
  5256 0000307C FF0D[44480000]              dec dword [ v_words ]
  5257 00003082 7403                        jz .forward
  5258                                      _DROP_
   148 00003084 AD                  <1>  lodsd
  5259 00003085 EBF5                        jmp short tic0
  5260                                  .forward:
  5261 00003087 C3                          ret
  5262                                  
  5263                                  tic_:   ; ( -- a )   \ return the byte address of the next word entered
  5264 00003088 E81AF9FFFF                  call _word          ; allow user to enter the word to  search for
  5265 0000308D E8EAFFFFFF                  call tic0           ; remove the entered word from the stack
  5266 00003092 E867D5FFFF                  call find_          ; find the word in the dictionary, return its index in  ecx
  5267 00003097 0F8575D5FFFF                jnz abort_
  5268 0000309D 8B048D00C04600              mov _TOS_, [ ( ecx * 4 ) + ForthJumpTable ]     ; return the word's address from the jump table
  5269 000030A4 C3                          ret
  5270                                  
  5271                                  itick:
  5272 000030A5 83E0F0                      and _TOS_, byte -0x10 ; (saves 2 bytes compared to 'and _TOS_, 0xFFFFFFF0' )
  5273 000030A8 E851D5FFFF                  call find_
  5274 000030AD 8B048D00C04600              mov _TOS_, [ ( ecx * 4 ) + ForthJumpTable ]
  5275 000030B4 C3                          ret
  5276                                  
  5277                                  ; *****************************************************************************
  5278                                  
  5279                                  plusList_words:   ; ( -- ) display the current colorForth block
  5280                                      _DUP_
   132 000030B5 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000030B8 8906                <1>  mov [ esi ], _TOS_
  5281 000030BA 31C0                        xor _TOS_, _TOS_
  5282 000030BC A3[CA1D0000]                mov [ currentState ], _TOS_
  5283 000030C1 A3[CE1D0000]                mov [ lastState ], _TOS_
  5284 000030C6 A3[AC470000]                mov [ v_curs ], _TOS_           ; set the cursor to top left (0, 0) ToDo: Note : does not work!
  5285                                      _DROP_
   148 000030CB AD                  <1>  lodsd
  5286                                  
  5287 000030CC E84EDFFFFF                  call setupText_                 ; setup the clip window for this display
  5288                                      _DUP_
   132 000030D1 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000030D4 8906                <1>  mov [ esi ], _TOS_
  5289 000030D6 A1[E0470000]                mov _TOS_, [ v_lcad ]
  5290 000030DB A3[D8470000]                mov [ v_cad ], _TOS_
  5291 000030E0 A1[A8470000]                mov _TOS_, [ v_blk ]            ; get the current block number to be edited
  5292 000030E5 E895D8FFFF                  call blockToCellAddress         ; add the RELOCATED block number offset and convert to cell address
  5293 000030EA 89C7                        mov edi, _TOS_
  5294 000030EC 31C0                        xor _TOS_, _TOS_
  5295 000030EE 033D[56250000]              add edi, [ v_lineOffset ]
  5296 000030F4 893D[DC470000]              mov [ v_pcad ], edi
  5297                                  .back:
  5298 000030FA 8B14BD00000000              mov edx, dword [ ( edi * 4 ) + 0x00 ]   ; edi is the display pointer and is a cell address
  5299 00003101 E83DECFFFF                  call show_cursor                        ; show the PacMan-like cursor
  5300 00003106 E8CDDEFFFF                  call space_
  5301 0000310B 47                          inc edi
  5302 0000310C 83E20F                      and edx, byte 0x0F
  5303                                      _DUP_
   132 0000310F 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003112 8906                <1>  mov [ esi ], _TOS_
  5304 00003114 B809000000                  mov _TOS_, 0x09
  5305                                      ; call doColourBlind
  5306 00003119 FF1495[16250000]            call [ ( edx * 4 ) + displayShannonFanoActions ]
  5307 00003120 EBD8                        jmp short .back
  5308                                  
  5309                                  refresh_words:                      ; refresh the editor display to show all Forth words
  5310 00003122 E888D3FFFF                  call show                       ; set the screen task to execute the code following :
  5311 00003127 E848DFFFFF                  call page_                      ; clear the screen
  5312                                      ; call displayBlockNumber       ; display the current block number on the screen
  5313 0000312C E884FFFFFF                  call plusList_words             ; list the contents of the block
  5314                                      _DUP_
   132 00003131 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003134 8906                <1>  mov [ esi ], _TOS_
  5315                                      ; mov _TOS_, 0x0F
  5316                                      ; call doColourBlind             ; display the final colour-blind punctuation, set up for next call of plusList
  5317 00003136 E94BE3FFFF                  jmp dword displayTheKeypad_
  5318                                  
  5319                                  words_:     ; \ show the ForthNames array as if it is a sequence of blocks 
  5320                                      _DUP_
   132 0000313B 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000313E 8906                <1>  mov [ esi ], _TOS_
  5321 00003140 B800804600                  mov _TOS_, ForthNames
  5322 00003145 E82E040000                  call a2blk_
  5323 0000314A E83AFBFFFF                  call save_edit_state
  5324 0000314F E8CEFFFFFF                  call refresh_words
  5325 00003154 C3                          ret
  5326                                  
  5327                                  ; *****************************************************************************
  5328                                  
  5329                                  ; Int 0x13 AH Return Code error type
  5330                                  ; 0x00 Success
  5331                                  ; 0x01 Invalid Command
  5332                                  ; 0x02 Cannot Find Address Mark
  5333                                  ; 0x03 Attempted Write On Write Protected Disk
  5334                                  ; 0x04 Sector Not Found
  5335                                  ; 0x05 Reset Failed
  5336                                  ; 0x06 Disk change line 'active'
  5337                                  ; 0x07 Drive parameter activity failed
  5338                                  ; 0x08 DMA overrun
  5339                                  ; 0x09 Attempt to DMA over 64kb boundary
  5340                                  ; 0x0A Bad sector detected
  5341                                  ; 0x0B Bad cylinder (track) detected
  5342                                  ; 0x0C Media type not found
  5343                                  ; 0x0D Invalid number of sectors
  5344                                  ; 0x0E Control data address mark detected
  5345                                  ; 0x0F DMA out of range
  5346                                  ; 0x10 CRC/ECC data error
  5347                                  ; 0x11 ECC corrected data error
  5348                                  ; 0x20 Controller failure
  5349                                  ; 0x40 Seek failure
  5350                                  ; 0x80 Drive timed out, assumed not ready
  5351                                  ; 0xAA Drive not ready
  5352                                  ; 0xBB Undefined error
  5353                                  ; 0xCC Write fault
  5354                                  ; 0xE0 Status error
  5355                                  ; 0xFF Sense operation failed
  5356                                  
  5357                                  ; *****************************************************************************
  5358                                  ; 16 bit BIOS disk read/write from 32 bit
  5359                                  ; *****************************************************************************
  5360                                  
  5361                                  ; set the required parameters into the DAP buffer for the LBA BIOS extended read/write calls.
  5362                                  ; Also set up the extra DAP buffer values for use by the CHS BIOS calls, if the LBA call fails.
  5363                                  ; This is to avoid returning from 16 bit mode to calculate the values.
  5364                                  setupDAP_:   ; ( sector n cmd -- )   \ setup the DAP for the given LBA sector number
  5365                                  
  5366 00003155 57                          push edi
  5367                                  
  5368 00003156 31C9                        xor ecx, ecx
  5369 00003158 BF687C0000                  mov edi, (data_area - $$ + BOOTOFFSET)   ; setup the data index pointer
  5370 0000315D 66678B8D0400                mov cx, [ word di + ( driveinfo_Drive_DX - data_area ) ]  ; restore the boot drive into dl
  5371 00003163 BFE0170000                  mov edi, DAP_BUFFER
  5372 00003168 66894F12                    mov word [ edi + o_Int13_DAP_saved_DX ], cx     ; setup DX value returned by the BIOS
  5373                                  
  5374 0000316C 66894710                    mov word [ edi + o_Int13_DAP_readwrite ], ax    ; set the read/write cmd value, 0x0000 or 0x0001
  5375                                      _DROP_
   148 00003170 AD                  <1>  lodsd
  5376                                  
  5377                                      ; limit the number of sectors to the size of the SECTOR_BUFFER
  5378 00003171 3D24000000                  cmp _TOS_, ( SECTOR_BUFFER_SIZE / 0x0200 )
  5379 00003176 7805                        js .forward
  5380 00003178 B824000000                      mov _TOS_, ( SECTOR_BUFFER_SIZE / 0x0200 )
  5381                                      .forward:
  5382 0000317D 66894702                    mov word [ edi + o_Int13_DAP_num_sectors ], ax
  5383                                      _DROP_
   148 00003181 AD                  <1>  lodsd
  5384                                  
  5385 00003182 894708                      mov dword [ edi + o_Int13_DAP_LBA_64_lo ], eax
  5386 00003185 50                          push eax    ; save for later
  5387                                  
  5388 00003186 31C0                        xor eax, eax
  5389 00003188 89470C                      mov dword [ edi + o_Int13_DAP_LBA_64_hi ], eax
  5390                                  
  5391                                      ; buffer within low 16 bits of address space
  5392 0000318B 66894706                    mov word [ edi + o_Int13_DAP_segment ], ax
  5393 0000318F 66B80020                    mov ax, ( SECTOR_BUFFER )
  5394 00003193 66894704                    mov word [ edi + o_Int13_DAP_address ], ax
  5395                                  
  5396                                      ; set the configuration buffer values from the registers
  5397 00003197 B810000000                  mov eax, 0x0010
  5398 0000319C 668907                      mov word [ edi + o_Int13_DAP_size ], ax  ; setup DAP buffer size
  5399                                  
  5400                                  ; setup values for CHS BIOS disk calls
  5401                                  
  5402 0000319F 58                          pop eax                         ; restore the start sector number
  5403 000031A0 0305687C0000                add eax, [ bootsector - $$ + BOOTOFFSET]    ; add the bootsector from the drive parameter table
  5404                                  
  5405 000031A6 50                          push eax                        ; save it while we calculate heads*sectors-per-track
  5406 000031A7 A0717C0000                  mov al, [ driveinfo_Head - $$ + BOOTOFFSET]      ; index of highest-numbered head
  5407 000031AC FEC0                        inc al                          ; 1-base the number to make count of heads
  5408 000031AE F625727C0000                mul byte [ driveinfo_SectorsPertrack - $$ + BOOTOFFSET]     ; sectors per track
  5409 000031B4 89C3                        mov ebx, eax
  5410 000031B6 58                          pop eax
  5411 000031B7 31D2                        xor edx, edx                    ; clear high 32 bits
  5412 000031B9 F7F3                        div ebx                         ; leaves cylinder number in eax, remainder in edx
  5413 000031BB 89C1                        mov ecx, eax                    ; store cylinder number in another register
  5414 000031BD 89D0                        mov eax, edx                    ; get remainder into AX
  5415 000031BF 8A1D727C0000                mov bl, [ driveinfo_SectorsPertrack - $$ + BOOTOFFSET]      ; number of sectors per track
  5416 000031C5 F6F3                        div bl                          ; head number into AX, remainder into DX
  5417 000031C7 88C3                        mov bl, al                      ; result must be one byte, so store it in BL
  5418 000031C9 C1C108                      rol ecx, 8                      ; high 2 bits of cylinder number into high 2 bits of CL
  5419 000031CC C0E106                      shl cl, 6                       ; makes room for sector number
  5420 000031CF 08E1                        or cl, ah                       ; merge cylinder number with sector number
  5421 000031D1 FEC1                        inc cl                          ; one-base sector number
  5422 000031D3 66894F18                    mov word [ edi + o_Int13_DAP_saved_CHS_CX ], cx  ; also save the calculated CX value
  5423 000031D7 668B0D6C7C0000              mov cx, [ driveinfo_Drive_DX - $$ + BOOTOFFSET]    ; drive number in low 8 bits
  5424 000031DE 88DD                        mov ch, bl                      ; place head number in high bits
  5425 000031E0 66894F1A                    mov word [ edi + o_Int13_DAP_saved_CHS_DX ], cx  ; also save the calculated DX value
  5426                                  
  5427 000031E4 5F                          pop edi
  5428                                      _DROP_
   148 000031E5 AD                  <1>  lodsd
  5429                                  
  5430 000031E6 C3                          ret
  5431                                  
  5432                                  ; *****************************************************************************
  5433                                  ; BIOS read/write 512 byte LBA sectors
  5434                                  ; *****************************************************************************
  5435                                  
  5436                                  BIOS_ReadWrite_Sector_LBA: ; ( -- )   \ try to read or write using the extended disk BIOS calls,
  5437                                  ; \ if that fails, try the CHS BIOS call. Parameters are in the DAP buffer.
  5438                                  
  5439 000031E7 9C                         pushf   ; save the processor flags, especially interrupt enable
  5440                                  
  5441                                  %ifdef NOT_BOCHS
  5442                                      call restore_BIOS_idt_and_pic   ;
  5443                                  %endif
  5444                                  
  5445                                      _DUP_
   132 000031E8 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000031EB 8906                <1>  mov [ esi ], _TOS_
  5446 000031ED 31C0                        xor _TOS_, _TOS_
  5447 000031EF E8B7070000                  call lidt_                      ; Load the BIOS Interrupt Descriptor Table
  5448                                  
  5449 000031F4 E81DD1FFFF                  call setRealModeAPI
  5450                                  [BITS 16]                           ; Real Mode code (16 bit)
  5451 000031F9 BEE017                      mov si, DAP_BUFFER
  5452 000031FC 8A6410                      mov byte ah, [ si + o_Int13_DAP_readwrite ]  ; 0x00 for read, 0x01 for write
  5453 000031FF 80CC42                      or  ah, 0x42                    ; BIOS extended read/write
  5454 00003202 B000                        mov al, 0x00
  5455 00003204 8B5412                      mov dx, [ si + o_Int13_DAP_saved_DX ]
  5456 00003207 CD13                        int 0x13
  5457 00003209 FA                          cli                             ; BIOS might have left interrupts enabled
  5458                                  
  5459 0000320A 894414                      mov word [ si + o_Int13_DAP_returned_AX ], ax  ; save the value in AX that the BIOS call returned
  5460 0000320D 7326                        jnc .forward
  5461 0000320F BEE017                          mov si, DAP_BUFFER
  5462                                  
  5463 00003212 8A6410                          mov byte ah, [ si + o_Int13_DAP_readwrite ]  ; 0x00 for read, 0x01 for write
  5464 00003215 80CC02                          or  ah, 0x02                ; CHS BIOS mode, read  al  sectors, set above
  5465 00003218 8A4402                          mov al, byte [ si + o_Int13_DAP_num_sectors ]   ; restore the number of sectors saved by setupDAP_
  5466                                  
  5467 0000321B 8B4C18                          mov word cx, [ si + o_Int13_DAP_saved_CHS_CX ]  ; restore the CX value calculated by sector_chs
  5468 0000321E 8B541A                          mov word dx, [ si + o_Int13_DAP_saved_CHS_DX ]  ; restore the DX value calculated by sector_chs
  5469 00003221 8B5C04                          mov word bx, [ si + o_Int13_DAP_address ]       ; restore the address saved by setupDAP_
  5470 00003224 CD13                            int 0x13
  5471 00003226 FA                              cli                         ; BIOS might have left interrupts enabled
  5472                                  
  5473 00003227 BEE017                          mov si, DAP_BUFFER
  5474 0000322A 894414                          mov word [ si + o_Int13_DAP_returned_AX ], ax  ; the BIOS call returned AX
  5475 0000322D B80100                          mov ax, 0x0001
  5476 00003230 7206                            jc .forward2
  5477 00003232 B80000                             mov ax, 0x0000
  5478                                          .forward:
  5479 00003235 894416                          mov [ si + o_Int13_DAP_returned_carry_flag ], ax  ; the BIOS call returned carry flag
  5480                                      .forward2:
  5481 00003238 894416                      mov [ si + o_Int13_DAP_returned_carry_flag ], ax  ; the BIOS call returned carry flag
  5482                                  
  5483 0000323B E8AFD0                      call setProtectedModeAPI        ; called from 16 bit code, returns to 32 bit code
  5484                                  [BITS 32]                           ; Protected Mode code (32 bit)
  5485                                  
  5486                                  %ifdef NOT_BOCHS
  5487                                      call restore_new_idt_and_pic
  5488                                  %endif
  5489                                  
  5490                                      _DUP_
   132 0000323E 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003241 8906                <1>  mov [ esi ], _TOS_
  5491 00003243 B8001C0000                  mov _TOS_, INTERRUPT_VECTORS
  5492 00003248 E85E070000                  call lidt_                      ; Load the new Interrupt Descriptor Table
  5493                                  
  5494 0000324D 9D                          popf   ; restore the processor flags, especially interrupt enable
  5495                                  
  5496 0000324E C3                          ret
  5497                                  
  5498                                  Read_Sector_LBA:    ; ( sector n -- )   "rlba"   GetFlag returns 0 for success
  5499                                      _DUP_
   132 0000324F 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003252 8906                <1>  mov [ esi ], _TOS_
  5500 00003254 B800000000                  mov eax, 0x0000                 ; read command
  5501 00003259 E8F7FEFFFF                  call setupDAP_                  ; setup up the DAP table using 3 items from the stack ( start n cmd -- )
  5502 0000325E FA                          cli                             ; disable interrupts
  5503 0000325F 60                          pushad                          ; Pushes all general purpose registers onto the stack
  5504 00003260 E882FFFFFF                  call BIOS_ReadWrite_Sector_LBA
  5505 00003265 61                          popad                           ; restore the registers pushed by  pushad
  5506 00003266 C3                          ret
  5507                                  
  5508                                  Write_Sector_LBA:   ; ( sector n -- )   "wlba"
  5509                                      _DUP_
   132 00003267 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000326A 8906                <1>  mov [ esi ], _TOS_
  5510 0000326C B801000000                  mov eax, 0x0001                 ; write command
  5511 00003271 E8DFFEFFFF                  call setupDAP_                  ; setup up the DAP table using 3 items from the stack ( start n cmd -- )
  5512 00003276 FA                          cli                             ; disable interrupts
  5513 00003277 60                          pushad                          ; Pushes all general purpose registers onto the stack
  5514 00003278 E86AFFFFFF                  call BIOS_ReadWrite_Sector_LBA
  5515 0000327D 61                          popad                           ; restore the registers pushed by  pushad
  5516 0000327E C3                          ret
  5517                                  
  5518                                  ReadSectors:    ; ( a sector n -- a' )  \ read  n  sectors from  sector  into address  a
  5519 0000327F E8CBFFFFFF                  call Read_Sector_LBA            ; reads  n  sectors starting from  sector  into the SECTOR_BUFFER
  5520                                  
  5521 00003284 56                          push esi                        ; esi is changed by rep movsw
  5522                                  
  5523 00003285 BEE0170000                  mov esi, DAP_BUFFER
  5524 0000328A 31C9                        xor ecx, ecx
  5525 0000328C 66678B4C02                  mov word cx, [ si + o_Int13_DAP_num_sectors ]   ; restore the number of sectors saved by setupDAP_
  5526 00003291 89CB                        mov ebx, ecx                    ; save number of sectors for later
  5527 00003293 BE00200000                  mov esi, SECTOR_BUFFER          ; source address
  5528 00003298 89C7                        mov edi, eax                    ; destination address
  5529 0000329A C1E107                      shl ecx, 0x07                   ; 512 bytes in cells = 2 ** 7
  5530 0000329D F3A5                        rep movsd                       ; does not change AX , it moves DS:SI to ES:DI and increments SI and DI
  5531                                  
  5532                                      ; ( a -- a' )
  5533 0000329F 89D9                        mov ecx, ebx
  5534 000032A1 C1E109                      shl ecx, 0x09                   ; 512 bytes in bytes = 2 ** 9
  5535 000032A4 01C8                        add eax, ecx                    ; increment the address that is TOS
  5536                                  
  5537 000032A6 5E                          pop esi
  5538                                      ; ( a -- a' sector' )
  5539                                      _DUP_
   132 000032A7 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000032AA 8906                <1>  mov [ esi ], _TOS_
  5540 000032AC 56                          push esi
  5541 000032AD BEE0170000                  mov esi, DAP_BUFFER             ; esi is changed by rep movsd above
  5542 000032B2 31C9                        xor ecx, ecx
  5543 000032B4 66678B4C08                  mov word cx, [ si + o_Int13_DAP_LBA_64_lo ]   ; restore the start sector
  5544 000032B9 5E                          pop esi
  5545 000032BA 89C8                        mov eax, ecx
  5546 000032BC 01D8                        add eax, ebx
  5547                                  
  5548                                  ;    call GetFlag
  5549 000032BE C3                          ret
  5550                                  
  5551                                  WriteSectors:    ; ( a sector n -- a' ) \ write  n  sectors starting at  sector  from address  a
  5552                                  
  5553 000032BF 51                          push ecx
  5554 000032C0 52                          push edx
  5555                                  
  5556 000032C1 8B5604                      mov edx, [ esi + 4 ]            ; save  a  from stack in  edx
  5557                                  
  5558 000032C4 56                          push esi                        ; esi is also changed by rep movsw
  5559 000032C5 BEE0170000                  mov esi, DAP_BUFFER
  5560 000032CA 31C9                        xor ecx, ecx
  5561 000032CC 66678B4C02                  mov word cx, [ si + o_Int13_DAP_num_sectors ]   ; restore the number of sectors saved by setupDAP_
  5562 000032D1 89CB                        mov ebx, ecx                    ; save number of sectors for later
  5563                                  
  5564 000032D3 C1E107                      shl ecx, 0x07                   ; 512 bytes in cells = 2 ** 7
  5565                                  
  5566 000032D6 89D6                        mov esi, edx                    ; source address
  5567 000032D8 BF00200000                  mov edi, SECTOR_BUFFER          ; destination address
  5568 000032DD F3A5                        rep movsd                       ; does not change AX , it moves DS:SI to ES:DI and increments SI and DI
  5569                                  
  5570 000032DF 5E                          pop esi
  5571                                  
  5572 000032E0 53                          push ebx
  5573 000032E1 E881FFFFFF                  call Write_Sector_LBA    ; writes  n  sectors starting from  sector  from the SECTOR_BUFFER
  5574 000032E6 5B                          pop ebx
  5575                                  ;    push esi                        ; esi is also changed by rep movsw
  5576                                  
  5577                                      ; ( a -- a' )
  5578 000032E7 89D9                        mov ecx, ebx
  5579 000032E9 C1E109                      shl ecx, 0x09                   ; 512 bytes in bytes = 2 ** 9
  5580 000032EC 01C8                        add eax, ecx                    ; increment the address that is TOS
  5581                                  
  5582                                  ;    pop esi
  5583                                      ; ( a -- a' sector' )
  5584                                      _DUP_
   132 000032EE 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000032F1 8906                <1>  mov [ esi ], _TOS_
  5585 000032F3 56                          push esi
  5586 000032F4 BEE0170000                  mov esi, DAP_BUFFER             ; esi is changed by rep movsd above
  5587 000032F9 31C9                        xor ecx, ecx
  5588 000032FB 66678B4C08                  mov word cx, [ si + o_Int13_DAP_LBA_64_lo ]   ; restore the start sector
  5589 00003300 5E                          pop esi
  5590 00003301 89C8                        mov eax, ecx
  5591 00003303 01D8                        add eax, ebx
  5592                                  
  5593 00003305 5A                          pop edx
  5594 00003306 59                          pop ecx
  5595                                  
  5596 00003307 C3                          ret
  5597                                  
  5598                                  SaveAll_:    ; ( -- ) "sss"
  5599 00003308 9C                          pushf   ; save the processor flags, especially interrupt enable
  5600 00003309 FA                          cli
  5601                                  
  5602                                      _DUP_
   132 0000330A 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000330D 8906                <1>  mov [ esi ], _TOS_
  5603 0000330F 31C0                        xor eax, eax
  5604 00003311 E859020000                  call block_
  5605                                      _DUP_
   132 00003316 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003319 8906                <1>  mov [ esi ], _TOS_
  5606 0000331B 31C0                        xor eax, eax
  5607 0000331D B921000000                  mov ecx, 0x21   ; 32 x 16 Kbytes= 512 + 32 Kbytes
  5608                                      .back:
  5609                                      _DUP_
   132 00003322 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003325 8906                <1>  mov [ esi ], _TOS_
  5610 00003327 B820000000                  mov eax, 0x20   ; 32 x 512 byte sectors = 16 Kbytes
  5611 0000332C E88EFFFFFF                  call WriteSectors   ; ( a sector n -- a' ) \ write  n  sectors starting at  sector  from address  a
  5612 00003331 E2EF                        loop .back
  5613                                      _DROP_
   148 00003333 AD                  <1>  lodsd
  5614                                      _DROP_
   148 00003334 AD                  <1>  lodsd
  5615                                  
  5616                                  ;    ; repeat the first group of sectors, to flush the save
  5617                                  ;    _DUP_
  5618                                  ;    xor eax, eax
  5619                                  ;    call block_
  5620                                  ;    _DUP_
  5621                                  ;    xor eax, eax
  5622                                  ;    mov ecx, 0x01   ; 1 x 16 Kbytes= 162 Kbytes
  5623                                  ;    .back2:
  5624                                  ;    _DUP_
  5625                                  ;    mov eax, 0x20   ; 32 x 512 byte sectors = 16 Kbytes
  5626                                  ;    call WriteSectors   ; ( a sector n -- a' ) \ write  n  sectors starting at  sector  from address  a
  5627                                  ;    loop .back2
  5628                                  ;    _DROP_
  5629                                  ;    _DROP_
  5630                                  
  5631                                  ;    ; repeat the last sector, to flush the save
  5632                                  ;    _DUP_
  5633                                  ;    ; address
  5634                                  ;    mov eax, LAST_BLOCK_NUMBER
  5635                                  ;    call block_
  5636                                  ;    _DUP_
  5637                                  ;    ; sector number
  5638                                  ;    mov eax, ( LAST_BLOCK_NUMBER * 2 )  ; 01 x 512 byte sectors = 512 bytes, just write one sector
  5639                                  ;    _DUP_
  5640                                  ;    ; number of 512 byte sectors to write
  5641                                  ;    mov eax, 0x01   ; 01 x 512 byte sectors = 512 bytes, just write one sector
  5642                                  ;    call WriteSectors   ; ( a sector n -- a' ) \ write  n  sectors starting at  sector  from address  a
  5643                                  ;    _DROP_
  5644                                  ;    _DROP_
  5645                                  
  5646 00003335 9D                          popf   ; restore the processor flags, especially interrupt enable
  5647 00003336 C3                      ret
  5648                                  
  5649                                  GetFlag: ; ( -- error | 0 )   0 for success, else the error type ( eax == 0x100 is Invalid Command )
  5650                                      _DUP_
   132 00003337 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000333A 8906                <1>  mov [ esi ], _TOS_
  5651 0000333C 31C0                        xor eax, eax
  5652 0000333E 57                          push edi
  5653 0000333F BFE0170000                  mov edi, DAP_BUFFER
  5654 00003344 668B4716                    mov ax, [ edi + o_Int13_DAP_returned_carry_flag ]  ; the BIOS call returned carry flag
  5655 00003348 66050000                    add ax, 0
  5656 0000334C 7404                        jz .forward
  5657 0000334E 668B4714                        mov ax, [ edi + o_Int13_DAP_returned_AX ]  ; the BIOS call returned error value in ax
  5658                                      .forward:
  5659 00003352 5F                          pop edi
  5660 00003353 C3                          ret
  5661                                  
  5662                                  %if 0
  5663                                  BIOS_Read_Sector_CHS:
  5664                                      call setRealModeAPI
  5665                                  [BITS 16]                           ; Real Mode code (16 bit)
  5666                                      mov si, DAP_BUFFER
  5667                                      mov al, byte [ si + o_Int13_DAP_num_sectors ]   ; setup the number of sectors saved by setupDAP_
  5668                                  ;    and al, 0x0F        ; limit to 16 sectors
  5669                                      mov ah, 0x02        ; CHT BIOS mode, read  al  sectors, set above
  5670                                      mov word cx, [ si + o_Int13_DAP_saved_CHS_CX ]  ; setup the CX value calculated by sector_chs
  5671                                      mov word dx, [ si + o_Int13_DAP_saved_CHS_DX ]  ; setup the DX value calculated by sector_chs
  5672                                      mov word bx, [ si + o_Int13_DAP_address ]       ; setup the address saved by setupDAP_
  5673                                      int 0x13
  5674                                      cli                             ; BIOS might have left interrupts enabled
  5675                                  
  5676                                      mov si, DAP_BUFFER
  5677                                      mov word [ si + o_Int13_DAP_returned_AX ], ax  ; the BIOS call returned AX
  5678                                      mov ax, 0x0001
  5679                                      jc .forward
  5680                                         mov ax, 0x0000
  5681                                      .forward:
  5682                                      mov [ si + o_Int13_DAP_returned_carry_flag ], ax  ; the BIOS call returned carry flag
  5683                                  
  5684                                      call setProtectedModeAPI        ; called from 16 bit code, returns to 32 bit code
  5685                                  [BITS 32]                           ; Protected Mode code (32 bit)
  5686                                      ret
  5687                                  
  5688                                  ; rchs:
  5689                                  Read_Sector_CHS:    ; ( sector n -- f )   "rchs"  returns 0 for success
  5690                                      call setupDAP_              ; ( start n -- ) store the sector number into the Disk Address Packet
  5691                                      cli                         ; disable interrupts
  5692                                      pushad                      ; Pushes all general purpose registers onto the stack
  5693                                      call BIOS_Read_Sector_CHS
  5694                                      popad                       ; restore the registers pushed by  pushad
  5695                                  ;    _DROP_
  5696                                      jmp GetFlag
  5697                                  
  5698                                  ; wcht:
  5699                                  Write_Sector_CHS:   ; ( sector -- )   "wcht"
  5700                                      call setupDAP_              ; store the sector number into the Disk Address Packet
  5701                                      cli                         ; disable interrupts
  5702                                      pushad                      ; Pushes all general purpose registers onto the stack
  5703                                      call BIOS_Read_Sector_CHS
  5704                                      popad                       ; restore the registers pushed by  pushad
  5705                                      ret
  5706                                  
  5707                                  %endif
  5708                                  
  5709                                  ; *****************************************************************************
  5710                                  ; *****************************************************************************
  5711                                  
  5712                                  %if 0
  5713                                  [BITS 16]                           ; Real Mode code (16 bit)
  5714                                  storeBefore:    ; ( -- )   \ store registers to the V_REGS array
  5715                                      mov word [ V_REGS + 0x00 ], ax
  5716                                      mov word [ V_REGS + 0x04 ], bx
  5717                                      mov word [ V_REGS + 0x08 ], cx
  5718                                      mov word [ V_REGS + 0x0C ], dx
  5719                                      mov word [ V_REGS + 0x10 ], si
  5720                                      mov word [ V_REGS + 0x14 ], di
  5721                                      mov word [ V_REGS + 0x18 ], bp
  5722                                      push ax                         ; save eax
  5723                                      pushfd                          ; push the 32 bit eflags register onto the stack
  5724                                      pop ax                          ; and pop it off into eax
  5725                                      mov word [ V_REGS + 0x1C ], ax  ; eflags
  5726                                      pop ax
  5727                                      mov word [ V_REGS + 0x1E ], ax  ; eflags top 16 bits
  5728                                      pop ax                          ; restore eax
  5729                                      ret
  5730                                  
  5731                                  storeAfter:     ; ( -- )   \ store registers to the V_REGS array
  5732                                      mov word [ V_REGS + 0x20 ], ax
  5733                                      mov word [ V_REGS + 0x24 ], bx
  5734                                      mov word [ V_REGS + 0x28 ], cx
  5735                                      mov word [ V_REGS + 0x2C ], dx
  5736                                      mov word [ V_REGS + 0x30 ], si
  5737                                      mov word [ V_REGS + 0x34 ], di
  5738                                      mov word [ V_REGS + 0x38 ], bp
  5739                                      push ax                         ; save eax
  5740                                      pushfd                          ; push the 32 bit eflags register onto the stack
  5741                                      pop ax                          ; and pop it off into eax
  5742                                      mov word [ V_REGS + 0x3C ], ax  ; eflags
  5743                                      pop ax
  5744                                      mov word [ V_REGS + 0x3E ], ax  ; eflags top 16 bits
  5745                                      pop ax                          ; restore eax
  5746                                      ret
  5747                                  [BITS 32]                           ; Protected Mode code (32 bit)
  5748                                  
  5749                                  BIOS_thunk:     ; ( -- )   \ call the BIOS - registers will have previously been setup
  5750                                      call setRealModeAPI
  5751                                  [BITS 16]                           ; Real Mode code (16 bit)
  5752                                      push ax
  5753                                      push es                         ; this operation messes with ES
  5754                                      push di                         ; and DI
  5755                                      call storeBefore
  5756                                      int 0x13
  5757                                      jc $                            ; stop here on error
  5758                                      call storeAfter
  5759                                      pop di
  5760                                      pop es
  5761                                      pop ax
  5762                                      cli                             ; BIOS might have left interrupts enabled
  5763                                      call setProtectedModeAPI        ; called from 16 bit code, returns to 32 bit code
  5764                                  [BITS 32]                           ; Protected Mode code (32 bit)
  5765                                      ret
  5766                                  
  5767                                  %endif
  5768                                  
  5769                                  %if 0
  5770                                  th_:        ; ( ax bx cx dx si di es -- w )   \ th ( thunk to BIOS Int 0x13 )
  5771                                              ; eax = 0x DH DL AH AL , returns in same order
  5772                                      cli                             ; disable interrupts
  5773                                      pushad  ; Pushes all general purpose registers onto the stack in the following order:
  5774                                              ; EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI. The value of ESP is the value before the actual push of ESP
  5775                                              ;  7    6    5    4    3    2    1    0   offset in cells from ESP
  5776                                  
  5777                                  ;    call setupDAP_
  5778                                  
  5779                                      push edi
  5780                                      mov di, (data_area - $$ + BOOTOFFSET)   ; setup the data index pointer
  5781                                      mov dx, [ byte di + ( driveinfo_Drive_DX - data_area) ]  ; restore the boot drive from dx (and head? )
  5782                                  ;    mov dl, 0x80
  5783                                      mov ebx, SECTOR_BUFFER
  5784                                      mov eax, ( 0x0200 + ( ( SECTOR_BUFFER_SIZE / 512 ) & 0xFF ) ) ; read n sectors to fill the buffer
  5785                                      mov ecx, 0x0201                  ; cylinder | sector
  5786                                  
  5787                                      call BIOS_thunk
  5788                                  
  5789                                      pop edi
  5790                                      popad   ; restore the stack values pushed by  pushad
  5791                                      ret
  5792                                  %endif
  5793                                  %if 0
  5794                                  XXXrsect_:     ; ( sector -- ax )       pushad  ; Pushes all general purpose registers onto the stack
  5796                                      push edi
  5797                                  
  5798                                  ;    call sector_chs                 ; store th sector number into the Disk Address Packet
  5799                                  
  5800                                      mov di, (data_area - $$ + BOOTOFFSET)   ; setup the data index pointer
  5801                                      mov dx, [ byte di + ( driveinfo_Drive_DX - data_area) ]  ; restore the boot drive from dx (and head? )
  5802                                  ;    mov dl, 0x80
  5803                                  
  5804                                      cli                             ; disable interrupts
  5805                                  ;    mov esi, DAP_BUFFER
  5806                                  ;    _DUP_
  5807                                      mov eax, 0x0201     ; BIOS read, one sector
  5808                                      mov bx, SECTOR_BUFFER
  5809                                      call BIOS_thunk
  5810                                  
  5811                                      pop edi
  5812                                      popad   ; restore the stack values pushed by  pushad
  5813                                      ret
  5814                                  %endif
  5815                                  
  5816                                  ; *****************************************************************************
  5817                                  ; *****************************************************************************
  5818                                  
  5819                                  %define FORTH_INITIAL_WORD_COUNT  ( ( ForthJumpTableROM_end - ForthJumpTableROM ) / 4 )     ; in cells
  5820                                  %define MACRO_INITIAL_WORD_COUNT  ( ( MacroJumpTableROM_end - MacroJumpTableROM ) / 4 )     ; in cells
  5821                                  %define BLUE_INITIAL_WORD_COUNT   ( ( BlueJumpTableROM_end  - BlueJumpTableROM )  / 4 )     ; in cells
  5822                                  
  5823                                  warm:   ; warm start
  5824 00003354 BB00680000                  mov _SCRATCH_, STACK_MEMORY_START ; start of stack memory area
  5825 00003359 B900040000                  mov ecx, ( TOTAL_STACK_SIZE >> 2 )  ; number of 32 bit cells to fill with the pattern
  5826                                  .back:
  5827 0000335E C70355555555                mov dword [ _SCRATCH_ ], 0x55555555             ; fill with this pattern
  5828 00003364 81C304000000                add _SCRATCH_, 0x04
  5829 0000336A E2F2                        loop .back
  5830                                  
  5831 0000336C 31C9                        xor ecx, ecx                    ; assumed by initshow to have been previously zeroed
  5832                                  ;    call initshow                  ; sets up do-nothing "show" task
  5833 0000336E E8C8F2FFFF                  call refresh                    ; starts the editor display task
  5834 00003373 E8C1D1FFFF                  call initserv1_                 ; sets up do-nothing "serv1" task
  5835 00003378 E8F8D1FFFF                  call initserv2_                 ; sets up do-nothing "serv2" task ToDo: fix the serv2 task...
  5836                                  
  5837 0000337D C705[A8480000]D300-         mov dword [ v_ForthWordCount ], FORTH_INITIAL_WORD_COUNT ; initial #words
  5837 00003385 0000               
  5838 00003387 C705[AC480000]0600-         mov dword [ v_MacroWordCount ], MACRO_INITIAL_WORD_COUNT ; initial #macros
  5838 0000338F 0000               
  5839 00003391 C705[B0480000]1000-         mov dword [ v_BlueWordCount ],  BLUE_INITIAL_WORD_COUNT  ; initial #blues
  5839 00003399 0000               
  5840                                  
  5841 0000339B C705[E4470000]00F0-         mov dword [ v_trash ], TRASH_BUFFER
  5841 000033A3 0800               
  5842                                      
  5843 000033A5 56                          push esi
  5844                                  
  5845                                  ;Forth wordlist
  5846 000033A6 8D35[A0490000]              lea esi, [ ForthNamesROM ]
  5847 000033AC BF00804600                  mov edi, ForthNames
  5848 000033B1 8B0D[A8480000]              mov ecx, [ v_ForthWordCount ]
  5849 000033B7 F3A5                        rep  movsd                  ; copy ecx 32 bit words from ds:esi to es:edi
  5850 000033B9 8D35[F04C0000]              lea esi, [ ForthJumpTableROM ]
  5851 000033BF BF00C04600                  mov edi, ForthJumpTable
  5852 000033C4 8B0D[A8480000]              mov ecx, [ v_ForthWordCount ]
  5853 000033CA F3A5                        rep  movsd                  ; copy ecx 32 bit words from ds:esi to es:edi
  5854                                  ; Macro wordlist
  5855 000033CC 8D35[70490000]              lea esi, [ MacroNamesROM ]
  5856 000033D2 BF00E04600                  mov edi, MacroNames
  5857 000033D7 8B0D[AC480000]              mov ecx, [ v_MacroWordCount ]
  5858 000033DD F3A5                        rep  movsd                  ; copy ecx 32 bit words from ds:esi to es:edi
  5859 000033DF 8D35[88490000]              lea esi, [ MacroJumpTableROM ]
  5860 000033E5 BF00004700                  mov edi, MacroJumpTable
  5861 000033EA 8B0D[AC480000]              mov ecx, [ v_MacroWordCount ]
  5862 000033F0 F3A5                        rep  movsd                  ; copy ecx 32 bit words from ds:esi to es:edi
  5863                                  
  5864 000033F2 5E                          pop esi
  5865                                  
  5866 000033F3 C705[74480000]0000-         mov dword [ v_H ], H0
  5866 000033FB 4800               
  5867 000033FD C705[08480000]0000-         mov dword [ x_qwerty ], 0x00        ; select non-qwerty mode
  5867 00003405 0000               
  5868 00003407 C705[E8470000]4000-         mov dword [ v_offset ], ( RELOCATED >> ( 2 + 8 ) ) ; 0x10000 >> 2 >> 8, offset of RELOCATED block 0 as 1024 byte block number
  5868 0000340F 0000               
  5869                                  
  5870                                  ; Historical note. This bug took about 15 hours to find and fix...
  5871                                  ; Below is code to track down a bug : Block 64 offset 0x7C contained 0x800
  5872                                  ; The code with the two test functions was re-compiled using the cf2022Ref.img file
  5873                                  ; Then block 64 was manually fixed ": rtc 94 ld ;"
  5874                                  ; The source blocks were saved with "sa"
  5875                                  ; cf2022 was restarted without recompilation
  5876                                  ; Looking at blocks 506 and 507 showed that the bug occurred between the two copy functions
  5877                                  ;
  5878                                  ;    ; OK at this point
  5879                                  ;    mov _SCRATCH_, [ v_blk ]
  5880                                  ;    mov dword [ v_blk ], 506   ; block 506 shows corruption
  5881                                  ;    mov _TOS_, 64
  5882                                  ;    call copy_
  5883                                  ;    mov [ v_blk ], _SCRATCH_
  5884                                  
  5885                                      ; setup  v_bytesPerLine
  5886 00003411 A112180000                  mov _TOS_, [ vesa_XResolution ]
  5887 00003416 25FFFF0000                  and _TOS_, 0xFFFF
  5888 0000341B 69C002000000                imul _TOS_, BYTES_PER_PIXEL
  5889 00003421 A3[7C000000]                mov [ v_bytesPerLine ], _TOS_
  5890                                      ; was :     mov [ v_bytesPerLine + RELOCATED ], _TOS_   <--- BUG!!!
  5891                                  
  5892                                  ;    ; NOT OK at this point
  5893                                  ;    mov _SCRATCH_, [ v_blk ]
  5894                                  ;    mov dword [ v_blk ], 507   ; block 506 shows corruption???
  5895                                  ;    mov _TOS_, 64
  5896                                  ;    call copy_
  5897                                  ;    mov [ v_blk ], _SCRATCH_
  5898                                  
  5899                                      ; set up  fov
  5900 00003426 A114180000                  mov _TOS_, [ vesa_YResolution ]
  5901 0000342B 25FFFF0000                  and _TOS_, 0x0000FFFF
  5902 00003430 89C3                        mov _SCRATCH_, _TOS_
  5903 00003432 D1E3                        shl _SCRATCH_, 1
  5904 00003434 D1E8                        shr _TOS_, 1
  5905 00003436 01D8                        add _TOS_, _SCRATCH_
  5906 00003438 69C00A000000                imul _TOS_, 10
  5907 0000343E A3[5C490000]                mov [ v_fov ], _TOS_
  5908                                  
  5909                                      ; select which code to use, depending on the display mode
  5910 00003443 C605[860F0000]00            mov byte [ displayMode ], 0
  5911 0000344A 66813D121800000004          cmp word [ vesa_XResolution ], scrnw1
  5912 00003453 7407                        jz .forward
  5913 00003455 C605[860F0000]01            mov byte [ displayMode ], 1
  5914                                  .forward:
  5915                                  
  5916                                  ; *****************************************************************************
  5917                                  ; miscellaneous setup
  5918                                  ; *****************************************************************************
  5919                                  
  5920 0000345C E84C070000                  call randInit_      ; initialise the Marsaglia Pseudo Random Number Generator
  5921 00003461 E824DBFFFF                  call initIconSize   ; sets up the size of an icon (glyph) according to the 800x600 or 1024x768 display size
  5922 00003466 E835F4FFFF                  call cursorHome     ; setup the initial cursor location
  5923 0000346B E80BD1FFFF                  call c_             ; clear the stack
  5924                                  
  5925                                  ; *****************************************************************************
  5926                                  ; erase the DAP buffer, for the Int 0x13 Disk Address Packet (DAP)
  5927                                  ; *****************************************************************************
  5928                                      _DUP_
   132 00003470 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003473 8906                <1>  mov [ esi ], _TOS_
  5929 00003475 B800200000                  mov _TOS_, SECTOR_BUFFER
  5930                                      _DUP_
   132 0000347A 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000347D 8906                <1>  mov [ esi ], _TOS_
  5931 0000347F B800480000                  mov _TOS_, SECTOR_BUFFER_SIZE
  5932 00003484 E8B4D5FFFF                  call erase_
  5933                                  
  5934                                  ; *****************************************************************************
  5935                                  ; load the colorForth source starting at the first colorForth source block
  5936                                  ; *****************************************************************************
  5937                                      _DUP_
   132 00003489 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000348C 8906                <1>  mov [ esi ], _TOS_
  5938 0000348E B840000000                  mov _TOS_, START_BLOCK_NUMBER
  5939                                      _DUP_                           ; not sure why we need this...
   132 00003493 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003496 8906                <1>  mov [ esi ], _TOS_
  5940 00003498 E8F6D4FFFF                  call _load_
  5941 0000349D E9D1E7FFFF                  jmp dword quit_
  5942                                  
  5943                                  ; *****************************************************************************
  5944                                  ; *****************************************************************************
  5945                                  
  5946                                  pad_:   ; ( -- a )
  5947                                      _DUP_
   132 000034A2 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000034A5 8906                <1>  mov [ esi ], _TOS_
  5948                                      LOAD_RELATIVE_ADDRESS v_pad
   188 000034A7 B8BC480100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  5949 000034AC C3                          ret
  5950                                  
  5951                                  v_srch:     ; variables to search for a token name
  5952 000034AD 0000B8C4                    dd 0xC4B80000   ; token name "pad"
  5953 000034B1 00000000                    dd 0            ; token name extension (optional)
  5954 000034B5 00000000                    dd 0            ; current found address
  5955 000034B9 00000000                    dd 0            ; last found address
  5956 000034BD 00000100                    dd ( START_BLOCK_NUMBER * 1024 )        ; start searching from here
  5957 000034C1 00000800                    dd ( ( LAST_BLOCK_NUMBER + 1 ) * 1024 ) ; end the search here
  5958                                  
  5959                                  vsrch_:   ; ( -- a )
  5960                                      _DUP_
   132 000034C5 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000034C8 8906                <1>  mov [ esi ], _TOS_
  5961                                      LOAD_RELATIVE_ADDRESS v_srch
   188 000034CA B8AD340100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  5962 000034CF C3                          ret
  5963                                  
  5964                                  srch_:   ; ( -- a )
  5965                                      _DUP_
   132 000034D0 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000034D3 8906                <1>  mov [ esi ], _TOS_
  5966                                      LOAD_RELATIVE_ADDRESS v_srch
   188 000034D5 B8AD340100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  5967 000034DA C3                          ret
  5968                                  
  5969                                  ; align 4, db 0  ; variables must be on dword boundary so that "dump" can show them correctly
  5970                                  ; 
  5971                                  ; hsvv:    ; the start address of the pre-assembled high level Forth words
  5972                                  ;     dd 0
  5973                                  ;     times 0x28 db 0
  5974                                  
  5975                                  xy_:   ; ( -- a )
  5976                                      _DUP_
   132 000034DB 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000034DE 8906                <1>  mov [ esi ], _TOS_
  5977                                      LOAD_RELATIVE_ADDRESS v_gr_xy
   188 000034E0 B850490100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  5978 000034E5 C3                          ret
  5979                                  
  5980                                  x_:   ; ( -- a )
  5981                                      _DUP_
   132 000034E6 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000034E9 8906                <1>  mov [ esi ], _TOS_
  5982                                      LOAD_RELATIVE_ADDRESS v_x
   188 000034EB B87C480100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  5983 000034F0 C3                          ret
  5984                                  
  5985                                  y_:   ; ( -- a )
  5986                                      _DUP_
   132 000034F1 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000034F4 8906                <1>  mov [ esi ], _TOS_
  5987                                      LOAD_RELATIVE_ADDRESS v_y
   188 000034F6 B880480100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  5988 000034FB C3                          ret
  5989                                  
  5990                                  z_:   ; ( -- a )
  5991                                      _DUP_
   132 000034FC 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000034FF 8906                <1>  mov [ esi ], _TOS_
  5992                                      LOAD_RELATIVE_ADDRESS v_z
   188 00003501 B884480100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  5993 00003506 C3                          ret
  5994                                  
  5995                                  lblk_:   ; ( -- a )
  5996                                      _DUP_
   132 00003507 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000350A 8906                <1>  mov [ esi ], _TOS_
  5997                                      LOAD_RELATIVE_ADDRESS v_lblk
   188 0000350C B878480100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  5998 00003511 C3                          ret
  5999                                  
  6000                                  fov_:   ; ( -- a )
  6001                                      _DUP_
   132 00003512 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003515 8906                <1>  mov [ esi ], _TOS_
  6002                                      LOAD_RELATIVE_ADDRESS v_fov
   188 00003517 B85C490100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6003 0000351C C3                          ret
  6004                                  
  6005                                  tokenActions_:   ; ( -- a )
  6006                                      _DUP_
   132 0000351D 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003520 8906                <1>  mov [ esi ], _TOS_
  6007                                      LOAD_RELATIVE_ADDRESS tokenActions
   188 00003522 B810490100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6008 00003527 C3                          ret
  6009                                  
  6010                                  last_:   ; ( -- a )
  6011                                      _DUP_
   132 00003528 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000352B 8906                <1>  mov [ esi ], _TOS_
  6012                                      LOAD_RELATIVE_ADDRESS last
   188 0000352D B89D360100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6013 00003532 C3                          ret
  6014                                  
  6015                                  version_:   ; ( -- a )
  6016                                      _DUP_
   132 00003533 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003536 8906                <1>  mov [ esi ], _TOS_
  6017                                      LOAD_RELATIVE_ADDRESS version
   188 00003538 B800040100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6018 0000353D C3                          ret
  6019                                  
  6020                                  vframe_:     ; ( -- a )  \ return the video frame address, where we create the image to be displayed
  6021                                      _DUP_
   132 0000353E 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003541 8906                <1>  mov [ esi ], _TOS_
  6022 00003543 A1[60490000]                mov _TOS_, [ vframe ]
  6023 00003548 C3                          ret
  6024                                  
  6025                                  vars_:
  6026                                      _DUP_
   132 00003549 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000354C 8906                <1>  mov [ esi ], _TOS_
  6027                                      LOAD_RELATIVE_ADDRESS vars
   188 0000354E B82C480100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6028 00003553 C3                          ret
  6029                                  
  6030                                  base_:
  6031                                      _DUP_
   132 00003554 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003557 8906                <1>  mov [ esi ], _TOS_
  6032                                      LOAD_RELATIVE_ADDRESS base
   188 00003559 B82C480100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6033 0000355E C3                          ret
  6034                                  
  6035                                  hex_:
  6036 0000355F C605[2C480000]10            mov byte [ base ], 16
  6037 00003566 C3                          ret
  6038                                  
  6039                                  decimal_:
  6040 00003567 C605[2C480000]0A            mov byte [ base ], 10
  6041 0000356E C3                          ret
  6042                                  
  6043                                  block_: ; ( block -- address )   \ : block ( n -- n ) $400 * ; block number to byte address of block 
  6044 0000356F C1E00A                      shl _TOS_, 0x0A
  6045 00003572 0500000100                  add _TOS_, RELOCATED
  6046 00003577 C3                          ret
  6047                                  
  6048                                  a2blk_: ; ( address -- block )   \ byte address of block to block number
  6049 00003578 2D00000100                  sub _TOS_, RELOCATED
  6050 0000357D C1E80A                      shr _TOS_, 0x0A
  6051 00003580 C3                          ret
  6052                                  
  6053                                  scrnw_:    ; ( -- n )   screen width ( number of horizontal pixels )
  6054                                      _DUP_
   132 00003581 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003584 8906                <1>  mov [ esi ], _TOS_
  6055 00003586 31C0                        xor _TOS_, _TOS_
  6056 00003588 66A112180000                mov word ax, [ vesa_XResolution ]
  6057 0000358E C3                          ret
  6058                                  
  6059                                  scrnh_:    ; ( -- n )    screen height ( number of vertical pixels )
  6060                                      _DUP_
   132 0000358F 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003592 8906                <1>  mov [ esi ], _TOS_
  6061 00003594 31C0                        xor _TOS_, _TOS_
  6062 00003596 66A114180000                mov word ax, [ vesa_YResolution ]     ; v_scrnh
  6063 0000359C C3                          ret
  6064                                  
  6065                                  bpp_:    ; ( -- n )    bits per pixel
  6066                                      _DUP_
   132 0000359D 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000035A0 8906                <1>  mov [ esi ], _TOS_
  6067 000035A2 31C0                        xor _TOS_, _TOS_
  6068 000035A4 A019180000                  mov byte al, [ vesa_BitsPerPixel ]     ; v_bitsPerPixel
  6069 000035A9 C3                          ret
  6070                                  
  6071                                  iconw_:    ; ( -- n )    icon width ( number of pixels between characters, fixed font width )
  6072                                      _DUP_
   132 000035AA 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000035AD 8906                <1>  mov [ esi ], _TOS_
  6073 000035AF A1[F0470000]                mov _TOS_, [ v_iconw ]
  6074 000035B4 C3                          ret
  6075                                  
  6076                                  iconh_:    ; ( -- n )    icon height ( number of pixels between lines )
  6077                                      _DUP_
   132 000035B5 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000035B8 8906                <1>  mov [ esi ], _TOS_
  6078 000035BA A1[F4470000]                mov _TOS_, [ v_iconh ]
  6079 000035BF C3                          ret
  6080                                  
  6081                                  counter_:   ; ( -- n )    roughly 1 ms counter
  6082                                      _DUP_
   132 000035C0 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000035C3 8906                <1>  mov [ esi ], _TOS_
  6083 000035C5 0F31                        RDTSC   ; Read Time-Stamp Counter  https://c9x.me/x86/html/file_module_x86_id_278.html
  6084 000035C7 B9E8030000                  mov ecx, 1000
  6085 000035CC F7F9                        idiv ecx
  6086 000035CE C3                          ret
  6087                                  
  6088                                  ; : drop ( lodsd, flags unchanged, why sp is in ESI )
  6089                                  ; : a! ?lit if $BA 1, , ; then $D08B 2, drop ;
  6090                                  ; : p@ ( a-n ) qdup a! $EC 1, ;
  6091                                  ; : p! ( na- ) a! $EE 1, drop ;
  6092                                  ; ( Real Time Clock )
  6093                                  ; : rtc@ ( t-c ) $70 p! $71 p@ ;
  6094                                  ; : rtc! ( ct- ) $70 p! $71 p! ;
  6095                                  ; : hi ( -- ) #10 rtc@ $80 and drop 0if hi ; then ;
  6096                                  ; : lo ( -- ) #10 rtc@ $80 and drop if lo ; then ; 
  6097                                  ; : calkhz ( -- ) hi lo counter hi lo counter swap - 
  6098                                  ;    dup onesec ! #1 rshift #250 + #500 / dup khz ! ;
  6099                                  ; : ms ( n- ) khz @ * counter + begin pause dup counter 
  6100                                  ;    invert + drop -if drop ; then end drop ;
  6101                                  
  6102                                  
  6103                                  p70_fetch:  ;  ( reg -- c ) 
  6104 000035CF BA70000000                  mov edx, 0x70   ; db 0xBA  dd 0x70
  6105 000035D4 EC                          IN AL, DX       ; db 0xEC
  6106 000035D5 C3                          ret
  6107                                  
  6108                                  p70_store:  ;  ( c reg -- ) 
  6109 000035D6 BA70000000                  mov edx, 0x70   ; db 0xBA  dd 0x70
  6110 000035DB EE                          OUT DX, AL      ; db 0xEE
  6111                                      _DROP_
   148 000035DC AD                  <1>  lodsd
  6112                                      _DROP_
   148 000035DD AD                  <1>  lodsd
  6113 000035DE C3                          ret
  6114                                  
  6115                                  p71_fetch:  ;  ( reg -- c ) 
  6116 000035DF BA71000000                  mov edx, 0x71   ; db 0xBA  dd 0x71
  6117 000035E4 EC                          IN AL, DX       ; db 0xEC
  6118 000035E5 C3                          ret
  6119                                  
  6120                                  p71_store:  ;  ( c reg -- ) 
  6121 000035E6 BA71000000                  mov edx, 0x71   ; db 0xBA  dd 0x71
  6122 000035EB EE                          OUT DX, AL      ; db 0xEE
  6123                                      _DROP_
   148 000035EC AD                  <1>  lodsd
  6124                                      _DROP_
   148 000035ED AD                  <1>  lodsd
  6125 000035EE C3                          ret
  6126                                  
  6127                                  rtc_fetch_:  ;  ( reg -- c ) 
  6128 000035EF BA70000000                  mov edx, 0x70   ; db 0xBA  dd 0x70
  6129 000035F4 EE                          OUT DX, AL      ; db 0xEE
  6130 000035F5 BA71000000                  mov edx, 0x71   ; db 0xBA  dd 0x71
  6131 000035FA EC                          IN AL, DX       ; db 0xEC
  6132 000035FB C3                          ret
  6133                                  
  6134                                  rtc_store_:  ;  ( c reg -- ) 
  6135 000035FC BA70000000                  mov edx, 0x70   ; db 0xBA  dd 0x70
  6136 00003601 EE                          OUT DX, AL      ; db 0xEE
  6137 00003602 BA71000000                  mov edx, 0x71   ; db 0xBA  dd 0x71
  6138                                      _DROP_
   148 00003607 AD                  <1>  lodsd
  6139 00003608 EE                          OUT DX, AL      ; db 0xEE
  6140                                      _DROP_
   148 00003609 AD                  <1>  lodsd
  6141 0000360A C3                          ret
  6142                                  
  6143                                  rtc_hi:     ; ( -- )   wait for the RTC second pulse to go high
  6144                                      _DUP_
   132 0000360B 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000360E 8906                <1>  mov [ esi ], _TOS_
  6145                                      .back:
  6146 00003610 B80A000000                  mov _TOS_, 10   ; Update in progress" flag (bit 7 of Status Register A). 
  6147 00003615 E8D5FFFFFF                  call rtc_fetch_
  6148 0000361A 2480                        and al, 0x80
  6149 0000361C 74F2                        jz .back
  6150                                      _DROP_
   148 0000361E AD                  <1>  lodsd
  6151 0000361F C3                          ret
  6152                                  
  6153                                  rtc_lo:     ; ( -- )   wait for the RTC second pulse to go low
  6154                                      _DUP_
   132 00003620 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003623 8906                <1>  mov [ esi ], _TOS_
  6155                                      .back:
  6156 00003625 B80A000000                  mov _TOS_, 10   ; Update in progress" flag (bit 7 of Status Register A). 
  6157 0000362A E8C0FFFFFF                  call rtc_fetch_
  6158 0000362F 2480                        and al, 0x80
  6159 00003631 75F2                        jnz .back
  6160                                      _DROP_
   148 00003633 AD                  <1>  lodsd
  6161 00003634 C3                          ret
  6162                                  
  6163                                  get_proc_clk:   ; ( -- d )  get the processor clock counter
  6164                                      _DUP_
   132 00003635 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003638 8906                <1>  mov [ esi ], _TOS_
  6165 0000363A 0F31                        RDTSC                           ; Read Time-Stamp Counter  https://c9x.me/x86/html/file_module_x86_id_278.html
  6166                                      _DUP_
   132 0000363C 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000363F 8906                <1>  mov [ esi ], _TOS_
  6167 00003641 89D0                        mov _TOS_, edx                  ; put the high cell in TOS
  6168 00003643 C3                          ret
  6169                                  
  6170                                  calck_:         ; ( -- )   calibrate the ms counter clock
  6171 00003644 E8C2FFFFFF                  call rtc_hi                     ; wait for the RTC second pulse to go high
  6172 00003649 E8D2FFFFFF                  call rtc_lo                     ; wait for the RTC second pulse to go low
  6173 0000364E E8E2FFFFFF                  call get_proc_clk
  6174 00003653 E8B2020000                  call d_negate_                  ; so the d_plus_ later subtracts this value
  6175 00003658 E8AEFFFFFF                  call rtc_hi                     ; wait for the RTC second pulse to go high
  6176 0000365D E8BEFFFFFF                  call rtc_lo                     ; wait for the RTC second pulse to go low
  6177 00003662 E8CEFFFFFF                  call get_proc_clk
  6178 00003667 E8AE020000                  call d_plus_                    ; double number "subtract"
  6179 0000366C A3[90480000]                mov [ v_onesec ], _TOS_      
  6180 00003671 8B1E                        mov _SCRATCH_, [ esi ]
  6181 00003673 891D[94480000]              mov [ v_onesec + 4 ], _SCRATCH_ ; put the result in onesec
  6182 00003679 C3                          ret
  6183                                  
  6184                                  ms_:        ; ( n -- )   delay n milli seconds
  6185                                      _DROP_
   148 0000367A AD                  <1>  lodsd
  6186 0000367B C3                          ret
  6187                                  
  6188                                  onesec_:    ; ( -- a )    return the address of the onesec variable
  6189                                      _DUP_
   132 0000367C 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000367F 8906                <1>  mov [ esi ], _TOS_
  6190                                      LOAD_RELATIVE_ADDRESS v_onesec ; 
   188 00003681 B890480100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6191 00003686 C3                          ret    
  6192                                  
  6193                                  khz_:       ; ( -- a )    return the address of the khz variable
  6194                                      _DUP_
   132 00003687 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000368A 8906                <1>  mov [ esi ], _TOS_
  6195                                      LOAD_RELATIVE_ADDRESS v_khz ; 
   188 0000368C B898480100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6196 00003691 C3                          ret    
  6197                                  
  6198                                  font_:    ; ( -- n )    return the address of the font pointer
  6199                                      _DUP_
   132 00003692 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003695 8906                <1>  mov [ esi ], _TOS_
  6200                                      LOAD_RELATIVE_ADDRESS v_font ; font16x24
   188 00003697 B88C480100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6201 0000369C C3                          ret
  6202                                  
  6203                                  last:   ; ( -- a )
  6204                                      _DUP_
   132 0000369D 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000036A0 8906                <1>  mov [ esi ], _TOS_
  6205                                      LOAD_RELATIVE_ADDRESS v_lastToken
   188 000036A2 B888480100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6206 000036A7 C3                          ret
  6207                                  
  6208                                  blk_:       ; ( -- a )
  6209                                      _DUP_
   132 000036A8 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000036AB 8906                <1>  mov [ esi ], _TOS_
  6210                                      LOAD_RELATIVE_ADDRESS v_blk
   188 000036AD B8A8470100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6211 000036B2 C3                          ret
  6212                                  
  6213                                  seeb:       ; ( -- )    \ toggle the display of blue words in the editor
  6214 000036B3 F615[14480000]              not byte [ v_seeb ]
  6215 000036B9 C3                          ret
  6216                                  
  6217                                  colourBlindModeToggle:   ; ( -- )    \ toggle the editor display colorForth / ANS style
  6218 000036BA F615[15480000]              not byte [ v_colourBlindMode ]
  6219 000036C0 C3                          ret
  6220                                  
  6221                                  curs:       ; ( -- a )
  6222                                      _DUP_
   132 000036C1 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000036C4 8906                <1>  mov [ esi ], _TOS_
  6223                                      LOAD_RELATIVE_ADDRESS v_curs
   188 000036C6 B8AC470100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6224 000036CB C3                          ret
  6225                                  
  6226                                  ; analyse stack usage
  6227                                  ; the stack areas are initialised to all 'U's at power up
  6228                                  ; areas of 8 bytes that re not all 'U's are marked by a byte in a 512 byte buffer 
  6229                                  ; analyse_eight_bytes:    ; ( a -- a' )   zero flag is true if all 'U's
  6230                                  ;     xor edx, edx 
  6231                                  ;     cmp dword [ _TOS_ ], 0x55555555
  6232                                  ;     jz .forward
  6233                                  ;         inc edx     ; not all 'U's
  6234                                  ;     .forward:
  6235                                  ;     inc dword _TOS_     ; next address
  6236                                  ;     cmp dword [ _TOS_ ], 0x55555555
  6237                                  ;     jz .forward2
  6238                                  ;         inc edx     ; not all 'U's
  6239                                  ;     .forward2:
  6240                                  ;     inc dword _TOS_     ; next address
  6241                                  ;     add edx, 0
  6242                                  ;     ret
  6243                                  
  6244                                  analyse_stacks:
  6245 000036CC B800680000                  mov _TOS_, STACK_MEMORY_START
  6246 000036D1 BB00660000                  mov _SCRATCH_, STACK_ANALYSIS_BUFFER
  6247 000036D6 B900020000                  mov ecx, ( TOTAL_STACK_SIZE / 8 ) ;  0x200
  6248                                      .back:
  6249                                          ; call analyse_eight_bytes
  6250 000036DB 31D2                            xor edx, edx 
  6251 000036DD 813855555555                    cmp dword [ _TOS_ ], 0x55555555
  6252 000036E3 7401                            jz .forward
  6253 000036E5 42                                  inc edx     ; not all 'U's
  6254                                          .forward:
  6255 000036E6 0504000000                      add _TOS_, 4    ; next address
  6256 000036EB 813855555555                    cmp dword [ _TOS_ ], 0x55555555
  6257 000036F1 7401                            jz .forward2
  6258 000036F3 42                                  inc edx     ; not all 'U's
  6259                                          .forward2:
  6260 000036F4 0504000000                      add _TOS_, 4    ; next address
  6261 000036F9 81C200000000                    add edx, 0
  6262                                  
  6263 000036FF 7408                            jz .forward3
  6264 00003701 C6032E                              mov byte [ _SCRATCH_], 0x2E
  6265 00003704 E903000000                          jmp .forward4
  6266                                          .forward3:
  6267 00003709 C60355                              mov byte [ _SCRATCH_], 0x55
  6268                                          .forward4:
  6269 0000370C 43                              inc _SCRATCH_   ; next address in the results buffer
  6270 0000370D E2CC                        loop .back
  6271 0000370F C3                          ret
  6272                                  
  6273                                  stacks_:    ; ( -- a n )
  6274 00003710 E8B7FFFFFF                  call analyse_stacks
  6275                                      _DUP_
   132 00003715 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003718 8906                <1>  mov [ esi ], _TOS_
  6276 0000371A B800660000                  mov _TOS_, STACK_ANALYSIS_BUFFER
  6277 0000371F C3                          ret
  6278                                      _DUP_
   132 00003720 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003723 8906                <1>  mov [ esi ], _TOS_
  6279 00003725 B800680000                  mov _TOS_, STACK_MEMORY_START
  6280                                      _DUP_
   132 0000372A 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000372D 8906                <1>  mov [ esi ], _TOS_
  6281 0000372F B800100000                  mov _TOS_, TOTAL_STACK_SIZE
  6282 00003734 C3                          ret
  6283                                  
  6284                                  %if 0
  6285                                  stacks_:   ;  ( -- a )   \ return the address of the stack memory information ( see v_stack_info for details )
  6286                                  ;RETURN_STACK_SIZE
  6287                                  ;DATA_STACK_SIZE
  6288                                  ;STACK_MEMORY_START       ; bottom of stack memory
  6289                                  ;TOTAL_STACK_SIZE
  6290                                      _DUP_
  6291                                      mov _TOS_, RETURN_STACK_0 - 0x3C           ; top of task 0 return stack
  6292                                      _DUP_
  6293                                      mov _TOS_, DATA_STACK_0   - 0x3C           ; top of task 0 data stack
  6294                                      _DUP_
  6295                                      mov _TOS_, RETURN_STACK_1 - 0x3C           ; top of task 1 return stack
  6296                                      _DUP_
  6297                                      mov _TOS_, DATA_STACK_1   - 0x3C           ; top of task 1 data stack
  6298                                      _DUP_
  6299                                      mov _TOS_, RETURN_STACK_2 - 0x3C           ; top of task 2 return stack
  6300                                  ;    _DUP_
  6301                                  ;    mov _TOS_, DATA_STACK_2   - 0x3C           ; top of task 2 data stack
  6302                                  ;    LOAD_RELATIVE_ADDRESS v_stack_info
  6303                                      ret
  6304                                  %endif
  6305                                  
  6306                                  ekt:   ; ( -- a ) ; editor key table - variable containing vectors for editor keys beginning with null
  6307                                      ; and the shift keys.  Then follows right hand top, middle, bottom rows,
  6308                                      ; and left hand top, middle, bottom rows. (from ColorForth2.0a.doc)
  6309                                      _DUP_
   132 00003735 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003738 8906                <1>  mov [ esi ], _TOS_
  6310                                      LOAD_RELATIVE_ADDRESS editorActionTable
   188 0000373A B8BF2B0100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6311 0000373F C3                          ret
  6312                                  
  6313                                  vword_:   ; ( -- a )
  6314                                      _DUP_
   132 00003740 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003743 8906                <1>  mov [ esi ], _TOS_
  6315                                      LOAD_RELATIVE_ADDRESS v_words
   188 00003745 B844480100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6316 0000374A C3                          ret
  6317                                  
  6318                                  ;vregs_:   ; ( -- a )
  6319                                  ;    _DUP_
  6320                                  ;    mov _TOS_, V_REGS
  6321                                  ;    ret
  6322                                  
  6323                                  ivec_:   ; ( -- a )
  6324                                      _DUP_
   132 0000374B 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000374E 8906                <1>  mov [ esi ], _TOS_
  6325 00003750 B8001C0000                  mov _TOS_, INTERRUPT_VECTORS
  6326 00003755 C3                          ret
  6327                                  
  6328                                  pic_:   ; ( -- a )
  6329                                      _DUP_
   132 00003756 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003759 8906                <1>  mov [ esi ], _TOS_
  6330 0000375B B880170000                  mov _TOS_, IDT_AND_PIC_SETTINGS
  6331 00003760 C3                          ret
  6332                                  
  6333                                  %if 0
  6334                                  
  6335                                  From : https://pdos.csail.mit.edu/6.828/2014/readings/hardware/8259A.pdf
  6336                                  
  6337                                  The following registers can be read via OCW3 (IRR and ISR or OCW1 [IMR]).
  6338                                  
  6339                                  Interrupt Request Register (IRR):
  6340                                  8-bit register which contains the levels requesting an interrupt to be acknowledged.
  6341                                  The highest request level is reset from the IRR when an interrupt is acknowledged. (Not affected by IMR.)
  6342                                  
  6343                                  In-Service Register (ISR):
  6344                                  8-bit register which contains the priority levels that are being serviced.
  6345                                  The ISR is updated when an End of Interrupt Command is issued.
  6346                                  
  6347                                  Interrupt Mask Register:
  6348                                  8-bit register which contains the interrupt request lines which are masked.
  6349                                      The IRR can be read when, prior to the RD pulse, a Read Register Command is issued with OCW3 (RR = 1, RIS = 0.)
  6350                                      The ISR can be read, when, prior to the RD pulse, a Read Register Command is issued with OCW3 (RR = 1, RIS = 1).
  6351                                  There is no need to write an OCW3 before every status read operation,
  6352                                     as long as the status read corresponds with the previous one; i.e., the 8259A 'remembers' whether
  6353                                     the IRR or ISR has been previously selected by the OCW3.
  6354                                     This is not true when poll is used.
  6355                                     After initialization the 8259A is set to IRR.
  6356                                  
  6357                                  For reading the IMR, no OCW3 is needed.
  6358                                  The output data bus will contain the IMR whenever RD is active and A0 = 1 (OCW1).
  6359                                  Polling overrides status read when P = 1, RR = 1 in OCW3.
  6360                                  
  6361                                  From : https://en.wikibooks.org/wiki/X86_Assembly/Programmable_Interrupt_Controller
  6362                                  
  6363                                  Remapping
  6364                                  Another common task, often performed during the initialization of an operating system, is remapping the PICs.
  6365                                  That is, changing their internal vector offsets, thereby altering the interrupt numbers they send.
  6366                                  The initial vector offset of PIC1 is 8, so it raises interrupt numbers 8 to 15.
  6367                                  Unfortunately, some of the low 32 interrupts are used by the CPU for exceptions
  6368                                  (divide-by-zero, page fault, etc.), causing a conflict between hardware and software interrupts.
  6369                                  The usual solution to this is remapping the PIC1 to start at 32, and often the PIC2 right after it at 40.
  6370                                  This requires a complete restart of the PICs, but is not actually too difficult, requiring just eight 'out's.
  6371                                  
  6372                                  mov al, 0x11
  6373                                  out 0x20, al                        ; restart PIC1
  6374                                  out 0xA0, al                        ; restart PIC2
  6375                                  
  6376                                  mov al, 0x20
  6377                                  out 0x21, al                        ; PIC1 now starts at 32
  6378                                  mov al, 0x28
  6379                                  out 0xA1, al                        ; PIC2 now starts at 40
  6380                                  
  6381                                  mov al, 3
  6382                                  out 0x21, al                        ; setup cascading
  6383                                  mov al, 0x02
  6384                                  out 0xA1, al
  6385                                  
  6386                                  mov al, 0x01
  6387                                  out 0x21, al
  6388                                  out 0xA1, al                        ;done!
  6389                                  
  6390                                  From: cf2019 Forth block 244
  6391                                  : p!   pc! ;  \ 8 bit port store
  6392                                  : pic1! $21 p! ;
  6393                                  : pic2! $A1 p! ;
  6394                                  
  6395                                  : !pic cli
  6396                                  ( init )       $11 dup $20 p! $A0 p!
  6397                                  ( irq )        $20 pic1! $28 pic2!
  6398                                  ( master )     #4 pic1!
  6399                                  ( slave )      #2 pic2!
  6400                                  ( 8086 mode )  #1 dup pic1! pic2!
  6401                                  ( mask irqs )  $FF pic2! $FA pic1! ;
  6402                                  
  6403                                  Re-factored :
  6404                                  : !pic cli
  6405                                  \ PIC1
  6406                                  ( init )     $11 $20 p!
  6407                                  ( irq )      $20 $21 p!
  6408                                  ( master )   $04 $21 p!
  6409                                  ( 8086 mode) $01 $21 p!
  6410                                  ( mask irqs) $FA $21 p!
  6411                                  \ PIC2
  6412                                  ( init )     $11 $A0 p!
  6413                                  ( irq )      $28 $A1 p!
  6414                                  ( slave )    $02 $A1 p!
  6415                                  ( 8086 mode) $01 $A1 p!
  6416                                  ( mask irqs) $FF $A1 p!
  6417                                  ;
  6418                                  
  6419                                  %endif
  6420                                  
  6421                                  dap_:   ; ( -- a )
  6422                                      _DUP_
   132 00003761 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003764 8906                <1>  mov [ esi ], _TOS_
  6423 00003766 B8E0170000                  mov _TOS_, DAP_BUFFER
  6424 0000376B C3                          ret
  6425                                  
  6426                                  sect_:   ; ( -- a )
  6427                                      _DUP_
   132 0000376C 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000376F 8906                <1>  mov [ esi ], _TOS_
  6428 00003771 B800200000                  mov _TOS_, SECTOR_BUFFER
  6429 00003776 C3                          ret
  6430                                  
  6431                                  digin:   ; ( -- a )
  6432                                      _DUP_
   132 00003777 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000377A 8906                <1>  mov [ esi ], _TOS_
  6433                                      LOAD_RELATIVE_ADDRESS v_digin
   188 0000377C B84C480100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6434 00003781 C3                          ret
  6435                                  
  6436                                  actc:   ; ( -- a )
  6437                                      _DUP_
   132 00003782 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003785 8906                <1>  mov [ esi ], _TOS_
  6438                                      LOAD_RELATIVE_ADDRESS actionColourTable
   188 00003787 B864260100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6439 0000378C C3                          ret
  6440                                  
  6441                                  tickh:   ; ( -- a )    HERE variable address
  6442                                      _DUP_
   132 0000378D 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003790 8906                <1>  mov [ esi ], _TOS_
  6443                                      LOAD_RELATIVE_ADDRESS v_H
   188 00003792 B874480100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6444 00003797 C3                          ret
  6445                                  
  6446                                  md5buf_:   ; ( -- a )    \ the address of the 16 byte MD5 output buffer
  6447                                      _DUP_
   132 00003798 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000379B 8906                <1>  mov [ esi ], _TOS_
  6448 0000379D B840170000                  mov _TOS_, MD5_OUTPUT_BUFFER
  6449 000037A2 C3                          ret
  6450                                  
  6451                                  ; *****************************************************************************
  6452                                  ; wordlist addresses and lengths
  6453                                  ; *****************************************************************************
  6454                                  
  6455                                  maca_:    ; ( -- a )  \ the address of the Macro wordlist
  6456                                      _DUP_
   132 000037A3 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000037A6 8906                <1>  mov [ esi ], _TOS_
  6457 000037A8 B800E04600                  mov _TOS_,  MacroNames
  6458 000037AD C3                          ret
  6459                                  
  6460                                  macn_:   ; ( -- a )   the number of words in the Macro wordlist
  6461                                      _DUP_
   132 000037AE 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000037B1 8906                <1>  mov [ esi ], _TOS_
  6462                                      LOAD_RELATIVE_ADDRESS v_MacroWordCount
   188 000037B3 B8AC480100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6463 000037B8 C3                          ret
  6464                                  
  6465                                  macl_:    ; ( -- a )  \ the address of the Macro Locates list
  6466                                      _DUP_
   132 000037B9 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000037BC 8906                <1>  mov [ esi ], _TOS_
  6467 000037BE B800204700                  mov _TOS_,  MacroLocates
  6468 000037C3 C3                          ret
  6469                                  
  6470                                  mact_:    ; ( -- a )  \ the address of the Macro Jump Table
  6471                                      _DUP_
   132 000037C4 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000037C7 8906                <1>  mov [ esi ], _TOS_
  6472 000037C9 B800004700                  mov _TOS_,  MacroJumpTable
  6473 000037CE C3                          ret
  6474                                  
  6475                                  ftha_:    ; ( -- a )  \ the address of the Forth wordlist
  6476                                      _DUP_
   132 000037CF 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000037D2 8906                <1>  mov [ esi ], _TOS_
  6477 000037D4 B800804600                  mov _TOS_,  ForthNames
  6478 000037D9 C3                          ret
  6479                                  
  6480                                  fthn_:   ; ( -- a )   the number of words in the Forth wordlist
  6481                                      _DUP_
   132 000037DA 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000037DD 8906                <1>  mov [ esi ], _TOS_
  6482                                      LOAD_RELATIVE_ADDRESS v_ForthWordCount
   188 000037DF B8A8480100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6483 000037E4 C3                          ret
  6484                                  
  6485                                  fthl_:    ; ( -- a )  \ the address of the Forth Locates list
  6486                                      _DUP_
   132 000037E5 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000037E8 8906                <1>  mov [ esi ], _TOS_
  6487 000037EA B800A04600                  mov _TOS_,  ForthLocates
  6488 000037EF C3                          ret
  6489                                  
  6490                                  ftht_:    ; ( -- a )  \ the address of the Forth Jump Table
  6491                                      _DUP_
   132 000037F0 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000037F3 8906                <1>  mov [ esi ], _TOS_
  6492 000037F5 B800C04600                  mov _TOS_,  ForthJumpTable
  6493 000037FA C3                          ret
  6494                                  
  6495                                  ; the blue wordlist is not extensible, at the moment
  6496                                  blua_:    ; ( -- a )  \ the address of the Blue wordlist
  6497                                      _DUP_
   132 000037FB 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000037FE 8906                <1>  mov [ esi ], _TOS_
  6498 00003800 B8[3E240000]                mov _TOS_,  BlueNames
  6499 00003805 C3                          ret
  6500                                  
  6501                                  blun_:   ; ( -- a )   the number of words in the Blue wordlist
  6502                                      _DUP_
   132 00003806 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003809 8906                <1>  mov [ esi ], _TOS_
  6503                                      LOAD_RELATIVE_ADDRESS v_BlueWordCount
   188 0000380B B8B0480100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6504 00003810 C3                          ret
  6505                                  
  6506                                  ; *****************************************************************************
  6507                                  ; loc , see and fnd
  6508                                  ; *****************************************************************************
  6509                                  
  6510                                  loc_:   ; ( token# -- a )
  6511 00003811 8B048500A04600              mov dword _TOS_, [ ( _TOS_ * 4 ) + ForthLocates ]
  6512                                      ; ret
  6513 00003818 3D00000000                  cmp _TOS_, 0x0000000
  6514 0000381D 7405                        jz .forward                 ; do nothing is the locate field is 0
  6515 0000381F E919F5FFFF                  jmp editAddress_
  6516                                      .forward:
  6517 00003824 C3                          ret
  6518                                  
  6519                                  see_:   ; ( token# -- a )
  6520 00003825 8B048500C04600              mov dword _TOS_, [ ( _TOS_ * 4 ) + ForthJumpTable ]
  6521                                      ; call dmp_
  6522 0000382C C3                          ret
  6523                                  
  6524                                  fnd_:       ; ( sf -- token# ) 
  6525 0000382D 83E0F0                      and _TOS_, byte -0x10 ; (saves 2 bytes compared to 'and _TOS_, 0xFFFFFFF0' )
  6526 00003830 E8C9CDFFFF                  call find_
  6527 00003835 B800000000                  mov _TOS_, 0x00000000
  6528 0000383A 7502                        jnz .skip
  6529 0000383C 89C8                        mov _TOS_, ecx
  6530                                  .skip:
  6531 0000383E C3                          ret
  6532                                  
  6533                                  dmp_:
  6534 0000383F 8B048500804600              mov _TOS_, [ ( _TOS_ * 4 ) + ForthNames ]
  6535 00003846 C3                          ret
  6536                                  
  6537                                  ; *****************************************************************************
  6538                                  ; *****************************************************************************
  6539                                  
  6540                                  offset_:   ; ( -- a )
  6541                                      _DUP_
   132 00003847 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000384A 8906                <1>  mov [ esi ], _TOS_
  6542                                      LOAD_RELATIVE_ADDRESS v_offset
   188 0000384C B8E8470100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6543 00003851 C3                          ret
  6544                                  
  6545                                  vesa:   ; ( -- a )
  6546                                      _DUP_
   132 00003852 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003855 8906                <1>  mov [ esi ], _TOS_
  6547 00003857 B800180000                  mov _TOS_, VESA_BUFFER
  6548 0000385C C3                          ret
  6549                                  
  6550                                  vesamode_:   ; ( -- u )
  6551                                      _DUP_
   132 0000385D 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003860 8906                <1>  mov [ esi ], _TOS_
  6552 00003862 31C0                        xor _TOS_, _TOS_
  6553 00003864 66A11E180000                mov word ax, [ vesa_SavedMode ]     ; the saved  VESA video mode value
  6554 0000386A C3                          ret
  6555                                  
  6556                                  fetchDX_:   ; ( -- c )
  6557                                      _DUP_
   132 0000386B 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000386E 8906                <1>  mov [ esi ], _TOS_
  6558 00003870 31C0                        xor _TOS_, _TOS_
  6559 00003872 57                          push edi
  6560 00003873 BFE0170000                  mov edi, DAP_BUFFER
  6561 00003878 8A4712                      mov _TOS_l_, [ edi + o_Int13_DAP_saved_DX ]     ; setup DX value returned by the BIOS
  6562 0000387B 5F                          pop edi
  6563 0000387C C3                          ret
  6564                                  
  6565                                  trash_:   ; ( -- a )
  6566                                      _DUP_
   132 0000387D 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003880 8906                <1>  mov [ esi ], _TOS_
  6567                                      LOAD_RELATIVE_ADDRESS v_trash
   188 00003882 B8E4470100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6568 00003887 C3                          ret
  6569                                  
  6570                                  buffer_:   ; ( -- a )
  6571                                      _DUP_
   132 00003888 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 0000388B 8906                <1>  mov [ esi ], _TOS_
  6572 0000388D B800200000                  mov _TOS_, SECTOR_BUFFER ;0x25300
  6573 00003892 C3                          ret
  6574                                  
  6575                                  cad:   ; ( -- a )   \ the address of the cursor as an offset from the start of the currently displayed block
  6576                                      _DUP_
   132 00003893 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003896 8906                <1>  mov [ esi ], _TOS_
  6577                                      LOAD_RELATIVE_ADDRESS v_cad
   188 00003898 B8D8470100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6578 0000389D C3                          ret
  6579                                  
  6580                                  pcad:   ; ( -- a )
  6581                                      _DUP_
   132 0000389E 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000038A1 8906                <1>  mov [ esi ], _TOS_
  6582                                      LOAD_RELATIVE_ADDRESS v_pcad
   188 000038A3 B8DC470100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6583 000038A8 C3                          ret
  6584                                  
  6585                                  ; hsvv_:   ; ( -- a )
  6586                                  ;     _DUP_
  6587                                  ;     LOAD_RELATIVE_ADDRESS hsvv
  6588                                  ;     ret
  6589                                  
  6590                                  displ:   ; ( -- a )
  6591                                      _DUP_
   132 000038A9 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000038AC 8906                <1>  mov [ esi ], _TOS_
  6592                                      LOAD_RELATIVE_ADDRESS displayShannonFanoActions
   188 000038AE B816250100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6593 000038B3 C3                          ret
  6594                                  
  6595                                  cBlindAddr_:   ; ( -- a )
  6596                                      _DUP_
   132 000038B4 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000038B7 8906                <1>  mov [ esi ], _TOS_
  6597                                      LOAD_RELATIVE_ADDRESS x_colourBlind
   188 000038B9 B810480100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6598 000038BE C3                          ret
  6599                                  
  6600                                  ; *****************************************************************************
  6601                                  ; memory operators
  6602                                  ; *****************************************************************************
  6603                                  
  6604                                  cFetch_:      ; ( a -- c ) \ c@
  6605 000038BF 31DB                        xor _SCRATCH_, _SCRATCH_
  6606 000038C1 8A18                        mov byte _SCRATCH_l_, [ _TOS_ ] ;
  6607 000038C3 89D8                        mov _TOS_, _SCRATCH_
  6608 000038C5 C3                          ret
  6609                                  
  6610                                  wFetch_:      ; ( a -- w ) \ w@
  6611 000038C6 31DB                        xor _SCRATCH_, _SCRATCH_
  6612 000038C8 668B18                      mov word _SCRATCH_x_, [ _TOS_ ] ;
  6613 000038CB 89D8                        mov _TOS_, _SCRATCH_
  6614 000038CD C3                          ret
  6615                                  
  6616                                  fetch_:       ; ( a -- u ) \ @
  6617 000038CE 8B00                        mov dword _TOS_, [ _TOS_ ] ;
  6618 000038D0 C3                          ret
  6619                                  
  6620                                  two_fetch_:     ; ( a -- x1 x2 )
  6621 000038D1 81EE04000000               sub esi, 4                       ; make room on stack 
  6622 000038D7 8B5804                     mov _SCRATCH_, [ _TOS_ + 4 ]     ; read x1 from addr+4
  6623 000038DA 891E                       mov [ esi ], _SCRATCH_           ; write onto stack
  6624 000038DC 8B00                       mov _TOS_, [ _TOS_ ]             ; read x2 from addr+0, replacing tos
  6625 000038DE C3                         ret
  6626                                  
  6627                                  cStore_:      ; ( c a -- )          \ c!
  6628 000038DF 8B1E                        mov _SCRATCH_, [ esi ]
  6629 000038E1 8818                        mov byte [ _TOS_ ], _SCRATCH_l_
  6630                                      _DROP_
   148 000038E3 AD                  <1>  lodsd
  6631                                      _DROP_
   148 000038E4 AD                  <1>  lodsd
  6632 000038E5 C3                          ret
  6633                                  
  6634                                  wStore_:      ; ( w a -- )          \ w!
  6635 000038E6 8B1E                        mov _SCRATCH_, [ esi ]
  6636 000038E8 668918                      mov word [ _TOS_ ], _SCRATCH_x_
  6637                                      _DROP_
   148 000038EB AD                  <1>  lodsd
  6638                                      _DROP_
   148 000038EC AD                  <1>  lodsd
  6639 000038ED C3                          ret
  6640                                  
  6641                                  store_:       ; ( u a -- )          \ !
  6642 000038EE 8B1E                        mov _SCRATCH_, [ esi ]
  6643 000038F0 8918                        mov dword [ _TOS_ ], _SCRATCH_
  6644                                      _DROP_
   148 000038F2 AD                  <1>  lodsd
  6645                                      _DROP_
   148 000038F3 AD                  <1>  lodsd
  6646 000038F4 C3                          ret
  6647                                  
  6648                                  two_store_:     ; ( x1 x2 a -- )    \ 2!
  6649 000038F5 8B1E                        mov _SCRATCH_, [ esi ]          ; x2 into scratch
  6650 000038F7 8918                        mov [ _TOS_ ], _SCRATCH_        ; write x2 to addr+0
  6651 000038F9 8B5E04                      mov _SCRATCH_, [ esi + 4 ]      ; x1 into scratch
  6652 000038FC 895804                      mov [ _TOS_ + 4 ], _SCRATCH_    ; write x1 to addr+4
  6653                                      _DROP_                          ; drop the stack
   148 000038FF AD                  <1>  lodsd
  6654                                      _DROP_
   148 00003900 AD                  <1>  lodsd
  6655                                      _DROP_
   148 00003901 AD                  <1>  lodsd
  6656 00003902 C3                          ret
  6657                                  
  6658                                  plus_store_:  ; ( n addr -- )       \ +!
  6659 00003903 8B1E                        mov _SCRATCH_, [ esi ]          ; copy the value n into the scratch register  
  6660 00003905 0118                        add [ _TOS_ ], _SCRATCH_        ; add to value at addr
  6661                                      _DROP_                          ; drop the stack
   148 00003907 AD                  <1>  lodsd
  6662                                      _DROP_
   148 00003908 AD                  <1>  lodsd
  6663 00003909 C3                          ret
  6664                                  
  6665                                  ; *****************************************************************************
  6666                                  ; double number operators
  6667                                  ; *****************************************************************************
  6668                                  
  6669                                  d_negate_:  ; ( d1 -- d2 )
  6670 0000390A F716                       not dword [ esi ]                ; invert d1-lo
  6671 0000390C F7D0                       not _TOS_                        ; invert d1-hi
  6672 0000390E 810601000000               add dword [ esi ], 1             ; make two's complement
  6673 00003914 1500000000                 adc _TOS_, 0                     ; from invert + 1
  6674 00003919 C3                         ret
  6675                                  
  6676                                  d_plus_:   ; ( d1 d2 -- d3 )   add d2 to d1 to give d3
  6677 0000391A 8B1E                       mov _SCRATCH_, [ esi ]           ; get d2-lo
  6678 0000391C 035E08                     add _SCRATCH_, [ esi + 8 ]       ; add d1-lo
  6679 0000391F 134604                     adc _TOS_, [ esi + 4 ]           ; add d1-hi and carry to d2-hi
  6680 00003922 895E08                     mov [ esi + 8 ], _SCRATCH_       ; write d3-low
  6681 00003925 81C608000000               add esi, 8                       ; and clean up stack
  6682 0000392B C3                         ret
  6683                                  
  6684                                  d_minus_:   ; ( d1 d2 -- d3 )   subtract d2 from d1 to give d3
  6685 0000392C E8D9FFFFFF                  call d_negate_
  6686 00003931 E8E4FFFFFF                  call d_plus_
  6687 00003936 C3                          ret
  6688                                  
  6689                                  ; *****************************************************************************
  6690                                  ; stack operators
  6691                                  ; *****************************************************************************
  6692                                  
  6693                                  two_dup_:       ; ( a b -- a b a b )
  6694                                  ;    sub esi, byte 0x08 ; lea esi, [ esi - 0x08 ]    ; pre-decrement the stack pointer, adding 2 cells
  6695                                  ;    mov [ esi + 4 ], _TOS_  ; copy x2 to Third On Stack ( second on the real stack )
  6696                                  ;    mov _SCRATCH_, [ esi + 8 ]    ; copy x1 to register ebx
  6697                                  ;    mov [ esi ], _SCRATCH_        ; copy register ebx to Fourth On Stack
  6698                                      _OVER_
   142 00003937 83EE04              <1>  sub esi, byte 0x04
   143 0000393A 8906                <1>  mov [ esi ], _TOS_
   144 0000393C 8B4604              <1>  mov _TOS_, [ esi + 4 ]
  6699                                      _OVER_
   142 0000393F 83EE04              <1>  sub esi, byte 0x04
   143 00003942 8906                <1>  mov [ esi ], _TOS_
   144 00003944 8B4604              <1>  mov _TOS_, [ esi + 4 ]
  6700 00003947 C3                          ret
  6701                                  
  6702                                  two_drop_:      ; ( a b -- )
  6703                                      _DROP_
   148 00003948 AD                  <1>  lodsd
  6704                                      _DROP_
   148 00003949 AD                  <1>  lodsd
  6705 0000394A C3                          ret
  6706                                  
  6707                                  two_swap_:      ; ( a b c d -- c d a b )
  6708 0000394B 8B5E08                      mov _SCRATCH_, [ esi + 8 ]
  6709 0000394E 871E                        xchg _SCRATCH_, [ esi ]
  6710 00003950 895E08                      mov  [ esi + 8 ], _SCRATCH_
  6711 00003953 874604                      xchg _TOS_, [ esi + 4 ]
  6712 00003956 C3                          ret
  6713                                  
  6714                                  two_over_:      ; ( a b c d -- a b c d a b )
  6715 00003957 8D76F8                      lea esi, [ esi - 8 ]
  6716 0000395A 894604                      mov [ esi + 4 ], _TOS_
  6717 0000395D 8B5E10                      mov _SCRATCH_, [ esi + 0x10 ]
  6718 00003960 891E                        mov [esi], _SCRATCH_
  6719 00003962 8B460C                      mov _TOS_, [ esi + 0x0C ]
  6720 00003965 C3                          ret
  6721                                  
  6722                                  rot_:           ; ( a b c -- b c a)
  6723 00003966 8B5E04                      mov _SCRATCH_,[ esi + 4 ]
  6724 00003969 8B2E                        mov ebp, [ esi ]
  6725 0000396B 896E04                      mov [ esi + 4 ], ebp
  6726 0000396E 8906                        mov [ esi ],_TOS_
  6727 00003970 89D8                        mov _TOS_, _SCRATCH_
  6728 00003972 C3                          ret
  6729                                  
  6730                                  minus_rot_:     ; -rot ( a b c -- c b a)
  6731 00003973 8B5E04                      mov _SCRATCH_, [ esi + 4 ]
  6732 00003976 8B2E                        mov ebp, [ esi ]
  6733 00003978 894604                      mov [ esi + 4 ], _TOS_
  6734 0000397B 891E                        mov [esi], _SCRATCH_
  6735 0000397D 89E8                        mov _TOS_, ebp
  6736 0000397F C3                          ret
  6737                                  
  6738                                  tuck_:          ; ( a b -- b a b )
  6739                                      _SWAP_
   138 00003980 8706                <1>  xchg _TOS_, [ esi ]
  6740                                      _OVER_
   142 00003982 83EE04              <1>  sub esi, byte 0x04
   143 00003985 8906                <1>  mov [ esi ], _TOS_
   144 00003987 8B4604              <1>  mov _TOS_, [ esi + 4 ]
  6741 0000398A C3                          ret
  6742                                  
  6743                                  pick_:          ; ( ... n -- ... u ) where u is the n'th stack item
  6744 0000398B 8B0486                      mov _TOS_, [ esi + ( _TOS_ * 4 ) ]
  6745 0000398E C3                          ret
  6746                                  
  6747                                  %define CELL_WIDTH  0x04    ; this is a 32 bit wide system = 4 bytes
  6748                                  
  6749                                  cell_:          ; ( -- c )
  6750                                      _DUP_
   132 0000398F 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003992 8906                <1>  mov [ esi ], _TOS_
  6751 00003994 B804000000                  mov _TOS_, CELL_WIDTH
  6752 00003999 C3                          ret
  6753                                  
  6754                                  cell_minus_:    ; ( u -- u' )
  6755 0000399A 2D04000000                  sub _TOS_, CELL_WIDTH
  6756 0000399F C3                          ret
  6757                                  
  6758                                  cell_plus_:    ; ( u -- u' )
  6759 000039A0 0504000000                  add _TOS_, CELL_WIDTH
  6760 000039A5 C3                          ret
  6761                                  
  6762                                  cells_:         ; ( u -- u' )
  6763 000039A6 01C0                        add _TOS_, _TOS_    ; this code must be changed if CELL_WIDTH is changed
  6764 000039A8 01C0                        add _TOS_, _TOS_
  6765 000039AA C3                          ret
  6766                                  
  6767                                  ; *****************************************************************************
  6768                                  ; save and restore the Interrupt Descriptor Table and Interrupt Mask Registers
  6769                                  ; *****************************************************************************
  6770                                  
  6771                                  lidt_:  ; ( a -- )  \ set a into the Interrupt Descriptor Table (IDT) register
  6772 000039AB FA                          cli
  6773 000039AC 55                          push ebp
  6774 000039AD BD80170000                  mov ebp, ( PIC_BIOS_IDT_SETTINGS )   ; 6 bytes of RAM used to store the IDT info
  6775 000039B2 66C74500B703                mov word [ ebp ], 0x03B7
  6776 000039B8 894502                      mov [ ebp + 2 ], _TOS_   ; save IDT base address from eax
  6777 000039BB 0F015D00                    lidt [ ebp ]  ; db 0x0F, 0x01, 0x18
  6778                                      _DROP_
   148 000039BF AD                  <1>  lodsd
  6779 000039C0 5D                          pop ebp
  6780 000039C1 C3                          ret
  6781                                  
  6782                                  sidt_:  ; ( -- a )  \ return the address contained in the Interrupt Descriptor Table (IDT) register
  6783 000039C2 FA                          cli
  6784                                      _DUP_
   132 000039C3 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 000039C6 8906                <1>  mov [ esi ], _TOS_
  6785 000039C8 55                          push ebp
  6786 000039C9 BDA0170000                  mov ebp, ( IDT_AND_PIC_SETTINGS_PAD )   ; 6 bytes of RAM used to interface to the stack
  6787 000039CE 0F014D00                    sidt [ ebp ]        ; write the 6-byte IDT to memory location pointed to by  ebp
  6788 000039D2 8B4502                      mov _TOS_, [ ebp + 2 ]   ; save IDT base address to eax
  6789 000039D5 5D                          pop ebp
  6790 000039D6 C3                          ret
  6791                                  
  6792                                  save_BIOS_idt:  ; ( -- )  \ save the Interrupt Descriptor Table (IDT) register value
  6793 000039D7 FA                          cli
  6794 000039D8 55                          push ebp
  6795 000039D9 BD80170000                  mov ebp, ( PIC_BIOS_IDT_SETTINGS )   ; 6 bytes of RAM used to save the values in
  6796 000039DE 0F014D00                    sidt [ ebp ]        ; write the 6-byte IDT to memory location pointed to by  ebp
  6797 000039E2 5D                          pop ebp
  6798 000039E3 C3                          ret
  6799                                  
  6800                                  restore_BIOS_idt:  ; ( -- )  \ restore the saved IDT value into the Interrupt Descriptor Table (IDT) register
  6801 000039E4 FA                          cli
  6802 000039E5 55                          push ebp
  6803 000039E6 BD80170000                  mov ebp, ( PIC_BIOS_IDT_SETTINGS )   ; 6 bytes of RAM used to restore from
  6804 000039EB 0F015D00                    lidt [ ebp ]  ; db 0x0F, 0x01, 0x18
  6805 000039EF 5D                          pop ebp
  6806 000039F0 C3                          ret
  6807                                  
  6808                                  save_BIOS_idt_and_pic: ; ( -- )   \ save the PIC1 and PIC2 IMR values into IDT_AND_PIC_SETTINGS at startup
  6809 000039F1 FA                          cli
  6810 000039F2 E8E0FFFFFF                  call save_BIOS_idt
  6811 000039F7 55                          push ebp
  6812 000039F8 BD86170000                  mov ebp, ( PIC_BIOS_IMR_SETTINGS )   ; 2 bytes of RAM used to save the IMR for PIC1 and PIC2
  6813                                  ; PIC1
  6814 000039FD E421                        in al, 0x21     ; read PIC1's IMR value
  6815 000039FF 884500                      mov [ ebp ], al
  6816                                  ; PIC2
  6817 00003A02 45                          inc ebp
  6818 00003A03 E4A1                        in al, 0xA1     ; read PIC 2's IMR value
  6819 00003A05 884500                      mov [ ebp ], al
  6820 00003A08 5D                          pop ebp
  6821 00003A09 C3                          ret
  6822                                  
  6823                                  restore_BIOS_idt_and_pic: ; ( -- )   \ restore the saved BIOS PIC and IMR values into PIC1 and PIC2
  6824 00003A0A FA                          cli
  6825 00003A0B E8D4FFFFFF                  call restore_BIOS_idt
  6826 00003A10 55                          push ebp
  6827 00003A11 BD86170000                  mov ebp, ( PIC_BIOS_IMR_SETTINGS )   ; 2 bytes of RAM used to save the IMR for PIC1 and PIC2
  6828                                  ; PIC1
  6829 00003A16 B011                        mov al, 0x11    ; init command
  6830 00003A18 E620                        out 0x20, al    ; init PIC1                 ( $11 $20 p! )
  6831 00003A1A B000                        mov al, 0x00    ; PIC1 Interrupt Vector table start address
  6832 00003A1C E621                        out 0x21, al    ; PIC1 now starts at 0x00   ( $00 $21 p! )
  6833 00003A1E B004                        mov al, 0x04    ; master mode command
  6834 00003A20 E621                        out 0x21, al    ; set PIC1 as master, sets up cascading of PIC1 and PIC2 ( $04 $21 p! )
  6835 00003A22 B001                        mov al, 0x01    ; 8086 command
  6836 00003A24 E621                        out 0x21, al    ; set 8086 mode         ( $01 $21 p! )
  6837 00003A26 8A4500                      mov al, [ ebp ] ; Interrupt Mask Register ( IMR )
  6838 00003A29 E621                        out 0x21, al    ; set PIC1's IMR, BIOS = 0xB8 ( $xx $21 p! )
  6839                                  ; PIC2
  6840 00003A2B 45                          inc ebp
  6841 00003A2C B011                        mov al, 0x11    ; init command
  6842 00003A2E E6A0                        out 0xA0, al    ; init PIC2
  6843 00003A30 B008                        mov al, 0x08    ; PIC2 Interrupt Vector table start address
  6844 00003A32 E6A1                        out 0xA1, al    ; PIC2 now starts at 0x08   $08 $A1 p!
  6845 00003A34 B002                        mov al, 0x02    ; slave mode command
  6846 00003A36 E6A1                        out 0xA1, al    ; set PIC2 as slave     ( $02 $A1 p! )
  6847 00003A38 B001                        mov al, 0x01    ; 8086 command
  6848 00003A3A E6A1                        out 0xA1, al    ; set 8086 mode         ( $01 $A1 p! )
  6849 00003A3C 8A4500                      mov al, [ ebp ] ; Interrupt Mask Register ( IMR )
  6850 00003A3F E6A1                        out 0xA1, al    ; set PIC2's IMR, BIOS = 0x8F ( $xx $A1 p! )
  6851 00003A41 5D                          pop ebp
  6852 00003A42 C3                          ret
  6853                                  
  6854                                  restore_new_idt_and_pic: ; ( -- )   \ restore the new IDT and PIC IMR values
  6855 00003A43 FA                          cli
  6856 00003A44 55                          push ebp
  6857 00003A45 BD96170000                  mov ebp, ( PIC_NEW_IMR_SETTINGS )   ; 2 bytes of RAM used to save the IMR for PIC1 and PIC2
  6858                                  ; PIC1
  6859 00003A4A B011                        mov al, 0x11    ; init command
  6860 00003A4C E620                        out 0x20, al    ; init PIC1                 ( $11 $20 p! )
  6861 00003A4E B020                        mov al, 0x20    ; PIC1 Interrupt Vector table start address
  6862 00003A50 E621                        out 0x21, al    ; PIC1 now starts at 0x20   ( $20 $21 p! )
  6863 00003A52 B004                        mov al, 0x04    ; master mode command
  6864 00003A54 E621                        out 0x21, al    ; set PIC1 as master, sets up cascading of PIC1 and PIC2 ( $04 $21 p! )
  6865 00003A56 B001                        mov al, 0x01    ; 8086 command
  6866 00003A58 E621                        out 0x21, al    ; set 8086 mode         ( $01 $21 p! )
  6867 00003A5A 8A4500                      mov al, [ ebp ] ; Interrupt Mask Register ( IMR )
  6868 00003A5D E621                        out 0x21, al    ; set PIC1's IMR, BIOS = 0xB8 ( $xx $21 p! )
  6869                                  ; PIC2
  6870 00003A5F 45                          inc ebp
  6871 00003A60 B011                        mov al, 0x11    ; init command
  6872 00003A62 E6A0                        out 0xA0, al    ; init PIC2
  6873 00003A64 B028                        mov al, 0x28    ; PIC2 Interrupt Vector table start address
  6874 00003A66 E6A1                        out 0xA1, al    ; PIC2 now starts at 0x28   $28 $A1 p!
  6875 00003A68 B002                        mov al, 0x02    ; slave mode command
  6876 00003A6A E6A1                        out 0xA1, al    ; set PIC2 as slave     ( $02 $A1 p! )
  6877 00003A6C B001                        mov al, 0x01    ; 8086 command
  6878 00003A6E E6A1                        out 0xA1, al    ; set 8086 mode         ( $01 $A1 p! )
  6879 00003A70 8A4500                      mov al, [ ebp ] ; Interrupt Mask Register ( IMR )
  6880 00003A73 E6A1                        out 0xA1, al    ; set PIC2's IMR, BIOS = 0x8F ( $xx $A1 p! )
  6881 00003A75 5D                          pop ebp
  6882 00003A76 C3                          ret
  6883                                  
  6884                                  init_default_PIC_IMRs:  ; ( -- )
  6885 00003A77 9C                          pushf
  6886 00003A78 FA                          cli
  6887                                  
  6888 00003A79 60                          pusha
  6889 00003A7A BE00000000                  mov esi, 0x0000                 ; source address = the BIOS interrupt vector table
  6890 00003A7F BF001C0000                  mov edi, INTERRUPT_VECTORS      ; destination address
  6891 00003A84 B900010000                  mov ecx, ( 1024 / 4 )           ; 1024 bytes in cells
  6892 00003A89 F3A5                        rep movsd                       ; does not change AX , it moves DS:SI to ES:DI and increments SI and DI
  6893                                      ; now copy Interrupts 0x00 to 0x0F up to 0x20 to 0x2F
  6894 00003A8B BE00000000                  mov esi, 0x0000                 ; source address = the BIOS interrupt vector table
  6895 00003A90 BF801C0000                  mov edi, ( INTERRUPT_VECTORS + ( 0x20 * 4 ) )  ; destination address
  6896 00003A95 B910000000                  mov ecx, ( 0x10 )               ; 16 vectors in cells
  6897 00003A9A F3A5                        rep movsd                       ; does not change AX , it moves DS:SI to ES:DI and increments SI and DI
  6898                                  
  6899 00003A9C 61                          popa
  6900                                  
  6901 00003A9D 55                          push ebp
  6902 00003A9E BD96170000                  mov ebp, ( PIC_NEW_IMR_SETTINGS )   ; 2 bytes of RAM used to save the IMR for PIC1 and PIC2
  6903 00003AA3 C64500FA                    mov byte [ ebp ] , 0xFA   ; Interrupt Mask Register ( IMR ) saved value for PIC1
  6904 00003AA7 45                          inc ebp
  6905 00003AA8 C64500FF                    mov byte [ ebp ] , 0xFF   ; Interrupt Mask Register ( IMR ) saved value for PIC2
  6906 00003AAC 5D                          pop ebp
  6907 00003AAD 9D                          popf
  6908 00003AAE C3                          ret
  6909                                  
  6910                                  set_PIC1_IMR:   ; ( c -- )   \ set the Interrupt Mask Register for PIC1 and copy to PIC_NEW_IMR_SETTINGS
  6911 00003AAF 9C                          pushf
  6912 00003AB0 FA                          cli
  6913 00003AB1 55                          push ebp
  6914 00003AB2 BD96170000                  mov ebp, ( PIC_NEW_IMR_SETTINGS )   ; 1 byte of RAM used to save the IMR for PIC1
  6915 00003AB7 884500                      mov [ ebp ] , al    ; Interrupt Mask Register ( IMR )
  6916 00003ABA E621                        out 0x21, al        ; set PIC1's IMR ( $xx $21 p! )
  6917 00003ABC 5D                          pop ebp
  6918 00003ABD 9D                          popf
  6919                                      _DROP_
   148 00003ABE AD                  <1>  lodsd
  6920 00003ABF C3                          ret
  6921                                  
  6922                                  set_PIC2_IMR:   ; ( c -- )   \ set the Interrupt Mask Register for PIC2 and copy to PIC_NEW_IMR_SETTINGS+1
  6923 00003AC0 9C                          pushf
  6924 00003AC1 FA                          cli
  6925 00003AC2 55                          push ebp
  6926 00003AC3 BD97170000                  mov ebp, ( PIC_NEW_IMR_SETTINGS + 1 )   ; 1 byte of RAM used to save the IMR for PIC1
  6927 00003AC8 884500                      mov [ ebp ] , al    ; Interrupt Mask Register ( IMR )
  6928 00003ACB E6A1                        out 0xA1, al        ; set PIC2's IMR ( $xx $A1 p! )
  6929 00003ACD 5D                          pop ebp
  6930 00003ACE 9D                          popf
  6931                                      _DROP_
   148 00003ACF AD                  <1>  lodsd
  6932 00003AD0 C3                          ret
  6933                                  
  6934                                  ; *****************************************************************************
  6935                                  ; lp support for GRaphics demo
  6936                                  ; *****************************************************************************
  6937                                  
  6938                                  lp_:
  6939                                  ;; test what lodsd actually does
  6940                                  ;    push esi
  6941                                  ;    mov esi, [ v_trash ]    ; setup EDI to point to the current trash buffer address
  6942                                  ;    mov [ v_lcad ], esi
  6943                                  ;    lodsd  ; loads a 32 bit dword from [ds:esi] into _TOS_, increments  esi  by 4 : true
  6944                                  ;    mov [ v_pcad ], esi
  6945                                  ;    pop esi
  6946                                  ;    _DUP_
  6947                                  ;    mov _TOS_, [ v_lcad ]
  6948                                  ;    _DUP_
  6949                                  ;    mov _TOS_, [ v_pcad ]
  6950                                  ;    ret
  6951 00003AD1 90                          nop
  6952 00003AD2 90                          nop
  6953 00003AD3 90                          nop
  6954 00003AD4 8BE8                        db 0x8B , 0xE8 ; mov ebp,eax
  6955 00003AD6 AD                          lodsd  ; loads a 32 bit dword from [ds:esi] into _TOS_, increments  esi  by 4
  6956 00003AD7 8BC8                        db 0x8B , 0xC8 ; mov ecx,eax
  6957 00003AD9 AD                          lodsd  ; loads a 32 bit dword from [ds:esi] into _TOS_, increments  esi  by 4
  6958 00003ADA 8B5A20                      mov ebx,[edx+0x20]
  6959                                      .back:
  6960 00003ADD 66892B                      mov [ebx],bp
  6961 00003AE0 23C0                        db 0x23 , 0xC0 ; and eax,eax   21C0                        and eax,eax
  6962 00003AE2 7805                        js .forward
  6963 00003AE4 0302                        add eax,[edx]
  6964 00003AE6 035A18                      add ebx,[edx+0x18]
  6965                                      .forward:
  6966 00003AE9 034208                      add eax,[edx+0x8]
  6967 00003AEC 035A10                      add ebx,[edx+0x10]
  6968 00003AEF E2EC                        loop .back
  6969                                  ;    dd 0x8B909090 , 0xC88BADE8 , 0x205A8BAD , 0x232B8966
  6970                                  ;    dd 0x030578C0 , 0x185A0302 , 0x03084203 , 0xECE2105A
  6971 00003AF1 C3                          ret
  6972                                  
  6973                                  ; *****************************************************************************
  6974                                  ; maths operators
  6975                                  ; The ANSI/ISO Forth Standard (adopted in 1994) mandates the minimal set
  6976                                  ; of arithmetic operators +  -  *  /  MOD  */  /MOD  */MOD and  M* .
  6977                                  ; *****************************************************************************
  6978                                  
  6979                                  two_slash_:                         ; ( n -- n' )   "2/" arithmetic divide by 2
  6980 00003AF2 D1F8                        sar _TOS_, 0x01
  6981 00003AF4 C3                          ret
  6982                                  
  6983                                  u_two_slash_:                       ; ( u -- u' )   "u2/" unsigned divide by 2
  6984 00003AF5 D1E8                        shr _TOS_, 0x01
  6985 00003AF7 C3                          ret
  6986                                  
  6987                                  rshift_:                            ; ( u c -- u' )   shift TOS right by c bits 
  6988 00003AF8 89C1                        mov ecx, _TOS_
  6989                                      _DROP_
   148 00003AFA AD                  <1>  lodsd
  6990 00003AFB D3E8                        shr _TOS_, cl
  6991 00003AFD C3                          ret
  6992                                  
  6993                                  lshift_:                            ; ( u c -- u' )   shift TOS left by c bits 
  6994 00003AFE 89C1                        mov ecx, _TOS_
  6995                                      _DROP_
   148 00003B00 AD                  <1>  lodsd
  6996 00003B01 D3E0                        shl _TOS_, cl
  6997 00003B03 C3                          ret
  6998                                  %if 0
  6999                                  ; untested!!!
  7000                                  mod_:                               ; ( n1 n2 -- n3 )
  7001                                     mov _TOS_, [ esi ]               ; get dividend
  7002                                     cdq                              ; sign extend dividend
  7003                                     idiv _SCRATCH_                   ; do the divide
  7004                                     add esi, 4                       ; clean up stack
  7005                                     mov _TOS_, edx                   ; and return remainder in tos
  7006                                     ret
  7007                                  
  7008                                  %endif
  7009                                  
  7010                                  ; "idiv ecx" divides the signed double dividend EDX:EAX, by the divisor in ECX 
  7011                                  ; and stores the remainder in EDX and quotient in EAX  
  7012                                  slash_mod_:                         ; /mod ( n1 n2 -- r q )
  7013 00003B04 89C1                       mov ecx, _TOS_                   ; get n2 the divisor
  7014 00003B06 8B06                       mov _TOS_, [ esi ]               ; get n1 the dividend
  7015 00003B08 99                         cdq                              ; sign extend into edx
  7016 00003B09 F7F9                       idiv ecx                         ; do the divide
  7017 00003B0B 8916                       mov [ esi ], edx                 ; and remainder to stack
  7018 00003B0D C3                         ret 
  7019                                  
  7020                                  ; "imul ecx" multiplies ECX by EAX and stores the result in EDX:EAX
  7021                                  ; ToDo: fix and test this properly...
  7022                                  star_slash_mod_:                    ; */mod ( n1 n2 n3 -- r q )
  7023 00003B0E 50                         push _TOS_
  7024 00003B0F 8B0E                       mov ecx, [ esi ]                 ; get n2
  7025 00003B11 8B4604                     mov _TOS_, [ esi + 4 ]           ; get n1
  7026 00003B14 F7E9                       imul ecx                         ; n1*n2 => edx:eax
  7027 00003B16 81C604000000               add esi, 4                       ; clean up stack
  7028 00003B1C 59                         pop ecx
  7029 00003B1D F7F9                       idiv ecx                         ; n1*n2/n3
  7030 00003B1F 8916                       mov [ esi ], edx                 ; remainder to stack
  7031 00003B21 C3                         ret
  7032                                  
  7033                                  star_slash_:                        ; */ ( n1 n2 n3 -- n )
  7034 00003B22 50                         push _TOS_
  7035 00003B23 8B0E                       mov ecx, [ esi ]                 ; get n2
  7036 00003B25 8B4604                     mov _TOS_, [ esi + 4 ]           ; get n1
  7037 00003B28 F7E9                       imul ecx                         ; n1*n2 => edx:eax
  7038 00003B2A 81C608000000               add esi, 8                       ; clean up stack
  7039 00003B30 59                         pop ecx
  7040 00003B31 F7F9                       idiv ecx                         ; n1*n2/n3
  7041 00003B33 C3                         ret
  7042                                  
  7043                                  ; U*/  is an unsigned  */  with the twist of rounding up
  7044                                  ; It adds one less than the divisor ( u3 ) to the dividend before dividing
  7045                                  ; ToDo: fix and test this properly...
  7046                                  u_star_slash_:                      ; U*/ ( u1 u2 u3 -- u )
  7047 00003B34 89C3                       mov _SCRATCH_, _TOS_
  7048 00003B36 4B                         dec _SCRATCH_                    ; divisor
  7049 00003B37 8B0E                       mov ecx, [ esi ]                 ; get n2
  7050 00003B39 8B5604                     mov edx, [ esi + 4 ]             ; get n1
  7051 00003B3C F7E1                       mul ecx                          ; u1 * u2
  7052 00003B3E 01D8                       add _TOS_, _SCRATCH_               ; round up
  7053 00003B40 81D200000000               adc edx, 0                       ;
  7054 00003B46 43                         inc _SCRATCH_                    ; restore the original u3 divisor
  7055 00003B47 F7F3                       div _SCRATCH_                    ; do the division
  7056 00003B49 81C608000000               add esi, 8                       ; clean up stack
  7057 00003B4F C3                         ret
  7058                                  
  7059                                  cmove_:                             ; ( from to count -- )
  7060 00003B50 85C0                        test _TOS_, _TOS_
  7061 00003B52 7410                        jz .forward
  7062 00003B54 89C3                            mov _SCRATCH_, _TOS_
  7063 00003B56 8B16                            mov edx, [ esi + 0 ]
  7064 00003B58 8B4E04                          mov ecx, [ esi + 0x04 ]
  7065                                          .back:
  7066 00003B5B 8A01                                mov byte al, [ ecx + 0 ]
  7067 00003B5D 8802                                mov byte [ edx + 0 ], al
  7068 00003B5F 41                                  inc ecx
  7069 00003B60 42                                  inc edx
  7070 00003B61 4B                                  dec _SCRATCH_
  7071 00003B62 75F7                            jnz .back
  7072                                      .forward:
  7073 00003B64 8B4608                      mov _TOS_, [ esi + 0x08 ]
  7074 00003B67 81C60C000000                add esi, 0x0C
  7075 00003B6D C3                          ret
  7076                                  
  7077                                  two_star_:                          ; 2* ( u -- u' )    u' = 2 * u
  7078 00003B6E D1E0                        shl _TOS_, 1
  7079 00003B70 C3                          ret
  7080                                  
  7081                                  two_star_star_:                     ; 2** ( c -- u )    u  = 2 ** c
  7082 00003B71 89C1                        mov ecx, _TOS_
  7083 00003B73 B801000000                  mov _TOS_, 0x00000001
  7084 00003B78 D3E0                        shl _TOS_, cl
  7085 00003B7A C3                          ret
  7086                                  
  7087                                  ; *****************************************************************************
  7088                                  ; Random and Pseudo Random Number Generators
  7089                                  ; *****************************************************************************
  7090                                  
  7091                                  GetCPUIDsupport:    ; ( -- )  equal flag is set if no CPUID support
  7092                                      ; check to see if CPUID is supported
  7093 00003B7B 9C                          pushfd              ; save EFLAGS
  7094 00003B7C 58                          pop eax             ; store EFLAGS in EAX
  7095 00003B7D 89C3                        mov ebx, eax        ; save in EBX for later testing
  7096 00003B7F 3500002000                  xor eax, 00200000h  ; toggle bit 21
  7097 00003B84 50                          push eax            ; push to stack
  7098 00003B85 9D                          popfd               ; save changed EAX to EFLAGS
  7099 00003B86 9C                          pushfd              ; push EFLAGS to TOS
  7100 00003B87 58                          pop eax             ; store EFLAGS in EAX
  7101 00003B88 39D8                        cmp eax, ebx        ; see if bit 21 has changed
  7102 00003B8A C3                          ret
  7103                                  
  7104                                  GetRDRANDsupport:   ; zero flag is set if no support for RDRAND, the hardware Random Number generator
  7105 00003B8B B801000000                  mov _TOS_, 0x00000001     ; select the 'features' CPU information
  7106 00003B90 0FA2                        CPUID           ; get CPU information into eax, ebx, ecx and edx
  7107 00003B92 A900000040                  test eax, 0x40000000 ; Bit 30 of ECX returned by CPUID => RDRAND present if true
  7108 00003B97 C3                          ret
  7109                                  
  7110                                  GetCPUID_:   ; ( -- u )
  7111                                      _DUP_
   132 00003B98 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003B9B 8906                <1>  mov [ esi ], _TOS_
  7112 00003B9D B801000000                  mov _TOS_, 0x00000001     ; select the 'features' CPU information
  7113 00003BA2 0FA2                        CPUID           ; get CPU information into eax, ebx, ecx and edx
  7114 00003BA4 C3                          ret
  7115                                  
  7116                                  rdtsc_:  ; ( -- u )   \ return the current processor instruction counter
  7117                                      _DUP_
   132 00003BA5 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003BA8 8906                <1>  mov [ esi ], _TOS_
  7118 00003BAA 0F31                        rdtsc ; db 0x0F, 0x31
  7119 00003BAC C3                          ret
  7120                                  
  7121                                  randInit_:
  7122 00003BAD E8F3FFFFFF                  call rdtsc_
  7123 00003BB2 55                          push ebp
  7124 00003BB3 BD[1C480000]                mov ebp, v_random
  7125 00003BB8 314500                      xor [ ebp ], _TOS_      ; vRandom ! , if the value was 0
  7126 00003BBB 5D                          pop ebp
  7127                                      _DROP_
   148 00003BBC AD                  <1>  lodsd
  7128 00003BBD C3                          ret
  7129                                  
  7130                                  %if 0
  7131                                  \ Marsaglia, "Xorshift RNGs".  http://www.jstatsoft.org/v08/i14/paper
  7132                                  : Random32 ( -- u )
  7133                                      vRandom @
  7134                                      dup 0= or
  7135                                      dup 6 lshift xor
  7136                                      dup 21 rshift xor
  7137                                      dup 7 lshift xor
  7138                                      dup vRandom ! ;
  7139                                  %endif
  7140                                  
  7141                                  ; \ Marsaglia, "Xorshift RNGs".  http://www.jstatsoft.org/v08/i14/paper
  7142                                  getRandMarsaglia: ; ( -- u )   \ load a 32 bit pseudo random number into TOS
  7143                                      _DUP_
   132 00003BBE 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003BC1 8906                <1>  mov [ esi ], _TOS_
  7144 00003BC3 55                          push ebp
  7145 00003BC4 BD[1C480000]                mov ebp, v_random
  7146 00003BC9 8B4500                      mov _TOS_, [ ebp ]      ; vRandom @
  7147 00003BCC 85C0                        test _TOS_, _TOS_
  7148 00003BCE 7505                        jnz .forward            ; dup 0= or
  7149 00003BD0 B8FFFFFFFF                      mov _TOS_, 0xFFFFFFFF
  7150                                      .forward:
  7151                                  
  7152 00003BD5 89C3                        mov _SCRATCH_, _TOS_    ; dup 6 lshift xor
  7153 00003BD7 C1E306                      shl _SCRATCH_, 0x06
  7154 00003BDA 31D8                        xor _TOS_, _SCRATCH_
  7155                                  
  7156 00003BDC 89C3                        mov _SCRATCH_, _TOS_    ; dup 21 rshift xor
  7157 00003BDE C1EB15                      shr _SCRATCH_, 0x15
  7158 00003BE1 31D8                        xor _TOS_, _SCRATCH_
  7159                                  
  7160 00003BE3 89C3                        mov _SCRATCH_, _TOS_    ; dup 7 lshift xor
  7161 00003BE5 C1E307                      shl _SCRATCH_, 0x07
  7162 00003BE8 31D8                        xor _TOS_, _SCRATCH_
  7163                                  
  7164 00003BEA 894500                      mov [ ebp ], _TOS_      ; vRandom !
  7165                                  
  7166 00003BED 5D                          pop ebp
  7167 00003BEE C3                          ret
  7168                                  
  7169                                  rand_:  ; ( -- u )   \ load a 32 bit true random number into TOS
  7170                                      _DUP_
   132 00003BEF 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003BF2 8906                <1>  mov [ esi ], _TOS_
  7171 00003BF4 E882FFFFFF                  call GetCPUIDsupport
  7172 00003BF9 740B                        je .NO_CPUID             ; if no change to bit 21, no CPUID
  7173                                          ; CPUID is supported, so check if RDRAND is supported
  7174 00003BFB E88BFFFFFF                      call GetRDRANDsupport
  7175 00003C00 7404                            jz .NO_CPUID         ; test for RDRAND support
  7176 00003C02 0FC7F0                              RDRAND _TOS_    ; supported, so call the instruction
  7177 00003C05 C3                                  ret
  7178                                      .NO_CPUID:
  7179                                      _DROP_
   148 00003C06 AD                  <1>  lodsd
  7180 00003C07 E8B2FFFFFF                  call getRandMarsaglia
  7181 00003C0C C3                          ret
  7182                                  
  7183                                  randq_:     ; ( -- f )   \ returns true if the processor supports the RDRAND random number instruction
  7184                                      _DUP_
   132 00003C0D 8D76FC              <1>  lea esi, [ esi - 4 ]
   133                              <1> 
   134 00003C10 8906                <1>  mov [ esi ], _TOS_
  7185 00003C12 E864FFFFFF                  call GetCPUIDsupport
  7186 00003C17 740D                        jz .NO_CPUID             ; if no change, no CPUID
  7187                                          ; CPUID is supported, so check if RDRAND is supported
  7188 00003C19 E86DFFFFFF                      call GetRDRANDsupport
  7189 00003C1E 7406                            jz .NO_CPUID         ; test for RDRAND support
  7190 00003C20 B8FFFFFFFF                          mov _TOS_, 0xFFFFFFFF
  7191 00003C25 C3                              ret
  7192                                      .NO_CPUID:
  7193 00003C26 31C0                        xor _TOS_, _TOS_
  7194 00003C28 C3                          ret
  7195                                  
  7196                                  ; *****************************************************************************
  7197                                  ; CRC32 Cyclic Redundancy Checksum (32 bit)
  7198                                  ; The International Standard 32-bit cyclical redundancy check defined by :
  7199                                  ; [ITU-T-V42] International Telecommunications Union, "Error-correcting
  7200                                  ; Procedures for DCEs Using Asynchronous-to-Synchronous Conversion",
  7201                                  ; ITU-T Recommendation V.42, 1994, Rev. 1.
  7202                                  ; and
  7203                                  ; [ISO-3309]
  7204                                  ; International Organization for Standardization,
  7205                                  ; "Information Processing Systems--Data Communication High-Level Data Link
  7206                                  ; Control Procedure--Frame Structure", IS 3309, October 1984, 3rd Edition.
  7207                                  ; *****************************************************************************
  7208                                  
  7209                                  crc32_table:
  7210 00003C29 00000000963007772C-         dd 000000000h, 077073096h, 0EE0E612Ch, 0990951BAh, 0076DC419h, 0706AF48Fh, 0E963A535h, 09E6495A3h, 00EDB8832h, 079DCB8A4h
  7210 00003C32 610EEEBA51099919C4-
  7210 00003C3B 6D078FF46A7035A563-
  7210 00003C44 E9A395649E3288DB0E-
  7210 00003C4D A4B8DC79           
  7211 00003C51 1EE9D5E088D9D2972B-         dd 0E0D5E91Eh, 097D2D988h, 009B64C2Bh, 07EB17CBDh, 0E7B82D07h, 090BF1D91h, 01DB71064h, 06AB020F2h, 0F3B97148h, 084BE41DEh
  7211 00003C5A 4CB609BD7CB17E072D-
  7211 00003C63 B8E7911DBF906410B7-
  7211 00003C6C 1DF220B06A4871B9F3-
  7211 00003C75 DE41BE84           
  7212 00003C79 7DD4DA1AEBE4DD6D51-         dd 01ADAD47Dh, 06DDDE4EBh, 0F4D4B551h, 083D385C7h, 0136C9856h, 0646BA8C0h, 0FD62F97Ah, 08A65C9ECh, 014015C4Fh, 063066CD9h
  7212 00003C82 B5D4F4C785D3835698-
  7212 00003C8B 6C13C0A86B647AF962-
  7212 00003C94 FDECC9658A4F5C0114-
  7212 00003C9D D96C0663           
  7213 00003CA1 633D0FFAF50D088DC8-         dd 0FA0F3D63h, 08D080DF5h, 03B6E20C8h, 04C69105Eh, 0D56041E4h, 0A2677172h, 03C03E4D1h, 04B04D447h, 0D20D85FDh, 0A50AB56Bh
  7213 00003CAA 206E3B5E10694CE441-
  7213 00003CB3 60D5727167A2D1E403-
  7213 00003CBC 3C47D4044BFD850DD2-
  7213 00003CC5 6BB50AA5           
  7214 00003CC9 FAA8B5356C98B242D6-         dd 035B5A8FAh, 042B2986Ch, 0DBBBC9D6h, 0ACBCF940h, 032D86CE3h, 045DF5C75h, 0DCD60DCFh, 0ABD13D59h, 026D930ACh, 051DE003Ah
  7214 00003CD2 C9BBDB40F9BCACE36C-
  7214 00003CDB D832755CDF45CF0DD6-
  7214 00003CE4 DC593DD1ABAC30D926-
  7214 00003CED 3A00DE51           
  7215 00003CF1 8051D7C81661D0BFB5-         dd 0C8D75180h, 0BFD06116h, 021B4F4B5h, 056B3C423h, 0CFBA9599h, 0B8BDA50Fh, 02802B89Eh, 05F058808h, 0C60CD9B2h, 0B10BE924h
  7215 00003CFA F4B42123C4B3569995-
  7215 00003D03 BACF0FA5BDB89EB802-
  7215 00003D0C 280888055FB2D90CC6-
  7215 00003D15 24E90BB1           
  7216 00003D19 877C6F2F114C6858AB-         dd 02F6F7C87h, 058684C11h, 0C1611DABh, 0B6662D3Dh, 076DC4190h, 001DB7106h, 098D220BCh, 0EFD5102Ah, 071B18589h, 006B6B51Fh
  7216 00003D22 1D61C13D2D66B69041-
  7216 00003D2B DC760671DB01BC20D2-
  7216 00003D34 982A10D5EF8985B171-
  7216 00003D3D 1FB5B606           
  7217 00003D41 A5E4BF9F33D4B8E8A2-         dd 09FBFE4A5h, 0E8B8D433h, 07807C9A2h, 00F00F934h, 09609A88Eh, 0E10E9818h, 07F6A0DBBh, 0086D3D2Dh, 091646C97h, 0E6635C01h
  7217 00003D4A C9077834F9000F8EA8-
  7217 00003D53 099618980EE1BB0D6A-
  7217 00003D5C 7F2D3D6D08976C6491-
  7217 00003D65 015C63E6           
  7218 00003D69 F4516B6B62616C1CD8-         dd 06B6B51F4h, 01C6C6162h, 0856530D8h, 0F262004Eh, 06C0695EDh, 01B01A57Bh, 08208F4C1h, 0F50FC457h, 065B0D9C6h, 012B7E950h
  7218 00003D72 3065854E0062F2ED95-
  7218 00003D7B 066C7BA5011BC1F408-
  7218 00003D84 8257C40FF5C6D9B065-
  7218 00003D8D 50E9B712           
  7219 00003D91 EAB8BE8B7C88B9FCDF-         dd 08BBEB8EAh, 0FCB9887Ch, 062DD1DDFh, 015DA2D49h, 08CD37CF3h, 0FBD44C65h, 04DB26158h, 03AB551CEh, 0A3BC0074h, 0D4BB30E2h
  7219 00003D9A 1DDD62492DDA15F37C-
  7219 00003DA3 D38C654CD4FB5861B2-
  7219 00003DAC 4DCE51B53A7400BCA3-
  7219 00003DB5 E230BBD4           
  7220 00003DB9 41A5DF4AD795D83D6D-         dd 04ADFA541h, 03DD895D7h, 0A4D1C46Dh, 0D3D6F4FBh, 04369E96Ah, 0346ED9FCh, 0AD678846h, 0DA60B8D0h, 044042D73h, 033031DE5h
  7220 00003DC2 C4D1A4FBF4D6D36AE9-
  7220 00003DCB 6943FCD96E34468867-
  7220 00003DD4 ADD0B860DA732D0444-
  7220 00003DDD E51D0333           
  7221 00003DE1 5F4C0AAAC97C0DDD3C-         dd 0AA0A4C5Fh, 0DD0D7CC9h, 05005713Ch, 0270241AAh, 0BE0B1010h, 0C90C2086h, 05768B525h, 0206F85B3h, 0B966D409h, 0CE61E49Fh
  7221 00003DEA 710550AA4102271010-
  7221 00003DF3 0BBE86200CC925B568-
  7221 00003DFC 57B3856F2009D466B9-
  7221 00003E05 9FE461CE           
  7222 00003E09 0EF9DE5E98C9D92922-         dd 05EDEF90Eh, 029D9C998h, 0B0D09822h, 0C7D7A8B4h, 059B33D17h, 02EB40D81h, 0B7BD5C3Bh, 0C0BA6CADh, 0EDB88320h, 09ABFB3B6h
  7222 00003E12 98D0B0B4A8D7C7173D-
  7222 00003E1B B359810DB42E3B5CBD-
  7222 00003E24 B7AD6CBAC02083B8ED-
  7222 00003E2D B6B3BF9A           
  7223 00003E31 0CE2B6039AD2B17439-         dd 003B6E20Ch, 074B1D29Ah, 0EAD54739h, 09DD277AFh, 004DB2615h, 073DC1683h, 0E3630B12h, 094643B84h, 00D6D6A3Eh, 07A6A5AA8h
  7223 00003E3A 47D5EAAF77D29D1526-
  7223 00003E43 DB048316DC73120B63-
  7223 00003E4C E3843B64943E6A6D0D-
  7223 00003E55 A85A6A7A           
  7224 00003E59 0BCF0EE49DFF099327-         dd 0E40ECF0Bh, 09309FF9Dh, 00A00AE27h, 07D079EB1h, 0F00F9344h, 08708A3D2h, 01E01F268h, 06906C2FEh, 0F762575Dh, 0806567CBh
  7224 00003E62 AE000AB19E077D4493-
  7224 00003E6B 0FF0D2A3088768F201-
  7224 00003E74 1EFEC206695D5762F7-
  7224 00003E7D CB676580           
  7225 00003E81 71366C19E7066B6E76-         dd 0196C3671h, 06E6B06E7h, 0FED41B76h, 089D32BE0h, 010DA7A5Ah, 067DD4ACCh, 0F9B9DF6Fh, 08EBEEFF9h, 017B7BE43h, 060B08ED5h
  7225 00003E8A 1BD4FEE02BD3895A7A-
  7225 00003E93 DA10CC4ADD676FDFB9-
  7225 00003E9C F9F9EFBE8E43BEB717-
  7225 00003EA5 D58EB060           
  7226 00003EA9 E8A3D6D67E93D1A1C4-         dd 0D6D6A3E8h, 0A1D1937Eh, 038D8C2C4h, 04FDFF252h, 0D1BB67F1h, 0A6BC5767h, 03FB506DDh, 048B2364Bh, 0D80D2BDAh, 0AF0A1B4Ch
  7226 00003EB2 C2D83852F2DF4FF167-
  7226 00003EBB BBD16757BCA6DD06B5-
  7226 00003EC4 3F4B36B248DA2B0DD8-
  7226 00003ECD 4C1B0AAF           
  7227 00003ED1 F64A0336607A0441C3-         dd 036034AF6h, 041047A60h, 0DF60EFC3h, 0A867DF55h, 0316E8EEFh, 04669BE79h, 0CB61B38Ch, 0BC66831Ah, 0256FD2A0h, 05268E236h
  7227 00003EDA EF60DF55DF67A8EF8E-
  7227 00003EE3 6E3179BE69468CB361-
  7227 00003EEC CB1A8366BCA0D26F25-
  7227 00003EF5 36E26852           
  7228 00003EF9 95770CCC03470BBBB9-         dd 0CC0C7795h, 0BB0B4703h, 0220216B9h, 05505262Fh, 0C5BA3BBEh, 0B2BD0B28h, 02BB45A92h, 05CB36A04h, 0C2D7FFA7h, 0B5D0CF31h
  7228 00003F02 1602222F260555BE3B-
  7228 00003F0B BAC5280BBDB2925AB4-
  7228 00003F14 2B046AB35CA7FFD7C2-
  7228 00003F1D 31CFD0B5           
  7229 00003F21 8B9ED92C1DAEDE5BB0-         dd 02CD99E8Bh, 05BDEAE1Dh, 09B64C2B0h, 0EC63F226h, 0756AA39Ch, 0026D930Ah, 09C0906A9h, 0EB0E363Fh, 072076785h, 005005713h
  7229 00003F2A C2649B26F263EC9CA3-
  7229 00003F33 6A750A936D02A90609-
  7229 00003F3C 9C3F360EEB85670772-
  7229 00003F45 13570005           
  7230 00003F49 824ABF95147AB8E2AE-         dd 095BF4A82h, 0E2B87A14h, 07BB12BAEh, 00CB61B38h, 092D28E9Bh, 0E5D5BE0Dh, 07CDCEFB7h, 00BDBDF21h, 086D3D2D4h, 0F1D4E242h
  7230 00003F52 2BB17B381BB60C9B8E-
  7230 00003F5B D2920DBED5E5B7EFDC-
  7230 00003F64 7C21DFDB0BD4D2D386-
  7230 00003F6D 42E2D4F1           
  7231 00003F71 F8B3DD686E83DA1FCD-         dd 068DDB3F8h, 01FDA836Eh, 081BE16CDh, 0F6B9265Bh, 06FB077E1h, 018B74777h, 088085AE6h, 0FF0F6A70h, 066063BCAh, 011010B5Ch
  7231 00003F7A 16BE815B26B9F6E177-
  7231 00003F83 B06F7747B718E65A08-
  7231 00003F8C 88706A0FFFCA3B0666-
  7231 00003F95 5C0B0111           
  7232 00003F99 FF9E658F69AE62F8D3-         dd 08F659EFFh, 0F862AE69h, 0616BFFD3h, 0166CCF45h, 0A00AE278h, 0D70DD2EEh, 04E048354h, 03903B3C2h, 0A7672661h, 0D06016F7h
  7232 00003FA2 FF6B6145CF6C1678E2-
  7232 00003FAB 0AA0EED20DD7548304-
  7232 00003FB4 4EC2B30339612667A7-
  7232 00003FBD F71660D0           
  7233 00003FC1 4D476949DB776E3E4A-         dd 04969474Dh, 03E6E77DBh, 0AED16A4Ah, 0D9D65ADCh, 040DF0B66h, 037D83BF0h, 0A9BCAE53h, 0DEBB9EC5h, 047B2CF7Fh, 030B5FFE9h
  7233 00003FCA 6AD1AEDC5AD6D9660B-
  7233 00003FD3 DF40F03BD83753AEBC-
  7233 00003FDC A9C59EBBDE7FCFB247-
  7233 00003FE5 E9FFB530           
  7234 00003FE9 1CF2BDBD8AC2BACA30-         dd 0BDBDF21Ch, 0CABAC28Ah, 053B39330h, 024B4A3A6h, 0BAD03605h, 0CDD70693h, 054DE5729h, 023D967BFh, 0B3667A2Eh, 0C4614AB8h
  7234 00003FF2 93B353A6A3B4240536-
  7234 00003FFB D0BA9306D7CD2957DE-
  7234 00004004 54BF67D9232E7A66B3-
  7234 0000400D B84A61C4           
  7235 00004011 021B685D942B6F2A37-         dd 05D681B02h, 02A6F2B94h, 0B40BBE37h, 0C30C8EA1h, 05A05DF1Bh, 02D02EF8Dh
  7235 0000401A BE0BB4A18E0CC31BDF-
  7235 00004023 055A8DEF022D       
  7236                                  
  7237                                  ; CRC-32 with polynomial $04c11db7, as specified in IEEE 802.3 ( Ethernet )
  7238                                   crc32_:    ; ( a n -- u )   \ CRC32 Cyclic Redundancy Checksum
  7239 00004029 53                          push    _SCRATCH_
  7240 0000402A 51                          push    ecx
  7241 0000402B 52                          push    edx
  7242                                  
  7243 0000402C 89C1                        mov ecx, _TOS_
  7244                                      _DROP_
   148 0000402E AD                  <1>  lodsd
  7245 0000402F 89C3                        mov _SCRATCH_, _TOS_
  7246                                      ; address in ebx, count in ecx, result in eax
  7247                                  
  7248 00004031 31D2                        xor edx, edx
  7249                                  
  7250 00004033 B8FFFFFFFF                  mov  _TOS_, 0xFFFFFFFF     ; initial CRC value
  7251                                  
  7252 00004038 85C9                        test ecx, ecx
  7253 0000403A 7414                        jz .forward
  7254                                  
  7255                                          .back:
  7256 0000403C 8A13                            mov dl, byte [_SCRATCH_]
  7257 0000403E 30C2                            xor dl, al
  7258 00004040 C1E808                          shr _TOS_, 8
  7259 00004043 330495[293C0000]                xor _TOS_, dword [ crc32_table + ( 4 * edx ) ]
  7260 0000404A 43                              inc _SCRATCH_
  7261 0000404B 49                              dec ecx
  7262 0000404C 75EE                            jnz .back
  7263                                  
  7264 0000404E F7D0                            not _TOS_     ; invert the final CRC value
  7265                                      .forward:
  7266                                  
  7267 00004050 5A                          pop edx
  7268 00004051 59                          pop ecx
  7269 00004052 5B                          pop _SCRATCH_
  7270 00004053 C3                          ret
  7271                                  
  7272                                  ; *****************************************************************************
  7273                                  ; MD5
  7274                                  ; *****************************************************************************
  7275                                  
  7276                                  ; From : https://github.com/rwfpl/rewolf-md5/blob/master/nasm/rewolf_md5.inc
  7277                                  
  7278                                  ;----------------------------------------------------------------------------
  7279                                  ;|                     The MD5 Message-Digest Algorithm                     |
  7280                                  ;----------------------------------------------------------------------------
  7281                                  ;|   Description:                                                           |
  7282                                  ;|   ============                                                           |
  7283                                  ;|                                                                          |
  7284                                  ;|   The MD5 algorithm is designed to be quite fast on 32-bit machines. In  |
  7285                                  ;|   addition,  the MD5 algorithm  does not require any large substitution  |
  7286                                  ;|   tables, the algorithm can be coded quite compactly.                    |
  7287                                  ;|                                                                          |
  7288                                  ;|   The MD5 algorithm is an extension of the MD4 message-digest algorithm  |
  7289                                  ;|   1,2]. MD5 is  slightly slower than MD4, but is more "conservative" in  |
  7290                                  ;|   design. MD5  was designed  because it  was felt  that MD4 was perhaps  |
  7291                                  ;|   being adopted  for use more  quickly than  justified by  the existing  |
  7292                                  ;|   critical  review, because MD4  was designed to be exceptionally fast,  |
  7293                                  ;|   it  is "at the edge"  in terms of  risking  successful  cryptanalytic  |
  7294                                  ;|   attack.  MD5 backs off  a bit, giving up a little in speed for a much  |
  7295                                  ;|   greater   likelihood  of  ultimate  security.  It  incorporates  some  |
  7296                                  ;|   suggestions  made  by  various  reviewers,  and  contains  additional  |
  7297                                  ;|   optimizations. The MD5 algorithm is being placed in the public domain  |
  7298                                  ;|   for review and possible adoption as a standard.                        |
  7299                                  ;|                                                                          |
  7300                                  ;----------------------------------------------------------------------------
  7301                                  ;|   Implementation based on rfc1321 (fully rewritten in asm, not ripped :))|
  7302                                  ;----------------------------------------------------------------------------
  7303                                  ;|   Usage:                                                                 |
  7304                                  ;|   ======                                                                 |
  7305                                  ;|                                                                          |
  7306                                  ;|   Simply include this file to your project:                              |
  7307                                  ;|   exp: include \..path..\rewolf_md5.inc                                  |
  7308                                  ;|                                                                          |
  7309                                  ;|   Target compiler...: NASM-YASM                                          |
  7310                                  ;|   Calling convention:                                                    |
  7311                                  ;|                                                                          |
  7312                                  ;|       push    size of datablock                                          |
  7313                                  ;|       push    datablock                                                  |
  7314                                  ;|       push    destHash                                                   |
  7315                                  ;|       call    _rwf_md5                                                   |
  7316                                  ;|                                                                          |
  7317                                  ;|   datablock -> (input)  -> buffer that contains data to hash             |
  7318                                  ;|   destHash  -> (output) -> 16-bytes buffer for hashed data               |
  7319                                  ;|                                                                          |
  7320                                  ;|   Modified registers: none                                               |
  7321                                  ;|   Stack is automatically cleared                                         |
  7322                                  ;----------------------------------------------------------------------------
  7323                                  ;|   Coder.: ReWolf^HTB                                                     |
  7324                                  ;|   Date..: 17.XII.2004                                                    |
  7325                                  ;|   E-mail: rewolf@poczta.onet.pl                                          |
  7326                                  ;|   WWW...: http://www.rewolf.prv.pl                                       |
  7327                                  ;----------------------------------------------------------------------------
  7328                                  ;|   Adaptation for NASM/YASM:  Ange Albertini                              |
  7329                                  ;----------------------------------------------------------------------------
  7330                                  
  7331                                  S11 equ 7
  7332                                  S12 equ 12
  7333                                  S13 equ 17
  7334                                  S14 equ 22
  7335                                  S21 equ 5
  7336                                  S22 equ 9
  7337                                  S23 equ 14
  7338                                  S24 equ 20
  7339                                  S31 equ 4
  7340                                  S32 equ 11
  7341                                  S33 equ 16
  7342                                  S34 equ 23
  7343                                  S41 equ 6
  7344                                  S42 equ 10
  7345                                  S43 equ 15
  7346                                  S44 equ 21
  7347                                  
  7348                                  %macro FF 7 ;a,b,c,d,k,s,i
  7349                                      mov edi,%2
  7350                                      mov ebp,%2
  7351                                      and edi,%3
  7352                                      not ebp
  7353                                      and ebp,%4
  7354                                      or  edi,ebp
  7355                                      lea %1, [%1+edi+%7]
  7356                                      add %1, dword [esi+%5*4]
  7357                                      rol %1,%6
  7358                                      add %1,%2
  7359                                  %endmacro
  7360                                  
  7361                                  %macro GG 7
  7362                                      mov edi,%4
  7363                                      mov ebp,%4
  7364                                      and edi,%2
  7365                                      not ebp
  7366                                      and ebp,%3
  7367                                      or  edi,ebp
  7368                                      lea %1, [%1+edi+%7]
  7369                                      add %1, dword [esi+%5*4]
  7370                                      rol %1,%6
  7371                                      add %1,%2
  7372                                  %endmacro
  7373                                  
  7374                                  %macro  HH  7
  7375                                      mov ebp,%2
  7376                                      xor ebp,%3
  7377                                      xor ebp,%4
  7378                                      lea %1, [%1+ebp+%7]
  7379                                      add %1,dword [esi+%5*4]
  7380                                      rol %1,%6
  7381                                      add %1,%2
  7382                                  %endmacro
  7383                                  
  7384                                  %macro  II  7
  7385                                      mov ebp,%4
  7386                                      not ebp
  7387                                      or  ebp,%2
  7388                                      xor ebp,%3
  7389                                      lea %1, [%1+ebp+%7]
  7390                                      add %1,dword [esi+%5*4]
  7391                                      rol %1,%6
  7392                                      add %1,%2
  7393                                  %endmacro
  7394                                  
  7395                                  ;|       push    size of datablock                                          |
  7396                                  ;|       push    datablock                                                  |
  7397                                  ;|       push    destHash
  7398                                  md5_:    ; ( a n -- md5_address )
  7399 00004054 50                          push _TOS_      ; [ a -- ]
  7400                                      _DROP_
   148 00004055 AD                  <1>  lodsd
  7401 00004056 50                          push _TOS_  ; [ a n -- ]
  7402 00004057 BB40170000                  mov _SCRATCH_, MD5_OUTPUT_BUFFER
  7403 0000405C 53                          push _SCRATCH_  ; [ a n md5_output -- ]
  7404 0000405D E806000000                  call _rwf_md5
  7405 00004062 B840170000                  mov _TOS_, MD5_OUTPUT_BUFFER
  7406 00004067 C3                          ret
  7407                                  
  7408                                  _rwf_md5:   ; ( a n outputPtr 0 -- )
  7409 00004068 60                          pushad
  7410 00004069 8B742424                    mov esi,dword [esp+04h+8*4]
  7411 0000406D C70601234567                mov dword [esi], 067452301h
  7412 00004073 C7460489ABCDEF              mov dword [esi+04h], 0efcdab89h
  7413 0000407A C74608FEDCBA98              mov dword [esi+08h], 098badcfeh
  7414 00004081 C7460C76543210              mov dword [esi+0Ch], 010325476h
  7415 00004088 8B44242C                    mov eax,dword [esp+0Ch+8*4]
  7416 0000408C 50                          push eax
  7417 0000408D 31D2                        xor edx,edx
  7418 0000408F B940000000                  mov ecx,64
  7419 00004094 F7F1                        div ecx
  7420 00004096 40                          inc eax
  7421 00004097 5A                          pop edx
  7422 00004098 81EC40000000                sub esp,64
  7423 0000409E 89E3                        mov ebx,esp
  7424 000040A0 8B742468                    mov esi,dword [esp+08h+24*4]
  7425 000040A4 92                          xchg    eax,edx
  7426                                  _n0:
  7427 000040A5 89DF                        mov edi,ebx
  7428 000040A7 4A                          dec edx
  7429 000040A8 7549                        jne _n1
  7430 000040AA 85C0                        test eax,eax
  7431 000040AC 7809                        js  _nD
  7432 000040AE C6040380                    mov byte [ebx+eax],80h
  7433 000040B2 E903000000                  jmp _nC
  7434                                  _nD:
  7435 000040B7 31C0                        xor eax,eax
  7436 000040B9 48                          dec eax
  7437                                  _nC:
  7438 000040BA B940000000                  mov ecx,64
  7439 000040BF 29C1                        sub ecx,eax
  7440 000040C1 01C7                        add edi,eax
  7441 000040C3 50                          push eax
  7442 000040C4 31C0                        xor eax,eax
  7443 000040C6 47                          inc edi
  7444 000040C7 49                          dec ecx
  7445 000040C8 F3AA                        rep stosb
  7446 000040CA 58                          pop eax
  7447 000040CB 85C0                        test eax,eax
  7448 000040CD 7807                        js  _nB
  7449 000040CF 3D38000000                  cmp eax,56
  7450 000040D4 731C                        jnb _nE
  7451                                  _nB:
  7452 000040D6 50                          push eax
  7453 000040D7 8B442470                    mov eax,dword [esp+0Ch+25*4]
  7454 000040DB 52                          push edx
  7455 000040DC 31D2                        xor edx,edx
  7456 000040DE B908000000                  mov ecx,8
  7457 000040E3 F7E1                        mul ecx
  7458 000040E5 894338                      mov dword [ebx+56],eax
  7459 000040E8 89533C                      mov dword [ebx+60],edx
  7460 000040EB 5A                          pop edx
  7461 000040EC 58                          pop eax
  7462 000040ED E901000000                  jmp _n1
  7463                                  _nE:
  7464 000040F2 42                          inc edx
  7465                                  _n1:
  7466 000040F3 85C0                        test eax,eax
  7467 000040F5 780C                        js  _nA
  7468 000040F7 3D40000000                  cmp eax,64
  7469 000040FC 730E                        jnb _n2
  7470 000040FE E902000000                  jmp _n10
  7471                                  _nA:
  7472 00004103 31C0                        xor eax,eax
  7473                                  _n10:
  7474 00004105 89C1                        mov ecx,eax
  7475 00004107 E905000000                  jmp _n3
  7476                                  _n2:
  7477 0000410C B940000000                  mov ecx,64
  7478                                  _n3:
  7479 00004111 89DF                        mov edi,ebx
  7480 00004113 F3A4                        rep movsb
  7481 00004115 50                          push eax
  7482 00004116 52                          push edx
  7483 00004117 53                          push ebx
  7484 00004118 56                          push esi
  7485 00004119 8D742410                    lea esi, [esp+10h]
  7486 0000411D 8B7C2474                    mov edi, dword [esp+4+28*4]
  7487 00004121 57                          push edi
  7488 00004122 8B07                        mov eax, dword [edi]
  7489 00004124 8B5F04                      mov ebx, dword [edi+04h]
  7490 00004127 8B4F08                      mov ecx, dword [edi+08h]
  7491 0000412A 8B570C                      mov edx, dword [edi+0Ch]
  7492                                  
  7493                                      FF  eax, ebx, ecx, edx, 0, S11, 0d76aa478h
  7349 0000412D 89DF                <1>  mov edi,%2
  7350 0000412F 89DD                <1>  mov ebp,%2
  7351 00004131 21CF                <1>  and edi,%3
  7352 00004133 F7D5                <1>  not ebp
  7353 00004135 21D5                <1>  and ebp,%4
  7354 00004137 09EF                <1>  or edi,ebp
  7355 00004139 8D843878A46AD7      <1>  lea %1, [%1+edi+%7]
  7356 00004140 0306                <1>  add %1, dword [esi+%5*4]
  7357 00004142 C1C007              <1>  rol %1,%6
  7358 00004145 01D8                <1>  add %1,%2
  7494                                      FF  edx, eax, ebx, ecx, 1, S12, 0e8c7b756h
  7349 00004147 89C7                <1>  mov edi,%2
  7350 00004149 89C5                <1>  mov ebp,%2
  7351 0000414B 21DF                <1>  and edi,%3
  7352 0000414D F7D5                <1>  not ebp
  7353 0000414F 21CD                <1>  and ebp,%4
  7354 00004151 09EF                <1>  or edi,ebp
  7355 00004153 8D943A56B7C7E8      <1>  lea %1, [%1+edi+%7]
  7356 0000415A 035604              <1>  add %1, dword [esi+%5*4]
  7357 0000415D C1C20C              <1>  rol %1,%6
  7358 00004160 01C2                <1>  add %1,%2
  7495                                      FF  ecx, edx, eax, ebx, 2, S13, 0242070dbh
  7349 00004162 89D7                <1>  mov edi,%2
  7350 00004164 89D5                <1>  mov ebp,%2
  7351 00004166 21C7                <1>  and edi,%3
  7352 00004168 F7D5                <1>  not ebp
  7353 0000416A 21DD                <1>  and ebp,%4
  7354 0000416C 09EF                <1>  or edi,ebp
  7355 0000416E 8D8C39DB702024      <1>  lea %1, [%1+edi+%7]
  7356 00004175 034E08              <1>  add %1, dword [esi+%5*4]
  7357 00004178 C1C111              <1>  rol %1,%6
  7358 0000417B 01D1                <1>  add %1,%2
  7496                                      FF  ebx, ecx, edx, eax, 3, S14, 0c1bdceeeh
  7349 0000417D 89CF                <1>  mov edi,%2
  7350 0000417F 89CD                <1>  mov ebp,%2
  7351 00004181 21D7                <1>  and edi,%3
  7352 00004183 F7D5                <1>  not ebp
  7353 00004185 21C5                <1>  and ebp,%4
  7354 00004187 09EF                <1>  or edi,ebp
  7355 00004189 8D9C3BEECEBDC1      <1>  lea %1, [%1+edi+%7]
  7356 00004190 035E0C              <1>  add %1, dword [esi+%5*4]
  7357 00004193 C1C316              <1>  rol %1,%6
  7358 00004196 01CB                <1>  add %1,%2
  7497                                      FF  eax, ebx, ecx, edx, 4, S11, 0f57c0fafh
  7349 00004198 89DF                <1>  mov edi,%2
  7350 0000419A 89DD                <1>  mov ebp,%2
  7351 0000419C 21CF                <1>  and edi,%3
  7352 0000419E F7D5                <1>  not ebp
  7353 000041A0 21D5                <1>  and ebp,%4
  7354 000041A2 09EF                <1>  or edi,ebp
  7355 000041A4 8D8438AF0F7CF5      <1>  lea %1, [%1+edi+%7]
  7356 000041AB 034610              <1>  add %1, dword [esi+%5*4]
  7357 000041AE C1C007              <1>  rol %1,%6
  7358 000041B1 01D8                <1>  add %1,%2
  7498                                      FF  edx, eax, ebx, ecx, 5, S12, 04787c62ah
  7349 000041B3 89C7                <1>  mov edi,%2
  7350 000041B5 89C5                <1>  mov ebp,%2
  7351 000041B7 21DF                <1>  and edi,%3
  7352 000041B9 F7D5                <1>  not ebp
  7353 000041BB 21CD                <1>  and ebp,%4
  7354 000041BD 09EF                <1>  or edi,ebp
  7355 000041BF 8D943A2AC68747      <1>  lea %1, [%1+edi+%7]
  7356 000041C6 035614              <1>  add %1, dword [esi+%5*4]
  7357 000041C9 C1C20C              <1>  rol %1,%6
  7358 000041CC 01C2                <1>  add %1,%2
  7499                                      FF  ecx, edx, eax, ebx, 6, S13, 0a8304613h
  7349 000041CE 89D7                <1>  mov edi,%2
  7350 000041D0 89D5                <1>  mov ebp,%2
  7351 000041D2 21C7                <1>  and edi,%3
  7352 000041D4 F7D5                <1>  not ebp
  7353 000041D6 21DD                <1>  and ebp,%4
  7354 000041D8 09EF                <1>  or edi,ebp
  7355 000041DA 8D8C39134630A8      <1>  lea %1, [%1+edi+%7]
  7356 000041E1 034E18              <1>  add %1, dword [esi+%5*4]
  7357 000041E4 C1C111              <1>  rol %1,%6
  7358 000041E7 01D1                <1>  add %1,%2
  7500                                      FF  ebx, ecx, edx, eax, 7, S14, 0fd469501h
  7349 000041E9 89CF                <1>  mov edi,%2
  7350 000041EB 89CD                <1>  mov ebp,%2
  7351 000041ED 21D7                <1>  and edi,%3
  7352 000041EF F7D5                <1>  not ebp
  7353 000041F1 21C5                <1>  and ebp,%4
  7354 000041F3 09EF                <1>  or edi,ebp
  7355 000041F5 8D9C3B019546FD      <1>  lea %1, [%1+edi+%7]
  7356 000041FC 035E1C              <1>  add %1, dword [esi+%5*4]
  7357 000041FF C1C316              <1>  rol %1,%6
  7358 00004202 01CB                <1>  add %1,%2
  7501                                      FF  eax, ebx, ecx, edx, 8, S11, 0698098d8h
  7349 00004204 89DF                <1>  mov edi,%2
  7350 00004206 89DD                <1>  mov ebp,%2
  7351 00004208 21CF                <1>  and edi,%3
  7352 0000420A F7D5                <1>  not ebp
  7353 0000420C 21D5                <1>  and ebp,%4
  7354 0000420E 09EF                <1>  or edi,ebp
  7355 00004210 8D8438D8988069      <1>  lea %1, [%1+edi+%7]
  7356 00004217 034620              <1>  add %1, dword [esi+%5*4]
  7357 0000421A C1C007              <1>  rol %1,%6
  7358 0000421D 01D8                <1>  add %1,%2
  7502                                      FF  edx, eax, ebx, ecx, 9, S12, 08b44f7afh
  7349 0000421F 89C7                <1>  mov edi,%2
  7350 00004221 89C5                <1>  mov ebp,%2
  7351 00004223 21DF                <1>  and edi,%3
  7352 00004225 F7D5                <1>  not ebp
  7353 00004227 21CD                <1>  and ebp,%4
  7354 00004229 09EF                <1>  or edi,ebp
  7355 0000422B 8D943AAFF7448B      <1>  lea %1, [%1+edi+%7]
  7356 00004232 035624              <1>  add %1, dword [esi+%5*4]
  7357 00004235 C1C20C              <1>  rol %1,%6
  7358 00004238 01C2                <1>  add %1,%2
  7503                                      FF  ecx, edx, eax, ebx, 10, S13, 0ffff5bb1h
  7349 0000423A 89D7                <1>  mov edi,%2
  7350 0000423C 89D5                <1>  mov ebp,%2
  7351 0000423E 21C7                <1>  and edi,%3
  7352 00004240 F7D5                <1>  not ebp
  7353 00004242 21DD                <1>  and ebp,%4
  7354 00004244 09EF                <1>  or edi,ebp
  7355 00004246 8D8C39B15BFFFF      <1>  lea %1, [%1+edi+%7]
  7356 0000424D 034E28              <1>  add %1, dword [esi+%5*4]
  7357 00004250 C1C111              <1>  rol %1,%6
  7358 00004253 01D1                <1>  add %1,%2
  7504                                      FF  ebx, ecx, edx, eax, 11, S14, 0895cd7beh
  7349 00004255 89CF                <1>  mov edi,%2
  7350 00004257 89CD                <1>  mov ebp,%2
  7351 00004259 21D7                <1>  and edi,%3
  7352 0000425B F7D5                <1>  not ebp
  7353 0000425D 21C5                <1>  and ebp,%4
  7354 0000425F 09EF                <1>  or edi,ebp
  7355 00004261 8D9C3BBED75C89      <1>  lea %1, [%1+edi+%7]
  7356 00004268 035E2C              <1>  add %1, dword [esi+%5*4]
  7357 0000426B C1C316              <1>  rol %1,%6
  7358 0000426E 01CB                <1>  add %1,%2
  7505                                      FF  eax, ebx, ecx, edx, 12, S11, 06b901122h
  7349 00004270 89DF                <1>  mov edi,%2
  7350 00004272 89DD                <1>  mov ebp,%2
  7351 00004274 21CF                <1>  and edi,%3
  7352 00004276 F7D5                <1>  not ebp
  7353 00004278 21D5                <1>  and ebp,%4
  7354 0000427A 09EF                <1>  or edi,ebp
  7355 0000427C 8D84382211906B      <1>  lea %1, [%1+edi+%7]
  7356 00004283 034630              <1>  add %1, dword [esi+%5*4]
  7357 00004286 C1C007              <1>  rol %1,%6
  7358 00004289 01D8                <1>  add %1,%2
  7506                                      FF  edx, eax, ebx, ecx, 13, S12, 0fd987193h
  7349 0000428B 89C7                <1>  mov edi,%2
  7350 0000428D 89C5                <1>  mov ebp,%2
  7351 0000428F 21DF                <1>  and edi,%3
  7352 00004291 F7D5                <1>  not ebp
  7353 00004293 21CD                <1>  and ebp,%4
  7354 00004295 09EF                <1>  or edi,ebp
  7355 00004297 8D943A937198FD      <1>  lea %1, [%1+edi+%7]
  7356 0000429E 035634              <1>  add %1, dword [esi+%5*4]
  7357 000042A1 C1C20C              <1>  rol %1,%6
  7358 000042A4 01C2                <1>  add %1,%2
  7507                                      FF  ecx, edx, eax, ebx, 14, S13, 0a679438eh
  7349 000042A6 89D7                <1>  mov edi,%2
  7350 000042A8 89D5                <1>  mov ebp,%2
  7351 000042AA 21C7                <1>  and edi,%3
  7352 000042AC F7D5                <1>  not ebp
  7353 000042AE 21DD                <1>  and ebp,%4
  7354 000042B0 09EF                <1>  or edi,ebp
  7355 000042B2 8D8C398E4379A6      <1>  lea %1, [%1+edi+%7]
  7356 000042B9 034E38              <1>  add %1, dword [esi+%5*4]
  7357 000042BC C1C111              <1>  rol %1,%6
  7358 000042BF 01D1                <1>  add %1,%2
  7508                                      FF  ebx, ecx, edx, eax, 15, S14, 049b40821h
  7349 000042C1 89CF                <1>  mov edi,%2
  7350 000042C3 89CD                <1>  mov ebp,%2
  7351 000042C5 21D7                <1>  and edi,%3
  7352 000042C7 F7D5                <1>  not ebp
  7353 000042C9 21C5                <1>  and ebp,%4
  7354 000042CB 09EF                <1>  or edi,ebp
  7355 000042CD 8D9C3B2108B449      <1>  lea %1, [%1+edi+%7]
  7356 000042D4 035E3C              <1>  add %1, dword [esi+%5*4]
  7357 000042D7 C1C316              <1>  rol %1,%6
  7358 000042DA 01CB                <1>  add %1,%2
  7509                                  
  7510                                      GG  eax, ebx, ecx, edx, 1, S21, 0f61e2562h
  7362 000042DC 89D7                <1>  mov edi,%4
  7363 000042DE 89D5                <1>  mov ebp,%4
  7364 000042E0 21DF                <1>  and edi,%2
  7365 000042E2 F7D5                <1>  not ebp
  7366 000042E4 21CD                <1>  and ebp,%3
  7367 000042E6 09EF                <1>  or edi,ebp
  7368 000042E8 8D843862251EF6      <1>  lea %1, [%1+edi+%7]
  7369 000042EF 034604              <1>  add %1, dword [esi+%5*4]
  7370 000042F2 C1C005              <1>  rol %1,%6
  7371 000042F5 01D8                <1>  add %1,%2
  7511                                      GG  edx, eax, ebx, ecx, 6, S22, 0c040b340h
  7362 000042F7 89CF                <1>  mov edi,%4
  7363 000042F9 89CD                <1>  mov ebp,%4
  7364 000042FB 21C7                <1>  and edi,%2
  7365 000042FD F7D5                <1>  not ebp
  7366 000042FF 21DD                <1>  and ebp,%3
  7367 00004301 09EF                <1>  or edi,ebp
  7368 00004303 8D943A40B340C0      <1>  lea %1, [%1+edi+%7]
  7369 0000430A 035618              <1>  add %1, dword [esi+%5*4]
  7370 0000430D C1C209              <1>  rol %1,%6
  7371 00004310 01C2                <1>  add %1,%2
  7512                                      GG  ecx, edx, eax, ebx,11, S23, 0265e5a51h
  7362 00004312 89DF                <1>  mov edi,%4
  7363 00004314 89DD                <1>  mov ebp,%4
  7364 00004316 21D7                <1>  and edi,%2
  7365 00004318 F7D5                <1>  not ebp
  7366 0000431A 21C5                <1>  and ebp,%3
  7367 0000431C 09EF                <1>  or edi,ebp
  7368 0000431E 8D8C39515A5E26      <1>  lea %1, [%1+edi+%7]
  7369 00004325 034E2C              <1>  add %1, dword [esi+%5*4]
  7370 00004328 C1C10E              <1>  rol %1,%6
  7371 0000432B 01D1                <1>  add %1,%2
  7513                                      GG  ebx, ecx, edx, eax, 0, S24, 0e9b6c7aah
  7362 0000432D 89C7                <1>  mov edi,%4
  7363 0000432F 89C5                <1>  mov ebp,%4
  7364 00004331 21CF                <1>  and edi,%2
  7365 00004333 F7D5                <1>  not ebp
  7366 00004335 21D5                <1>  and ebp,%3
  7367 00004337 09EF                <1>  or edi,ebp
  7368 00004339 8D9C3BAAC7B6E9      <1>  lea %1, [%1+edi+%7]
  7369 00004340 031E                <1>  add %1, dword [esi+%5*4]
  7370 00004342 C1C314              <1>  rol %1,%6
  7371 00004345 01CB                <1>  add %1,%2
  7514                                      GG  eax, ebx, ecx, edx, 5, S21, 0d62f105dh
  7362 00004347 89D7                <1>  mov edi,%4
  7363 00004349 89D5                <1>  mov ebp,%4
  7364 0000434B 21DF                <1>  and edi,%2
  7365 0000434D F7D5                <1>  not ebp
  7366 0000434F 21CD                <1>  and ebp,%3
  7367 00004351 09EF                <1>  or edi,ebp
  7368 00004353 8D84385D102FD6      <1>  lea %1, [%1+edi+%7]
  7369 0000435A 034614              <1>  add %1, dword [esi+%5*4]
  7370 0000435D C1C005              <1>  rol %1,%6
  7371 00004360 01D8                <1>  add %1,%2
  7515                                      GG  edx, eax, ebx, ecx,10, S22, 002441453h
  7362 00004362 89CF                <1>  mov edi,%4
  7363 00004364 89CD                <1>  mov ebp,%4
  7364 00004366 21C7                <1>  and edi,%2
  7365 00004368 F7D5                <1>  not ebp
  7366 0000436A 21DD                <1>  and ebp,%3
  7367 0000436C 09EF                <1>  or edi,ebp
  7368 0000436E 8D943A53144402      <1>  lea %1, [%1+edi+%7]
  7369 00004375 035628              <1>  add %1, dword [esi+%5*4]
  7370 00004378 C1C209              <1>  rol %1,%6
  7371 0000437B 01C2                <1>  add %1,%2
  7516                                      GG  ecx, edx, eax, ebx,15, S23, 0d8a1e681h
  7362 0000437D 89DF                <1>  mov edi,%4
  7363 0000437F 89DD                <1>  mov ebp,%4
  7364 00004381 21D7                <1>  and edi,%2
  7365 00004383 F7D5                <1>  not ebp
  7366 00004385 21C5                <1>  and ebp,%3
  7367 00004387 09EF                <1>  or edi,ebp
  7368 00004389 8D8C3981E6A1D8      <1>  lea %1, [%1+edi+%7]
  7369 00004390 034E3C              <1>  add %1, dword [esi+%5*4]
  7370 00004393 C1C10E              <1>  rol %1,%6
  7371 00004396 01D1                <1>  add %1,%2
  7517                                      GG  ebx, ecx, edx, eax, 4, S24, 0e7d3fbc8h
  7362 00004398 89C7                <1>  mov edi,%4
  7363 0000439A 89C5                <1>  mov ebp,%4
  7364 0000439C 21CF                <1>  and edi,%2
  7365 0000439E F7D5                <1>  not ebp
  7366 000043A0 21D5                <1>  and ebp,%3
  7367 000043A2 09EF                <1>  or edi,ebp
  7368 000043A4 8D9C3BC8FBD3E7      <1>  lea %1, [%1+edi+%7]
  7369 000043AB 035E10              <1>  add %1, dword [esi+%5*4]
  7370 000043AE C1C314              <1>  rol %1,%6
  7371 000043B1 01CB                <1>  add %1,%2
  7518                                      GG  eax, ebx, ecx, edx, 9, S21, 021e1cde6h
  7362 000043B3 89D7                <1>  mov edi,%4
  7363 000043B5 89D5                <1>  mov ebp,%4
  7364 000043B7 21DF                <1>  and edi,%2
  7365 000043B9 F7D5                <1>  not ebp
  7366 000043BB 21CD                <1>  and ebp,%3
  7367 000043BD 09EF                <1>  or edi,ebp
  7368 000043BF 8D8438E6CDE121      <1>  lea %1, [%1+edi+%7]
  7369 000043C6 034624              <1>  add %1, dword [esi+%5*4]
  7370 000043C9 C1C005              <1>  rol %1,%6
  7371 000043CC 01D8                <1>  add %1,%2
  7519                                      GG  edx, eax, ebx, ecx,14, S22, 0c33707d6h
  7362 000043CE 89CF                <1>  mov edi,%4
  7363 000043D0 89CD                <1>  mov ebp,%4
  7364 000043D2 21C7                <1>  and edi,%2
  7365 000043D4 F7D5                <1>  not ebp
  7366 000043D6 21DD                <1>  and ebp,%3
  7367 000043D8 09EF                <1>  or edi,ebp
  7368 000043DA 8D943AD60737C3      <1>  lea %1, [%1+edi+%7]
  7369 000043E1 035638              <1>  add %1, dword [esi+%5*4]
  7370 000043E4 C1C209              <1>  rol %1,%6
  7371 000043E7 01C2                <1>  add %1,%2
  7520                                      GG  ecx, edx, eax, ebx, 3, S23, 0f4d50d87h
  7362 000043E9 89DF                <1>  mov edi,%4
  7363 000043EB 89DD                <1>  mov ebp,%4
  7364 000043ED 21D7                <1>  and edi,%2
  7365 000043EF F7D5                <1>  not ebp
  7366 000043F1 21C5                <1>  and ebp,%3
  7367 000043F3 09EF                <1>  or edi,ebp
  7368 000043F5 8D8C39870DD5F4      <1>  lea %1, [%1+edi+%7]
  7369 000043FC 034E0C              <1>  add %1, dword [esi+%5*4]
  7370 000043FF C1C10E              <1>  rol %1,%6
  7371 00004402 01D1                <1>  add %1,%2
  7521                                      GG  ebx, ecx, edx, eax, 8, S24, 0455a14edh
  7362 00004404 89C7                <1>  mov edi,%4
  7363 00004406 89C5                <1>  mov ebp,%4
  7364 00004408 21CF                <1>  and edi,%2
  7365 0000440A F7D5                <1>  not ebp
  7366 0000440C 21D5                <1>  and ebp,%3
  7367 0000440E 09EF                <1>  or edi,ebp
  7368 00004410 8D9C3BED145A45      <1>  lea %1, [%1+edi+%7]
  7369 00004417 035E20              <1>  add %1, dword [esi+%5*4]
  7370 0000441A C1C314              <1>  rol %1,%6
  7371 0000441D 01CB                <1>  add %1,%2
  7522                                      GG  eax, ebx, ecx, edx,13, S21, 0a9e3e905h
  7362 0000441F 89D7                <1>  mov edi,%4
  7363 00004421 89D5                <1>  mov ebp,%4
  7364 00004423 21DF                <1>  and edi,%2
  7365 00004425 F7D5                <1>  not ebp
  7366 00004427 21CD                <1>  and ebp,%3
  7367 00004429 09EF                <1>  or edi,ebp
  7368 0000442B 8D843805E9E3A9      <1>  lea %1, [%1+edi+%7]
  7369 00004432 034634              <1>  add %1, dword [esi+%5*4]
  7370 00004435 C1C005              <1>  rol %1,%6
  7371 00004438 01D8                <1>  add %1,%2
  7523                                      GG  edx, eax, ebx, ecx, 2, S22, 0fcefa3f8h
  7362 0000443A 89CF                <1>  mov edi,%4
  7363 0000443C 89CD                <1>  mov ebp,%4
  7364 0000443E 21C7                <1>  and edi,%2
  7365 00004440 F7D5                <1>  not ebp
  7366 00004442 21DD                <1>  and ebp,%3
  7367 00004444 09EF                <1>  or edi,ebp
  7368 00004446 8D943AF8A3EFFC      <1>  lea %1, [%1+edi+%7]
  7369 0000444D 035608              <1>  add %1, dword [esi+%5*4]
  7370 00004450 C1C209              <1>  rol %1,%6
  7371 00004453 01C2                <1>  add %1,%2
  7524                                      GG  ecx, edx, eax, ebx, 7, S23, 0676f02d9h
  7362 00004455 89DF                <1>  mov edi,%4
  7363 00004457 89DD                <1>  mov ebp,%4
  7364 00004459 21D7                <1>  and edi,%2
  7365 0000445B F7D5                <1>  not ebp
  7366 0000445D 21C5                <1>  and ebp,%3
  7367 0000445F 09EF                <1>  or edi,ebp
  7368 00004461 8D8C39D9026F67      <1>  lea %1, [%1+edi+%7]
  7369 00004468 034E1C              <1>  add %1, dword [esi+%5*4]
  7370 0000446B C1C10E              <1>  rol %1,%6
  7371 0000446E 01D1                <1>  add %1,%2
  7525                                      GG  ebx, ecx, edx, eax,12, S24, 08d2a4c8ah
  7362 00004470 89C7                <1>  mov edi,%4
  7363 00004472 89C5                <1>  mov ebp,%4
  7364 00004474 21CF                <1>  and edi,%2
  7365 00004476 F7D5                <1>  not ebp
  7366 00004478 21D5                <1>  and ebp,%3
  7367 0000447A 09EF                <1>  or edi,ebp
  7368 0000447C 8D9C3B8A4C2A8D      <1>  lea %1, [%1+edi+%7]
  7369 00004483 035E30              <1>  add %1, dword [esi+%5*4]
  7370 00004486 C1C314              <1>  rol %1,%6
  7371 00004489 01CB                <1>  add %1,%2
  7526                                  
  7527                                      HH  eax, ebx, ecx, edx, 5, S31, 0fffa3942h
  7375 0000448B 89DD                <1>  mov ebp,%2
  7376 0000448D 31CD                <1>  xor ebp,%3
  7377 0000448F 31D5                <1>  xor ebp,%4
  7378 00004491 8D84284239FAFF      <1>  lea %1, [%1+ebp+%7]
  7379 00004498 034614              <1>  add %1,dword [esi+%5*4]
  7380 0000449B C1C004              <1>  rol %1,%6
  7381 0000449E 01D8                <1>  add %1,%2
  7528                                      HH  edx, eax, ebx, ecx, 8, S32, 08771f681h
  7375 000044A0 89C5                <1>  mov ebp,%2
  7376 000044A2 31DD                <1>  xor ebp,%3
  7377 000044A4 31CD                <1>  xor ebp,%4
  7378 000044A6 8D942A81F67187      <1>  lea %1, [%1+ebp+%7]
  7379 000044AD 035620              <1>  add %1,dword [esi+%5*4]
  7380 000044B0 C1C20B              <1>  rol %1,%6
  7381 000044B3 01C2                <1>  add %1,%2
  7529                                      HH  ecx, edx, eax, ebx,11, S33, 06d9d6122h
  7375 000044B5 89D5                <1>  mov ebp,%2
  7376 000044B7 31C5                <1>  xor ebp,%3
  7377 000044B9 31DD                <1>  xor ebp,%4
  7378 000044BB 8D8C2922619D6D      <1>  lea %1, [%1+ebp+%7]
  7379 000044C2 034E2C              <1>  add %1,dword [esi+%5*4]
  7380 000044C5 C1C110              <1>  rol %1,%6
  7381 000044C8 01D1                <1>  add %1,%2
  7530                                      HH  ebx, ecx, edx, eax,14, S34, 0fde5380ch
  7375 000044CA 89CD                <1>  mov ebp,%2
  7376 000044CC 31D5                <1>  xor ebp,%3
  7377 000044CE 31C5                <1>  xor ebp,%4
  7378 000044D0 8D9C2B0C38E5FD      <1>  lea %1, [%1+ebp+%7]
  7379 000044D7 035E38              <1>  add %1,dword [esi+%5*4]
  7380 000044DA C1C317              <1>  rol %1,%6
  7381 000044DD 01CB                <1>  add %1,%2
  7531                                      HH  eax, ebx, ecx, edx, 1, S31, 0a4beea44h
  7375 000044DF 89DD                <1>  mov ebp,%2
  7376 000044E1 31CD                <1>  xor ebp,%3
  7377 000044E3 31D5                <1>  xor ebp,%4
  7378 000044E5 8D842844EABEA4      <1>  lea %1, [%1+ebp+%7]
  7379 000044EC 034604              <1>  add %1,dword [esi+%5*4]
  7380 000044EF C1C004              <1>  rol %1,%6
  7381 000044F2 01D8                <1>  add %1,%2
  7532                                      HH  edx, eax, ebx, ecx, 4, S32, 04bdecfa9h
  7375 000044F4 89C5                <1>  mov ebp,%2
  7376 000044F6 31DD                <1>  xor ebp,%3
  7377 000044F8 31CD                <1>  xor ebp,%4
  7378 000044FA 8D942AA9CFDE4B      <1>  lea %1, [%1+ebp+%7]
  7379 00004501 035610              <1>  add %1,dword [esi+%5*4]
  7380 00004504 C1C20B              <1>  rol %1,%6
  7381 00004507 01C2                <1>  add %1,%2
  7533                                      HH  ecx, edx, eax, ebx, 7, S33, 0f6bb4b60h
  7375 00004509 89D5                <1>  mov ebp,%2
  7376 0000450B 31C5                <1>  xor ebp,%3
  7377 0000450D 31DD                <1>  xor ebp,%4
  7378 0000450F 8D8C29604BBBF6      <1>  lea %1, [%1+ebp+%7]
  7379 00004516 034E1C              <1>  add %1,dword [esi+%5*4]
  7380 00004519 C1C110              <1>  rol %1,%6
  7381 0000451C 01D1                <1>  add %1,%2
  7534                                      HH  ebx, ecx, edx, eax,10, S34, 0bebfbc70h
  7375 0000451E 89CD                <1>  mov ebp,%2
  7376 00004520 31D5                <1>  xor ebp,%3
  7377 00004522 31C5                <1>  xor ebp,%4
  7378 00004524 8D9C2B70BCBFBE      <1>  lea %1, [%1+ebp+%7]
  7379 0000452B 035E28              <1>  add %1,dword [esi+%5*4]
  7380 0000452E C1C317              <1>  rol %1,%6
  7381 00004531 01CB                <1>  add %1,%2
  7535                                      HH  eax, ebx, ecx, edx,13, S31, 0289b7ec6h
  7375 00004533 89DD                <1>  mov ebp,%2
  7376 00004535 31CD                <1>  xor ebp,%3
  7377 00004537 31D5                <1>  xor ebp,%4
  7378 00004539 8D8428C67E9B28      <1>  lea %1, [%1+ebp+%7]
  7379 00004540 034634              <1>  add %1,dword [esi+%5*4]
  7380 00004543 C1C004              <1>  rol %1,%6
  7381 00004546 01D8                <1>  add %1,%2
  7536                                      HH  edx, eax, ebx, ecx, 0, S32, 0eaa127fah
  7375 00004548 89C5                <1>  mov ebp,%2
  7376 0000454A 31DD                <1>  xor ebp,%3
  7377 0000454C 31CD                <1>  xor ebp,%4
  7378 0000454E 8D942AFA27A1EA      <1>  lea %1, [%1+ebp+%7]
  7379 00004555 0316                <1>  add %1,dword [esi+%5*4]
  7380 00004557 C1C20B              <1>  rol %1,%6
  7381 0000455A 01C2                <1>  add %1,%2
  7537                                      HH  ecx, edx, eax, ebx, 3, S33, 0d4ef3085h
  7375 0000455C 89D5                <1>  mov ebp,%2
  7376 0000455E 31C5                <1>  xor ebp,%3
  7377 00004560 31DD                <1>  xor ebp,%4
  7378 00004562 8D8C298530EFD4      <1>  lea %1, [%1+ebp+%7]
  7379 00004569 034E0C              <1>  add %1,dword [esi+%5*4]
  7380 0000456C C1C110              <1>  rol %1,%6
  7381 0000456F 01D1                <1>  add %1,%2
  7538                                      HH  ebx, ecx, edx, eax, 6, S34, 004881d05h
  7375 00004571 89CD                <1>  mov ebp,%2
  7376 00004573 31D5                <1>  xor ebp,%3
  7377 00004575 31C5                <1>  xor ebp,%4
  7378 00004577 8D9C2B051D8804      <1>  lea %1, [%1+ebp+%7]
  7379 0000457E 035E18              <1>  add %1,dword [esi+%5*4]
  7380 00004581 C1C317              <1>  rol %1,%6
  7381 00004584 01CB                <1>  add %1,%2
  7539                                      HH  eax, ebx, ecx, edx, 9, S31, 0d9d4d039h
  7375 00004586 89DD                <1>  mov ebp,%2
  7376 00004588 31CD                <1>  xor ebp,%3
  7377 0000458A 31D5                <1>  xor ebp,%4
  7378 0000458C 8D842839D0D4D9      <1>  lea %1, [%1+ebp+%7]
  7379 00004593 034624              <1>  add %1,dword [esi+%5*4]
  7380 00004596 C1C004              <1>  rol %1,%6
  7381 00004599 01D8                <1>  add %1,%2
  7540                                      HH  edx, eax, ebx, ecx,12, S32, 0e6db99e5h
  7375 0000459B 89C5                <1>  mov ebp,%2
  7376 0000459D 31DD                <1>  xor ebp,%3
  7377 0000459F 31CD                <1>  xor ebp,%4
  7378 000045A1 8D942AE599DBE6      <1>  lea %1, [%1+ebp+%7]
  7379 000045A8 035630              <1>  add %1,dword [esi+%5*4]
  7380 000045AB C1C20B              <1>  rol %1,%6
  7381 000045AE 01C2                <1>  add %1,%2
  7541                                      HH  ecx, edx, eax, ebx,15, S33, 01fa27cf8h
  7375 000045B0 89D5                <1>  mov ebp,%2
  7376 000045B2 31C5                <1>  xor ebp,%3
  7377 000045B4 31DD                <1>  xor ebp,%4
  7378 000045B6 8D8C29F87CA21F      <1>  lea %1, [%1+ebp+%7]
  7379 000045BD 034E3C              <1>  add %1,dword [esi+%5*4]
  7380 000045C0 C1C110              <1>  rol %1,%6
  7381 000045C3 01D1                <1>  add %1,%2
  7542                                      HH  ebx, ecx, edx, eax, 2, S34, 0c4ac5665h
  7375 000045C5 89CD                <1>  mov ebp,%2
  7376 000045C7 31D5                <1>  xor ebp,%3
  7377 000045C9 31C5                <1>  xor ebp,%4
  7378 000045CB 8D9C2B6556ACC4      <1>  lea %1, [%1+ebp+%7]
  7379 000045D2 035E08              <1>  add %1,dword [esi+%5*4]
  7380 000045D5 C1C317              <1>  rol %1,%6
  7381 000045D8 01CB                <1>  add %1,%2
  7543                                  
  7544                                      II  eax, ebx, ecx, edx, 0, S41, 0f4292244h
  7385 000045DA 89D5                <1>  mov ebp,%4
  7386 000045DC F7D5                <1>  not ebp
  7387 000045DE 09DD                <1>  or ebp,%2
  7388 000045E0 31CD                <1>  xor ebp,%3
  7389 000045E2 8D8428442229F4      <1>  lea %1, [%1+ebp+%7]
  7390 000045E9 0306                <1>  add %1,dword [esi+%5*4]
  7391 000045EB C1C006              <1>  rol %1,%6
  7392 000045EE 01D8                <1>  add %1,%2
  7545                                      II  edx, eax, ebx, ecx, 7, S42, 0432aff97h
  7385 000045F0 89CD                <1>  mov ebp,%4
  7386 000045F2 F7D5                <1>  not ebp
  7387 000045F4 09C5                <1>  or ebp,%2
  7388 000045F6 31DD                <1>  xor ebp,%3
  7389 000045F8 8D942A97FF2A43      <1>  lea %1, [%1+ebp+%7]
  7390 000045FF 03561C              <1>  add %1,dword [esi+%5*4]
  7391 00004602 C1C20A              <1>  rol %1,%6
  7392 00004605 01C2                <1>  add %1,%2
  7546                                      II  ecx, edx, eax, ebx,14, S43, 0ab9423a7h
  7385 00004607 89DD                <1>  mov ebp,%4
  7386 00004609 F7D5                <1>  not ebp
  7387 0000460B 09D5                <1>  or ebp,%2
  7388 0000460D 31C5                <1>  xor ebp,%3
  7389 0000460F 8D8C29A72394AB      <1>  lea %1, [%1+ebp+%7]
  7390 00004616 034E38              <1>  add %1,dword [esi+%5*4]
  7391 00004619 C1C10F              <1>  rol %1,%6
  7392 0000461C 01D1                <1>  add %1,%2
  7547                                      II  ebx, ecx, edx, eax, 5, S44, 0fc93a039h
  7385 0000461E 89C5                <1>  mov ebp,%4
  7386 00004620 F7D5                <1>  not ebp
  7387 00004622 09CD                <1>  or ebp,%2
  7388 00004624 31D5                <1>  xor ebp,%3
  7389 00004626 8D9C2B39A093FC      <1>  lea %1, [%1+ebp+%7]
  7390 0000462D 035E14              <1>  add %1,dword [esi+%5*4]
  7391 00004630 C1C315              <1>  rol %1,%6
  7392 00004633 01CB                <1>  add %1,%2
  7548                                      II  eax, ebx, ecx, edx,12, S41, 0655b59c3h
  7385 00004635 89D5                <1>  mov ebp,%4
  7386 00004637 F7D5                <1>  not ebp
  7387 00004639 09DD                <1>  or ebp,%2
  7388 0000463B 31CD                <1>  xor ebp,%3
  7389 0000463D 8D8428C3595B65      <1>  lea %1, [%1+ebp+%7]
  7390 00004644 034630              <1>  add %1,dword [esi+%5*4]
  7391 00004647 C1C006              <1>  rol %1,%6
  7392 0000464A 01D8                <1>  add %1,%2
  7549                                      II  edx, eax, ebx, ecx, 3, S42, 08f0ccc92h
  7385 0000464C 89CD                <1>  mov ebp,%4
  7386 0000464E F7D5                <1>  not ebp
  7387 00004650 09C5                <1>  or ebp,%2
  7388 00004652 31DD                <1>  xor ebp,%3
  7389 00004654 8D942A92CC0C8F      <1>  lea %1, [%1+ebp+%7]
  7390 0000465B 03560C              <1>  add %1,dword [esi+%5*4]
  7391 0000465E C1C20A              <1>  rol %1,%6
  7392 00004661 01C2                <1>  add %1,%2
  7550                                      II  ecx, edx, eax, ebx,10, S43, 0ffeff47dh
  7385 00004663 89DD                <1>  mov ebp,%4
  7386 00004665 F7D5                <1>  not ebp
  7387 00004667 09D5                <1>  or ebp,%2
  7388 00004669 31C5                <1>  xor ebp,%3
  7389 0000466B 8D8C297DF4EFFF      <1>  lea %1, [%1+ebp+%7]
  7390 00004672 034E28              <1>  add %1,dword [esi+%5*4]
  7391 00004675 C1C10F              <1>  rol %1,%6
  7392 00004678 01D1                <1>  add %1,%2
  7551                                      II  ebx, ecx, edx, eax, 1, S44, 085845dd1h
  7385 0000467A 89C5                <1>  mov ebp,%4
  7386 0000467C F7D5                <1>  not ebp
  7387 0000467E 09CD                <1>  or ebp,%2
  7388 00004680 31D5                <1>  xor ebp,%3
  7389 00004682 8D9C2BD15D8485      <1>  lea %1, [%1+ebp+%7]
  7390 00004689 035E04              <1>  add %1,dword [esi+%5*4]
  7391 0000468C C1C315              <1>  rol %1,%6
  7392 0000468F 01CB                <1>  add %1,%2
  7552                                      II  eax, ebx, ecx, edx, 8, S41, 06fa87e4fh
  7385 00004691 89D5                <1>  mov ebp,%4
  7386 00004693 F7D5                <1>  not ebp
  7387 00004695 09DD                <1>  or ebp,%2
  7388 00004697 31CD                <1>  xor ebp,%3
  7389 00004699 8D84284F7EA86F      <1>  lea %1, [%1+ebp+%7]
  7390 000046A0 034620              <1>  add %1,dword [esi+%5*4]
  7391 000046A3 C1C006              <1>  rol %1,%6
  7392 000046A6 01D8                <1>  add %1,%2
  7553                                      II  edx, eax, ebx, ecx,15, S42, 0fe2ce6e0h
  7385 000046A8 89CD                <1>  mov ebp,%4
  7386 000046AA F7D5                <1>  not ebp
  7387 000046AC 09C5                <1>  or ebp,%2
  7388 000046AE 31DD                <1>  xor ebp,%3
  7389 000046B0 8D942AE0E62CFE      <1>  lea %1, [%1+ebp+%7]
  7390 000046B7 03563C              <1>  add %1,dword [esi+%5*4]
  7391 000046BA C1C20A              <1>  rol %1,%6
  7392 000046BD 01C2                <1>  add %1,%2
  7554                                      II  ecx, edx, eax, ebx, 6, S43, 0a3014314h
  7385 000046BF 89DD                <1>  mov ebp,%4
  7386 000046C1 F7D5                <1>  not ebp
  7387 000046C3 09D5                <1>  or ebp,%2
  7388 000046C5 31C5                <1>  xor ebp,%3
  7389 000046C7 8D8C29144301A3      <1>  lea %1, [%1+ebp+%7]
  7390 000046CE 034E18              <1>  add %1,dword [esi+%5*4]
  7391 000046D1 C1C10F              <1>  rol %1,%6
  7392 000046D4 01D1                <1>  add %1,%2
  7555                                      II  ebx, ecx, edx, eax,13, S44, 04e0811a1h
  7385 000046D6 89C5                <1>  mov ebp,%4
  7386 000046D8 F7D5                <1>  not ebp
  7387 000046DA 09CD                <1>  or ebp,%2
  7388 000046DC 31D5                <1>  xor ebp,%3
  7389 000046DE 8D9C2BA111084E      <1>  lea %1, [%1+ebp+%7]
  7390 000046E5 035E34              <1>  add %1,dword [esi+%5*4]
  7391 000046E8 C1C315              <1>  rol %1,%6
  7392 000046EB 01CB                <1>  add %1,%2
  7556                                      II  eax, ebx, ecx, edx, 4, S41, 0f7537e82h
  7385 000046ED 89D5                <1>  mov ebp,%4
  7386 000046EF F7D5                <1>  not ebp
  7387 000046F1 09DD                <1>  or ebp,%2
  7388 000046F3 31CD                <1>  xor ebp,%3
  7389 000046F5 8D8428827E53F7      <1>  lea %1, [%1+ebp+%7]
  7390 000046FC 034610              <1>  add %1,dword [esi+%5*4]
  7391 000046FF C1C006              <1>  rol %1,%6
  7392 00004702 01D8                <1>  add %1,%2
  7557                                      II  edx, eax, ebx, ecx,11, S42, 0bd3af235h
  7385 00004704 89CD                <1>  mov ebp,%4
  7386 00004706 F7D5                <1>  not ebp
  7387 00004708 09C5                <1>  or ebp,%2
  7388 0000470A 31DD                <1>  xor ebp,%3
  7389 0000470C 8D942A35F23ABD      <1>  lea %1, [%1+ebp+%7]
  7390 00004713 03562C              <1>  add %1,dword [esi+%5*4]
  7391 00004716 C1C20A              <1>  rol %1,%6
  7392 00004719 01C2                <1>  add %1,%2
  7558                                      II  ecx, edx, eax, ebx, 2, S43, 02ad7d2bbh
  7385 0000471B 89DD                <1>  mov ebp,%4
  7386 0000471D F7D5                <1>  not ebp
  7387 0000471F 09D5                <1>  or ebp,%2
  7388 00004721 31C5                <1>  xor ebp,%3
  7389 00004723 8D8C29BBD2D72A      <1>  lea %1, [%1+ebp+%7]
  7390 0000472A 034E08              <1>  add %1,dword [esi+%5*4]
  7391 0000472D C1C10F              <1>  rol %1,%6
  7392 00004730 01D1                <1>  add %1,%2
  7559                                      II  ebx, ecx, edx, eax, 9, S44, 0eb86d391h
  7385 00004732 89C5                <1>  mov ebp,%4
  7386 00004734 F7D5                <1>  not ebp
  7387 00004736 09CD                <1>  or ebp,%2
  7388 00004738 31D5                <1>  xor ebp,%3
  7389 0000473A 8D9C2B91D386EB      <1>  lea %1, [%1+ebp+%7]
  7390 00004741 035E24              <1>  add %1,dword [esi+%5*4]
  7391 00004744 C1C315              <1>  rol %1,%6
  7392 00004747 01CB                <1>  add %1,%2
  7560                                  
  7561 00004749 5F                          pop edi
  7562 0000474A 0107                        add dword [edi],eax
  7563 0000474C 015F04                      add dword [edi+04h],ebx
  7564 0000474F 014F08                      add dword [edi+08h],ecx
  7565 00004752 01570C                      add dword [edi+0Ch],edx
  7566 00004755 5E                          pop esi
  7567 00004756 5B                          pop ebx
  7568 00004757 5A                          pop edx
  7569 00004758 58                          pop eax
  7570 00004759 2D40000000                  sub eax,64
  7571 0000475E 85D2                        test edx,edx
  7572 00004760 0F853FF9FFFF                jne _n0
  7573 00004766 81C440000000                add esp,64
  7574 0000476C 61                          popad
  7575 0000476D C20C00                      ret 0Ch
  7576                                  
  7577                                  ; *****************************************************************************
  7578                                  ; *****************************************************************************
  7579                                  
  7580                                  align 4, nop
  7581                                  
  7582                                  tens:
  7583 00004770 0A000000                    dd 10
  7584 00004774 64000000                    dd 100
  7585 00004778 E8030000                    dd 1000
  7586 0000477C 10270000                    dd 10000
  7587 00004780 A0860100                    dd 100000
  7588 00004784 40420F00                    dd 1000000
  7589 00004788 80969800                    dd 10000000
  7590 0000478C 00E1F505                    dd 100000000
  7591 00004790 00CA9A3B                    dd 1000000000
  7592                                  
  7593                                  x_numberDisplay:    ; either dotDecimal or dotHex , depending on the BASE to use to display numbers
  7594 00004794 [9C120000]                  dd dotDecimal
  7595                                  
  7596                                  v_help_counter:     ; cycles through the help screens used by "help" ( F1 key )
  7597 00004798 00000000                    dd 0
  7598                                  
  7599                                  v_saved_v_blk:      ; the block number saved by "help"
  7600 0000479C FF000000                    dd 0xFF
  7601                                  
  7602                                  v_locatedBlock:     ; the block of the located word  
  7603 000047A0 FE010000                    dd 510          ; demo only to see if the interface is OK - toggling the located word on "L" in the editor keypad
  7604                                  v_locatedCurs:      ; the address of the located word within its block 
  7605 000047A4 0A000000                    dd 10           ; demo only to see if the interface is OK - toggling the located word on "L" in the editor keypad
  7606                                  
  7607                                  v_blk:              ; the currently edited block
  7608 000047A8 40000000                    dd START_BLOCK_NUMBER ; the default edited block
  7609                                  v_curs:             ; the offset in cells of the cursor within the currently edited block
  7610 000047AC 00000000                    dd 0
  7611                                  
  7612                                  v_otherBlock:       ; the previously edited block
  7613 000047B0 FE010000                    dd 510          ; the default other block is the highest non-shadow block saved by 'sa'
  7614                                  v_otherCursor:      ; the v_curs cursor position in the other block
  7615 000047B4 00000000                    dd 0 
  7616                                  
  7617                                  ; v_otherBlocks:      ; the previously edited help block array
  7618                                  ;     dd START_BLOCK_NUMBER           ; the default edited block
  7619                                  ;     dd START_BLOCK_NUMBER + 1       ; the default other block is the shadow of the default edited block
  7620                                  ;     dd START_BLOCK_NUMBER + 2       ; the default other block is the shadow of the default edited block
  7621                                  ;     dd START_BLOCK_NUMBER + 3       ; the default other block is the shadow of the default edited block
  7622                                  
  7623                                  v_cursPtr:          ; variable to count the cursor offset from the start of the block
  7624 000047B8 00000000                    dd 0
  7625                                  
  7626                                  v_cursLine:         ; which line we want to display the cursor on
  7627 000047BC 00000000                    dd 0
  7628                                  
  7629                                  v_curs_number_down: ; to limit the steps down
  7630 000047C0 00000000                    dd 0
  7631                                  
  7632                                  v_display_token_number: ; how many tokens we have displayed in the editor screen
  7633 000047C4 00000000                    dd 0
  7634                                  
  7635                                  v_numberOfMagentas:
  7636 000047C8 00000000                    dd 0
  7637                                  
  7638                                  v_numberOfBigConstants:
  7639 000047CC 00000000                    dd 0
  7640                                  
  7641                                  v_numberOfRedAndMagentas:
  7642 000047D0 00000000                    dd 0
  7643                                  
  7644                                  v_numberOfTokens:   ; in the current block
  7645 000047D4 00000000                    dd 0
  7646                                  
  7647                                  v_cad:              ; the address of the cursor as an offset from the start of the currently displayed block
  7648 000047D8 00000000                    dd 0
  7649                                  
  7650                                  v_pcad:             ; saved pointer to current cursor address (?)
  7651 000047DC 00000000                    dd 0
  7652                                  
  7653                                  v_lcad:             ; saved length of 32 bit cells to move (?)
  7654 000047E0 00000000                    dd 0
  7655                                  
  7656                                  v_trash:                            ; pointer to "trash" buffer, saves words deleted while editing
  7657 000047E4 00F00800                    dd TRASH_BUFFER
  7658                                  
  7659                                  v_offset:
  7660 000047E8 40000000                    dd ( RELOCATED >> ( 2 + 8 ) )
  7661                                  
  7662                                  v_bitsPerPixel:
  7663 000047EC 10000000                    dd 16   ; default, set using VESA info
  7664                                  
  7665                                  v_iconw:
  7666 000047F0 00000000                    dd 0 ; iconw
  7667                                  
  7668                                  v_iconh:
  7669 000047F4 00000000                    dd 0 ; iconh
  7670                                  
  7671                                  v_keypadY_iconh:
  7672 000047F8 00000000                    dd 0    ; keypadY * iconh
  7673                                  
  7674                                  v_nine_iconw:
  7675 000047FC 00000000                    dd 0
  7676                                  
  7677                                  v_twentytwo_iconw:  ; width of 12 history characters, 1 space and 9 keypad characters
  7678 00004800 00000000                    dd 0            ; to calculate the start of the history display, subtracted from the right edge of the screen
  7679                                  
  7680                                  v_10000_iconw:
  7681 00004804 00000000                    dd 0    ; iconw*0x10000
  7682                                  
  7683                                  x_qwerty:           ; selects non-QWERTY if set to 0, else jumps to the address
  7684 00004808 FFFFFFFF                    dd 0xFFFFFFFF   ;
  7685                                  
  7686                                  x_abort:
  7687 0000480C [602F0000]                  dd abort_action
  7688                                  
  7689                                  x_colourBlind:  ; ( state -- state )
  7690 00004810 [601F0000]                  dd colourBlindAction
  7691                                  
  7692                                  ; byte variables
  7693                                  v_seeb:             ; if = 255, show blue words in editor
  7694 00004814 00                          db 0            ; 255 enable, 0 disable
  7695                                  
  7696                                  v_colourBlindMode:  ; if = 255, select ANS style editor display
  7697 00004815 00                          db 0            ; 255 enable, 0 disable
  7698                                  
  7699                                  v_not_cr:   ; true to disable the  cr  before a red word is displayed in the editor
  7700 00004816 00                          db 0
  7701                                  
  7702                                  v_quitMode:         ; if non zero, the keypad is in Edit mode, else immediate (TIB) mode
  7703 00004817 00                          db 0            ; 255 enable, 0 disable
  7704                                  
  7705                                  v_hintChar:         ; the character to display in the bottom right hand corner of the keyboard
  7706 00004818 00000000                    dd 0            ; as a hint to the colour being used
  7707                                  
  7708                                  v_random:           ; the current Marsaglia Pseudo Random Number Generator state
  7709 0000481C 00000000                    dd 0
  7710                                  
  7711                                  v_show_ASCII:       ; if true show the ASCII keyboard entry field at the cursor
  7712 00004820 00                          db 0
  7713                                  
  7714                                  ; align 4, nop    ; so we can read these variables easily from Forth
  7715                                  ; md5_output: times 4 dd 0    ; the MD5 hash output
  7716                                  
  7717 00004821 90<rep 3h>              align 4
  7718                                  
  7719                                  currentKeypadIcons:
  7720 00004824 [8C150000]                  dd ( alphaKeypad - 4 )
  7721                                  
  7722                                  shiftAction:        ; the table of Forth words to execute for the current keypad
  7723 00004828 [4A190000]                  dd alpha0
  7724                                  
  7725                                  vars:       ; colorForth system variables start here
  7726                                  base:
  7727 0000482C 0A000000                    dd 10
  7728                                  
  7729                                  setCurrentBase:                     ; set the base to either decimalor hexadecimal
  7730 00004830 [FD1B0000]                  dd setBase_decimal
  7731                                  
  7732                                  keypad_colour:
  7733 00004834 E0FF0000                    dd colour_yellow   ; current key colour for displaying key presses
  7734                                  
  7735                                  chars:
  7736 00004838 01000000                    dd 1
  7737                                  
  7738                                  aword:
  7739 0000483C [C2070000]                  dd ex1
  7740                                  
  7741                                  anumber:
  7742 00004840 [40040000]                  dd nul
  7743                                  
  7744                                  v_words:
  7745 00004844 01000000                    dd 1
  7746                                  
  7747                                  v_qwerty_key:
  7748 00004848 00000000                    dd 0
  7749                                  
  7750                                  v_digin:
  7751 0000484C 00000000                    dd 0
  7752                                  
  7753                                  lit:
  7754 00004850 [2E060000]                  dd adup
  7755                                  
  7756                                  v_washColour:
  7757 00004854 00000000                    dd colour_background
  7758                                  
  7759                                  v_spare:        ; just to align v_pad to a 16 byte boundary
  7760 00004858 00000000                    dd 0
  7761 0000485C 00000000                    dd 0
  7762 00004860 00000000                    dd 0
  7763                                  
  7764                                  mark_MacroWordCount:
  7765 00004864 06000000                    dd MACRO_INITIAL_WORD_COUNT ; initial #macros
  7766                                      ; number of Macro words, saved by  mark , empty restores to this value
  7767                                  mark_v_ForthWordCount:
  7768 00004868 D3000000                    dd FORTH_INITIAL_WORD_COUNT ; initial #words
  7769                                      ; number of Forth words, saved by  mark , empty restores to this value
  7770                                  mark_v_BlueWordCount:
  7771 0000486C 10000000                    dd BLUE_INITIAL_WORD_COUNT ; initial #words
  7772                                      ; number of Blue words, saved by  mark , empty restores to this value
  7773                                  
  7774                                  mark_H:
  7775 00004870 00004800                    dd H0       ; top of dictionary pointer H , saved by  mark , empty restores to this value
  7776                                  
  7777                                  v_H:
  7778 00004874 00004800                    dd H0       ; variable H , dictionary pointer HERE, where new definitions go
  7779                                  
  7780                                  v_lblk:
  7781 00004878 00000000                    dd 0        ; the last block loaded by  ld 
  7782                                  
  7783                                  ; this variable address is 16 below pad
  7784                                  v_x:            ; general purpose variable e.g. for  dump
  7785 0000487C 00000000                    dd 0
  7786                                  
  7787                                  v_y:            ; general purpose variable e.g. for  dump
  7788 00004880 00000000                    dd 0
  7789                                  
  7790                                  v_z:            ; general purpose variable
  7791 00004884 00000000                    dd 0
  7792                                  
  7793                                  v_lastToken:
  7794 00004888 00000000                    dd 0
  7795                                  
  7796                                  v_font:         ; a pointer to the current font table
  7797 0000488C [00D00000]                  dd ( font16x24 )           ; default font
  7798                                  
  7799                                  v_onesec:       ; one second's worth of counter counts 
  7800 00004890 00000000                    dd 0
  7801 00004894 00000000                    dd 0
  7802                                  v_khz:          ; the Processor clock, scaled down to kHz
  7803 00004898 00000000                    dd 0
  7804                                  v_mhz:          ; the Processor clock, scaled down to MHz
  7805 0000489C 00000000                    dd 0
  7806                                  
  7807                                  v_lastAddress:
  7808 000048A0 00000000                    dd 0
  7809                                  v_lastAddress_copy:
  7810 000048A4 00000000                    dd 0                    ; saves a copy of v_lastAddress
  7811                                  
  7812                                  v_ForthWordCount:
  7813 000048A8 D3000000                 dd FORTH_INITIAL_WORD_COUNT ; initial #words  ; number of words in the Forth wordlist, empty resets this value
  7814                                  
  7815                                  v_MacroWordCount:
  7816 000048AC 06000000                 dd MACRO_INITIAL_WORD_COUNT ; initial #macros  ; number of words in the Macro wordlist, empty resets this value
  7817                                  
  7818                                  v_BlueWordCount:
  7819 000048B0 10000000                 dd BLUE_INITIAL_WORD_COUNT ; initial #macros  ; number of words in the Blue wordlist, empty resets this value
  7820                                  
  7821                                  v_test1:                            ; two 32 bit variables to save test values in. Use ' pad 8 - 2@ ' to view the values
  7822 000048B4 00000000                    dd 0
  7823                                  v_test2:
  7824 000048B8 00000000                    dd 0
  7825                                  v_pad:                              ; the standard Forth PAD, 84 bytes long
  7826 000048BC 00<rep 54h>                 times 84 db 0x00
  7827                                  
  7828                                  tokenActions:       ;
  7829 00004910 [62090000]                  dd qignore      ; 0  extension token
  7830 00004914 [CF070000]                  dd execute_lit  ; 1
  7831 00004918 [83080000]                  dd num          ; 2
  7832                                  adefine: ; compile time action for each type of token, 3 to 12 
  7833 0000491C [A0060000]                  dd forthd       ; 3
  7834 00004920 [FB070000]                  dd qcompile     ; 4
  7835 00004924 [31070000]                  dd cnum         ; 5
  7836 00004928 [41070000]                  dd cshort       ; 6
  7837 0000492C [4B080000]                  dd compile      ; 7
  7838 00004930 [69080000]                  dd short_       ; 8
  7839 00004934 [40040000]                  dd nul          ; 9
  7840 00004938 [40040000]                  dd nul          ; A
  7841 0000493C [40040000]                  dd nul          ; B
  7842 00004940 [8A070000]                  dd m_variable   ; C magenta variable
  7843 00004944 [40040000]                  dd nul          ; D
  7844 00004948 [40040000]                  dd nul          ; E
  7845 0000494C [40040000]                  dd nul          ; F
  7846                                  
  7847                                  v_gr_xy:  ; variable that holds the XY position for drawing characters, ( 0, 0 ) is top left
  7848                                  v_gr_y:
  7849 00004950 0300                        dw 0x0003
  7850                                  v_gr_x:
  7851 00004952 0300                        dw 0x0003
  7852                                  
  7853                                  v_leftMargin:
  7854 00004954 03000000                    dd 0x00000003  ; left margin
  7855                                  
  7856                                  v_rightMargin:
  7857 00004958 00000000                    dd 0           ; right margin
  7858                                  
  7859                                  ; xycr:
  7860                                      ; dd 0
  7861                                  
  7862                                  v_fov:  ; abstract display scale
  7863 0000495C 00000000                    dd 0    ; 10 * ( 2 * scrnh + scrnh / 2 )
  7864                                  
  7865                                  vframe:  ; pointer to display frame buffer where we create our image, down from top of 32 Mbytes RAM ( 0x2000000 )
  7866 00004960 0000E801                    dd 0x2000000 - ( MAX_SCREEN_WIDTH * MAX_SCREEN_HEIGHT * BYTES_PER_PIXEL )
  7867                                  
  7868                                  ; v_frameBuffer:          ; framebuffer address
  7869                                  ;    dd 0x00000000       ;
  7870                                  
  7871                                  v_foregroundColour:
  7872 00004964 00000000                    dd 0x00000000       ; the display foreground colour, set by  set_color_
  7873                                  
  7874                                  v_xc:
  7875 00004968 00000000                    dd 0x00000000       ;
  7876                                  v_yc:
  7877 0000496C 00000000                    dd 0x00000000          ;
  7878                                  
  7879                                  MacroNamesROM:
  7880 00004970 000000F0                    dd 0xF0000000       ; semicolon ";"
  7881 00004974 00109BC1                    dd 0xC19B1000       ; dup
  7882 00004978 203683CF                    dd 0xCF833620       ; qdup
  7883                                  ;    dd 0xFF833620       ; ?dup
  7884 0000497C 008827C0                    dd 0xC0278800       ; drop
  7885 00004980 00C0882C                    dd 0x2C88C000       ; then
  7886 00004984 007695C6                    dd 0xC6957600       ; begin_
  7887                                  ; MacroNamesROM_end:
  7888                                  
  7889                                  MacroJumpTableROM:         ; jump table for the macro wordlist
  7890 00004988 [CC080000]                  dd semicolon        ; ;
  7891 0000498C [34060000]                  dd cdup             ; compile dup
  7892 00004990 [4C060000]                  dd qdup             ; qdup
  7893 00004994 [18060000]                  dd cdrop            ; compile drop
  7894 00004998 [F0080000]                  dd then             ;
  7895 0000499C [03090000]                  dd begin_           ;
  7896                                  MacroJumpTableROM_end:
  7897                                  
  7898                                  ForthNamesROM:      ; displayed using cf2ansi
  7899 000049A0 004066C6                    dd 0xC6664000   ; boot
  7900 000049A4 00408CBA                    dd 0xBA8C4000   ; warm
  7901 000049A8 80A0B9C4                    dd 0xC4B9A080   ; pause
  7902 000049AC 004CC88A                    dd 0x8AC84C00   ; macro     macro_
  7903 000049B0 006489B1                    dd 0xB1896400   ; forth     forth_
  7904 000049B4 00000090                    dd 0x90000000   ; c
  7905 000049B8 0050631A                    dd 0x1A635000   ; rlba      Read_Sector_LBA
  7906 000049BC 00A831BD                    dd 0xBD31A800   ; wlba      Write_Sector_LBA
  7907 000049C0 00105C14                    dd 0x145C1000   ; reads     ReadSectors
  7908 000049C4 0024B9B8                    dd 0xB8B92400   ; writes    WriteSectors
  7909 000049C8 00002084                    dd 0x84200000   ; sss       SaveAll_
  7910                                  ;    dd 0x2C800000   ; th        th_ ( thunk to BIOS Int 0x13 )
  7911 000049CC 00005C14                    dd 0x145C0000   ; read      bios_read
  7912 000049D0 0020B9B8                    dd 0xB8B92000   ; write     bios_write
  7913                                  ;    dd 0x18248800   ; rsect
  7914 000049D4 002883F9                    dd 0xF9832800   ; @dx       fetchDX_
  7915 000049D8 007181F5                    dd 0xF5817100   ; !dap
  7916 000049DC 00001059                    dd 0x59100000   ; act(tivate)
  7917 000049E0 00B84386                    dd 0x8643B800   ; show
  7918 000049E4 0000AEA1                    dd 0xA1AE0000   ; load
  7919 000049E8 00E01A6A                    dd 0x6A1AE000   ; nload
  7920 000049EC 005C43F7                    dd 0xF7435C00   ; +load
  7921 000049F0 0098832C                    dd 0x2C839800   ; thru
  7922 000049F4 300759F6                    dd 0xF6590730   ; +thru
  7923 000049F8 00743A96                    dd 0x963A7400   ; cblk      return the block number currently being compiled, calculated from  edi
  7924 000049FC 00E8741C                    dd 0x1C74E800   ; rblk      return the block number offset of the RELOCATED address
  7925 00004A00 00E8745C                    dd 0x5C74E800   ; ablk      4 / cellAddressToBlock
  7926 00004A04 00205841                    dd 0x41582000   ; erase
  7927 00004A08 008082C8                    dd 0xC8828000   ; here      here_
  7928 00004A0C 002047FF                    dd 0xFF472000   ; ?lit
  7929 00004A10 0000F8D7                    dd 0xD7F80000   ; 3,
  7930 00004A14 0000F8D5                    dd 0xD5F80000   ; 2,
  7931 00004A18 0000F8D3                    dd 0xD3F80000   ; 1,
  7932 00004A1C 0000E097                    dd 0x97E00000   ; c,
  7933 00004A20 000000FC                    dd 0xFC000000   ; ,
  7934 00004A24 000042A2                    dd 0xA2420000   ; less
  7935 00004A28 80389AE5                    dd 0xE59A3880   ; jump
  7936 00004A2C 00C899CF                    dd 0xCF99C800   ; quit_      was accept = dd 0x59493110
  7937 00004A30 0000B8C4                    dd 0xC4B80000   ; pad_
  7938 00004A34 409601C3                    dd 0xC3019640   ; vsrch_
  7939 00004A38 0020CB80                    dd 0x80CB2000   ; srch_
  7940 00004A3C 80C593E8                    dd 0xE893C580   ; keypd_
  7941 00004A40 0040E2BB                    dd 0xBBE24000   ; wipe
  7942 00004A44 0048E2BB                    dd 0xBBE24800   ; wipes     was erase
  7943 00004A48 0098E291                    dd 0x91E29800   ; copy
  7944 00004A4C 00408F8A                    dd 0x8A8F4000   ; mark
  7945 00004A50 8029E248                    dd 0x48E22980   ; empty
  7946 00004A54 0000B948                    dd 0x48B90000   ; emit
  7947 00004A58 0040E229                    dd 0x29E24000   ; type   type_
  7948 00004A5C 0072F5C0                    dd 0xC0F57200   ; digit
  7949 00004A60 007291D4                    dd 0xD4917200   ; 2emit
  7950 00004A64 000000EA                    dd 0xEA000000   ; .
  7951 00004A68 0050D7C9                    dd 0xC9D75000   ; h.2    dotHex2_ 
  7952 00004A6C 0060D7C9                    dd 0xC9D76000   ; h.4    dotHex4_ 
  7953 00004A70 0000D4C9                    dd 0xC9D40000   ; h.     dotHex8_
  7954 00004A74 0080D5C9                    dd 0xC9D58000   ; h.n
  7955 00004A78 00008090                    dd 0x90800000   ; cr
  7956 00004A7C 00922586                    dd 0x86259200   ; space
  7957 00004A80 006077C0                    dd 0xC0776000   ; down
  7958 00004A84 00400E4C                    dd 0x4C0E4000   ; edit
  7959 00004A88 00000040                    dd 0x40000000   ; e
  7960 00004A8C 000040A4                    dd 0xA4400000   ; lm
  7961 00004A90 00008018                    dd 0x18800000   ; rm
  7962 00004A94 802CAEA8                    dd 0xA8AE2C80   ; graph
  7963 00004A98 0040CA24                    dd 0x24CA4000   ; text
  7964 00004A9C A0C493E8                    dd 0xE893C4A0   ; keypa(d)  displayTheKeypad_  was 0xE893C660 keybo(ard)
  7965 00004AA0 00F398C0                    dd 0xC098F300   ; debu(g)
  7966 00004AA4 00000052                    dd 0x52000000   ; at
  7967 00004AA8 0000A4F6                    dd 0xF6A40000   ; +at
  7968 00004AAC 000030CB                    dd 0xCB300000   ; xy
  7969 00004AB0 0040B5C4                    dd 0xC4B54000   ; page
  7970 00004AB4 80118584                    dd 0x84851180   ; screen
  7971 00004AB8 0000E1B1                    dd 0xB1E10000   ; fov
  7972                                  ;    dd 0xB3D8C000   ; fifo
  7973 00004ABC 004079C6                    dd 0xC6794000   ; box
  7974 00004AC0 0000B2A3                    dd 0xA3B20000   ; line
  7975 00004AC4 00C4D091                    dd 0x91D0C400   ; color     set_color_
  7976 00004AC8 00B11239                    dd 0x3912B100   ; octant
  7977 00004ACC 00002086                    dd 0x86200000   ; sp
  7978 00004AD0 0080C0A2                    dd 0xA2C08000   ; last
  7979 00004AD4 4096D8CC                    dd 0xCCD89640   ; unpac(k)
  7980 00004AD8 00E8B2C4                    dd 0xC4B2E800   ; pack
  7981 00004ADC 00804EC7                    dd 0xC74E8000   ; blk
  7982 00004AE0 00AE8584                    dd 0x8485AE00   ; scrnw   screen width in pixels
  7983 00004AE4 00B28584                    dd 0x8485B200   ; scrnh   screen height in pixels
  7984 00004AE8 00108BC7                    dd 0xC78B1000   ; bpp     bits per pixel
  7985 00004AEC 0000B1B1                    dd 0xB1B10000   ; font    address of font pointer, containing by default font16x24
  7986 00004AF0 005C1B79                    dd 0x791B5C00   ; iconw   icon width in pixels
  7987 00004AF4 00641B79                    dd 0x791B6400   ; iconh   icon height in pixels
  7988 00004AF8 4062E691                    dd 0x91E66240   ; counte(r) counter
  7989 00004AFC 0000008C                    dd 0x8C000000   ; ms      ms_
  7990 00004B00 80244836                    dd 0x36482480   ; onesec  onesec_
  7991 00004B04 00B093E9                    dd 0xE993B000   ; khz     khz_
  7992 00004B08 00C09712                    dd 0x1297C000   ; rtc@    rtc_fetch_
  7993 00004B0C 00A09712                    dd 0x1297A000   ; rtc!    rtc_store_
  7994 00004B10 005DD292                    dd 0x92D25D00   ; calck   calck_
  7995 00004B14 000082C2                    dd 0xC2820000   ; ver
  7996 00004B18 00806196                    dd 0x96618000   ; curs
  7997 00004B1C 409743C7                    dd 0xC7439740   ; block_    block number to address
  7998 00004B20 D0F9585D                    dd 0x5D58F9D0   ; a2blk_    address to block number
  7999 00004B24 A05861C3                    dd 0xC36158A0   ; vframe  video frame address, where we create the image to be displayed
  8000 00004B28 0000A3C2                    dd 0xC2A30000   ; vars
  8001                                  ; new words
  8002 00004B2C 00302682                    dd 0x82263000   ; seeb     ( see blue words, toggle )
  8003 00004B30 40BA2C81                    dd 0x812CBA40   ; stacks_
  8004 00004B34 000B65C0                    dd 0xC0650B00   ; dotsf    type a ShannonFano token
  8005 00004B38 00142EA2                    dd 0xA22E1400   ; leave
  8006                                  ;    dd 0x12312310   ; txtq
  8007 00004B3C 0000E31A                    dd 0x1AE30000   ; rgb
  8008 00004B40 000034C7                    dd 0xC7340000   ; bye
  8009 00004B44 00008EB9                    dd 0xB98E0000   ; word
  8010 00004B48 0000844E                    dd 0x4E840000   ; ekt
  8011 00004B4C 0024665C                    dd 0x5C662400   ; abort_
  8012 00004B50 804C9727                    dd 0x27974C80   ; tickh  HERE variable address
  8013 00004B54 40D69AC7                    dd 0xC79AD640   ; buffe(r)  buffer_
  8014 00004B58 40085A3B                    dd 0x3B5A0840   ; offset
  8015 00004B5C 00009027                    dd 0x27900000   ; tic   tic_
  8016 00004B60 005090C2                    dd 0xC2905000   ; vesa
  8017 00004B64 805890C2                    dd 0xC2905880   ; vesam
  8018 00004B68 00645821                    dd 0x21586400   ; trash trash_
  8019                                  ;    dd 0xC90C3840   ; hsvv_
  8020 00004B6C 001C73C3                    dd 0xC3731C00   ; vword
  8021                                  ;    dd 0xC2295800   ; vregs
  8022 00004B70 0020297C                    dd 0x7C292000   ; ivec
  8023 00004B74 00308614                    dd 0x14863000   ; resb  restore_BIOS_idt_and_pic
  8024 00004B78 0000F2C4                    dd 0xC4F20000   ; pic
  8025 00004B7C 0080B8C0                    dd 0xC0B88000   ; dap
  8026 00004B80 00804882                    dd 0x82488000   ; sect
  8027 00004B84 00088EB9                    dd 0xB98E0800   ; words
  8028 00004B88 000093E8                    dd 0xE8930000   ; key
  8029 00004B8C 0026D1CF                    dd 0xCFD12600   ; qkey
  8030 00004B90 0076F5C0                    dd 0xC0F57600   ; digin
  8031 00004B94 001274CF                    dd 0xCF741200   ; qwert
  8032 00004B98 0000E01F                    dd 0x1FE00000   ; r?
  8033 00004B9C 0000D46C                    dd 0x6CD40000   ; nul
  8034 00004BA0 0000E092                    dd 0x92E00000   ; cad
  8035 00004BA4 00C025C5                    dd 0xC525C000   ; pcad
  8036 00004BA8 40C5F0C0                    dd 0xC0F0C540   ; displ(ay)
  8037 00004BAC 00801459                    dd 0x59148000   ; actc
  8038 00004BB0 008147F7                    dd 0xF7478100   ; +list
  8039 00004BB4 00747972                    dd 0x72797400   ; itick
  8040 00004BB8 0000C0A3                    dd 0xA3C00000   ; lisl
  8041 00004BBC 000080F6                    dd 0xF6800000   ; +e
  8042 00004BC0 201D0E82                    dd 0x820E1D20   ; serv1     serv1_
  8043 00004BC4 201D0E78                    dd 0x780E1D20   ; isrv1_    initserv1_
  8044 00004BC8 401D0E82                    dd 0x820E1D40   ; serv2     serv2_
  8045 00004BCC 401D0E78                    dd 0x780E1D40   ; isrv2_    initserv2_
  8046 00004BD0 004A0E4C                    dd 0x4C0E4A00   ; edita     editAddress_
  8047 00004BD4 603B3A96                    dd 0x963A3B60   ; cblind
  8048                                  
  8049 00004BD8 0000C097                    dd 0x97C00000   ; c@        cFetch_
  8050 00004BDC 0000C0BF                    dd 0xBFC00000   ; w@        wFetch_
  8051 00004BE0 000000F8                    dd 0xF8000000   ; @         fetch_          no longer replaced by optimising verson in block 68
  8052                                      ; dd 0xB214B200   ; fetch     fetch_          was replaced by optimising verson in block 68
  8053                                  
  8054 00004BE4 0000F0D5                    dd 0xD5F00000   ; 2@        two_fetch_      no longer replaced by optimising verson in block 68
  8055                                  
  8056 00004BE8 0000A097                    dd 0x97A00000   ; c!        cStore_
  8057 00004BEC 0000A0BF                    dd 0xBFA00000   ; w!        wStore_
  8058 00004BF0 000000F4                    dd 0xF4000000   ; !         store_          no longer replaced by optimising verson in block 68
  8059 00004BF4 0000E8F7                    dd 0xF7E80000   ; +!        plus_store_
  8060 00004BF8 0000E8D5                    dd 0xD5E80000   ; 2!        two_store_      no longer replaced by optimising verson in block 68
  8061                                  
  8062 00004BFC 0050C9C0                    dd 0xC0C95000   ; dneg      d_negate_
  8063 00004C00 0000ECC1                    dd 0xC1EC0000   ; d+        d_plus_
  8064 00004C04 0000CCC1                    dd 0xC1CC0000   ; d-        d_minus_
  8065 00004C08 203683D5                    dd 0xD5833620   ; 2dup      two_dup_
  8066                                  
  8067 00004C0C 104F80D5                    dd 0xD5804F10   ; 2drop     two_drop_	bug fix from Marco Nicola
  8068 00004C10 20AE0BD5                    dd 0xD50BAE20   ; 2swap     two_swap_
  8069 00004C14 405078D4                    dd 0xD4785040   ; 2over     two_over_
  8070 00004C18 00002013                    dd 0x13200000   ; rot       rot_
  8071 00004C1C 004026E6                    dd 0xE6264000   ; -rot      minus_rot_
  8072 00004C20 00E8D22C                    dd 0x2CD2E800   ; tuck      tuck_
  8073 00004C24 00E8F2C4                    dd 0xC4F2E800   ; pick      pick_
  8074                                  
  8075 00004C28 00805292                    dd 0x92528000   ; cell      cell_
  8076 00004C2C C09C5292                    dd 0x92529CC0   ; cell-     cell_minus_
  8077 00004C30 C09E5292                    dd 0x92529EC0   ; cell+     cell_plus_
  8078 00004C34 00905292                    dd 0x92529000   ; cells     cells_
  8079                                  
  8080 00004C38 000020A6                    dd 0xA6200000   ; lp        lp_
  8081                                  
  8082 00004C3C 0020E0A3                    dd 0xA3E02000   ; lidt      lidt_
  8083 00004C40 0020E083                    dd 0x83E02000   ; sidt      sidt_
  8084                                  
  8085 00004C44 0000DCD5                    dd 0xD5DC0000   ; 2/        two_slash_
  8086 00004C48 00B8ABCD                    dd 0xCDABB800   ; u2/       u_two_slash_
  8087 00004C4C 107B6418                    dd 0x18647B10   ; rshift    rshift_
  8088 00004C50 00B8ABCD                    dd 0xCDABB800   ; lshif     lshift_
  8089 00004C54 0000DCFB                    dd 0xFBDC0000   ; */        star_slash_
  8090 00004C58 00B8F7CD                    dd 0xCDF7B800   ; u*/       u_star_slash_
  8091 00004C5C 00C013EF                    dd 0xeF13C000   ; /mod      slash_mod_
  8092 00004C60 8027DEFB                    dd 0xFBDE2780   ; */mod     star_slash_mod_
  8093 00004C64 000A4F94                    dd 0x944F0A00   ; cmove_    cmove
  8094 00004C68 0000F4D5                    dd 0xD5F40000   ; 2*        two_star_
  8095 00004C6C 00E8F7D5                    dd 0xD5F7E800   ; 2**       two_star_star_
  8096                                  ;    dd 0xD5DC0000  ; u/        u/_
  8097 00004C70 80CF2C96                    dd 0x962CCF80   ; cpuid     GetCPUID_
  8098 00004C74 0009051C                    dd 0x1C050900   ; rdtsc
  8099 00004C78 00006C15                    dd 0x156C0000   ; rand      rand_
  8100 00004C7C C01D6C15                    dd 0x156C1DC0   ; rand/     randInit_
  8101 00004C80 C0196C15                    dd 0x156C19C0   ; randq     randq_
  8102 00004C84 A05ECB90                    dd 0x90CB5EA0   ; crc32     crc32_
  8103 00004C88 00A00D8E                    dd 0x8E0DA000   ; md5       md5_
  8104 00004C8C C0B80D8E                    dd 0x8E0DB8C0   ; md5b      md5buf_
  8105                                  
  8106                                  ;    dd 0xB18C5480   ; format
  8107                                  ;    dd 0xC5270000   ; pci
  8108                                  ;    dd 0x68248000   ; nsec      was devic(e)
  8109 00004C90 90A5DC85                    dd 0x85DCA590   ; switch    switch 
  8110 00004C94 4076A2B0                    dd 0xB0A27640   ; freeze    freeze 
  8111 00004C98 0000C423                    dd 0x23C40000   ; top       top_   
  8112                                      
  8113 00004C9C 0040C98A                    dd 0x8AC94000   ; maca      maca_  
  8114 00004CA0 0080C98A                    dd 0x8AC98000   ; macn      macn_ 
  8115 00004CA4 0080CA8A                    dd 0x8ACA8000   ; macl      macl_      
  8116 00004CA8 0080C88A                    dd 0x8AC88000   ; mact      mact_      
  8117                                  
  8118 00004CAC 005064B1                    dd 0xB1645000   ; ftha      ftha_  
  8119 00004CB0 006064B1                    dd 0xB1646000   ; fthn      fthn_  
  8120 00004CB4 00A064B1                    dd 0xB164A000   ; fthl      fthl_  
  8121 00004CB8 002064B1                    dd 0xB1642000   ; ftht      ftht_  
  8122                                  
  8123 00004CBC 00CA4CC7                    dd 0xC74CCA00   ; blua      blua_  
  8124 00004CC0 00CC4CC7                    dd 0xC74CCC00   ; blun      blun_  
  8125 00004CC4 40663AB6                    dd 0xB63A6640   ; fblue     find_Blue_word_
  8126 00004CC8 0000C8A1                    dd 0xA1C80000   ; loc       loc_
  8127 00004CCC 00002082                    dd 0x82200000   ; see       see_
  8128 00004CD0 000060B3                    dd 0xB3600000   ; fnd       fnd_
  8129 00004CD4 00401CC1                    dd 0xC11C4000   ; dmp       dmp_
  8130 00004CD8 0020A94C                    dd 0x4CA92000   ; exec      execute_
  8131                                  
  8132 00004CDC 000000CA                    dd 0xCA000000   ; x         x_
  8133 00004CE0 00000098                    dd 0x98000000   ; y         y_
  8134 00004CE4 000000EC                    dd 0xEC000000   ; z         z_
  8135 00004CE8 00743AA6                    dd 0xA63A7400   ; lblk      lblk_
  8136                                  
  8137 00004CEC 00000000                    dd 0            ; terminating null at the end of the list
  8138                                  
  8139                                  ForthJumpTableROM:  ; jumptable:
  8140 00004CF0 [D82F0000]                  dd boot         ;
  8141 00004CF4 [54330000]                  dd warm         ;
  8142 00004CF8 [51040000]                  dd pause_       ; pause
  8143 00004CFC [6E060000]                  dd macro_       ; macro     select the macto wordlist
  8144 00004D00 [9B060000]                  dd forth_       ; forth     select the forth wordlist
  8145 00004D04 [7B050000]                  dd c_           ; c
  8146 00004D08 4FAE0000                    dd Read_Sector_LBA   - $$ + BOOTOFFSET  ; jmp Read_Sector_LBA
  8147 00004D0C 67AE0000                    dd Write_Sector_LBA  - $$ + BOOTOFFSET  ; jmp Write_Sector_LBA
  8148 00004D10 7FAE0000                    dd ReadSectors  - $$ + BOOTOFFSET  ; jmp ReadSectors    reads
  8149 00004D14 BFAE0000                    dd WriteSectors - $$ + BOOTOFFSET  ; jmp WriteSectors   writes
  8150 00004D18 08AF0000                    dd SaveAll_     - $$ + BOOTOFFSET  ; jmp SaveAll_
  8151                                  ;    dd th_        - $$ + BOOTOFFSET ; jmp th_ ( thunk to BIOS Int 0x13 )
  8152 00004D1C 497F0000                    dd bios_read  - $$ + BOOTOFFSET ; jmp bios_read   'read'
  8153 00004D20 917F0000                    dd bios_write - $$ + BOOTOFFSET ; jmp bios_write  'write'
  8154                                  ;    dd XXXrsect_  - $$ + BOOTOFFSET ; jmp rsect_  'rsect'
  8155 00004D24 [6B380000]                  dd fetchDX_     ; @dx
  8156 00004D28 [55310000]                  dd setupDAP_    ; !dap
  8157 00004D2C [94040000]                  dd activate     ; act
  8158 00004D30 [AF040000]                  dd show         ;
  8159 00004D34 [93090000]                  dd _load_       ;
  8160 00004D38 [B0090000]                  dd nload        ; nload
  8161 00004D3C [BF090000]                  dd plusLoad     ; +load
  8162 00004D40 [CE090000]                  dd thru_        ; thru
  8163 00004D44 [010A0000]                  dd plusThru_    ; +thru
  8164 00004D48 [1C0A0000]                  dd cblk_        ;           return the block number currently being compiled, calculated from  edi
  8165 00004D4C [290A0000]                  dd rblk_        ;           return the block number offset of the RELOCATED address
  8166 00004D50 [340A0000]                  dd ablk_        ;           convert byte address to block number
  8167 00004D54 [3D0A0000]                  dd erase_       ;
  8168 00004D58 [09090000]                  dd here_        ; here      returns the current dictionary pointer 
  8169 00004D5C [14090000]                  dd qlit         ; ?lit 
  8170 00004D60 [C5080000]                  dd comma3_      ; 3,   
  8171 00004D64 [BE080000]                  dd comma2_      ; 2,   
  8172 00004D68 [B7080000]                  dd comma1_      ; 1,   
  8173 00004D6C [B7080000]                  dd comma1_      ; c,   
  8174 00004D70 [9B080000]                  dd comma_       ; ,    
  8175 00004D74 [5B090000]                  dd less         ; less 
  8176 00004D78 [72090000]                  dd jump         ; jump 
  8177 00004D7C [731C0000]                  dd quit_        ; quit   
  8178 00004D80 [A2340000]                  dd pad_         ; pad
  8179 00004D84 [C5340000]                  dd vsrch_       ; vsrch
  8180 00004D88 [D0340000]                  dd srch_        ; srch
  8181 00004D8C [5C2D0000]                  dd keypd_       ; keypd  ( alias of pad )
  8182 00004D90 [DE2F0000]                  dd wipe         ;
  8183 00004D94 [FF2F0000]                  dd wipes        ;
  8184 00004D98 [0A300000]                  dd copy_        ; copy
  8185 00004D9C [81050000]                  dd mark         ;
  8186 00004DA0 [B2050000]                  dd empty_       ; empty
  8187 00004DA4 [C60F0000]                  dd emit_        ; emit
  8188 00004DA8 [EA0F0000]                  dd type_        ; type
  8189 00004DAC [03120000]                  dd digit        ;
  8190 00004DB0 [0D100000]                  dd two_emit     ; 2emit
  8191 00004DB4 [9C120000]                  dd dotDecimal   ; .
  8192 00004DB8 [42120000]                  dd dotHex2_     ; h.2
  8193 00004DBC [50120000]                  dd dotHex4_     ; h.4
  8194 00004DC0 [2F120000]                  dd dotHex8_     ; h.
  8195 00004DC4 [1D120000]                  dd h_dot_n      ; h.n
  8196 00004DC8 [970A0000]                  dd cr_          ; cr
  8197 00004DCC [D80F0000]                  dd space_       ; space
  8198 00004DD0 [47110000]                  dd down         ;
  8199 00004DD4 [D12C0000]                  dd edit_        ;
  8200 00004DD8 [D62C0000]                  dd e_           ; e
  8201 00004DDC [75110000]                  dd lm           ;
  8202 00004DE0 [7C110000]                  dd rm           ;
  8203 00004DE4 [060B0000]                  dd graphAction  ; graph
  8204 00004DE8 [1F100000]                  dd setupText_   ; text
  8205 00004DEC [86140000]                  dd displayTheKeypad_ ; keypa (d)
  8206 00004DF0 [3B300000]                  dd debug        ;
  8207 00004DF4 [83110000]                  dd _at          ; at
  8208 00004DF8 [92110000]                  dd plus_at      ; +at
  8209 00004DFC [DB340000]                  dd xy_          ;
  8210 00004E00 [74100000]                  dd page_        ; page
  8211 00004E04 [83100000]                  dd screen_      ; screen
  8212 00004E08 [12350000]                  dd fov_         ;
  8213                                  ;    dd fifo         ;
  8214 00004E0C [62100000]                  dd box_         ; box
  8215 00004E10 [31100000]                  dd line_        ; line
  8216 00004E14 [DD0A0000]                  dd set_color_    ; color
  8217 00004E18 [CF110000]                  dd octant       ;
  8218 00004E1C [1D350000]                  dd tokenActions_ ; tokenActions table
  8219 00004E20 [9D360000]                  dd last         ;
  8220 00004E24 [141D0000]                  dd unpack       ;
  8221 00004E28 [D5190000]                  dd pack_        ;
  8222 00004E2C [A8360000]                  dd blk_         ;
  8223 00004E30 [81350000]                  dd scrnw_       ; scrnw  screen width in pixels
  8224 00004E34 [8F350000]                  dd scrnh_       ; scrnh  screen height in pixels
  8225 00004E38 [9D350000]                  dd bpp_         ; bpp    bits per pixel
  8226 00004E3C [92360000]                  dd font_        ; font   address of font pointer, containing by default font16x24
  8227 00004E40 [AA350000]                  dd iconw_       ; iconw  icon width in pixels
  8228 00004E44 [B5350000]                  dd iconh_       ; iconh  icon height in pixels
  8229 00004E48 [C0350000]                  dd counter_     ; counter
  8230 00004E4C [7A360000]                  dd ms_          ; ms 
  8231 00004E50 [7C360000]                  dd onesec_      ; onesec
  8232 00004E54 [87360000]                  dd khz_         ; khz
  8233 00004E58 [EF350000]                  dd rtc_fetch_   ; rtc@    
  8234 00004E5C [FC350000]                  dd rtc_store_   ; rtc!    
  8235 00004E60 [44360000]                  dd calck_       ; calclk  calibrate the clock for ms 
  8236 00004E64 [33350000]                  dd version_     ; ver
  8237 00004E68 [C1360000]                  dd curs         ; curs
  8238 00004E6C [6F350000]                  dd block_       ; block
  8239 00004E70 [78350000]                  dd a2blk_       ; a2blk
  8240 00004E74 [3E350000]                  dd vframe_      ; vframe
  8241 00004E78 [49350000]                  dd vars_        ; vars
  8242                                  ; new words
  8243 00004E7C [B3360000]                  dd seeb         ; seeb
  8244 00004E80 [10370000]                  dd stacks_      ;
  8245 00004E84 [53210000]                  dd dotsf_       ; dotsf
  8246 00004E88 [4A210000]                  dd leave_       ; leave
  8247                                  ;    dd txtq_        ;
  8248 00004E8C [E40A0000]                  dd rgb          ; rgb
  8249 00004E90 [FA0A0000]                  dd bye_         ; bye
  8250 00004E94 [A7290000]                  dd _word        ;
  8251 00004E98 [35370000]                  dd ekt          ;
  8252 00004E9C [12060000]                  dd abort_       ;
  8253 00004EA0 [8D370000]                  dd tickh        ;
  8254 00004EA4 [88380000]                  dd buffer_      ; buffe(r)
  8255 00004EA8 [47380000]                  dd offset_      ;
  8256 00004EAC [88300000]                  dd tic_         ; tic
  8257 00004EB0 [52380000]                  dd vesa         ;
  8258 00004EB4 [5D380000]                  dd vesamode_    ;
  8259 00004EB8 [7D380000]                  dd trash_       ; trash
  8260                                  ;    dd hsvv_        ; hsvv
  8261 00004EBC [40370000]                  dd vword_       ; ('%s')", DB_NAME,
  8262                                  ;    dd vregs_       ; vregs
  8263 00004EC0 [4B370000]                  dd ivec_         ; ivec
  8264 00004EC4 [0A3A0000]                  dd restore_BIOS_idt_and_pic ; resb
  8265 00004EC8 [56370000]                  dd pic_         ; pic  Programmable Interrupt Controller settings, as set by the BIOS
  8266 00004ECC [61370000]                  dd dap_         ; dap
  8267 00004ED0 [6C370000]                  dd sect_        ; sect
  8268 00004ED4 [3B310000]                  dd words_       ; words
  8269 00004ED8 [09180000]                  dd get_key_     ; key
  8270 00004EDC [A6180000]                  dd get_qwerty_key_ ; qkey
  8271 00004EE0 [77370000]                  dd digin        ;
  8272 00004EE4 [552F0000]                  dd qwert        ;
  8273 00004EE8 [C72F0000]                  dd rquery       ; r?
  8274 00004EEC [40040000]                  dd nul          ;
  8275 00004EF0 [93380000]                  dd cad          ;
  8276 00004EF4 [9E380000]                  dd pcad         ;
  8277 00004EF8 [A9380000]                  dd displ        ;
  8278 00004EFC [82370000]                  dd actc         ;
  8279 00004F00 [82250000]                  dd plusList     ; +list
  8280 00004F04 [A5300000]                  dd itick        ;
  8281 00004F08 [3B260000]                  dd refresh      ; lis
  8282 00004F0C [E22C0000]                  dd plus_e       ; +e
  8283 00004F10 [1E050000]                  dd serv1_       ; serv1
  8284 00004F14 [39050000]                  dd initserv1_   ; isrv1_    
  8285 00004F18 [5A050000]                  dd serv2_       ; serv2
  8286 00004F1C [75050000]                  dd initserv2_   ; isrv1_    
  8287 00004F20 [3D2D0000]                  dd editAddress_ ; edita
  8288 00004F24 [B4380000]                  dd cBlindAddr_  ; cblind
  8289                                  
  8290 00004F28 [BF380000]                  dd cFetch_      ; c@
  8291 00004F2C [C6380000]                  dd wFetch_      ; w@
  8292 00004F30 [CE380000]                  dd fetch_       ; @     was replaced by optimising verson in block 68
  8293 00004F34 [D1380000]                  dd two_fetch_   ; 2@    was replaced by optimising verson in block 68
  8294 00004F38 [DF380000]                  dd cStore_      ; c!
  8295 00004F3C [E6380000]                  dd wStore_      ; w!
  8296 00004F40 [EE380000]                  dd store_       ; !     was replaced by optimising verson in block 68
  8297 00004F44 [03390000]                  dd plus_store_  ; +!
  8298 00004F48 [F5380000]                  dd two_store_   ; 2!    was replaced by optimising verson in block 68
  8299                                  
  8300 00004F4C [0A390000]                  dd d_negate_    ; dneg      
  8301 00004F50 [1A390000]                  dd d_plus_      ; d+    
  8302 00004F54 [2C390000]                  dd d_minus_     ; d-    
  8303 00004F58 [37390000]                  dd two_dup_     ; 2dup
  8304 00004F5C [48390000]                  dd two_drop_    ; 2drop
  8305 00004F60 [4B390000]                  dd two_swap_    ; 2swap
  8306 00004F64 [57390000]                  dd two_over_    ; 2over
  8307 00004F68 [66390000]                  dd rot_         ; rot
  8308 00004F6C [73390000]                  dd minus_rot_   ; -rot
  8309 00004F70 [80390000]                  dd tuck_        ; tuck
  8310 00004F74 [8B390000]                  dd pick_        ; pick
  8311                                  
  8312 00004F78 [8F390000]                  dd cell_        ; cell
  8313 00004F7C [9A390000]                  dd cell_minus_  ; cell-
  8314 00004F80 [A0390000]                  dd cell_plus_   ; cell+
  8315 00004F84 [A6390000]                  dd cells_       ; cells
  8316 00004F88 [D13A0000]                  dd lp_          ; lp
  8317 00004F8C [AB390000]                  dd lidt_        ; lidt
  8318 00004F90 [C2390000]                  dd sidt_        ; sidt
  8319 00004F94 [F23A0000]                  dd two_slash_   ; 2/      
  8320 00004F98 [F53A0000]                  dd u_two_slash_ ; u2/     
  8321 00004F9C [F83A0000]                  dd rshift_      ; rshift  
  8322 00004FA0 [FE3A0000]                  dd lshift_      ; lshif     lshift 
  8323 00004FA4 [223B0000]                  dd star_slash_  ; */ 
  8324 00004FA8 [343B0000]                  dd u_star_slash_; u*/    
  8325 00004FAC [043B0000]                  dd slash_mod_   ; /mod
  8326 00004FB0 [0E3B0000]                  dd star_slash_mod_ ; */mod
  8327 00004FB4 [503B0000]                  dd cmove_       ; cmove
  8328 00004FB8 [6E3B0000]                  dd two_star_    ; 2*      
  8329 00004FBC [713B0000]                  dd two_star_star_ ; 2**   _
  8330                                  ;    dd u/_          ; u/     
  8331                                  
  8332 00004FC0 [983B0000]                  dd GetCPUID_    ; cpuid
  8333 00004FC4 [A53B0000]                  dd rdtsc_       ; rdtsc
  8334 00004FC8 [EF3B0000]                  dd rand_        ; rand
  8335 00004FCC [AD3B0000]                  dd randInit_    ; rand/
  8336 00004FD0 [0D3C0000]                  dd randq_       ; randq
  8337 00004FD4 [29400000]                  dd crc32_       ; crc32
  8338 00004FD8 [54400000]                  dd md5_         ; md5
  8339 00004FDC [98370000]                  dd md5buf_      ; md5b      md5buf_   
  8340                                  
  8341                                  ;    dd format       ;
  8342                                  ;    dd pci          ;
  8343                                  ;    dd device       ;
  8344 00004FE0 [9C0F0000]                  dd switch       ;
  8345 00004FE4 [E1040000]                  dd freeze       ;
  8346 00004FE8 [740A0000]                  dd top_         ;
  8347                                  
  8348 00004FEC [A3370000]                  dd maca_        ; maca 
  8349 00004FF0 [AE370000]                  dd macn_        ; macn 
  8350 00004FF4 [B9370000]                  dd macl_        ; macl 
  8351 00004FF8 [C4370000]                  dd mact_        ; mact 
  8352                                                             
  8353 00004FFC [CF370000]                  dd ftha_        ; ftha 
  8354 00005000 [DA370000]                  dd fthn_        ; fthn 
  8355 00005004 [E5370000]                  dd fthl_        ; fthl 
  8356 00005008 [F0370000]                  dd ftht_        ; ftht 
  8357                                                             
  8358 0000500C [FB370000]                  dd blua_        ; blua 
  8359 00005010 [06380000]                  dd blun_        ; blun 
  8360 00005014 [BE240000]                  dd find_Blue_word_ ; fblue     
  8361 00005018 [11380000]                  dd loc_         ; loc       
  8362 0000501C [25380000]                  dd see_         ; see       
  8363 00005020 [2D380000]                  dd fnd_         ; fnd       
  8364 00005024 [3F380000]                  dd dmp_         ; dmp       
  8365 00005028 [E5070000]                  dd execute_     ; exec       
  8366                                  
  8367 0000502C [E6340000]                  dd x_           ; x         
  8368 00005030 [F1340000]                  dd y_           ; y         
  8369 00005034 [FC340000]                  dd z_           ; z       
  8370 00005038 [07350000]                  dd lblk_        ; lblk 
  8371                                  
  8372                                  ForthJumpTableROM_end:
  8373                                  
  8374                                  ; times 200 NOP   ;  enable this line to see how much space is left. If NASM reports :
  8375                                  ; "cf2022.nasm:6282: error: TIMES value -28 is negative" with "times 200" you have (200 - 28) bytes left
  8376                                  
  8377                                  ; fill with no-ops to 55AA at end of boot sector, less $40 for the info string
  8378 0000503C 90<rep 7FC4h>           times ( ( START_BLOCK_NUMBER - SIZE_OF_FONT_IN_BLOCKS ) * 0x400 ) - ($ - $$)  NOP
  8379                                  
  8380                                  ; the above produces a 26K boot image, we then add the 6K font and colorForth source blocks:
  8381                                  font16x24:
  8382                                  ; incbin "cf2023_font.img"
  8383                                  ; incbin "cf2023Ref.img",( OFFSET_OF_FONT +(SIZE_OF_FONT_IN_BLOCKS *1024) ), ( 512 * 1024 ) ; append the font and colorForth source blocks from the reference image, skip the kernel code
  8384                                  ; colorForth:                         ; the colorForth source blocks
  8385 0000D000 <bin 73000h>            incbin "cf2023Ref.img", OFFSET_OF_FONT, ( ( 512 - START_BLOCK_NUMBER + SIZE_OF_FONT_IN_BLOCKS ) * 1024 ); append the font and colorForth source blocks from the reference image, skip the kernel code
  8386 00080000 55<rep 8000h>           times 32768 db 'U'
  8387                                  
  8388                                  ; end of file
