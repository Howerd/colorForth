     1                                  ; cf2019.nasm 2019 Sep 14  "" (512K byte image size) with arrow, Enter and Escape keys
     2                                  ; colorForth for 80x86 PC for NASM , with 1024x768 and 800x600 graphics options
     3                                  ; Adapted by Howerd Oakford from code by :
     4                                  ; Chuck Moore : inventor, MASM
     5                                  ; Mark Slicker : ported to GNU Assembler
     6                                  ; Peter Appelman : ported to NASM with qwerty keyboard
     7                                  ; John Comeau : BIOS boot from ClusterFix
     8                                  ; and others... Thanks to all!!!
     9                                  ; Feedback welcome : howerd@inventio.co.uk www.inventio.co.uk
    10                                  
    11                                  ; %define NOT_BOCHS     Bochs cannot handle resetting of the PIT chips, so we can optionally disable this
    12                                  
    13                                  ; CPU 386 ; Assemble instructions for the 386 instruction set
    14                                  
    15                                  %define FORCE_800x600_VESA  0   ; true to force 800 x 600 x 16 bits for testing in  bochs
    16                                  
    17                                  %define START_BLOCK_NUMBER      32 ; must be an even number
    18                                  
    19                                  %define SIZE_OF_FONT_IN_BLOCKS   6
    20                                  %define OFFSET_OF_FONT          ( ( START_BLOCK_NUMBER - SIZE_OF_FONT_IN_BLOCKS ) * 0x400 )
    21                                  %define LAST_BLOCK_NUMBER       511  ; must be an odd number
    22                                  
    23                                  %define SECTORS_TO_LOAD ( ( LAST_BLOCK_NUMBER + 1 ) * 2 )   ; number of 512 octet sectors
    24                                  
    25                                  %define BITS_PER_PIXEL  16  ; MUST BE 16 !!! display pixel sizes, colour depth = 16 bit ( 2 bytes )
    26                                  
    27                                  ; for the maximum supported screen : 1024 x 768 pixels :
    28                                  %define MAX_SCREEN_WIDTH ( 1024 )   ; maximum screen width in pixels
    29                                  %define MAX_SCREEN_HEIGHT ( 768 )   ; maximum screen height in pixels
    30                                  
    31                                  %define BYTES_PER_PIXEL ( BITS_PER_PIXEL / 8 )
    32                                  
    33                                  PIXEL_SHIFT equ 1           ; how many bits to shift to scale by BYTES_PER_PIXEL
    34                                  
    35                                  ; Memory Map
    36                                  ; start   length
    37                                  ; 0x100000 ....   RAM
    38                                  ; 0xC0000 0xFFFFF BIOS video ROM - its not RAM!
    39                                  ; 0xB8000 0x08000 BIOS video RAM
    40                                  ; 0x10000 0xA8000 COLORFTH.CFX file is copied here
    41                                  ; 0x0F000 0x01000 BIOS shadow RAM - its OK to use this if we do not call the video BIOS
    42                                  ; 0x0A000 0x05000 BIOS video RAM - do not use until we have changed video mode
    43                                  ; 0x07c00 0x00200 BPB Boot sector after loading by BIOS
    44                                  ; 0x07c0b <----- di points here, the BPB ( + offset )  and variables ( - offset ) are accessed via [di]
    45                                  ; 0x07b8c 0x00080 variables referenced via [di], followed by BPB variables referenced via [di]
    46                                  ; 0x07800         Stacks, size = 0x0200 each , growing downwards
    47                                  ; 0x02000 0x06800 SECTOR_BUFFER
    48                                  ; 0x00000 0x02000 BIOS RAM
    49                                  
    50                                  %define SECTOR_BUFFER           0x00002000              ; buffer for disk reads and writes
    51                                  %define SECTOR_BUFFER_SIZE      0x4800                  ; 18 K bytes, 36 x 512 byte sectors
    52                                  %define INTERRUPT_VECTORS       ( SECTOR_BUFFER - 0x0400 ) ; the IDT register points to these interrupt vectors
    53                                  %define VESA_BUFFER             ( INTERRUPT_VECTORS - 0x0400 ) ; for the VESA mode information
    54                                  %define DAP_BUFFER              ( VESA_BUFFER   - 0x0020 ) ; 0x1BE0 for the Int 0x13 Disk Address Packet (DAP)
    55                                  %define DISK_INFO               ( DAP_BUFFER    - 0x0020 ) ; for the Int 0x13 AH=08h get info
    56                                  %define IDT_AND_PIC_SETTINGS    ( DISK_INFO     - 0x0040 ) ; bytes 0x00 - 0x05 SIDT value, 0x06 PIC1 IMR , 0x07 PIC2 IMR values saved at startup
    57                                  %define V_REGS                  ( IDT_AND_PIC_SETTINGS - 0x0020 ) ; test only - registers before and after thunk call
    58                                  %define TRASH_BUFFER            ( V_REGS        - 0x0400 ) ; saves words deleted while editing
    59                                  
    60                                  %define PIC_BIOS_IDT_SETTINGS   ( IDT_AND_PIC_SETTINGS )   ; bytes 0x00 - 0x05 SIDT value, 0x06 PIC1 IMR , 0x07 PIC2 IMR values saved at startup
    61                                  %define PIC_BIOS_IMR_SETTINGS   ( IDT_AND_PIC_SETTINGS + 6 ) ; bytes 0x00 - 0x05 SIDT value, 0x06 PIC1 IMR , 0x07 PIC2 IMR
    62                                  
    63                                  %define PIC_NEW_IDT_SETTINGS    ( IDT_AND_PIC_SETTINGS + 0x10 )   ; bytes 0x00 - 0x05 SIDT value, 0x08 new PIC1 IMR , 0x09 new PIC2 IMR
    64                                  %define PIC_NEW_IMR_SETTINGS    ( IDT_AND_PIC_SETTINGS + 0x16 )   ; bytes 0x00 - 0x05 SIDT value, 0x08 new PIC1 IMR , 0x09 new PIC2 IMR
    65                                  
    66                                  %define IDT_AND_PIC_SETTINGS_PAD ( IDT_AND_PIC_SETTINGS + 0x20 )
    67                                  
    68                                  %define vesa_BytesPerScanLine   ( VESA_BUFFER + 0x0E )  ; screen width ( number of horizontal pixels )
    69                                  %define vesa_XResolution        ( VESA_BUFFER + 0x12 )  ; screen width ( number of horizontal pixels )
    70                                  %define vesa_YResolution        ( VESA_BUFFER + 0x14 )  ; screen height ( number of vertical pixels )
    71                                  %define vesa_BitsPerPixel       ( VESA_BUFFER + 0x19 )  ; bits per pixel
    72                                  %define vesa_SavedMode          ( VESA_BUFFER + 0x1E )  ; "Reserved" - we save the VESA mode here
    73                                  %define vesa_PhysBasePtr        ( VESA_BUFFER + 0x28 )  ; address of linear frame buffer
    74                                  
    75                                  %define BOOTOFFSET      0x7C00
    76                                  
    77                                  %assign RELOC_BIT 16                            ; the relocation address must be a power of 2
    78                                  %assign RELOCATED 1 << RELOC_BIT                ; 0x10000
    79                                  
    80                                  ; stack allocation, three pairs of data and return stacks
    81                                  ; Note : the return stack must be in the lowest 64K byte segment, for the BIOS calls to work.
    82                                  %define RETURN_STACK_0      0x7800 ; top of stack memory area ; 0xa0000 in CM's code, 0x10000 in JC's code
    83                                  %define DATA_STACK_SIZE     0x0200
    84                                  %define RETURN_STACK_SIZE   0x0200
    85                                  ; combined stack sizes
    86                                  %define STACK_SIZE          ( DATA_STACK_SIZE + RETURN_STACK_SIZE )
    87                                  %define TWOxSTACK_SIZE      ( STACK_SIZE * 2 )
    88                                  %define TOTAL_STACK_SIZE    ( STACK_SIZE * 3 )      ; three pairs of stacks, one for each task
    89                                  %define STACK_MEMORY_START  ( RETURN_STACK_0 - TOTAL_STACK_SIZE )
    90                                  ; data stacks
    91                                  %define DATA_STACK_0        ( RETURN_STACK_0 - RETURN_STACK_SIZE ) ; 0x9f400 in CM's code
    92                                  %define DATA_STACK_1        ( DATA_STACK_0 - STACK_SIZE )
    93                                  %define DATA_STACK_2        ( DATA_STACK_0 - TWOxSTACK_SIZE )
    94                                  ; return stacks
    95                                  %define RETURN_STACK_1      ( RETURN_STACK_0 - STACK_SIZE )
    96                                  %define RETURN_STACK_2      ( RETURN_STACK_0 - TWOxSTACK_SIZE )
    97                                  
    98                                  %define _TOS_  eax
    99                                  %define _TOS_x_  ax
   100                                  %define _TOS_l_  al
   101                                  
   102                                  %define _SCRATCH_  ebx
   103                                  %define _SCRATCH_x_  bx
   104                                  %define _SCRATCH_l_  bl
   105                                  
   106                                  %define _MOV_TOS_LIT_  (0xB8)   ; the opcode for mov eax, 32_bit_literal  (in next 32 bit cell)
   107                                  
   108                                  %macro _DUP_  0                 ; Top Of Stack is in the  _TOS_  register
   109                                      sub esi, byte 0x04 ; lea esi, [ esi - 0x04 ]     ; pre-decrement the stack pointer
   110                                      mov [ esi ], _TOS_          ; copy the Top Of Stack ( TOS ) register to Second On Stack ( on the real stack )
   111                                  %endmacro
   112                                  
   113                                  %macro _SWAP_  0
   114                                      xchg _TOS_, [ esi ]
   115                                  %endmacro
   116                                  
   117                                  %macro _OVER_  0
   118                                      sub esi, byte 0x04 ; lea esi, [ esi - 0x04 ]     ; pre-decrement the stack pointer
   119                                      mov [ esi ], _TOS_          ; copy the Top Of Stack ( TOS ) register to Second On Stack ( on the real stack )
   120                                      mov _TOS_, [ esi + 4 ]
   121                                  %endmacro
   122                                  
   123                                  %macro _DROP_ 0
   124                                      lodsd
   125                                  %endmacro
   126                                  
   127                                  %define START_OF_RAM    0x00468000
   128                                  %define ForthNames      START_OF_RAM                ; copied to RAM here from ROM ( i.e. boot program ) version
   129                                  %define ForthJumpTable  ( ForthNames + 0x2800 )     ; copied to RAM here from ROM ( i.e. boot program ) version
   130                                  %define MacroNames      ( ForthJumpTable + 0x2800 ) ; copied to RAM here from ROM ( i.e. boot program ) version
   131                                  %define MacroJumpTable  ( MacroNames + 0x2800 )     ; copied to RAM here from ROM ( i.e. boot program ) version
   132                                  
   133                                  %define H0              ( MacroJumpTable + 0x2800 ) ; initial value of the dictionary pointer
   134                                  
   135                                  %define SECTOR  512     ; bytes per floppy sector
   136                                  %define HEADS   2       ; heads on 1.44M floppy drive
   137                                  %define SECTORS 18      ; floppy sectors per track
   138                                  %define CYLINDER (SECTOR * SECTORS * HEADS)
   139                                  %define CELL 4          ; bytes per cell
   140                                  %define DEBUGGER 0xe1   ; port to hardware debugger?
   141                                  
   142                                  ; int 0x13 Disk Address Packet (DAP) pointed to by  si  :
   143                                  %define o_Int13_DAP_size           ( 0x00 ) ; 2  0x0010
   144                                  %define o_Int13_DAP_num_sectors    ( 0x02 ) ; 2  0x0001
   145                                  %define o_Int13_DAP_address        ( 0x04 ) ; 2  0x2000
   146                                  %define o_Int13_DAP_segment        ( 0x06 ) ; 2  0x0000
   147                                  %define o_Int13_DAP_LBA_64_lo      ( 0x08 ) ; 4  0x00000028
   148                                  %define o_Int13_DAP_LBA_64_hi      ( 0x0C ) ; 4  0x00000000
   149                                  ; extended DAP values
   150                                  %define o_Int13_DAP_readwrite      ( 0x10 ) ; 2  0x0000
   151                                  %define o_Int13_DAP_saved_DX       ( 0x12 ) ; 2  0x0000
   152                                  %define o_Int13_DAP_returned_AX    ( 0x14 ) ; 2  0xHH00 see AH Return Code below
   153                                  %define o_Int13_DAP_returned_carry_flag ( 0x16 ) ; 2  0x0000
   154                                  %define o_Int13_DAP_saved_CHS_CX   ( 0x18 ) ; 2  0x0000
   155                                  %define o_Int13_DAP_saved_CHS_DX   ( 0x1A ) ; 2  0x0000
   156                                  
   157                                  %macro LOAD_RELATIVE_ADDRESS  1
   158                                      mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
   159                                  %endmacro
   160                                  
   161                                  ; emit the given following character
   162                                  %macro EMIT_IMM 1
   163                                  ;    push esi
   164                                      _DUP_
   165                                      mov _TOS_, %1
   166                                      call emit_
   167                                  ;    pop esi
   168                                  %endmacro
   169                                  
   170                                  ; *****************************************************************************
   171                                  ; Registers used
   172                                  ; *****************************************************************************
   173                                  ; _TOS_ is the top stack item ( eax --> ebx )
   174                                  ; esp the call ... ret  return stack pointer
   175                                  ; edi  dictionary pointer ( H --> : HERE ( -- a )   H @ ; )
   176                                  ; esi is the stack pointer, also needed by lods and movs
   177                                  ; e.g. lodsd  loads a 32 bit dword from [ds:esi] into _TOS_, increments  esi  by 4
   178                                  ; ebx  scratch register
   179                                  ; ecx  counter and scratch register
   180                                  ; edx  run-time pointer (?), "a register" used by  a!  , otherwise scratch register
   181                                  ; ebp  variable pointer register
   182                                  ; "ds" = selector 0x10 ==> 0x0000:0000
   183                                  ; "es" = selector 0x10 ==> 0x0000:0000
   184                                  ; "ss" = selector 0x10 ==> 0x0000:0000
   185                                  
   186                                  ; colours RGB in 16 bits
   187                                  colour_background   equ 0x0000
   188                                  colour_yellow       equ 0xFFE0
   189                                  colour_black        equ 0x0000
   190                                  colour_red          equ 0xF800
   191                                  colour_green        equ 0x0600
   192                                  colour_cyan         equ 0x07FF
   193                                  colour_white        equ 0xFFFF
   194                                  colour_light_blue   equ 0x841F
   195                                  colour_silver       equ 0xC618
   196                                  colour_magenta      equ 0xF81F
   197                                  colour_magentaData  equ 0xD010
   198                                  colour_blue         equ 0x001F
   199                                  colour_orange       equ 0xE200
   200                                  colour_dark_yellow  equ 0xFFE0
   201                                  colour_dark_green   equ 0x07C0
   202                                  colour_PacMan       equ 0xE200
   203                                  colour_blockNumber  equ 0xE200
   204                                  colour_taupe        equ 0xB2E7
   205                                  [BITS 16]                           ; Real Mode code (16 bit)
   206                                  
   207                                  org RELOCATED
   208                                  
   209                                  start:
   210                                  codeStart:
   211 00000000 E98100                      jmp  main_16bit    ; 0x03 bytes |  EB 58 90  00 Jump to boot code
   212                                      times 3 - ($ - $$) nop        ; fill with 1 or 0 no-ops to address 3
   213                                      ; BIOS boot parameter table = 0x25 bytes
   214 00000003 6366323031392030            db 'cf2019 0'      ; 03 Eight byte OEM name
   215 0000000B 0002                        dw 0x0200          ; 11 Number of Bytes Per Sector
   216 0000000D 08                          db 0x08            ; 13 Number of Sectors Per Cluster
   217 0000000E E005                        dw 0x05E0          ; 14 Number of Reserved Sectors until the FAT
   218 00000010 02                          db 0x02            ; 16 Number of Copies of FAT : always = 2
   219 00000011 0000                        dw 0x0000          ; 17 Maximum number of Root Directory Entries
   220 00000013 0000                        dw 0x0000          ; 19 Not used for FAT32
   221 00000015 F8                          db 0xF8            ; 21 Media type F0 = 1.44M 3.5 inch floppy disk, F8 = hard disk
   222 00000016 0000                        dw 0x0000          ; 22 Sectors Per FAT for FAT12 and FAT16 - not used for FAT32
   223 00000018 3F00                        dw 0x003F          ; 24 Sectors per Track
   224 0000001A FF00                        dw 0x00FF          ; 26 Number of heads
   225 0000001C 38000000                    dd 0x00000038      ; 28 Hidden sectors preceding the partition that contains this FAT volume
   226 00000020 C8777400                    dd 0x007477C8      ; 32
   227 00000024 101D0000                    dd 0x00001D10      ; 36 Sectors Per FAT for FAT32
   228 00000028 0000                        dw 0x0000          ; 40
   229 0000002A 0000                        dw 0x0000          ; 42
   230 0000002C 02000000                    dd 0x00000002      ; 44 Start of all directories, including root.
   231 00000030 0100                        dw 0x0001          ; 48
   232 00000032 0600                        dw 0x0006          ; 50 Offset in sectors from this sector to the backup BPB sector
   233                                  ;    times 12 db 0      ; 0x0C bytes |  00 00 00 00 00 00 00 00 00 00 00 00  52
   234                                  ;    db 0x00            ; 64
   235                                  ;    db 0x00            ; 65
   236                                  ;    db 0x29            ; 66 Extended Boot Signature
   237                                  ;    dd 0x44444444      ; 67 serial number
   238                                  ;    db 'colorForth '   ; 71 Eleven byte Volume Label
   239                                  ;    db 'cFblocks'      ; 82 Eight byte File System name
   240                                  
   241                                  ; ******************************************************************************
   242                                  ; ******************************************************************************
   243                                  
   244 00000034 90<rept>                align 8, nop    ; has to be aligned to 8 for GDT
   245                                      ; Note : we are NOT using null descriptor as GDT descriptor, see: http://wiki.osdev.org/GDT_Tutorial
   246                                      ; "The null descriptor which is never referenced by the processor. Certain emulators, like Bochs, will complain about limit exceptions if you do not have one present.
   247                                      ; Some use this descriptor to store a pointer to the GDT itself (to use with the LGDT instruction).
   248                                      ; The null descriptor is 8 bytes wide and the pointer is 6 bytes wide so it might just be the perfect place for this."
   249                                  
   250                                  gdt:                                ; the GDT descriptor
   251 00000038 2F00                        dw gdt_end - gdt - 1            ; GDT limit
   252 0000003A [407C]                      dw gdt0 + BOOTOFFSET            ; pointer to start of table, low 16 bits
   253 0000003C 00000000                    dw 0 , 0                        ; the high bits of the longword pointer to gdt
   254                                  
   255                                  gdt0:                               ; null descriptor
   256 00000040 0000                        dw 0    ; 0,1 limit 15:0
   257 00000042 0000                            dw 0    ; 2,3 base  15:0
   258 00000044 00                              db 0    ; 4   base  23:16
   259 00000045 00                              db 0    ; 5   type
   260 00000046 00                              db 0    ; 6   limit 19:16, flags
   261 00000047 00                              db 0    ; 7   base  31:24
   262                                  code32p_SELECTOR_0x08 equ $ - gdt0
   263                                  ; bytes   1 0     3 2     5 4     7 6
   264 00000048 FFFF0000009ACF00            dw 0xFFFF, 0x0000, 0x9A00, 0x00CF   ; 32-bit protected-mode code, limit 0xFFFFF
   265                                  data32p_SELECTOR_0x10 equ $ - gdt0
   266 00000050 FFFF00000092CF00            dw 0xFFFF, 0x0000, 0x9200, 0x00CF   ; 32-bit protected-mode data, limit 0xFFFFF
   267                                  code16r_SELECTOR_0x18 equ $ - gdt0
   268 00000058 FFFF0000009A0000            dw 0xFFFF, 0x0000, 0x9A00, 0x0000   ; 16-bit real-mode code, limit 0xFFFFF
   269                                  data16r_SELECTOR_0x20 equ $ - gdt0
   270 00000060 FFFF000000920000            dw 0xFFFF, 0x0000, 0x9200, 0x0000   ; 16-bit real-mode data, limit 0xFFFFF
   271                                  gdt_end:
   272                                  
   273                                  ; ******************************************************************************
   274                                  ; ******************************************************************************
   275                                  
   276                                  ; align to 4 so we can access variables from high-level Forth
   277                                  align 4, nop
   278                                  
   279                                  data_area:   ; data area begins here
   280                                  
   281                                  bootsector:                         ; LBA of boot sector
   282 00000068 00000000                    dd 0
   283                                  
   284                                  ; save disk information, cylinder, sector, head and drive from BIOS call
   285                                  driveinfo_Drive_DX:                 ; use low byte to store boot Drive into from BIOS DL
   286 0000006C 0000                        dw 0
   287                                  
   288                                  driveinfo_CX:         ; [7:6] [15:8][7] logical last index of cylinders = number_of - 1 (because index starts with 0)
   289                                                        ; [5:0][7] logical last index of sectors per track = number_of (because index starts with 1)
   290 0000006E 0000                        dw 0
   291                                  
   292                                  ; cylinders, sectors, heads of boot drive
   293                                  ; low word: high byte is head
   294                                  ; high word: cylinder and sector: C76543210 C98S543210
   295                                  driveinfo_Cylinder:
   296 00000070 00                          db 0
   297                                  driveinfo_Head:
   298 00000071 00                          db 0
   299                                  driveinfo_SectorsPertrack:
   300 00000072 0000                        dw 0
   301                                  
   302                                  align 4, nop
   303                                  
   304                                  destination:
   305 00000074 00000100                    dd RELOCATED
   306                                  
   307                                  dispPtr:
   308 00000078 40010000                    dd 0x00000140
   309                                  
   310                                  v_bytesPerLine:
   311 0000007C 00000000                    dd 0x00
   312                                  
   313                                  v_scanCode:
   314 00000080 00000000                    dd 0x00
   315                                  
   316                                  align 4
   317                                  
   318                                  ; ******************************************************************************
   319                                  ; the main program called from initial 16 bit mode
   320                                  ; ******************************************************************************
   321                                  
   322                                  main_16bit:
   323                                  
   324 00000084 FA                          cli                         ; clear interrupts
   325                                                                  ; turns out we don't need interrupts at all, even when using BIOS routines
   326                                                                  ; but we need to turn them off after disk calls because BIOS leaves them on
   327                                  
   328 00000085 56                          push si                     ; need to transfer SI to unused register BX later
   329                                  
   330                                  ; note: cannot touch DX or BP registers until we've checked for partition boot
   331                                  ; (SI could be used as well as BP but we use SI for relocation)
   332                                  
   333                                   ;see mbrboot.nasm
   334                                                                  ; Note : relocate the bootblock before we do anything else
   335 00000086 5B                          pop bx                      ; we cannot use the current stack after changing SS or SP
   336                                                                  ; ... because mbrboot.nasm places stack at 0x7c00, in SECTOR_BUFFER
   337                                                                  ; and we cannot use BP because its default segment is SS
   338 00000087 31C0                        xor ax, ax
   339 00000089 8ED8                        mov ds, ax
   340 0000008B 8EC0                        mov es, ax
   341                                  
   342 0000008D BE007C                      mov si, BOOTOFFSET
   343 00000090 BF0020                      mov di, SECTOR_BUFFER
   344 00000093 89FC                        mov sp, di
   345 00000095 B90001                      mov cx, 0x100
   346 00000098 F3A5                        rep movsw                   ; note that this instruction doesn't change AX , it moves DS:SI to ES:DI and increments SI and DI
   347                                  
   348 0000009A 8ED0                        mov ss, ax                  ; stack segment also zero
   349 0000009C B4B8                        mov ah, 0xb8                ; video RAM
   350 0000009E 8EE8                        mov gs, ax                  ; store in unused segment register
   351                                  
   352 000000A0 0F0116387C                  lgdt [gdt - $$ + BOOTOFFSET]
   353                                  
   354 000000A5 E82E01                      call SetupUnrealMode     ; gs and ss must be initialized before going to Unreal Mode
   355                                  
   356                                  ; *****************************************************************************
   357                                  ; Enable the A20 address line, otherwise all odd 1 MByte pages are disabled
   358                                  ; Using the "PS/2 Controller" or 8042 "Keyboard controller"
   359                                  ; *****************************************************************************
   360                                      ; from  http://wiki.osdev.org/%228042%22_PS/2_Controller#Step_1:_Initialise_USB_Controllers
   361                                      ; Write a command to the on-board 8042 "Keyboard controller" port 0x64 :
   362                                      ; 0x20     Read "byte 0" from internal RAM     Controller Configuration Byte
   363                                      ; 0x21 to 0x3F    Read "byte N" from internal RAM (where 'N' is the command byte & 0x1F)
   364                                      ; 0x60    Write next byte to "byte 0" of internal RAM (Controller Configuration Byte)
   365                                      ; 0x61 to 0x7F    Write next byte to "byte N" of internal RAM (where 'N' is the command byte & 0x1F)
   366                                      ; 0xA7    Disable second PS/2 port
   367                                      ; 0xA8    Enable second PS/2 port
   368                                      ; 0xA9    Test second PS/2 port
   369                                      ;     0x00 test passed
   370                                      ;     0x01 clock line stuck low
   371                                      ;     0x02 clock line stuck high
   372                                      ;     0x03 data line stuck low
   373                                      ;     0x04 data line stuck high
   374                                      ; 0xAA    Test PS/2 Controller
   375                                      ;     0x55 test passed
   376                                      ;     0xFC test failed
   377                                      ; 0xAB    Test first PS/2 port
   378                                      ;     0x00 test passed
   379                                      ;     0x01 clock line stuck low
   380                                      ;     0x02 clock line stuck high
   381                                      ;     0x03 data line stuck low
   382                                      ;     0x04 data line stuck high
   383                                      ; 0xAC    Diagnostic dump (real all bytes of internal RAM)    Unknown
   384                                      ; 0xAD    Disable first PS/2 port     None
   385                                      ; 0xAE    Enable first PS/2 port  None
   386                                      ; 0xC0    Read controller input port  Unknown (none of these bits have a standard/defined purpose)
   387                                      ; 0xC1    Copy bits 0 to 3 of input port to status bits 4 to 7    None
   388                                      ; 0xC2    Copy bits 4 to 7 of input port to status bits 4 to 7    None
   389                                      ; 0xD0    Read Controller Output Port     Controller Output Port (see below)
   390                                      ; 0xD1    Write next byte to Keyboard Controller Output Port Note: Check if output buffer is empty first
   391                                      ; 0xD2    Write next byte to first PS/2 port output buffer
   392                                      ; 0xD3    Write next byte to second PS/2 port output buffer
   393                                      ; 0xD4    Write next byte to second PS/2 port input buffer
   394                                      ; 0xF0 to 0xFF  Pulse output line low for 6 ms.
   395                                      ;     Bits 0 to 3 are used as a mask (0 = pulse line, 1 = do not pulse line) and correspond to 4 different output lines.
   396                                      ;     Bit 0 is the "reset" line, active low.
   397 000000A8 B0D1                        mov al, 0xD1    ; 0xD1 = Write next byte to Keyboard Controller Output Port
   398 000000AA E664                        out 0x64, al    ; On-board controller Command Write
   399                                  .back:
   400 000000AC E464                        in al, 0x64
   401 000000AE 2402                        and al, 0x02
   402 000000B0 75FA                        jnz .back
   403 000000B2 B04B                        mov al, 0x4B
   404 000000B4 E660                        out 0x60, al
   405                                  
   406                                  ; *****************************************************************************
   407                                  ; Get disk drive parameters from the BIOS
   408                                  ; *****************************************************************************
   409                                  
   410 000000B6 BF687C                      mov di, (data_area - $$ + BOOTOFFSET)   ; setup the data index pointer
   411 000000B9 6631C0                      xor eax, eax
   412 000000BC 660FBAE810                  bts eax, 16                     ; in case NOT booted from partition: sector 1, head 0, cylinder 0
   413 000000C1 08F6                        or dh, dh                       ; booted from partition?
   414 000000C3 740B                        jz .forward3
   415 000000C5 668B4708                    mov eax, [ bx + 8 ]             ; SI (now BX) contains pointer to partition record
   416 000000C9 66894500                    mov [ byte di + (bootsector - data_area) ], eax     ; offset 8 was LBA of first absolute sector
   417 000000CD 668B07                      mov eax, [bx]                   ; CHS of first sector in partition
   418                                  .forward3:
   419 000000D0 88D0                        mov al, dl                      ; bootdrive into AL
   420 000000D2 6689850400                  mov [ word di + ( driveinfo_Drive_DX - data_area) ], eax    ; save the Drive info from BIOS
   421 000000D7 B408                        mov ah, 8                       ; get drive parameters
   422 000000D9 06                          push es                         ; this operation messes with ES
   423 000000DA 57                          push di                         ; and DI
   424 000000DB BFC017                      mov di, DISK_INFO               ; point di at the table returned by this software interrupt
   425 000000DE CD13                        int 0x13
   426 000000E0 72FE                        jc $                            ; stop here on error
   427                                  
   428 000000E2 E80601                      call ReSetupUnrealMode
   429 000000E5 5F                          pop di
   430 000000E6 07                          pop es
   431                                  
   432                                  ; ******************************************************************************
   433                                  ; load the bootdisk into both low and high RAM
   434                                  ; ******************************************************************************
   435                                  
   436 000000E7 895508                      mov [ byte di + ( driveinfo_Cylinder - data_area) ], dx             ; heads in high byte
   437 000000EA 80E13F                      and cl, 0x3F                    ; we don't care about two high bits of cylinder count
   438 000000ED 894D0A                      mov [ byte di + ( driveinfo_SectorsPertrack - data_area) ], cx     ; cylinders and sectors/track
   439 000000F0 8B5504                      mov dx, [ byte di + ( driveinfo_Drive_DX - data_area) ]         ; restore dl Drive value from BIOS, dh = 0
   440                                  ;    mov dl, 0x80
   441 000000F3 8B4D06                      mov cx, [ di + ( driveinfo_CX - data_area) ]               ; restore cl value, ch = 0
   442 000000F6 BE0004                      mov si, SECTORS_TO_LOAD
   443                                  
   444 000000F9 BB0020                      mov bx, SECTOR_BUFFER            ; relocate the sector we are running from
   445 000000FC E89800                      call relocate
   446                                  
   447 000000FF BB007C                      mov bx, BOOTOFFSET              ; we will fix this below by adding 0x200
   448                                                                      ; remember the sector is 1-based, head and cylinder both 0-based
   449                                  
   450                                  .nextsector:
   451 00000102 FEC1                        inc cl
   452 00000104 4E                          dec si
   453 00000105 747D                        jz setVideoMode    ; success, so setup the video now...
   454                                  
   455                                  .bootload:
   456 00000107 B80102                      mov ax, 0x201                   ; read 1 sector
   457 0000010A 80C702                      add bh, 0x02                    ; into next available slot in RAM
   458 0000010D 7503                        jnz .forward
   459 0000010F 80EF02                      sub bh, 0x02                    ; at 0x10000 we go back to 0xfe00
   460                                  .forward:
   461 00000112 CD13                        int 0x13
   462 00000114 E8D400                      call ReSetupUnrealMode
   463 00000117 72FE                        jc $                            ; stop here on error
   464 00000119 E87B00                      call relocate
   465 0000011C 88C8                        mov al, cl
   466 0000011E 243F                        and al, 0x3F                    ; low 6 bits
   467 00000120 3A450A                      cmp al, [ byte di + ( driveinfo_SectorsPertrack - data_area) ]
   468 00000123 75DD                        jnz .nextsector
   469 00000125 FEC6                        inc dh                          ; next head
   470 00000127 3A7509                      cmp dh, [ byte di + ( driveinfo_Head - data_area) ]
   471 0000012A 7609                        jna .forward2                   ; not JNZ, the head index is 1 less than head count
   472 0000012C 30F6                        xor dh, dh
   473 0000012E FEC5                        inc ch                          ; next cylinder
   474 00000130 7503                        jnz .forward2
   475 00000132 80C140                      add cl, 0x40                    ; bit 8 of cylinder count
   476                                  .forward2:
   477 00000135 80E1C0                      and cl, 0xC0                    ; clear sector count, low 6 bits of cl
   478 00000138 EBC8                        jmp short .nextsector
   479                                  
   480                                  ; ******************************************************************************
   481                                  ; ******************************************************************************
   482                                  ; Start here after loading the program
   483                                  ; ******************************************************************************
   484                                  ; ******************************************************************************
   485                                  
   486                                  ; From : VESA BIOS EXTENSION (VBE) Core Functions Standard Version: 3.0 Date: September 16, 1998
   487                                  ; Mandatory information for all VBE revisions
   488                                  ; dw ModeAttributes         ; 0x00 mode attributes
   489                                  ; db WinAAttributes         ; 0x02 window A attributes
   490                                  ; db WinBAttributes         ; 0x03 window B attributes
   491                                  ; dw WinGranularity         ; 0x04 window granularity
   492                                  ; dw WinSize                ; 0x06 window size
   493                                  ; dw WinASegment            ; 0x08 window A start segment
   494                                  ; dw WinBSegment            ; 0x0A window B start segment
   495                                  ; dd WinFuncPtr             ; 0x0C real mode pointer to window function
   496                                  ; dw BytesPerScanLine       ; 0x10 bytes per scan line               <--------------
   497                                  ; Mandatory information for VBE 1.2 and above
   498                                  ; dw XResolution            ; 0x12 horizontal resolution in pixels   <-------------- scrnw
   499                                  ; dw YResolution            ; 0x14 vertical resolution in pixels     <-------------- scrnh
   500                                  ; db XCharSize              ; 0x16 character cell width in pixels
   501                                  ; db YCharSize              ; 0x17 character cell height in pixels
   502                                  ; db NumberOfPlanes         ; 0x18 number of memory planes
   503                                  ; db BitsPerPixel           ; 0x19 bits per pixel                    <-------------- bpp
   504                                  ; db NumberOfBanks          ; 0x1A number of banks
   505                                  ; db MemoryModel            ; 0x1B memory model type
   506                                  ; db BankSize               ; 0x1C bank size in KB
   507                                  ; db NumberOfImagePages     ; 0x1D number of images
   508                                  ; db Reserved               ; 0x1E reserved for page function        <-------------- mode (we copy it here)
   509                                  ; Direct Color fields (required for direct/6 and YUV/7 memory models)
   510                                  ; db RedMaskSize            ; 0x1F size of direct color red mask in bits
   511                                  ; db RedFieldPosition       ; 0x20 bit position of lsb of red mask
   512                                  ; db GreenMaskSize          ; 0x21 size of direct color green mask in bits
   513                                  ; db GreenFieldPosition     ; 0x22 bit position of lsb of green mask
   514                                  ; db BlueMaskSize           ; 0x23 size of direct color blue mask in bits
   515                                  ; db BlueFieldPosition      ; 0x24 bit position of lsb of blue mask
   516                                  ; db RsvdMaskSize           ; 0x25 size of direct color reserved mask in bits
   517                                  ; db RsvdFieldPosition      ; 0x26 bit position of lsb of reserved mask
   518                                  ; db DirectColorModeInfo    ; 0x27 direct color mode attributes
   519                                  ; Mandatory information for VBE 2.0 and above
   520                                  ; dd PhysBasePtr            ; 0x28 physical address for flat memory frame buffer  <-------------- vframe
   521                                  ; dd Reserved               ; 0x2C Reserved - always set to 0
   522                                  ; dw Reserved               ; 0x30 Reserved - always set to 0
   523                                  ; Mandatory information for VBE 3.0 and above
   524                                  ; dw LinBytesPerScanLine    ; 0x32 bytes per scan line for linear modes
   525                                  ; db BnkNumberOfImagePages  ; 0x34 number of images for banked modes
   526                                  ; db LinNumberOfImagePages  ; 0x35 number of images for linear modes
   527                                  ; db LinRedMaskSize         ; 0x36 size of direct color red mask (linear modes)
   528                                  ; db LinRedFieldPosition    ; 0x37 bit position of lsb of red mask (linear modes)
   529                                  ; db LinGreenMaskSize       ; 0x38 size of direct color green mask  (linear modes)
   530                                  ; db LinGreenFieldPosition  ; 0x39 bit position of lsb of green mask (linear modes)
   531                                  ; db LinBlueMaskSize        ; 0x3A size of direct color blue mask  (linear modes)
   532                                  ; db LinBlueFieldPosition   ; 0x3B bit position of lsb of blue mask (linear modes)
   533                                  ; db LinRsvdMaskSize        ; 0x3C size of direct color reserved mask (linear modes)
   534                                  ; db LinRsvdFieldPosition   ; 0x3D bit position of lsb of reserved mask (linear modes)
   535                                  ; dd MaxPixelClock          ; 0x3E maximum pixel clock (in Hz) for graphics mode
   536                                  ; times 189 db 0            ; 0x42 remainder of ModeInfoBlock
   537                                  ; End                       ; 0xFF
   538                                  
   539                                  scanVESA:   ; ( w+h+b -- )  in ax
   540 0000013A 89C3                        mov bx, ax
   541 0000013C 57                          push di                         ; save di
   542 0000013D B91641                      mov cx, ( 0x4117 - 1 )          ; start scanning from the expected VESA mode 0x4117 ( the -1 is because of the  inc cx  below )
   543                                  .back:
   544 00000140 FEC1                        inc cl                          ; increment just the bottom byte, we test 0x41xx
   545 00000142 80F916                      cmp cl, 0x16                    ; scanned from 0x4117 to 0x4116, not found, so show error
   546 00000145 741B                        jz .failure
   547 00000147 BF0018                      mov di, VESA_BUFFER             ; buffer for the VESA mode information block
   548 0000014A B8014F                      mov ax, 0x4F01                  ; INT 0x10, AX=0x4F01, CX=mode Get Mode Info
   549 0000014D CD10                        int 0x10
   550 0000014F 3C4F                        cmp al, 0x4F                    ; success code = 0x4F
   551 00000151 75ED                        jne .back                       ; try the next VESA mode
   552 00000153 8B4512                      mov ax, [di + 0x12]             ; width
   553 00000156 034514                      add ax, [di + 0x14]             ; height
   554 00000159 024519                      add al, [di + 0x19]             ; bits per pixel
   555                                  ;    adc ah, 0                       ; should not be necessary for the expected result, 0x400+0x300+0x10
   556 0000015C 39D8                        cmp ax, bx                      ; width + height + bits per pixel
   557 0000015E 740A                        je .success
   558 00000160 75DE                        jne .back                       ; try the next VESA mode
   559                                  .failure:                           ; VESA mode not found, so continue
   560 00000162 5F                          pop di                          ; restore di
   561 00000163 B80000                      mov ax, 0                       ; return flag false
   562 00000166 050000                      add ax, 0                       ; set the zero flag
   563 00000169 C3                          ret
   564                                  .success:
   565 0000016A 894D1E                      mov [ di + ( vesa_SavedMode - VESA_BUFFER ) ], cx ; save the VESA mode in the VESA_BUFFER at offset 0x1E "Reserved"
   566 0000016D B80100                      mov ax, 1                       ; return flag true
   567 00000170 050000                      add ax, 0                       ; set the zero flag
   568 00000173 5F                          pop di                          ; restore di
   569 00000174 C3                          ret
   570                                  
   571                                  setVESA:    ; we found a valid VESA mode
   572                                  
   573 00000175 1E                          push ds                         ; clear all flags including Interrupt using DS, known to be zero
   574 00000176 9D                          popf                            ; this is necessary to clear T flag also, end register display
   575                                  
   576 00000177 E8E000                      call greet      ; show greeting message
   577                                  
   578 0000017A 89CB                        mov bx, cx
   579 0000017C B8024F                      mov ax, 0x4F02  ; INT 0x10, AX=0x4F02, BX=mode, ES:DI=CRTCInfoBlock Set Video Mode
   580 0000017F CD10                        int 0x10
   581                                  
   582 00000181 E9E400                      jmp main_32bit
   583                                  
   584                                  setVideoMode:
   585                                  %if ( FORCE_800x600_VESA == 0 )     ; test the 800x600 mode in bochs, which supports 1024x768
   586 00000184 B81007                      mov ax, ( 1024 + 768 + BITS_PER_PIXEL ) ; try the highest resolution first
   587 00000187 E8B0FF                      call scanVESA                   ; if VESA mode is found, jump to setVESA
   588 0000018A 75E9                        jnz setVESA                     ; success - we found the requested VESA mode
   589                                  %endif
   590 0000018C B88805                      mov ax, ( 800 + 600 + BITS_PER_PIXEL ) ; then try a lower resolution
   591 0000018F E8A8FF                      call scanVESA                   ; if VESA mode is found, jump to setVESA
   592 00000192 75E1                        jnz setVESA                     ; success - we found the requested VESA mode
   593                                  
   594                                  ;    mov ax, 640 + 480 + BITS_PER_PIXEL  ; then try an even lower resolution
   595                                  ;    call scanVESA                   ; if VESA mode is found, jump to setVESA
   596                                  ;    jnz setVESA                     ; success - we found the requested VESA mode
   597 00000194 E9B200                      jmp showVESAerror               ; we have tried all VESA modes without success, so report an error
   598                                  
   599                                  ; ******************************************************************************
   600                                  ; ******************************************************************************
   601                                  
   602                                  relocate:                   ; copy 512 bytes from  [bx]  to FS:[destination]
   603 00000197 60                          pusha
   604 00000198 B90001                      mov cx, 0x200 / 2
   605 0000019B 89DE                        mov si, bx
   606 0000019D 668B5D0C                    mov ebx, [ byte di + ( destination - data_area) ]
   607                                  .back:
   608 000001A1 AD                          lodsw               ; load the 16 bit value pointed to by SI into  ax
   609 000001A2 64678903                    mov [fs:ebx], ax    ; Note : the  fs:  uses the 32 bit FS value setup in Unreal Mode to move the data outside of the 1 Mbyte Real Mode address range
   610 000001A6 6683C302                    add ebx, byte +2
   611 000001AA E2F5                        loop .back
   612                                  
   613 000001AC 66895D0C                    mov [ byte di + ( destination - data_area) ], ebx
   614 000001B0 61                          popa
   615 000001B1 C3                          ret
   616                                  
   617                                      ; not used because it is very slow :
   618                                  ; now set up for trap displaying registers on screen during bootup
   619                                  ;    push cs
   620                                  ;    push showstate - $$ + BOOTOFFSET
   621                                  ;    pop dword [word +4]
   622                                  
   623                                  ; ******************************************************************************
   624                                  ; ******************************************************************************
   625                                  ;1. MasterBoot Record - MBR   at Sector     0 (decimal 0)        MBR
   626                                  ; Partition at offset 1BE
   627                                  ;   BootSignature                0
   628                                  ;   Start Head|Sector|Cylinder   1   1     0
   629                                  ;   Partition Type               B  DOS 7.1+
   630                                  ;   End   Head|Sector|Cylinder  FE  3F   3E5
   631                                  ;   BPBsectorNumber                   00  \ was 3F
   632                                  ;   Size of partition (decimal)  16035777 sectors,  8210317824 bytes,  8017889 Ki bytes,  7830 Mi bytes,  8 Gi bytes
   633                                  ; Partition at offset 1CE
   634                                  ;   BootSignature                0
   635                                  ;   Start Head|Sector|Cylinder   0   0     0
   636                                  ;   Partition Type               0  Empty partition
   637                                  ;   End   Head|Sector|Cylinder   0   0     0
   638                                  ;   BPBsectorNumber                    0
   639                                  ;   Size of partition (decimal)         0 sectors,           0 bytes,  0 Ki bytes,  0 Mi bytes,
   640                                  
   641                                  ; pretend to be a Master Boot Record so that the BIOS will load us
   642 000001B2 77<rept>                times ( 0x000001BE - ( $ - $$ ) ) db 0x77
   643 000001BE 800101000BFEFFE500-         db 0x80, 0x01, 0x01, 0x00, 0x0B, 0xFE, 0xFF, 0xE5, 0x00, 0x00, 0x00, 0x00, 0xC1, 0xAF, 0xF4, 0x00 ; 0x1BE DOS partition 0  working on PC
   644 000001C7 000000C1AFF400     
   645 000001CE 0000000000000000            db 00, 00, 00, 00, 00, 00, 00, 00   ; 0x1CE first 8 bytes of empty partition 1
   646                                  
   647                                  SetupUnrealMode:
   648                                      ; set the FS segment in "unreal" mode, must be done before the Trap Flag is set in EFLAGS register
   649 000001D6 0F20C0                      mov eax, cr0
   650 000001D9 0C01                        or al, 1    ; set the "protected mode enable" bit => "unreal mode"
   651 000001DB 0F22C0                      mov cr0, eax
   652 000001DE 681000                      push word data32p_SELECTOR_0x10 ; set the FS segment
   653 000001E1 0FA1                        pop fs
   654 000001E3 FEC8                        dec al      ; clear the "protected mode enable" bit
   655 000001E5 0F22C0                      mov cr0, eax
   656 000001E8 1E                          push ds                         ; now set FS to 0
   657 000001E9 0FA1                        pop fs
   658                                  
   659                                  ReSetupUnrealMode:
   660 000001EB 0E                          push cs                         ; for iret
   661 000001EC 9C                          pushf                           ; for iret
   662 000001ED 60                          pusha
   663 000001EE 89E5                        mov bp, sp
   664 000001F0 8B4610                      mov ax, [bp + 16]               ; get flags
   665                                  ;    or ah, 0x01                    ; set Trap Flag, bit 8 in the EFLAGS register ; debug only - very slow!
   666 000001F3 80E4FD                      and ah, ~0x02                   ; reset interrupt flag
   667 000001F6 874614                      xchg ax, [ bp + 20 ]            ; swap flags with return address
   668 000001F9 894610                      mov [ bp + 16 ], ax             ; return address at top of stack after popa
   669 000001FC 61                          popa
   670 000001FD CF                          iret
   671                                  
   672                                  ; ******************************************************************************
   673                                  ; ******************************************************************************
   674                                  
   675                                  times 512 - 2 - ($ - $$) nop        ; fill with no-ops to 55AA at end of boot sector
   676 000001FE 55AA                        db 0x55 , 0xAA  ; boot sector terminating bytes
   677                                  
   678                                  ; ******************************************************************************
   679                                  ; End of Boot Sector
   680                                  ; ******************************************************************************
   681                                  
   682                                  ; ******************************************************************************
   683                                  ; Show the user a null terminated string - writes directly into video RAM
   684                                  ; ******************************************************************************
   685                                  
   686                                  displayString:
   687                                  
   688                                      ; restore the pointer to screen memory into di
   689 00000200 BF687C                      mov di, (data_area - $$ + BOOTOFFSET)
   690 00000203 8B4510                      mov ax, [ di + ( dispPtr - data_area) ]
   691 00000206 89C7                        mov di, ax
   692                                  
   693 00000208 06                          push es         ; save es
   694 00000209 B800B8                      mov ax, 0xb800  ; video RAM segment
   695 0000020C 8EC0                        mov es, ax
   696                                  
   697                                  backhere2:
   698 0000020E AC                          lodsb               ; loads a byte from [ds:si] into al, then increments  si
   699 0000020F 3C00                        cmp al, 0
   700 00000211 7406                        jz forward1     ; If al = 0 then leave the loop
   701 00000213 B40D                        mov ah, 0x0D    ; text colour, magenta on black background
   702 00000215 AB                          stosw               ; stores  ax  into  [es:di]  then increments  di
   703 00000216 E9F5FF                      jmp backhere2
   704                                  forward1:
   705                                      ; save the pointer to screen memory from di
   706 00000219 89F8                        mov ax, di
   707 0000021B BF687C                      mov di, (data_area - $$ + BOOTOFFSET)
   708 0000021E 894510                      mov [ di + ( dispPtr - data_area) ], ax
   709 00000221 07                          pop es          ; restore es
   710 00000222 C3                          ret
   711                                  
   712                                  ; display a string then Wait for a key press
   713                                  displayStringW:
   714                                  
   715 00000223 60                          pusha
   716 00000224 E8D9FF                      call displayString
   717                                  
   718 00000227 31C0                        xor  ax, ax     ; wait for and get a key press ( AX = 0 )
   719 00000229 CD16                        int  0x16       ; BIOS interrupt Read a Key From the Keyboard
   720 0000022B 61                          popa
   721 0000022C C3                          ret
   722                                  
   723                                  ; msg_greeting2:
   724                                  ;     db ' Press any key : ' , 0x00
   725                                  
   726                                  msg_VESAerror:
   727 0000022D 4E6F2076616C696420-         db 'No valid VESA mode found! ' , 0x02, 0x00
   728 00000236 56455341206D6F6465-
   729 0000023F 20666F756E64212002-
   730 00000248 00                 
   731                                  ;    db ' No VESA mode ' , 0x02, 0x00
   732                                  
   733                                  [BITS 16]                           ; Real Mode code (16 bit)
   734                                  
   735                                  showVESAerror:
   736 00000249 E80E00                      call greet
   737 0000024C 56                          push si
   738 0000024D C74510E001                  mov word [ di + ( dispPtr - data_area) ] , 0x000001E0    ; line 3 0x50 x 2 x 3 = 0x1E0
   739 00000252 BE2D7E                      mov si, ( msg_VESAerror - $$ + BOOTOFFSET )  ; string to display
   740 00000255 E8CBFF                      call displayStringW
   741 00000258 5E                          pop si
   742 00000259 C3                          ret
   743                                  
   744                                  greet:     ; jump here to show 16 bit version text
   745 0000025A 56                          push si
   746 0000025B C745104001                  mov word [ di + ( dispPtr - data_area) ] , 0x00000140    ; line 2 0x50 x 2 x 2 = 0x140
   747 00000260 BEC0E3                      mov si, ( version - $$ + BOOTOFFSET )  ; string to display
   748 00000263 E89AFF                      call displayString
   749                                  ;    mov si, ( msg_greeting2 - $$ + BOOTOFFSET )  ; string to display
   750                                  ;    call displayStringW
   751 00000266 5E                          pop si
   752 00000267 C3                          ret
   753                                  
   754                                  ; ******************************************************************************
   755                                  ; the main program in 32 bit ( protected ) mode
   756                                  ; ******************************************************************************
   757                                  
   758                                  main_32bit:
   759                                  
   760 00000268 E88200                      call setProtectedModeAPI        ; called from 16 bit code, returns in 32 bit code
   761                                  
   762                                  [BITS 32]                           ; Protected Mode code (32 bit) - assemble for 32 bit mode from now on
   763                                  
   764 0000026B BC00780000                  mov esp, RETURN_STACK_0         ; setup the return stack pointer
   765 00000270 BE04760000                  mov esi, ( DATA_STACK_0 + 4 )   ; setup our data stack pointer
   766                                  
   767 00000275 E8DB2F0000                  call save_BIOS_idt_and_pic      ; to be restored later, when making BIOS calls
   768 0000027A E85C300000                  call init_default_PIC_IMRs      ; set the default values and copy the BIOS Interrupt Vectors to our new table
   769                                      _DUP_
   770 0000027F 83EE04              <1>  sub esi, byte 0x04
   771 00000282 8906                <1>  mov [ esi ], _TOS_
   772 00000284 B8001C0000                  mov _TOS_, INTERRUPT_VECTORS
   773 00000289 E8812F0000                  call lidt_                      ; Load the new Interrupt Descriptor Table
   774                                  
   775 0000028E E9A22B0000                  jmp dword warm
   776                                  
   777                                  ; *****************************************************************************
   778                                  ; calculate Cylinder, Head and Sector from zero-based sector number
   779                                  ; see http://teaching.idallen.com/dat2343/00f/calculating_cylinder.htm
   780                                  ; Note : uses pushad to copy registers onto the ESP stack, stores the
   781                                  ; calculated values onto the stack at the correct offsets, then restores the
   782                                  ; stack back to the registers.
   783                                  ; *****************************************************************************
   784                                  
   785                                  sector_chs:  ; ( sector -- eax ) calculate CHS from a sector number in eax,
   786                                      ; returns with DX = HHDD, CX = CCSS where HH=head, DD=drive, CC=cylinder, SS=sector
   787                                      ; Note that the input sector number is zero based, and that the high 16 bits of EAX must be 0
   788 00000293 60                          pushad  ; Pushes all general purpose registers onto the stack in the following order:
   789                                          ; EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI. The value of ESP is the value before the actual push of ESP
   790                                          ;  7    6    5    4    3    2    1    0   offset in cells from ESP
   791 00000294 89E5                        mov ebp, esp    ; copy the original ESP stack pointer to EBP so we can access items on the stack easily
   792                                  
   793                                      ; save the register values in the DAP buffer for use later, via ESI
   794 00000296 BEE0170000                  mov esi, DAP_BUFFER
   795                                  
   796 0000029B 0305687C0000                add eax, [ bootsector - $$ + BOOTOFFSET]
   797 000002A1 50                          push eax                            ; save it while we calculate heads*sectors-per-track
   798 000002A2 A0717C0000                  mov al, [ driveinfo_Head - $$ + BOOTOFFSET]      ; index of highest-numbered head
   799 000002A7 FEC0                        inc al                              ; 1-base the number to make count of heads
   800 000002A9 F625727C0000                mul byte [ driveinfo_SectorsPertrack - $$ + BOOTOFFSET]     ; sectors per track
   801 000002AF 89C3                        mov ebx, eax
   802 000002B1 58                          pop eax
   803 000002B2 31D2                        xor edx, edx                        ; clear high 32 bits
   804 000002B4 F7F3                        div ebx                             ; leaves cylinder number in eax, remainder in edx
   805 000002B6 89C1                        mov ecx, eax                        ; store cylinder number in another register
   806 000002B8 89D0                        mov eax, edx                        ; get remainder into AX
   807 000002BA 8A1D727C0000                mov bl, [ driveinfo_SectorsPertrack - $$ + BOOTOFFSET]      ; number of sectors per track
   808 000002C0 F6F3                        div bl                              ; head number into AX, remainder into DX
   809 000002C2 88C3                        mov bl, al                          ; result must be one byte, so store it in BL
   810 000002C4 C1C108                      rol ecx, 8                          ; high 2 bits of cylinder number into high 2 bits of CL
   811 000002C7 C0E106                      shl cl, 6                           ; makes room for sector number
   812 000002CA 08E1                        or cl, ah                           ; merge cylinder number with sector number
   813 000002CC FEC1                        inc cl                              ; one-base sector number
   814 000002CE 894D18                      mov [ ebp + ( 6 * 4 ) ], ecx        ; store the result in ECX position on esp stack
   815 000002D1 66894E18                    mov word [ esi + o_Int13_DAP_saved_CHS_CX ], cx  ; also save the calculated CX value
   816 000002D5 668B0D6C7C0000              mov cx, [ driveinfo_Drive_DX - $$ + BOOTOFFSET]    ; drive number in low 8 bits
   817 000002DC 88DD                        mov ch, bl                          ; place head number in high bits
   818                                  ;    mov cl, 0x80
   819 000002DE 894D14                      mov [ ebp + ( 5 * 4 ) ], ecx    ; store the result in EDX position on esp stack
   820 000002E1 66894E1A                    mov word [ esi + o_Int13_DAP_saved_CHS_DX ], cx  ; also save the calculated DX value
   821 000002E5 61                          popad                           ; restore registers from esp stack
   822 000002E6 C3                          ret
   823                                  
   824                                  ; *****************************************************************************
   825                                  ; enter Protected Mode (32 bit) and Real Mode (16 bit)
   826                                  ; from http://ringzero.free.fr/os/protected%20mode/Pm/PM1.ASM
   827                                  ; *****************************************************************************
   828                                  
   829                                  [BITS 16]   ; Real Mode code (16 bit)
   830                                  
   831                                  enterProtectedMode:                 ; must come from a 'call' , can not be inlined
   832 000002E7 58                          pop ax
   833 000002E8 680800                      push code32p_SELECTOR_0x08
   834 000002EB 50                          push ax
   835 000002EC CB                          retf
   836                                  
   837                                  setProtectedModeAPI:                ; set protected mode from 'Real' mode. Called from 16 bit code, returns to 32 bit code
   838 000002ED 6660                        pushad                          ; save all registers as doublewords
   839 000002EF 0F20C0                      mov eax, cr0
   840 000002F2 0C01                        or al, 1
   841 000002F4 0F22C0                      mov cr0, eax                    ; set the Protected Mode bit in the Control Register
   842 000002F7 6631C0                      xor eax, eax                    ; clear high bits of eax
   843 000002FA E8EAFF                      call enterProtectedMode
   844                                  
   845                                  [BITS 32]                           ; Protected Mode code (32 bit)
   846                                  
   847 000002FD B810000000                  mov eax, data32p_SELECTOR_0x10  ; Protected Mode data segment
   848 00000302 668EC0                      mov es, ax
   849 00000305 668ED8                      mov ds, ax
   850 00000308 668ED0                      mov ss, ax                      ; this makes stack segment 32 bits
   851 0000030B 61                          popad
   852 0000030C 66C3                        o16 ret
   853                                  
   854                                  enter16bitProtectedMode:            ; 32 bit code. Must come from a 'call' , can not be inlined
   855 0000030E 58                          pop eax                         ; return address
   856 0000030F 6818000000                  push dword code16r_SELECTOR_0x18    ; select 16-bit Protected Mode AKA 'Real' Mode
   857 00000314 50                          push eax
   858 00000315 CB                          retf
   859                                  
   860                                  setRealModeAPI:                     ; set 'Real' mode from protected mode.
   861                                                                      ; Called from 32 bit code, returns to 16 bit code
   862                                                                      ; assumed that protected-mode stack is based at 0
   863                                                                      ; and that bits 16 through 19 will not change during time in realmode
   864 00000316 60                          pushad                          ; save 32-bit values of registers
   865 00000317 89E1                        mov ecx, esp                    ; do all possible 32-bit ops before going to 16 bits
   866 00000319 0F20C2                      mov edx, cr0
   867 0000031C E8EDFFFFFF                  call enter16bitProtectedMode
   868                                  
   869                                  [BITS 16]                           ; Real Mode code (16 bit)
   870                                  
   871 00000321 B82000                      mov ax, data16r_SELECTOR_0x20
   872 00000324 8ED8                        mov ds, ax
   873 00000326 8EC0                        mov es, ax
   874 00000328 8ED0                        mov ss, ax                      ; here the stack becomes 16 bits based at 0, and SP used not ESP
   875                                                                      ; *** consider stack to be invalid from here until we reach real mode ***
   876 0000032A 31C9                        xor cx, cx                      ; clear low 16 bits
   877 0000032C 66C1E904                    shr ecx, 4                      ; move high 4 bits into cl
   878 00000330 FECA                        dec dl                          ; leave protected mode, only works if we KNOW bit 0 is set
   879 00000332 0F22C2                      mov cr0, edx
   880 00000335 E80C00                      call enterRealMode
   881 00000338 31C0                        xor ax, ax
   882 0000033A 8ED8                        mov ds, ax
   883 0000033C 8EC0                        mov es, ax
   884 0000033E 8ED1                        mov ss, cx
   885                                      ; note we don't need to set SP to 8xxx if ESP is b8xxx, since
   886                                      ; the b000 is now in SS, and the b of b8xxx is ignored in real mode
   887 00000340 6661                        popad
   888 00000342 66C3                        o32 ret
   889                                  
   890                                  enterRealMode:                      ; 16 bit code. Must come from a 'call' , can not be inlined
   891 00000344 58                          pop ax
   892 00000345 0FA0                        push fs                         ; real-mode code segment
   893 00000347 50                          push ax
   894 00000348 CB                          retf
   895                                  
   896                                  [BITS 32]                           ; Protected Mode code (32 bit)
   897                                  
   898                                  ; *****************************************************************************
   899                                  ; *****************************************************************************
   900                                  
   901                                  ;%include "JCreadwrite.nasm"
   902                                  ; JCreadwrite.nasm 2012 Oct 23   read and write the disk using 16 bit BIOS calls
   903                                  ; BIOS read and write routines for colorForth
   904                                  
   905                                  [BITS 32]                           ; Protected Mode code (32 bit)
   906                                  
   907                                  bios_read:  ; ( a c -- a' c' )   \  read cylinder c into address a , leave next address and cylinder
   908                                                                      ; c is cylinder, we will use 1.44Mb floppy's idea of cylinder regardless
   909                                                                      ; a is byte address
   910                                                                      ; leave updated c and a on stack as c' and a'
   911                                                                      ; a cylinder is 36 tracks of 512 bytes each, 0x4800 bytes, 0x1200 cells (words)
   912                                  
   913 00000349 FA                          cli                             ; disable interrupts
   914 0000034A 60                          pushad                          ; push all registers ( except esp ) and flags onto the stack
   915 0000034B 89E5                        mov ebp, esp                    ; copy of stack pointer for use below ( * ), points to registers copied by pushad , above
   916                                  
   917 0000034D B924000000                  mov ecx, HEADS * SECTORS        ; sectors per track (both heads)
   918 00000352 F6E1                        mul cl                          ; sector number goes into AX
   919                                                                      ; note that resultant sector number is zero-based going into sector_chs!
   920                                                                      ; set up loop to read one floppy cylinder's worth
   921                                  
   922 00000354 50                          push eax                        ; absolute sector number to start
   923                                  .back:
   924 00000355 51                          push ecx
   925 00000356 E838FFFFFF                  call sector_chs                 ; convert to Cylinder-Head-Sector in CX-DX
   926 0000035B E81F000000                  call .readsector
   927                                  
   928 00000360 8B5D04                      mov ebx, [ ebp + ( 1 * 4 ) ]    ; ( * ) get ESI stored on stack, via stack pointer saved in ebp
   929 00000363 8B3B                        mov edi, [ebx]                  ; destination index address for movsd
   930 00000365 B980000000                  mov ecx, ( 512 >> 2 )           ; number of 32-bit words to move, 512 bytes
   931 0000036A BE00200000                  mov esi, SECTOR_BUFFER          ; source index for movsd
   932 0000036F F3A5                        rep  movsd                      ; copy ecx 32 bit words from ds:esi to es:edi
   933 00000371 893B                        mov [ebx], edi
   934 00000373 59                          pop ecx
   935 00000374 58                          pop eax
   936 00000375 40                          inc eax
   937 00000376 50                          push eax
   938 00000377 E2DC                        loop .back
   939 00000379 58                          pop eax
   940 0000037A FF451C                      inc dword [ebp + 7 * 4]         ; for updated cylinder number after return
   941 0000037D 61                          popad
   942 0000037E C3                          ret
   943                                  
   944                                  .readsector:                        ; no need to save registers because we take care of them in calling routine
   945 0000037F E892FFFFFF                  call setRealModeAPI
   946                                  [BITS 16]                           ; Real Mode code (16 bit)
   947 00000384 BB0020                      mov bx, SECTOR_BUFFER
   948 00000387 B80102                      mov ax, 0x0201                  ; read 1 sector
   949 0000038A CD13                        int 0x13
   950 0000038C FA                          cli                             ; BIOS might have left interrupts enabled
   951 0000038D E85DFF                      call setProtectedModeAPI        ; called from 16 bit code, returns to 32 bit code
   952                                  [BITS 32]                           ; Protected Mode code (32 bit)
   953 00000390 C3                          ret
   954                                  
   955                                  bios_write:     ; ( a c -- a' c' )   \  write cylinder c from address a , leave next address and cylinder
   956 00000391 FA                          cli                             ; disable interrupts
   957 00000392 60                          pushad
   958 00000393 89E5                        mov ebp, esp
   959                                                                      ; eax contains cylinder to start, the 'c' parameter
   960 00000395 B924000000                  mov ecx, HEADS * SECTORS        ; sectors per track (both heads)
   961 0000039A F6E1                        mul cl                          ; absolute sector number goes into AX
   962                                  
   963 0000039C 8B5D04                      mov ebx, [ebp + ( 1 * 4 ) ]     ; stored ESI on stack
   964 0000039F 8B33                        mov esi, [ebx]                  ; word address, 'a' parameter
   965                                  ;        shl esi, 2                 ; change word address into byte address
   966                                                                      ; set up loop to write one floppy cylinder's worth
   967 000003A1 50                          push eax                        ; absolute sector number to start
   968                                  
   969                                  .back:
   970 000003A2 51                          push ecx
   971                                                                      ; load sector data into buffer
   972                                                                      ; DO NOT take advantage of knowing ECX only has byte value
   973 000003A3 B980000000                  mov ecx, 128 ; ( 512 >> 2 )     ; number of 32-bit words to move
   974 000003A8 BF00200000                  mov edi, SECTOR_BUFFER
   975 000003AD F3A5                        rep  movsd                      ; copy ecx 32 bit words from ds:esi to es:edi
   976 000003AF E8DFFEFFFF                  call sector_chs                 ; convert to Cylinder-Head-Sector in CX-DX
   977 000003B4 E811000000                  call .writesector
   978 000003B9 59                          pop ecx
   979 000003BA 58                          pop eax
   980 000003BB 40                          inc eax
   981 000003BC 50                          push eax
   982 000003BD E2E3                        loop .back
   983 000003BF 58                          pop eax
   984 000003C0 FF451C                      inc dword [ ebp + ( 7 * 4 ) ]   ; for updated cylinder after return (EAX)
   985 000003C3 8B5D04                      mov ebx, [ ebp + ( 1 * 4 ) ]    ; stored ESI on stack
   986 000003C6 8933                        mov [ebx], esi                  ; updated address
   987 000003C8 61                          popad
   988 000003C9 C3                          ret
   989                                  
   990                                  .writesector:                       ; no need to save registers because we take care of them in calling routine
   991 000003CA E847FFFFFF                  call setRealModeAPI
   992                                  [BITS 16]                           ; Real Mode code (16 bit)
   993 000003CF BB0020                      mov bx, SECTOR_BUFFER
   994 000003D2 B80103                      mov ax, 0x0301                  ; write 1 sector
   995 000003D5 CD13                        int 0x13
   996 000003D7 FA                          cli                             ; BIOS might have left interrupts enabled
   997 000003D8 E812FF                      call setProtectedModeAPI        ; called from 16 bit code, returns to 32 bit code
   998                                  [BITS 32]                           ; Protected Mode code (32 bit)
   999 000003DB C3                          ret
  1000                                  
  1001 000003DC 90<rept>                 times (0x400 - ($ - $$)) nop
  1002                                  
  1003                                  ; *****************************************************************************
  1004                                  ; *****************************************************************************
  1005                                  ; After Two Sectors
  1006                                  ; *****************************************************************************
  1007                                  ; *****************************************************************************
  1008                                  
  1009                                  nul:
  1010 00000400 C3                          ret
  1011                                  
  1012                                  ; *****************************************************************************
  1013                                  ; cooperative multi-tasker
  1014                                  ; *****************************************************************************
  1015                                  
  1016                                  me:
  1017 00000401 [2F040000]                  dd God
  1018                                  x_screenTask:
  1019 00000405 [00040000]                  dd nul
  1020                                  x_serverTask:
  1021 00000409 [00040000]                  dd nul
  1022                                  
  1023                                  pause_:
  1024                                      _DUP_
  1025 0000040D 83EE04              <1>  sub esi, byte 0x04
  1026 00000410 8906                <1>  mov [ esi ], _TOS_
  1027 00000412 56                          push esi
  1028 00000413 A1[01040000]                mov _TOS_, [ me ]  ; points to God at startup
  1029 00000418 8920                        mov [_TOS_], esp
  1030 0000041A 83C004                      add _TOS_, byte 0x04
  1031 0000041D FFE0                        jmp _TOS_
  1032                                  
  1033                                  unpause:
  1034 0000041F 58                          pop _TOS_
  1035 00000420 8B20                        mov esp, [_TOS_]
  1036 00000422 A3[01040000]                mov [ me ], _TOS_
  1037 00000427 5E                          pop esi
  1038                                      _DROP_
  1039 00000428 AD                  <1>  lodsd
  1040 00000429 C3                          ret
  1041                                  
  1042                                  round:
  1043 0000042A E8F0FFFFFF                      call unpause
  1044                                  God:                                ; graphics update task
  1045 0000042F 00000000                    dd 0                            ; new stack location
  1046 00000433 E8E7FFFFFF                  call unpause
  1047                                  main:                               ; main program task
  1048 00000438 00000000                    dd 0                            ; new stack location
  1049                                  ;    call unpause
  1050                                  otherTask:
  1051                                  ;    dd RETURN_STACK_2 - 8          ; new stack location
  1052 0000043C EBEC                        jmp short round                 ; loop forever between 3 stacks
  1053                                  
  1054                                  activate:   ; ( a -- )    \ activate the main task to execute colorForth code at the given address
  1055 0000043E BAFC710000                  mov edx, DATA_STACK_1 - 4
  1056 00000443 890A                        mov [edx], ecx
  1057 00000445 B9FC730000                  mov ecx, RETURN_STACK_1 - 4
  1058 0000044A 8F01                        pop dword [ecx]
  1059 0000044C 8D49FC                      lea ecx, [ ecx - 0x04 ]
  1060 0000044F 8911                        mov [ecx], edx
  1061 00000451 890D[38040000]              mov dword [ main ], ecx
  1062                                      _DROP_
  1063 00000457 AD                  <1>  lodsd
  1064 00000458 C3                          ret
  1065                                  
  1066                                  show:   ; ( -- )    \ set the screen task to execute the code following  show
  1067 00000459 8F05[05040000]              pop dword [ x_screenTask ]      ; copy the return address of the calling word into the screenTask variable
  1068                                      _DUP_
  1069 0000045F 83EE04              <1>  sub esi, byte 0x04
  1070 00000462 8906                <1>  mov [ esi ], _TOS_
  1071 00000464 31C0                        xor _TOS_, _TOS_
  1072 00000466 E8D3FFFFFF                  call activate
  1073                                  .show:
  1074 0000046B E8BE050000                  call graphAction                ; perform a graphical update
  1075 00000470 FF15[05040000]              call [ x_screenTask ]           ; execute the code that called show, saved on entry
  1076 00000476 E8D1090000                  call switch                     ; copy the screen image to the VESA buffer
  1077 0000047B 31C0                        xor _TOS_, _TOS_
  1078 0000047D E88BFFFFFF                  call pause_
  1079 00000482 40                          inc _TOS_
  1080 00000483 EBE6                        jmp short .show
  1081                                  
  1082                                  initshow:                           ; called by warm
  1083 00000485 E8CFFFFFFF                  call show
  1084                                      ; <--- this address ( on the return stack from the preceding call ) goes into  x_screenTask
  1085 0000048A C3                          ret                 ; makes this a no-op "show"
  1086                                  
  1087                                  ; *****************************************************************************
  1088                                  ; "other" task execution
  1089                                  ; *****************************************************************************
  1090                                  
  1091                                  activate2:  ; ( a -- )    \ activate the  other  task to execute colorForth code at the given address
  1092 0000048B BAFC6D0000                  mov edx, DATA_STACK_2 - 4
  1093 00000490 890A                        mov [edx], ecx
  1094 00000492 B9FC6F0000                  mov ecx, RETURN_STACK_2 - 4
  1095 00000497 8F01                        pop dword [ecx]
  1096 00000499 8D49FC                      lea ecx, [ ecx - 0x04 ]
  1097 0000049C 8911                        mov [ecx], edx
  1098 0000049E 890D[3C040000]              mov [ otherTask ], ecx
  1099                                      _DROP_
  1100 000004A4 AD                  <1>  lodsd
  1101 000004A5 C3                          ret
  1102                                  
  1103                                  freeze:
  1104 000004A6 8F05[05040000]              pop dword [ x_screenTask ]
  1105 000004AC E88DFFFFFF                  call activate
  1106                                  .back:
  1107 000004B1 FF15[05040000]              call [ x_screenTask ]
  1108 000004B7 EBF8                        jmp short .back
  1109                                  
  1110                                  serve:
  1111 000004B9 8F05[09040000]              pop dword [ x_serverTask ]
  1112 000004BF E8C7FFFFFF                  call activate2
  1113                                  .back:
  1114 000004C4 31C0                        xor _TOS_, _TOS_
  1115 000004C6 E842FFFFFF                  call pause_
  1116 000004CB FF15[09040000]              call [ x_serverTask ]
  1117 000004D1 EBF1                        jmp short .back
  1118                                  
  1119                                  initserve:
  1120 000004D3 E8E1FFFFFF                  call serve
  1121 000004D8 C3                          ret
  1122                                  
  1123                                  ; *****************************************************************************
  1124                                  ; *****************************************************************************
  1125                                  
  1126                                  c_:     ; ( -- )   \ clear the data stack for keyboard task
  1127 000004D9 BE04760000                  mov esi, ( DATA_STACK_0 + 4 )
  1128 000004DE C3                          ret
  1129                                  
  1130                                  ; *****************************************************************************
  1131                                  ; *****************************************************************************
  1132                                  
  1133                                  mark:
  1134 000004DF 8B0D[68390000]              mov ecx, [ v_MacroWordCount]
  1135 000004E5 890D[44390000]              mov [ mark_MacroWordCount], ecx
  1136 000004EB 8B0D[64390000]              mov ecx, [ v_ForthWordCount ]
  1137 000004F1 890D[48390000]              mov [ mark_v_ForthWordCount], ecx
  1138 000004F7 8B0D[50390000]              mov ecx, [ v_H ]
  1139 000004FD 890D[4C390000]              mov [ mark_H ], ecx
  1140 00000503 C3                          ret
  1141                                  
  1142                                  empty_:
  1143 00000504 FA                          cli                             ; disable interrupts
  1144 00000505 8B0D[4C390000]              mov ecx, [ mark_H ]
  1145 0000050B 890D[50390000]              mov [ v_H ], ecx
  1146 00000511 8B0D[48390000]              mov ecx, [ mark_v_ForthWordCount]
  1147 00000517 890D[64390000]              mov [ v_ForthWordCount ], ecx
  1148 0000051D 8B0D[44390000]              mov ecx, [ mark_MacroWordCount]
  1149 00000523 890D[68390000]              mov [ v_MacroWordCount ], ecx
  1150 00000529 C705[58390000]0000-         mov dword [ class], 0x00
  1151 00000531 0000               
  1152 00000533 C3                          ret
  1153                                  
  1154                                  ; *****************************************************************************
  1155                                  ; *****************************************************************************
  1156                                  
  1157                                  mfind:  ; ( sf -- )   \ ecx = index ; find the Shannon-Fano word sf in the Macro wordlist, return its index in ecx
  1158 00000534 8B0D[68390000]              mov ecx, [ v_MacroWordCount ]   ; count of Macro wordlist words
  1159 0000053A 57                          push edi
  1160 0000053B 8D3C8DFCCF4600              lea edi, [ ( ecx * 4 ) + MacroNames - 4 ]
  1161 00000542 EB0E                        jmp short ffind
  1162                                  
  1163                                  find_:   ; ( sf -- )   \ ecx = index ; find the Shannon-Fano word sf in the Forth wordlist, return its index in ecx
  1164 00000544 8B0D[64390000]              mov ecx, [ v_ForthWordCount ]   ; count of Forth wordlist words
  1165 0000054A 57                          push edi
  1166 0000054B 8D3C8DFC7F4600              lea edi, [ ( ecx * 4 ) + ForthNames - 4 ]   ; set edi to the top of the Forth name table
  1167                                  ffind:
  1168 00000552 FD                          std                    ; scan backwards
  1169 00000553 F2AF                        repne scasd            ; locate the 32 bit Shanon-Fano encoded name, compare eax with doubleword at es:edi and set status flags.
  1170 00000555 FC                          cld                    ; reset the direction flag
  1171 00000556 5F                          pop edi
  1172 00000557 C3                          ret
  1173                                  
  1174                                  ; *****************************************************************************
  1175                                  ; *****************************************************************************
  1176                                  
  1177                                  abort:
  1178 00000558 FF25[FC380000]              jmp dword [ x_abort ]
  1179                                  
  1180                                  ; *****************************************************************************
  1181                                  ; *****************************************************************************
  1182                                  
  1183                                  cdrop:
  1184 0000055E 8B15[50390000]              mov edx, [ v_H ]
  1185 00000564 8915[5C390000]              mov [ list ], edx
  1186 0000056A C602AD                      mov byte [edx], 0xAD            ; 0xAD is the opcode for 'lodsd'
  1187 0000056D FF05[50390000]              inc dword [ v_H ]
  1188 00000573 C3                          ret
  1189                                  
  1190                                  ; *****************************************************************************
  1191                                  ; *****************************************************************************
  1192                                  
  1193                                  qdup:
  1194 00000574 8B15[50390000]              mov edx, [ v_H ]
  1195 0000057A 4A                          dec edx
  1196 0000057B 3915[5C390000]              cmp dword [ list ], edx
  1197 00000581 750C                        jnz cdup
  1198 00000583 803AAD                      cmp byte [edx], 0xAD            ; 0xAD is the opcode for 'lodsd'
  1199 00000586 7507                        jnz cdup
  1200 00000588 8915[50390000]              mov [ v_H ], edx
  1201 0000058E C3                          ret
  1202                                  
  1203                                  cdup:   ; compile action of  dup  macro
  1204 0000058F 8B15[50390000]              mov edx, [ v_H ]
  1205 00000595 C7028D76FC89                mov dword [edx], 0x89FC768D     ; assemble the instruction sequence for  DUP  "lea esi, [ esi - 4 ]" , "mov [esi], eax"
  1206 0000059B C6420406                    mov byte [ edx + 4 ], 0x006     ;  "8d 76 fc" , "89 06" ( the first 4 are expressed in little endian format above )
  1207 0000059F 8305[50390000]05            add dword [ v_H ], byte 0x05
  1208 000005A6 C3                          ret
  1209                                  
  1210                                  adup:
  1211                                      _DUP_   ; interpret action of  dup  macro
  1212 000005A7 83EE04              <1>  sub esi, byte 0x04
  1213 000005AA 8906                <1>  mov [ esi ], _TOS_
  1214 000005AC C3                          ret
  1215                                  
  1216                                  ; *****************************************************************************
  1217                                  ; *****************************************************************************
  1218                                  
  1219                                  sdefine:
  1220 000005AD 8F05[78390000]              pop dword [ adefine ]
  1221 000005B3 C3                          ret
  1222                                  
  1223                                  macro:     ; select the Macro wordlist
  1224 000005B4 E8F4FFFFFF                  call sdefine
  1225                                  macrod:
  1226 000005B9 50                          push _TOS_
  1227 000005BA 8B0D[68390000]              mov ecx, [ v_MacroWordCount]
  1228 000005C0 FF05[68390000]              inc dword [ v_MacroWordCount]
  1229 000005C6 8D0C8D00D04600              lea ecx, [ ( ecx * 4 ) + MacroNames ]
  1230 000005CD B800280000                  mov _TOS_, ( MacroJumpTable - MacroNames ) ; mov _TOS_, 0x218
  1231 000005D2 EB1E                        jmp short forthdd
  1232                                  
  1233                                  forth:      ; select the Forth wordlist
  1234 000005D4 E8D4FFFFFF                  call sdefine
  1235                                  forthd:
  1236 000005D9 50                          push _TOS_
  1237 000005DA 8B0D[64390000]              mov ecx, [ v_ForthWordCount ]
  1238 000005E0 FF05[64390000]              inc dword [ v_ForthWordCount ]
  1239 000005E6 8D0C8D00804600              lea ecx, [ ( ecx * 4 ) + ForthNames ]
  1240 000005ED B800280000                  mov _TOS_, ( ForthJumpTable - ForthNames )
  1241                                  forthdd:
  1242 000005F2 8B14BDFCFFFFFF              mov edx, [ ( edi * 4 ) - 0x04 ]
  1243 000005F9 83E2F0                      and edx, byte -0x10
  1244 000005FC 8911                        mov [ecx], edx
  1245 000005FE 8B15[50390000]              mov edx, [ v_H ]
  1246 00000604 891401                      mov [ecx+_TOS_], edx
  1247 00000607 8D1401                      lea edx, [ecx+_TOS_]
  1248 0000060A C1EA02                      shr edx, 0x02
  1249 0000060D 8915[54390000]              mov [ v_last ], edx
  1250 00000613 58                          pop _TOS_
  1251 00000614 8925[5C390000]              mov [ list ], esp
  1252 0000061A C705[3C390000]-             mov dword [ lit ], adup
  1253 00000620 [A7050000]         
  1254 00000624 F705[58390000]FFFF-         test dword [ class ], -1
  1255 0000062C FFFF               
  1256 0000062E 7406                        jz .fthd
  1257 00000630 FF25[58390000]              jmp dword [ class ]
  1258                                  .fthd:
  1259 00000636 C3                          ret
  1260                                  
  1261                                  ; *****************************************************************************
  1262                                  ; *****************************************************************************
  1263                                  
  1264                                  var1:   ; interpret time code for magenta variable
  1265                                      _DUP_
  1266 00000637 83EE04              <1>  sub esi, byte 0x04
  1267 0000063A 8906                <1>  mov [ esi ], _TOS_
  1268 0000063C 8B048D04804600              mov _TOS_, [ 4 + ForthNames + ( ecx * 4 ) ]
  1269 00000643 C1E002                      shl _TOS_, 2
  1270 00000646 C3                          ret
  1271                                  
  1272                                  m_variable:   ; create a magenta variable
  1273 00000647 E88DFFFFFF                  call forthd
  1274 0000064C C78100280000-               mov dword [ ForthJumpTable - ForthNames + ecx ], var1
  1275 00000652 [37060000]         
  1276 00000656 FF05[64390000]              inc dword [ v_ForthWordCount ]      ; dummy entry for source address
  1277 0000065C 897904                      mov [ 4 + ecx ], edi
  1278 0000065F E855FFFFFF                  call macrod
  1279 00000664 C78100280000-               mov dword [ MacroJumpTable - MacroNames + ecx ], .var
  1280 0000066A [79060000]         
  1281 0000066E FF05[68390000]              inc dword [ v_MacroWordCount ]
  1282 00000674 897904                      mov [ 4 + ecx ], edi
  1283 00000677 47                          inc edi
  1284 00000678 C3                          ret
  1285                                  
  1286                                  .var:   ; compile time code for magenta variable in Macro dictionary
  1287 00000679 FF15[3C390000]              call [ lit ]
  1288 0000067F 8B048D04D04600              mov _TOS_, [ 4 + MacroNames + ( ecx * 4 ) ]
  1289 00000686 C1E002                      shl _TOS_, 2
  1290 00000689 EB55                        jmp short cshrt
  1291                                  
  1292                                  ; *****************************************************************************
  1293                                  ; *****************************************************************************
  1294                                  
  1295                                  alit:
  1296 0000068B C705[3C390000]-             mov dword [ lit ], adup
  1297 00000691 [A7050000]         
  1298                                  
  1299                                  literal:
  1300 00000695 E8DAFEFFFF                  call qdup
  1301 0000069A 8B15[5C390000]              mov edx, [ list ]               ; select the wordlist to add the literal to
  1302 000006A0 8915[60390000]              mov [ list + 4 ], edx
  1303 000006A6 8B15[50390000]              mov edx, [ v_H ]
  1304 000006AC 8915[5C390000]              mov [ list ], edx
  1305 000006B2 C602B8                      mov byte [edx], _MOV_TOS_LIT_   ; the opcode for mov eax, 32_bit_literal  (in next 32 bit cell)
  1306 000006B5 894201                      mov [ edx + 0x01 ], _TOS_       ; the literal value follows in the next 4 bytes in the dictionary
  1307 000006B8 8305[50390000]05            add dword [ v_H ], byte 0x05    ; move the dictionary pointer forward 5 bytes
  1308 000006BF C3                          ret
  1309                                  
  1310                                  ; *****************************************************************************
  1311                                  ; *****************************************************************************
  1312                                  
  1313                                  cnum:
  1314 000006C0 FF15[3C390000]              call [ lit ]
  1315 000006C6 8B04BD00000000              mov _TOS_, [ ( edi * 4 ) + 0x00 ]
  1316 000006CD 47                          inc edi
  1317 000006CE EB10                        jmp short cshrt
  1318                                  
  1319                                  cshort:
  1320 000006D0 FF15[3C390000]              call [ lit]
  1321 000006D6 8B04BDFCFFFFFF              mov _TOS_, [ ( edi * 4 ) - 0x04 ]
  1322 000006DD C1F805                      sar _TOS_, 0x05
  1323                                  cshrt:
  1324 000006E0 E8B0FFFFFF                  call literal
  1325                                      _DROP_
  1326 000006E5 AD                  <1>  lodsd
  1327 000006E6 C3                          ret
  1328                                  
  1329                                  ; *****************************************************************************
  1330                                  ; *****************************************************************************
  1331                                  
  1332                                  ex1:
  1333 000006E7 31FF                        xor edi, edi
  1334                                  .back:
  1335 000006E9 FF0D[30390000]              dec dword [ v_words ]
  1336 000006EF 741C                        jz ex2
  1337                                      _DROP_
  1338 000006F1 AD                  <1>  lodsd
  1339 000006F2 EBF5                        jmp short .back
  1340                                  
  1341                                  execute_lit:    ; ( -- )
  1342 000006F4 C705[3C390000]-             mov dword [ lit ], alit
  1343 000006FA [8B060000]         
  1344                                      _DUP_
  1345 000006FE 83EE04              <1>  sub esi, byte 0x04
  1346 00000701 8906                <1>  mov [ esi ], _TOS_
  1347 00000703 8B04BDFCFFFFFF              mov _TOS_, [ ( edi * 4 ) - 0x04 ]
  1348                                  execute:    ; ( name -- )
  1349 0000070A 83E0F0                      and _TOS_, byte -0x10
  1350                                  ex2:
  1351 0000070D E832FEFFFF                  call find_
  1352 00000712 0F8540FEFFFF                jnz abort
  1353                                      _DROP_
  1354 00000718 AD                  <1>  lodsd
  1355 00000719 FF248D00A84600              jmp dword [ ( ecx * 4 ) + ForthJumpTable ]
  1356                                  
  1357                                  ; *****************************************************************************
  1358                                  ; *****************************************************************************
  1359                                  
  1360                                  qcompile:
  1361 00000720 FF15[3C390000]              call [ lit ]
  1362 00000726 8B04BDFCFFFFFF              mov _TOS_, [ ( edi * 4 ) - 0x04 ]
  1363 0000072D 83E0F0                      and _TOS_, byte -0x10
  1364 00000730 E8FFFDFFFF                  call mfind
  1365 00000735 7508                        jnz .forward
  1366                                      _DROP_
  1367 00000737 AD                  <1>  lodsd
  1368 00000738 FF248D00F84600              jmp dword [ ( ecx * 4 ) + MacroJumpTable ]
  1369                                  .forward:
  1370 0000073F E800FEFFFF                  call find_
  1371 00000744 8B048D00A84600              mov _TOS_, [ ( ecx * 4 ) + ForthJumpTable ]
  1372                                  
  1373                                  qcom1:
  1374 0000074B 0F8507FEFFFF                jnz abort
  1375                                  call_:
  1376 00000751 8B15[50390000]              mov edx, [ v_H ]
  1377 00000757 8915[5C390000]              mov [ list ], edx
  1378 0000075D C602E8                      mov byte [edx], 0xE8        ; 0xE8 is the opcode for 'call immediate'
  1379 00000760 83C205                      add edx, byte 0x05
  1380 00000763 29D0                        sub _TOS_, edx
  1381 00000765 8942FC                      mov [ edx - 0x04 ], _TOS_
  1382 00000768 8915[50390000]              mov [ v_H ], edx
  1383                                      _DROP_
  1384 0000076E AD                  <1>  lodsd
  1385 0000076F C3                       ret
  1386                                  
  1387                                  ; *****************************************************************************
  1388                                  ; *****************************************************************************
  1389                                  
  1390                                  compile:
  1391 00000770 FF15[3C390000]              call [ lit]
  1392 00000776 8B04BDFCFFFFFF              mov _TOS_, [ ( edi * 4 ) - 0x04 ]
  1393 0000077D 83E0F0                      and _TOS_, byte -0x10
  1394 00000780 E8AFFDFFFF                  call mfind
  1395 00000785 8B048D00F84600              mov _TOS_, [ ( ecx * 4 ) + MacroJumpTable ]
  1396 0000078C EBBD                        jmp short qcom1
  1397                                  
  1398                                  ; *****************************************************************************
  1399                                  ; *****************************************************************************
  1400                                  
  1401                                  short_:
  1402 0000078E C705[3C390000]-             mov dword [ lit], alit
  1403 00000794 [8B060000]         
  1404                                      _DUP_
  1405 00000798 83EE04              <1>  sub esi, byte 0x04
  1406 0000079B 8906                <1>  mov [ esi ], _TOS_
  1407 0000079D 8B04BDFCFFFFFF              mov _TOS_, [ ( edi * 4 ) - 0x04 ]
  1408 000007A4 C1F805                      sar _TOS_, 0x05
  1409 000007A7 C3                          ret
  1410                                  
  1411                                  ; *****************************************************************************
  1412                                  ; *****************************************************************************
  1413                                  
  1414                                  num:
  1415 000007A8 C705[3C390000]-             mov dword [ lit], alit
  1416 000007AE [8B060000]         
  1417                                      _DUP_
  1418 000007B2 83EE04              <1>  sub esi, byte 0x04
  1419 000007B5 8906                <1>  mov [ esi ], _TOS_
  1420 000007B7 8B04BD00000000              mov _TOS_, [ ( edi * 4 ) + 0x00 ]
  1421 000007BE 47                          inc edi
  1422 000007BF C3                          ret
  1423                                  
  1424                                  ; *****************************************************************************
  1425                                  ; *****************************************************************************
  1426                                  
  1427                                  comma_:          ; 4 byte  ,
  1428 000007C0 B904000000                  mov ecx, 0x04
  1429                                  dcomma:     ; c,  performed n times ( n in ecx )
  1430 000007C5 8B15[50390000]              mov edx, [ v_H ]
  1431 000007CB 8902                        mov [edx], _TOS_
  1432 000007CD 8B06                        mov _TOS_, [ esi ]
  1433 000007CF 8D1411                      lea edx, [ ecx + edx ]
  1434 000007D2 8D7604                      lea esi, [ esi + 0x04 ]
  1435 000007D5 8915[50390000]              mov [ v_H ], edx
  1436 000007DB C3                          ret
  1437                                  
  1438                                  comma1_:     ; 1 byte  c,
  1439 000007DC B901000000                  mov ecx, 0x01
  1440 000007E1 EBE2                        jmp short dcomma
  1441                                  
  1442                                  comma2_:     ; 2 byte  w,
  1443 000007E3 B902000000                  mov ecx, 0x02
  1444 000007E8 EBDB                        jmp short dcomma
  1445                                  
  1446                                  comma3_:     ; 3 byte  c, c, c,
  1447 000007EA B903000000                  mov ecx, 0x03
  1448 000007EF EBD4                        jmp short dcomma
  1449                                  
  1450                                  ; *****************************************************************************
  1451                                  ; *****************************************************************************
  1452                                  
  1453                                  semicolon:
  1454 000007F1 8B15[50390000]              mov edx, [ v_H ]
  1455 000007F7 83EA05                      sub edx, byte 0x05
  1456 000007FA 3915[5C390000]              cmp [ list ], edx
  1457 00000800 7508                        jnz .forward
  1458 00000802 803AE8                      cmp byte [edx], 0xE8            ; 0xE8 is the opcode for 'call immediate'
  1459 00000805 7503                        jnz .forward
  1460 00000807 FE02                        inc byte [edx]
  1461 00000809 C3                          ret
  1462                                  .forward:
  1463 0000080A C64205C3                    mov byte [ edx + 0x05 ], 0xC3   ; 0xC3 is the opcode for 'ret'
  1464 0000080E FF05[50390000]              inc dword [ v_H ]
  1465 00000814 C3                          ret
  1466                                  
  1467                                  ; *****************************************************************************
  1468                                  ; *****************************************************************************
  1469                                  
  1470                                  then:
  1471 00000815 8925[5C390000]              mov [ list ], esp
  1472 0000081B 8B15[50390000]              mov edx, [ v_H ]
  1473 00000821 29C2                        sub edx, _TOS_
  1474 00000823 8850FF                      mov [ _TOS_ - 0x01 ], dl
  1475                                      _DROP_
  1476 00000826 AD                  <1>  lodsd
  1477 00000827 C3                          ret
  1478                                  
  1479                                  begin_:
  1480 00000828 8925[5C390000]              mov [ list ], esp
  1481                                  here:
  1482                                      _DUP_
  1483 0000082E 83EE04              <1>  sub esi, byte 0x04
  1484 00000831 8906                <1>  mov [ esi ], _TOS_
  1485 00000833 A1[50390000]                mov _TOS_, [v_H]
  1486 00000838 C3                          ret
  1487                                  
  1488                                  ; *****************************************************************************
  1489                                  ; *****************************************************************************
  1490                                  
  1491                                  qlit:  ; ?lit
  1492 00000839 8B15[50390000]              mov edx, [ v_H ]
  1493 0000083F 8D52FB                      lea edx, [ edx - 0x05 ]
  1494 00000842 3915[5C390000]              cmp [ list ], edx
  1495 00000848 7533                        jnz .forward
  1496 0000084A 803AB8                      cmp byte [edx], _MOV_TOS_LIT_   ; the opcode for mov eax, 32_bit_literal  (in next 32 bit cell)
  1497 0000084D 752E                        jnz .forward
  1498                                      _DUP_
  1499 0000084F 83EE04              <1>  sub esi, byte 0x04
  1500 00000852 8906                <1>  mov [ esi ], _TOS_
  1501 00000854 A1[60390000]                mov _TOS_, [ list + 4 ]
  1502 00000859 A3[5C390000]                mov [ list ], _TOS_
  1503 0000085E 8B4201                      mov _TOS_, [ edx + 0x01 ]
  1504 00000861 817AFB8D76FC89              cmp dword [ edx - 5 ], 0x89FC768D   ; assemble code 8D 76 FC 89 rr => lea esi, [ esi - 0x04 ] ;  mov [ esi ], register
  1505                                      ; like dup but with the register value still to follow in the next byte
  1506 00000868 740B                        jz .forward2
  1507 0000086A 8915[50390000]              mov [ v_H ], edx
  1508 00000870 E9E9FCFFFF                  jmp dword cdrop
  1509                                  .forward2:
  1510 00000875 8305[50390000]F6            add dword [ v_H ], byte -0x0A
  1511 0000087C C3                          ret
  1512                                  .forward:
  1513 0000087D 31D2                        xor edx, edx
  1514 0000087F C3                          ret
  1515                                  
  1516                                  less:
  1517 00000880 3906                        cmp [ esi ], _TOS_
  1518 00000882 7802                        js .forward
  1519 00000884 31C9                        xor ecx, ecx
  1520                                  .forward:
  1521 00000886 C3                          ret
  1522                                  
  1523                                  qignore:
  1524 00000887 F704BDFCFFFFFFF0FF-         test dword [ ( edi * 4 ) - 0x04 ], 0xFFFFFFF0
  1525 00000890 FFFF               
  1526 00000892 7502                        jnz .forward
  1527 00000894 5F                          pop edi
  1528 00000895 5F                          pop edi
  1529                                  .forward:
  1530 00000896 C3                          ret
  1531                                  
  1532                                  jump:
  1533 00000897 5A                          pop edx
  1534 00000898 01C2                        add edx, _TOS_
  1535 0000089A 8D548205                    lea edx, [ edx + ( _TOS_ * 4 ) + 0x05 ]
  1536 0000089E 0352FC                      add edx, [ edx - 0x04 ]
  1537                                      _DROP_
  1538 000008A1 AD                  <1>  lodsd
  1539 000008A2 FFE2                        jmp edx
  1540                                  
  1541                                  ; convert block start address to cell address, add the RELOCATED colorForth system base
  1542                                  blockToCellAddress:  ; ( blk -- a' )   \ add the RELOCATED offset and convert to cell address
  1543 000008A4 0305[D8380000]              add _TOS_, [ v_offset ]   ; add the RELOCATED block number offset
  1544 000008AA C1E008                      shl _TOS_, 0x08           ; convert to cell address
  1545 000008AD C3                          ret
  1546                                  
  1547                                  cellAddressToBlock:   ; ( a -- blk )  \ convert cell address to block number and subtract the RELOCATED block number offset
  1548 000008AE C1E808                      shr _TOS_, 0x08           ;  convert cell address to block number
  1549 000008B1 2B05[D8380000]              sub _TOS_, [ v_offset ]   ; subtract the block number of block 0
  1550 000008B7 C3                          ret
  1551                                  
  1552                                  _load_:   ; ( blk -- )    \ load the given block number
  1553 000008B8 E8E7FFFFFF                  call blockToCellAddress   ; add the RELOCATED block number offset and convert to cell address
  1554 000008BD 57                          push edi
  1555 000008BE 89C7                        mov edi, _TOS_
  1556                                      _DROP_
  1557 000008C0 AD                  <1>  lodsd
  1558                                  interpret:
  1559 000008C1 8B14BD00000000              mov edx, [ ( edi * 4 ) + 0x00 ]
  1560 000008C8 47                          inc edi
  1561 000008C9 83E20F                      and edx, byte 0x0F
  1562 000008CC FF1495[6C390000]            call [ ( edx * 4 ) + tokenActions ]
  1563 000008D3 EBEC                        jmp short interpret
  1564                                  
  1565 000008D5 00<rept>                    align 4, db 0   ; fill the gap with 0's
  1566                                  
  1567                                  ; : r@ qdup $8B 1, $C7 1, ;    \ mov _TOS_, edi  also db 0x89, 0xF8
  1568                                  ; : nload r@ $0100 / #2 + load ;
  1569                                  ; : +load ( n -- ) r@ $0100 / + load ;
  1570                                  nload:  ; ( -- )    \ load the next source block following the one currently being loaded
  1571 000008D8 E867000000                  call cblk_
  1572 000008DD 0502000000                  add _TOS_, 0x02
  1573 000008E2 E9D1FFFFFF                  jmp _load_
  1574                                  
  1575                                  plusLoad:   ; ( n -- )    \ load the n'th source block following the one currently being loaded
  1576 000008E7 89C3                        mov _SCRATCH_, _TOS_    ; save the required offset
  1577                                      _DROP_
  1578 000008E9 AD                  <1>  lodsd
  1579 000008EA E855000000                  call cblk_
  1580 000008EF 01D8                        add _TOS_, _SCRATCH_
  1581 000008F1 E9C2FFFFFF                  jmp _load_
  1582                                  
  1583                                  ; : THRU ( f l -- )   1+ SWAP DO  I LOAD  LOOP ;
  1584                                  thru_:  ; ( first last -- )   \ load from the first to the last block
  1585 000008F6 0502000000                  add _TOS_, 0x02
  1586 000008FB 89C3                        mov _SCRATCH_, _TOS_
  1587                                      _DROP_                          ; TOS = first, SCRATCH = last
  1588 000008FD AD                  <1>  lodsd
  1589 000008FE 89D9                        mov ecx, _SCRATCH_
  1590 00000900 29C1                        sub ecx, _TOS_                  ; ecx = count
  1591 00000902 741F                        jz .end                         ; exit if count is zero
  1592 00000904 721D                        jc .end                         ; exit if count is negative
  1593 00000906 D1E9                        shr ecx, 1                      ; divide by 2, as we skip 2 blocks each time round the loop
  1594                                  .back:
  1595                                      _DUP_
  1596 00000908 83EE04              <1>  sub esi, byte 0x04
  1597 0000090B 8906                <1>  mov [ esi ], _TOS_
  1598                                      _DUP_   ; just to be safe...
  1599 0000090D 83EE04              <1>  sub esi, byte 0x04
  1600 00000910 8906                <1>  mov [ esi ], _TOS_
  1601 00000912 51                          push ecx
  1602 00000913 53                          push _SCRATCH_
  1603 00000914 E89FFFFFFF                  call _load_
  1604 00000919 5B                          pop _SCRATCH_
  1605 0000091A 59                          pop ecx
  1606                                      _DROP_  ; just to be safe...
  1607 0000091B AD                  <1>  lodsd
  1608 0000091C 0502000000                  add _TOS_, 0x02
  1609 00000921 E2E5                        loop .back
  1610                                  .end:
  1611                                      _DROP_
  1612 00000923 AD                  <1>  lodsd
  1613 00000924 C3                          ret
  1614                                  
  1615                                  v_temp:
  1616 00000925 00000000                    dd 0
  1617                                  
  1618                                  plusThru_:  ; ( first+ last+ -- )   \ load from the first to the last block relative to the current block being loaded
  1619 00000929 E816000000                  call cblk_
  1620 0000092E A3[25090000]                mov [ v_temp ], _TOS_
  1621                                      _DROP_
  1622 00000933 AD                  <1>  lodsd
  1623 00000934 8B1D[25090000]              mov _SCRATCH_, [ v_temp ]
  1624 0000093A 011E                        add [ esi ], _SCRATCH_          ; add current block to second on stack
  1625 0000093C 01D8                        add _TOS_, _SCRATCH_            ; add current block to top of stack
  1626 0000093E E8B3FFFFFF                  call thru_
  1627 00000943 C3                          ret
  1628                                  
  1629                                  cblk_:   ; ( -- n )  \ return the currently compiling block number - only valid while compiling
  1630                                      _DUP_
  1631 00000944 83EE04              <1>  sub esi, byte 0x04
  1632 00000947 8906                <1>  mov [ esi ], _TOS_
  1633 00000949 89F8                        mov _TOS_, edi            ; edi  contains the cell address in the block currently being compiled
  1634 0000094B E85EFFFFFF                  call cellAddressToBlock   ; convert to block number relative to block 0
  1635 00000950 C3                          ret
  1636                                  
  1637                                  rblk_:   ; ( -- n )  \ return the block number offset of the RELOCATED address
  1638                                      _DUP_
  1639 00000951 83EE04              <1>  sub esi, byte 0x04
  1640 00000954 8906                <1>  mov [ esi ], _TOS_
  1641 00000956 B840000000                  mov _TOS_, ( RELOCATED >> ( 2 + 8 ) )
  1642 0000095B C3                          ret
  1643                                  
  1644                                  ablk_:   ; ( a -- n )  \ convert byte address to block number
  1645 0000095C C1E802                      shr _TOS_, 0x02
  1646 0000095F E84AFFFFFF                  call cellAddressToBlock
  1647 00000964 C3                          ret
  1648                                  
  1649                                  erase_:   ; ( a n -- )  \ erase n bytes starting at address a
  1650 00000965 89C1                        mov ecx, eax
  1651                                      _DROP_
  1652 00000967 AD                  <1>  lodsd
  1653 00000968 57                          push edi
  1654 00000969 89C7                        mov edi, eax
  1655 0000096B 31C0                        xor eax, eax
  1656 0000096D F3AA                        rep stosb
  1657 0000096F 5F                          pop edi
  1658                                      _DROP_
  1659 00000970 AD                  <1>  lodsd
  1660 00000971 C3                          ret
  1661                                  
  1662                                  v_curs_to_source:   ; ( n -- a32 )   \ return the cell address of the current cursor position in the current block being edited
  1663 00000972 89C3                        mov _SCRATCH_, _TOS_
  1664 00000974 A1[88380000]                mov _TOS_, [ v_blk ]            ; get the currently edited block number
  1665 00000979 E826FFFFFF                  call blockToCellAddress
  1666 0000097E 01D8                        add _TOS_, _SCRATCH_            ; add the cursor position (cell address) in the block
  1667 00000980 C3                          ret
  1668                                  
  1669                                  nth_to_token:   ; ( n -- tok )   \ return the token at the n'th cursor position in the current block being edited
  1670 00000981 E8ECFFFFFF                  call v_curs_to_source
  1671 00000986 C1E002                      shl _TOS_, 0x02                 ; convert cell address to byte address
  1672 00000989 8B00                        mov _TOS_, [ _TOS_ ]            ; fetch the token
  1673 0000098B C3                          ret
  1674                                  
  1675                                  v_curs_to_token:   ; ( -- tok )   \ return the token at the current cursor position in the current block being edited
  1676                                      _DUP_
  1677 0000098C 83EE04              <1>  sub esi, byte 0x04
  1678 0000098F 8906                <1>  mov [ esi ], _TOS_
  1679 00000991 A1[88380000]                mov _TOS_, [ v_blk ]            ; get the currently edited block number
  1680 00000996 E8E6FFFFFF                  call nth_to_token
  1681 0000099B C3                          ret
  1682                                  
  1683                                  ; : ?f $C021 2, ;
  1684                                  ;qf:
  1685                                  ;    db 0x21, 0xC0   ; and _TOS_, _TOS_
  1686                                  ;    ret
  1687                                  
  1688                                  ; *****************************************************************************
  1689                                  ; *****************************************************************************
  1690                                  
  1691                                  top_:   ; ( -- )   \ set the cursor to the left margin horizontally and 3 pixels down from the top vertically
  1692 0000099C 8B0D[B0390000]              mov ecx, [ v_leftMargin ]
  1693 000009A2 C1E110                      shl ecx, 0x10
  1694 000009A5 83C103                      add ecx, byte 0x03
  1695 000009A8 890D[AC390000]              mov [ v_xy ], ecx
  1696                                      ; mov [ xycr], ecx
  1697 000009AE C3                          ret
  1698                                  
  1699                                  qcr: ; ( -- )   \ ?cr  do a  CR  if the cursor has gone past the right margin
  1700 000009AF 668B0D[AE390000]            mov cx, [ v_x ]
  1701 000009B6 663B0D[B4390000]            cmp cx, [ v_rightMargin ]
  1702 000009BD 781D                        js cr_forward
  1703                                  cr_:  ; ( -- )
  1704 000009BF 8B0D[B0390000]              mov ecx, [ v_leftMargin ]
  1705 000009C5 C1E110                      shl ecx, 0x10
  1706 000009C8 668B0D[AC390000]            mov cx, [ v_xy ]
  1707 000009CF 66030D[E4380000]            add cx, [ v_iconh ]
  1708 000009D6 890D[AC390000]              mov [ v_xy ], ecx
  1709                                  cr_forward:
  1710 000009DC C3                          ret
  1711                                  
  1712                                  green:  ; ( -- )
  1713                                      _DUP_
  1714 000009DD 83EE04              <1>  sub esi, byte 0x04
  1715 000009E0 8906                <1>  mov [ esi ], _TOS_
  1716 000009E2 B800060000                  mov _TOS_, colour_green
  1717 000009E7 E919000000                  jmp color
  1718                                  
  1719                                  yellow:  ; ( -- )
  1720                                      _DUP_
  1721 000009EC 83EE04              <1>  sub esi, byte 0x04
  1722 000009EF 8906                <1>  mov [ esi ], _TOS_
  1723 000009F1 B8E0FF0000                  mov _TOS_, colour_yellow
  1724 000009F6 E90A000000                  jmp color
  1725                                  
  1726                                  ; red:  ; ( -- )    ; see redWord:
  1727                                  ;    _DUP_
  1728                                  ;    mov _TOS_, colour_red
  1729                                  ;    jmp color
  1730                                  
  1731                                  white:  ; ( -- )
  1732                                      _DUP_
  1733 000009FB 83EE04              <1>  sub esi, byte 0x04
  1734 000009FE 8906                <1>  mov [ esi ], _TOS_
  1735 00000A00 B8FFFF0000                  mov _TOS_, colour_white
  1736                                  color:  ; ( rgb16 -- )
  1737 00000A05 A3[C0390000]                mov [ v_foregroundColour ], _TOS_
  1738                                      _DROP_
  1739 00000A0A AD                  <1>  lodsd
  1740 00000A0B C3                          ret
  1741                                  
  1742                                  rgb:    ; ( rgb32 -- rgb16 )    ; convert from 32 bit ( 8:8:8:8 _RGB ) colour to 16 bit ( 5:6:5 RGB ) colour value
  1743 00000A0C C1C808                      ror _TOS_, 8
  1744 00000A0F 66C1E802                    shr ax, 2
  1745 00000A13 C1C806                      ror _TOS_, 6
  1746 00000A16 C0E803                      shr al, 3
  1747 00000A19 C1C00B                      rol _TOS_, ( 6 + 5 )
  1748 00000A1C 25FFFF0000                  and _TOS_, 0x0000FFFF
  1749 00000A21 C3                          ret
  1750                                  
  1751                                  bye_:  ; ( -- )   \ exit colorForth
  1752 00000A22 E8EFF8FFFF                  call setRealModeAPI
  1753                                  [BITS 16]                           ; Real Mode code (16 bit)
  1754 00000A27 CD19                        int 0x19    ; reboot the computer
  1755                                      ; should never get past this point.... but in case we do...
  1756 00000A29 FA                          cli                             ; BIOS might have left interrupts enabled
  1757 00000A2A E8C0F8                      call setProtectedModeAPI        ; called from 16 bit code, returns to 32 bit code
  1758                                  [BITS 32]                           ; Protected Mode code (32 bit)
  1759 00000A2D C3                          ret
  1760                                  
  1761                                  %if 0
  1762                                  pci:
  1763                                      mov edx, 0x0CF8
  1764                                      out dx, _TOS_
  1765                                      lea edx, [ edx + 0x04 ]
  1766                                      in _TOS_, dx
  1767                                      ret
  1768                                  
  1769                                  device:
  1770                                      times ( 0x93a - ( $ - $$ ) ) nop  ; fill with nops to find_display ???
  1771                                  
  1772                                  find_display:                       ; called by warm
  1773                                      mov _TOS_, 0x3000000            ; PCI class code 3 = display controller
  1774                                      call device                     ; returns header address
  1775                                      lea _TOS_, [ _TOS_ + 0x10 ]     ; point to Base Address #0 (BAR0)
  1776                                      mov cl, 0x06
  1777                                  .next:
  1778                                      _DUP_
  1779                                      call pci
  1780                                      and al, 0xFB
  1781                                      xor al, 0x08
  1782                                      jz .forward
  1783                                      _DROP_
  1784                                      lea _TOS_, [ _TOS_ + 0x04 ]
  1785                                      loop .next
  1786                                      lea _TOS_, [ _TOS_ - 0x18 ]
  1787                                      _DUP_
  1788                                      call pci
  1789                                      and al, 0xF0
  1790                                  .forward:
  1791                                      mov [ v_frameBuffer ], _TOS_     ; set framebuffer address
  1792                                      _DROP_
  1793                                      ret
  1794                                  
  1795                                  fifo:
  1796                                      _DROP_
  1797                                      ret
  1798                                  
  1799                                  %endif
  1800                                  
  1801                                  graphAction:
  1802 00000A2E C3                          ret
  1803                                  
  1804                                  ; *****************************************************************************
  1805                                  ; *****************************************************************************
  1806                                  ; grapics mode dependent code
  1807                                  ; *****************************************************************************
  1808                                  ; *****************************************************************************
  1809                                  
  1810                                  ; *****************************************************************************
  1811                                  ; 1024x768 display
  1812                                  ; *****************************************************************************
  1813                                  
  1814                                  scrnw1 equ 1024              ; screen width in pixels
  1815                                  scrnh1 equ 768               ; screen height in pixels
  1816                                  iconw1 equ ( 16 + 4 )        ; icon width
  1817                                  iconh1 equ ( 24 + 4 )        ; icon height for 768 pixel high screen
  1818                                  
  1819                                  keypadY1 equ 4               ; location of keyboard display vertically in lines from the bottom
  1820                                  
  1821                                  initIconSize1:
  1822 00000A2F C705[E0380000]1400-         mov dword [ v_iconw ], iconw1
  1823 00000A37 0000               
  1824 00000A39 C705[EC380000]B400-         mov dword [ v_nine_iconw ], ( iconw1 * 9 )
  1825 00000A41 0000               
  1826 00000A43 C705[F0380000]B801-         mov dword [ v_twentytwo_iconw ], ( iconw1 * ( 13 + 9 ) )
  1827 00000A4B 0000               
  1828 00000A4D C705[F4380000]0000-         mov dword [ v_10000_iconw ], ( iconw1 * 0x10000 )
  1829 00000A55 1400               
  1830 00000A57 C705[E4380000]1C00-         mov dword [ v_iconh ], iconh1
  1831 00000A5F 0000               
  1832 00000A61 C705[E8380000]7000-         mov dword [ v_keypadY_iconh ], keypadY1 * iconh1
  1833 00000A69 0000               
  1834 00000A6B C3                          ret
  1835                                  
  1836                                  switch1:     ; copy our created image to the real display buffer
  1837 00000A6C 56                          push esi
  1838 00000A6D 57                          push edi
  1839 00000A6E 8B35[BC390000]              mov  esi, dword [ vframe ]   ; vframe  points to where we create our image
  1840 00000A74 8B3D28180000                mov  edi, [ vesa_PhysBasePtr ]    ; VESA frame buffer, saved by VESA BIOS call, the address in RAM that is displayed by the hardware
  1841 00000A7A B900000600                  mov  ecx, ( ( scrnw1 * scrnh1 ) / 4 ) * BYTES_PER_PIXEL   ; the / 4 is because we are moving doubles = 4 bytes each
  1842 00000A7F F3A5                        rep  movsd                  ; copy ecx 32 bit words from ds:esi to es:edi
  1843 00000A81 5F                          pop  edi
  1844 00000A82 5E                          pop  esi
  1845 00000A83 C3                          ret
  1846                                  
  1847                                  clip1:
  1848 00000A84 8B3D[AC390000]              mov  edi, [ v_xy ]
  1849 00000A8A 89F9                        mov  ecx, edi
  1850 00000A8C 6685C9                      test cx, cx
  1851 00000A8F 7902                        jns  .forward
  1852 00000A91 31C9                        xor  ecx, ecx
  1853                                  .forward:
  1854 00000A93 81E1FFFF0000                and  ecx, 0x0000FFFF
  1855 00000A99 890D[C8390000]              mov  [ v_yc ], ecx
  1856 00000A9F 69C900080000                imul ecx, ( scrnw1 * BYTES_PER_PIXEL )
  1857 00000AA5 C1FF10                      sar  edi, 16
  1858 00000AA8 7902                        jns  .forward2
  1859 00000AAA 31FF                        xor  edi, edi
  1860                                  .forward2:
  1861 00000AAC 893D[C4390000]              mov  [ v_xc ], edi
  1862 00000AB2 8D3C79                      lea  edi, [ edi * BYTES_PER_PIXEL + ecx ]
  1863 00000AB5 033D[BC390000]              add  edi, [ vframe ]
  1864 00000ABB C3                          ret
  1865                                  
  1866                                  bit16:                    ; write a 16 x 24 glyph to the graphic screen
  1867 00000ABC 66AD                        lodsw                 ; load the 16 bit value pointed to by SI into  ax
  1868 00000ABE 86C4                        xchg al, ah             ; eax_TOS_
  1869                                  .back:
  1870 00000AC0 66D1E0                      shl ax, 0x01            ; eax_TOS_
  1871 00000AC3 7308                        jnc  .forward
  1872 00000AC5 668917                      mov  [ edi ], dx        ;
  1873 00000AC8 E906000000                  jmp .forward2
  1874                                  .forward:
  1875 00000ACD C1CA10                      ror edx, 0x10           ; use the background colour, in the high 16 bits
  1876                                  ;    mov [ edi ], dx        ;
  1877 00000AD0 C1CA10                      ror edx, 0x10           ; return to the foreground colour, in the low 16 bits
  1878                                  .forward2:
  1879 00000AD3 83C702                      add edi, byte BYTES_PER_PIXEL
  1880 00000AD6 E2E8                        loop .back
  1881 00000AD8 C3                          ret
  1882                                  
  1883                                  ; write the background after the glyph
  1884                                  bit16Background:          ; number of pixels to write in  ecx ,  screen address in  edi , colours in edx
  1885 00000AD9 C1CA10                      ror edx, 0x10           ; use the background colour, in the high 16 bits
  1886                                  .back:
  1887                                  ;    mov [ edi ], dx        ;
  1888 00000ADC 83C702                      add edi, byte BYTES_PER_PIXEL
  1889 00000ADF E2FB                        loop .back
  1890 00000AE1 C1CA10                      ror edx, 0x10           ; return to the foreground colour, in the low 16 bits
  1891 00000AE4 C3                          ret
  1892                                  
  1893                                  bit32:                          ; write a 32 x 48 double size glyph to the graphic screen
  1894 00000AE5 66AD                        lodsw                   ; load the 16 bit value pointed to by SI into  ax
  1895 00000AE7 86C4                        xchg al, ah             ; eax_TOS_
  1896 00000AE9 B910000000                  mov ecx, 0x10
  1897                                  .back:
  1898 00000AEE D1E0                        shl  _TOS_, 1           ; eax_TOS_
  1899 00000AF0 7331                        jnc  .forward
  1900 00000AF2 668917                      mov  [ edi ], dx
  1901 00000AF5 66895702                    mov  [ edi + BYTES_PER_PIXEL ], dx
  1902                                  
  1903 00000AF9 803D[360E0000]00            cmp byte [ displayMode ], 0
  1904 00000B00 7513                        jnz .width2
  1905 00000B02 66899700080000              mov  [ edi + ( scrnw1 * BYTES_PER_PIXEL ) ], dx
  1906 00000B09 66899702080000              mov  [ edi + ( scrnw1 * BYTES_PER_PIXEL ) + BYTES_PER_PIXEL ], dx
  1907 00000B10 E90E000000                  jmp .widthEnd
  1908                                  .width2:
  1909 00000B15 66899740060000              mov  [ edi + ( scrnw2 * BYTES_PER_PIXEL ) ], dx
  1910 00000B1C 66899742060000              mov  [ edi + ( scrnw2 * BYTES_PER_PIXEL ) + BYTES_PER_PIXEL ], dx
  1911                                  .widthEnd:
  1912                                  .forward:
  1913 00000B23 83C704                      add edi, byte ( BYTES_PER_PIXEL * 2 )
  1914 00000B26 E2C6                        loop .back
  1915 00000B28 C3                          ret
  1916                                  
  1917                                  emit1:      ; ( c -- )   \ display a single width and height character
  1918 00000B29 E881FEFFFF                  call qcr
  1919 00000B2E 56                          push esi
  1920 00000B2F 57                          push edi
  1921 00000B30 52                          push edx
  1922 00000B31 6BC030                      imul _TOS_, byte 16*24/8
  1923 00000B34 8DB0[00680000]              lea esi, [ _TOS_ + font16x24 ]
  1924 00000B3A E845FFFFFF                  call clip1
  1925 00000B3F 8B15[C0390000]              mov edx, [ v_foregroundColour ]
  1926 00000B45 B918000000                  mov ecx, 0x18   ; 24 lines
  1927                                  .back:
  1928 00000B4A 51                          push ecx
  1929 00000B4B B910000000                  mov ecx, 0x10
  1930 00000B50 E867FFFFFF                  call bit16
  1931 00000B55 B904000000                  mov ecx, 0x04
  1932 00000B5A 57                          push edi
  1933 00000B5B E879FFFFFF                  call bit16Background
  1934 00000B60 5F                          pop edi
  1935 00000B61 59                          pop ecx
  1936 00000B62 81C7E0070000                add edi, ( scrnw1 - 16 ) * BYTES_PER_PIXEL  ; address of the next line of the glyph
  1937 00000B68 E2E0                        loop .back      ; next horizontal line
  1938                                  
  1939 00000B6A B904000000                  mov ecx, 0x04   ; 4 background lines
  1940                                  .back2:
  1941 00000B6F 51                          push ecx
  1942 00000B70 B910000000                  mov ecx, 0x10
  1943 00000B75 E85FFFFFFF                  call bit16Background
  1944 00000B7A B904000000                  mov ecx, 0x04
  1945 00000B7F 57                          push edi
  1946 00000B80 E854FFFFFF                  call bit16Background
  1947 00000B85 5F                          pop edi
  1948 00000B86 59                          pop ecx
  1949 00000B87 81C7E0070000                add edi, ( scrnw1 - 16 ) * BYTES_PER_PIXEL  ; address of the next line of the glyph
  1950 00000B8D E2E0                        loop .back2      ; next horizontal line
  1951                                  
  1952 00000B8F 5A                          pop edx
  1953 00000B90 5F                          pop edi
  1954 00000B91 5E                          pop esi
  1955                                      _DROP_
  1956 00000B92 AD                  <1>  lodsd
  1957                                  space1:
  1958 00000B93 8105[AC390000]0000-         add dword [ v_xy ], iconw1 * 0x10000 ; 22 horizontal pixels
  1959 00000B9B 1400               
  1960 00000B9D C3                          ret
  1961                                  
  1962                                  two_emit1:  ; double width and height character
  1963 00000B9E 56                          push esi
  1964 00000B9F 57                          push edi
  1965 00000BA0 52                          push edx
  1966 00000BA1 6BC030                      imul _TOS_, byte 16*24/8
  1967 00000BA4 8DB0[00680000]              lea esi, [ _TOS_ + font16x24 ]
  1968 00000BAA E8D5FEFFFF                  call clip1
  1969 00000BAF 8B15[C0390000]              mov edx, [ v_foregroundColour ]
  1970 00000BB5 B918000000                  mov ecx, 24
  1971                                  .back:
  1972 00000BBA 51                          push ecx
  1973 00000BBB E825FFFFFF                  call bit32
  1974 00000BC0 81C7C00F0000                add edi, (2*scrnw1-16*2)*BYTES_PER_PIXEL
  1975 00000BC6 59                          pop ecx
  1976 00000BC7 E2F1                        loop .back
  1977 00000BC9 5A                          pop edx
  1978 00000BCA 5F                          pop edi
  1979 00000BCB 5E                          pop esi
  1980 00000BCC 8105[AC390000]0000-         add dword [ v_xy ], iconw1 * 2 * 0x10000 ; 44 horizontal pixels
  1981 00000BD4 2800               
  1982                                      _DROP_
  1983 00000BD6 AD                  <1>  lodsd
  1984 00000BD7 C3                          ret
  1985                                  
  1986                                  setupText__1:   ; setup for full screen text window display
  1987 00000BD8 E81EFEFFFF                  call white
  1988 00000BDD C705[B0390000]0300-         mov dword [ v_leftMargin ], 0x03
  1989 00000BE5 0000               
  1990 00000BE7 C705[B4390000]EC03-         mov dword [ v_rightMargin ], ( scrnw1 - iconw1 )
  1991 00000BEF 0000               
  1992 00000BF1 E9A6FDFFFF                  jmp dword top_
  1993                                  
  1994                                  box1: ; ( width height -- )
  1995 00000BF6 E889FEFFFF                  call clip1
  1996 00000BFB 3D01030000                  cmp _TOS_, scrnh1+1
  1997 00000C00 7805                        js .forward
  1998 00000C02 B800030000                  mov _TOS_, scrnh1
  1999                                  .forward:
  2000 00000C07 89C1                        mov ecx, _TOS_
  2001 00000C09 2B0D[C8390000]              sub ecx, [ v_yc ]
  2002 00000C0F 7E30                        jng .forward3
  2003 00000C11 813E01040000                cmp dword [esi], scrnw1+1
  2004 00000C17 7806                        js .forward2
  2005 00000C19 C70600040000                mov dword [esi], scrnw1
  2006                                  .forward2:
  2007 00000C1F A1[C4390000]                mov _TOS_, [ v_xc ]
  2008 00000C24 2906                        sub [esi], _TOS_
  2009 00000C26 7E19                        jng .forward3
  2010 00000C28 BA00040000                  mov edx, scrnw1
  2011 00000C2D 2B16                        sub edx, [esi]
  2012 00000C2F D1E2                        shl edx, PIXEL_SHIFT
  2013 00000C31 A1[C0390000]                mov _TOS_, [ v_foregroundColour ]
  2014                                  .back:
  2015 00000C36 51                          push ecx
  2016 00000C37 8B0E                        mov ecx, [esi]
  2017 00000C39 F366AB                      rep stosw   ; stosw depends on BYTES_PER_PIXEL, either stosw or stosd
  2018 00000C3C 01D7                        add edi, edx
  2019 00000C3E 59                          pop ecx
  2020 00000C3F E2F5                        loop .back
  2021                                  .forward3:
  2022                                      _DROP_
  2023 00000C41 AD                  <1>  lodsd
  2024                                      _DROP_
  2025 00000C42 AD                  <1>  lodsd
  2026 00000C43 C3                          ret
  2027                                  
  2028                                  wash1:   ; ( colour -- )   \ fill the full screeen with the given colour
  2029 00000C44 E8BCFDFFFF                  call color
  2030                                      _DUP_
  2031 00000C49 83EE04              <1>  sub esi, byte 0x04
  2032 00000C4C 8906                <1>  mov [ esi ], _TOS_
  2033                                  
  2034 00000C4E 31C0                        xor _TOS_, _TOS_     ; x,y = 0,0 top left corner
  2035 00000C50 A3[AC390000]                mov [ v_xy ], _TOS_
  2036                                  
  2037 00000C55 B800040000                  mov _TOS_, scrnw1
  2038                                      _DUP_
  2039 00000C5A 83EE04              <1>  sub esi, byte 0x04
  2040 00000C5D 8906                <1>  mov [ esi ], _TOS_
  2041 00000C5F B800030000                  mov _TOS_, scrnh1
  2042 00000C64 E980020000                  jmp dword box_
  2043                                  
  2044                                  ; *****************************************************************************
  2045                                  ; 800x600 screen
  2046                                  ; *****************************************************************************
  2047                                  
  2048                                  scrnw2 equ 800               ; screen width in pixels
  2049                                  scrnh2 equ 600               ; screen height in pixels
  2050                                  iconw2 equ ( 16 + 1 )        ; icon width
  2051                                  iconh2 equ ( 24 - 1 )        ; icon height for NC10 600 pixel high screen
  2052                                  
  2053                                  keypadY2 equ 4               ; location of keyboard display vertically in lines from the bottom
  2054                                  
  2055                                  initIconSize2:
  2056 00000C69 C705[E0380000]1100-         mov dword [ v_iconw ], iconw2
  2057 00000C71 0000               
  2058 00000C73 C705[EC380000]9900-         mov dword [ v_nine_iconw ], ( iconw2 * 9 )
  2059 00000C7B 0000               
  2060 00000C7D C705[F0380000]7601-         mov dword [ v_twentytwo_iconw ], ( iconw2 * ( 13 + 9 ) )
  2061 00000C85 0000               
  2062 00000C87 C705[F4380000]0000-         mov dword [ v_10000_iconw ], ( iconw2 * 0x10000 )
  2063 00000C8F 1100               
  2064 00000C91 C705[E4380000]1700-         mov dword [ v_iconh ], iconh2
  2065 00000C99 0000               
  2066 00000C9B C705[E8380000]5C00-         mov dword [ v_keypadY_iconh ], keypadY2 * iconh2
  2067 00000CA3 0000               
  2068 00000CA5 C3                          ret
  2069                                  
  2070                                  switch2:     ; copy our created image to the real display buffer
  2071 00000CA6 56                          push esi
  2072 00000CA7 57                          push edi
  2073 00000CA8 8B35[BC390000]              mov  esi, dword [ vframe ]   ; vframe  points to where we create our image
  2074 00000CAE 8B3D28180000                mov  edi, [ vesa_PhysBasePtr ]    ; VESA frame buffer, saved by VESA BIOS call, the address in RAM that is displayed by the hardware
  2075 00000CB4 B980A90300                  mov  ecx, ( ( scrnw2 * scrnh2 ) / 4 ) * BYTES_PER_PIXEL   ; the / 4 is because we are moving doubles = 4 bytes each
  2076 00000CB9 F3A5                        rep  movsd                  ; copy ecx 32 bit words from ds:esi to es:edi
  2077 00000CBB 5F                          pop  edi
  2078 00000CBC 5E                          pop  esi
  2079 00000CBD C3                          ret
  2080                                  
  2081                                  clip2:
  2082 00000CBE 8B3D[AC390000]              mov  edi, [ v_xy ]
  2083 00000CC4 89F9                        mov  ecx, edi
  2084 00000CC6 6685C9                      test cx, cx
  2085 00000CC9 7902                        jns  .forward
  2086 00000CCB 31C9                        xor  ecx, ecx
  2087                                  .forward:
  2088 00000CCD 81E1FFFF0000                and  ecx, 0x0000FFFF
  2089 00000CD3 890D[C8390000]              mov  [ v_yc ], ecx
  2090 00000CD9 69C940060000                imul ecx, ( scrnw2 * BYTES_PER_PIXEL )
  2091 00000CDF C1FF10                      sar  edi, 16
  2092 00000CE2 7902                        jns  .forward2
  2093 00000CE4 31FF                        xor  edi, edi
  2094                                  .forward2:
  2095 00000CE6 893D[C4390000]              mov  [ v_xc ], edi
  2096 00000CEC 8D3C79                      lea  edi, [ edi * BYTES_PER_PIXEL + ecx ]
  2097 00000CEF 033D[BC390000]              add  edi, [ vframe ]
  2098 00000CF5 C3                          ret
  2099                                  
  2100                                  emit2:      ; ( c -- )   \ display a single width and height character
  2101 00000CF6 E8B4FCFFFF                  call qcr
  2102 00000CFB 56                          push esi
  2103 00000CFC 57                          push edi
  2104 00000CFD 52                          push edx
  2105 00000CFE 6BC030                      imul _TOS_, byte 16*24/8
  2106 00000D01 8DB0[00680000]              lea esi, [ _TOS_ + font16x24 ]
  2107 00000D07 E8B2FFFFFF                  call clip2
  2108 00000D0C 8B15[C0390000]              mov edx, [ v_foregroundColour ]
  2109 00000D12 B918000000                  mov ecx, 0x18   ; 24 lines
  2110                                  .back:
  2111 00000D17 51                          push ecx
  2112 00000D18 B910000000                  mov ecx, 0x10
  2113 00000D1D E89AFDFFFF                  call bit16
  2114 00000D22 B904000000                  mov ecx, 0x04
  2115 00000D27 57                          push edi
  2116 00000D28 E8ACFDFFFF                  call bit16Background
  2117 00000D2D 5F                          pop edi
  2118 00000D2E 59                          pop ecx
  2119 00000D2F 81C720060000                add edi, ( scrnw2 - 16 ) * BYTES_PER_PIXEL  ; address of the next line of the glyph
  2120 00000D35 E2E0                        loop .back      ; next horizontal line
  2121                                  
  2122 00000D37 B904000000                  mov ecx, 0x04   ; 4 background lines
  2123                                  .back2:
  2124 00000D3C 51                          push ecx
  2125 00000D3D B910000000                  mov ecx, 0x10
  2126 00000D42 E892FDFFFF                  call bit16Background
  2127 00000D47 B904000000                  mov ecx, 0x04
  2128 00000D4C 57                          push edi
  2129 00000D4D E887FDFFFF                  call bit16Background
  2130 00000D52 5F                          pop edi
  2131 00000D53 59                          pop ecx
  2132 00000D54 81C720060000                add edi, ( scrnw2 - 16 ) * BYTES_PER_PIXEL  ; address of the next line of the glyph
  2133 00000D5A E2E0                        loop .back2      ; next horizontal line
  2134                                  
  2135 00000D5C 5A                          pop edx
  2136 00000D5D 5F                          pop edi
  2137 00000D5E 5E                          pop esi
  2138                                      _DROP_
  2139 00000D5F AD                  <1>  lodsd
  2140                                  space2:
  2141 00000D60 8105[AC390000]0000-         add dword [ v_xy ], iconw2 * 0x10000 ; 22 horizontal pixels
  2142 00000D68 1100               
  2143 00000D6A C3                          ret
  2144                                  
  2145                                  two_emit2:  ; double width and height character
  2146 00000D6B 56                          push esi
  2147 00000D6C 57                          push edi
  2148 00000D6D 52                          push edx
  2149 00000D6E 6BC030                      imul _TOS_, byte 16*24/8
  2150 00000D71 8DB0[00680000]              lea esi, [ _TOS_ + font16x24 ]
  2151 00000D77 E842FFFFFF                  call clip2
  2152 00000D7C 8B15[C0390000]              mov edx, [ v_foregroundColour ]
  2153 00000D82 B918000000                  mov ecx, 24
  2154                                  .back:
  2155 00000D87 51                          push ecx
  2156 00000D88 E858FDFFFF                  call bit32
  2157 00000D8D 81C7400C0000                add edi, (2*scrnw2-16*2)*BYTES_PER_PIXEL
  2158 00000D93 59                          pop ecx
  2159 00000D94 E2F1                        loop .back
  2160 00000D96 5A                          pop edx
  2161 00000D97 5F                          pop edi
  2162 00000D98 5E                          pop esi
  2163 00000D99 8105[AC390000]0000-         add dword [ v_xy ], iconw2 * 2 * 0x10000 ; 44 horizontal pixels
  2164 00000DA1 2200               
  2165                                      _DROP_
  2166 00000DA3 AD                  <1>  lodsd
  2167 00000DA4 C3                          ret
  2168                                  
  2169                                  setupText__2:   ; setup for full screen text window display
  2170 00000DA5 E851FCFFFF                  call white
  2171 00000DAA C705[B0390000]0300-         mov dword [ v_leftMargin ], 0x03
  2172 00000DB2 0000               
  2173 00000DB4 C705[B4390000]0F03-         mov dword [ v_rightMargin ], ( scrnw2 - iconw2 )
  2174 00000DBC 0000               
  2175 00000DBE E9D9FBFFFF                  jmp dword top_
  2176                                  
  2177                                  box2: ; ( width height -- )
  2178 00000DC3 E8F6FEFFFF                  call clip2
  2179 00000DC8 3D59020000                  cmp _TOS_, scrnh2+1
  2180 00000DCD 7805                        js .forward
  2181 00000DCF B858020000                  mov _TOS_, scrnh2
  2182                                  .forward:
  2183 00000DD4 89C1                        mov ecx, _TOS_
  2184 00000DD6 2B0D[C8390000]              sub ecx, [ v_yc ]
  2185 00000DDC 7E30                        jng .forward3
  2186 00000DDE 813E21030000                cmp dword [esi], scrnw2+1
  2187 00000DE4 7806                        js .forward2
  2188 00000DE6 C70620030000                mov dword [esi], scrnw2
  2189                                  .forward2:
  2190 00000DEC A1[C4390000]                mov _TOS_, [ v_xc ]
  2191 00000DF1 2906                        sub [esi], _TOS_
  2192 00000DF3 7E19                        jng .forward3
  2193 00000DF5 BA20030000                  mov edx, scrnw2
  2194 00000DFA 2B16                        sub edx, [esi]
  2195 00000DFC D1E2                        shl edx, PIXEL_SHIFT
  2196 00000DFE A1[C0390000]                mov _TOS_, [ v_foregroundColour ]
  2197                                  .back:
  2198 00000E03 51                          push ecx
  2199 00000E04 8B0E                        mov ecx, [esi]
  2200 00000E06 F366AB                      rep stosw   ; stosw depends on BYTES_PER_PIXEL, either stosw or stosd
  2201 00000E09 01D7                        add edi, edx
  2202 00000E0B 59                          pop ecx
  2203 00000E0C E2F5                        loop .back
  2204                                  .forward3:
  2205                                      _DROP_
  2206 00000E0E AD                  <1>  lodsd
  2207                                      _DROP_
  2208 00000E0F AD                  <1>  lodsd
  2209 00000E10 C3                          ret
  2210                                  
  2211                                  wash2:    ; ( colour -- )   \ fill the full screeen with the given colour
  2212 00000E11 E8EFFBFFFF                  call color
  2213                                      _DUP_
  2214 00000E16 83EE04              <1>  sub esi, byte 0x04
  2215 00000E19 8906                <1>  mov [ esi ], _TOS_
  2216                                  
  2217 00000E1B 31C0                        xor _TOS_, _TOS_     ; x,y = 0,0 top left corner
  2218 00000E1D A3[AC390000]                mov [ v_xy ], _TOS_
  2219                                  
  2220 00000E22 B820030000                  mov _TOS_, scrnw2
  2221                                      _DUP_
  2222 00000E27 83EE04              <1>  sub esi, byte 0x04
  2223 00000E2A 8906                <1>  mov [ esi ], _TOS_
  2224 00000E2C B858020000                  mov _TOS_, scrnh2
  2225 00000E31 E9B3000000                  jmp dword box_
  2226                                  
  2227                                  ; *****************************************************************************
  2228                                  ; select which display mode code to use
  2229                                  ; *****************************************************************************
  2230                                  
  2231                                  displayMode:
  2232 00000E36 01000000                    dd 1    ; 0 = 1024x768x16, 1 = 800x600x16
  2233                                  
  2234                                  initIconSize:
  2235 00000E3A 803D[360E0000]00            cmp byte [ displayMode ], 0
  2236 00000E41 0F84E8FBFFFF                jz initIconSize1
  2237 00000E47 E91DFEFFFF                  jmp initIconSize2
  2238                                  
  2239                                  switch:
  2240 00000E4C 803D[360E0000]00            cmp byte [ displayMode ], 0
  2241 00000E53 0F8413FCFFFF                jz switch1
  2242 00000E59 E948FEFFFF                  jmp switch2
  2243                                  
  2244                                  clip:
  2245 00000E5E 803D[360E0000]00            cmp byte [ displayMode ], 0
  2246 00000E65 0F8419FCFFFF                jz clip1
  2247 00000E6B E94EFEFFFF                  jmp clip2
  2248                                  
  2249                                  emit_:
  2250 00000E70 803D[360E0000]00            cmp byte [ displayMode ], 0
  2251 00000E77 0F84ACFCFFFF                jz emit1
  2252 00000E7D E974FEFFFF                  jmp emit2
  2253                                  
  2254                                  space_:
  2255 00000E82 803D[360E0000]00            cmp byte [ displayMode ], 0
  2256 00000E89 0F8404FDFFFF                jz space1
  2257 00000E8F E9CCFEFFFF                  jmp space2
  2258                                  
  2259                                  two_emit:
  2260 00000E94 803D[360E0000]00            cmp byte [ displayMode ], 0
  2261 00000E9B 0F84FDFCFFFF                jz two_emit1
  2262 00000EA1 E9C5FEFFFF                  jmp two_emit2
  2263                                  
  2264                                  setupText_:     ; setup for full screen text window display
  2265 00000EA6 803D[360E0000]00            cmp byte [ displayMode ], 0
  2266 00000EAD 0F8425FDFFFF                jz setupText__1
  2267 00000EB3 E9EDFEFFFF                  jmp setupText__2
  2268                                  
  2269                                  line_:  ; ( startX length -- )   \ draw a horizontal line in the current colour, from startX relative to current clip window, of given length in pixels
  2270 00000EB8 803D[360E0000]00            cmp byte [ displayMode ], 0
  2271 00000EBF 750A                        jnz .forward
  2272 00000EC1 E8BEFBFFFF                  call clip1
  2273 00000EC6 E905000000                  jmp .common
  2274                                  .forward:
  2275 00000ECB E8EEFDFFFF                  call clip2
  2276                                  .common:
  2277 00000ED0 8B0E                        mov ecx, [esi]
  2278 00000ED2 D1E1                        shl ecx, PIXEL_SHIFT
  2279 00000ED4 29CF                        sub edi, ecx
  2280 00000ED6 89C1                        mov ecx, _TOS_
  2281 00000ED8 A1[C0390000]                mov _TOS_, [ v_foregroundColour ]
  2282 00000EDD F366AB                      rep stosw   ;
  2283 00000EE0 FF05[AC390000]              inc dword [ v_xy ]
  2284                                      _DROP_
  2285 00000EE6 AD                  <1>  lodsd
  2286                                      _DROP_
  2287 00000EE7 AD                  <1>  lodsd
  2288 00000EE8 C3                          ret
  2289                                  
  2290                                  box_:
  2291 00000EE9 803D[360E0000]00            cmp byte [ displayMode ], 0
  2292 00000EF0 0F8400FDFFFF                jz box1
  2293 00000EF6 E9C8FEFFFF                  jmp box2
  2294                                  
  2295                                  page_:    ; ( -- )    \ fill the full screen with the current background colour
  2296                                      _DUP_
  2297 00000EFB 83EE04              <1>  sub esi, byte 0x04
  2298 00000EFE 8906                <1>  mov [ esi ], _TOS_
  2299 00000F00 B800000000                  mov _TOS_, colour_background   ;
  2300 00000F05 E90A000000                  jmp wash_
  2301                                  
  2302                                  screen_:    ; ( -- )   \ fill the full screen with the current foreground colour
  2303                                      _DUP_
  2304 00000F0A 83EE04              <1>  sub esi, byte 0x04
  2305 00000F0D 8906                <1>  mov [ esi ], _TOS_
  2306 00000F0F A1[C0390000]                mov _TOS_, [ v_foregroundColour ]  ;     ; select the foreground colour in the low 16 bits
  2307                                  ;    jmp wash_                      ; fall through to wash1
  2308                                  
  2309                                  wash_:  ; ( colour -- )   \ fill the full screeen with the given colour
  2310 00000F14 A3[40390000]                mov [ v_washColour ], _TOS_
  2311 00000F19 803D[360E0000]00            cmp byte [ displayMode ], 0
  2312 00000F20 0F841EFDFFFF                jz wash1
  2313 00000F26 E9E6FEFFFF                  jmp wash2
  2314                                  
  2315                                  ; *****************************************************************************
  2316                                  ; *****************************************************************************
  2317                                  ; *****************************************************************************
  2318                                  
  2319                                  setCyan:
  2320                                      _DUP_
  2321 00000F2B 83EE04              <1>  sub esi, byte 0x04
  2322 00000F2E 8906                <1>  mov [ esi ], _TOS_
  2323 00000F30 B8FF070000                  mov _TOS_, colour_cyan
  2324 00000F35 E9CBFAFFFF                  jmp dword color
  2325                                  
  2326                                  setMagenta:
  2327                                      _DUP_
  2328 00000F3A 83EE04              <1>  sub esi, byte 0x04
  2329 00000F3D 8906                <1>  mov [ esi ], _TOS_
  2330 00000F3F B81FF80000                  mov _TOS_, colour_magenta
  2331 00000F44 E9BCFAFFFF                  jmp dword color
  2332                                  
  2333                                  setMagentaData:
  2334                                      _DUP_
  2335 00000F49 83EE04              <1>  sub esi, byte 0x04
  2336 00000F4C 8906                <1>  mov [ esi ], _TOS_
  2337 00000F4E B810D00000                  mov _TOS_, colour_magentaData
  2338 00000F53 E9ADFAFFFF                  jmp dword color
  2339                                  
  2340                                  setBlue:
  2341                                      _DUP_
  2342 00000F58 83EE04              <1>  sub esi, byte 0x04
  2343 00000F5B 8906                <1>  mov [ esi ], _TOS_
  2344 00000F5D B81F000000                  mov _TOS_, colour_blue
  2345 00000F62 E99EFAFFFF                  jmp dword color
  2346                                  
  2347                                  setRed:
  2348                                      _DUP_
  2349 00000F67 83EE04              <1>  sub esi, byte 0x04
  2350 00000F6A 8906                <1>  mov [ esi ], _TOS_
  2351 00000F6C B800F80000                  mov _TOS_, colour_red
  2352 00000F71 E98FFAFFFF                  jmp dword color
  2353                                  
  2354                                  setGreen:
  2355                                      _DUP_
  2356 00000F76 83EE04              <1>  sub esi, byte 0x04
  2357 00000F79 8906                <1>  mov [ esi ], _TOS_
  2358 00000F7B B800060000                  mov _TOS_, colour_green
  2359 00000F80 E980FAFFFF                  jmp dword color
  2360                                  
  2361                                  setSilver:
  2362                                      _DUP_
  2363 00000F85 83EE04              <1>  sub esi, byte 0x04
  2364 00000F88 8906                <1>  mov [ esi ], _TOS_
  2365 00000F8A B818C60000                  mov _TOS_, colour_silver
  2366 00000F8F E971FAFFFF                  jmp dword color
  2367                                  
  2368                                  setTaupe:
  2369                                      _DUP_
  2370 00000F94 83EE04              <1>  sub esi, byte 0x04
  2371 00000F97 8906                <1>  mov [ esi ], _TOS_
  2372 00000F99 B8E7B20000                  mov _TOS_, colour_taupe
  2373 00000F9E E962FAFFFF                  jmp dword color
  2374                                  
  2375                                  
  2376                                  history:
  2377 00000FA3 00<rept>                    times 11 db 0
  2378                                  
  2379                                  echo_:
  2380 00000FAE 56                          push esi
  2381 00000FAF B90A000000                  mov ecx, 11-1
  2382 00000FB4 8D3D[A30F0000]              lea edi, [ history ]
  2383 00000FBA 8D7701                      lea esi, [edi+1]
  2384 00000FBD F3A4                        rep movsb
  2385 00000FBF 5E                          pop esi
  2386 00000FC0 A2[AD0F0000]                mov byte [ history+11-1 ], al
  2387                                      _DROP_
  2388 00000FC5 AD                  <1>  lodsd
  2389 00000FC6 C3                          ret
  2390                                  
  2391                                  right:
  2392                                      _DUP_
  2393 00000FC7 83EE04              <1>  sub esi, byte 0x04
  2394 00000FCA 8906                <1>  mov [ esi ], _TOS_
  2395 00000FCC B90B000000                  mov ecx, 11
  2396 00000FD1 8D3D[A30F0000]              lea edi, [history]
  2397 00000FD7 31C0                        xor _TOS_, _TOS_
  2398 00000FD9 F3AA                        rep stosb
  2399                                      _DROP_
  2400 00000FDB AD                  <1>  lodsd
  2401 00000FDC C3                          ret
  2402                                  
  2403                                  down:
  2404                                      _DUP_
  2405 00000FDD 83EE04              <1>  sub esi, byte 0x04
  2406 00000FE0 8906                <1>  mov [ esi ], _TOS_
  2407 00000FE2 31D2                        xor edx, edx
  2408 00000FE4 8B0D[E4380000]              mov ecx, [ v_iconh ]
  2409 00000FEA F7F1                        div ecx
  2410 00000FEC 89D0                        mov _TOS_, edx
  2411 00000FEE 2B15[E4380000]              sub edx, [ v_iconh ]
  2412 00000FF4 81C203800300                add edx, ( 3 * 0x10000 )+ 0x8000 + 3
  2413 00000FFA 8915[AC390000]              mov [ v_xy ], edx
  2414                                  ; zero:
  2415 00001000 85C0                        test _TOS_, _TOS_
  2416 00001002 B800000000                  mov _TOS_, 0
  2417 00001007 7501                        jnz .dw
  2418 00001009 40                          inc _TOS_
  2419                                  .dw:
  2420 0000100A C3                          ret
  2421                                  
  2422                                  lm:     ; ( leftMargin -- )
  2423 0000100B A3[B0390000]                mov [ v_leftMargin ], _TOS_
  2424                                      _DROP_
  2425 00001010 AD                  <1>  lodsd
  2426 00001011 C3                          ret
  2427                                  
  2428                                  rm:     ; ( rightMargin -- )
  2429 00001012 A3[B4390000]                mov [ v_rightMargin ], _TOS_
  2430                                      _DROP_
  2431 00001017 AD                  <1>  lodsd
  2432 00001018 C3                          ret
  2433                                  
  2434                                  _at:    ; ( y x -- )
  2435 00001019 66A3[AC390000]              mov word [ v_y ], ax
  2436                                      _DROP_
  2437 0000101F AD                  <1>  lodsd
  2438 00001020 66A3[AE390000]              mov word [ v_x ], ax
  2439                                      _DROP_
  2440 00001026 AD                  <1>  lodsd
  2441 00001027 C3                          ret
  2442                                  
  2443                                  plus_at:    ; ( y x -- )
  2444 00001028 660105[AC390000]            add word [ v_y ], ax
  2445                                      _DROP_
  2446 0000102F AD                  <1>  lodsd
  2447 00001030 660105[AE390000]            add word [ v_x ], ax
  2448                                      _DROP_
  2449 00001037 AD                  <1>  lodsd
  2450 00001038 C3                          ret
  2451                                  
  2452                                  
  2453                                  storew_:    ; ( w a -- ) \  ; : !w a! $00028966 3, drop ; 
  2454 00001039 8BD0                        db 0x8B, 0xD0           ; mov edx,eax       a! $D08B 2,   ( ?lit not true )
  2455 0000103B 668902                      db 0x66, 0x89, 0x02     ; mov [edx],ax      $00028966 3,
  2456                                      _DROP_                  ; lodsd        
  2457 0000103E AD                  <1>  lodsd
  2458 0000103F C3                          ret                     ; ret          
  2459                                  
  2460                                  
  2461                                  storeu_:    ; ( u a -- ) \  ; : !l a! $0289 2, drop ; forth
  2462 00001040 8BD0                        db 0x8B, 0xD0           ; mov edx,eax       a! $D08B 2,   ( ?lit not true )
  2463 00001042 8902                        db 0x89, 0x02           ; mov [edx],eax     $0289 2,
  2464                                      _DROP_                  ; lodsd         
  2465 00001044 AD                  <1>  lodsd
  2466 00001045 C3                          ret                     ; ret           
  2467                                  
  2468                                  uplus_: ; ( u u -- u )   \ : u+ ?lit if $0681 2, , ; then $00044601 3, drop ;
  2469 00001046 014604                      db 0x01, 0x46, 0x04     ; add [esi+0x4],eax   $00044601 3,   ( ?lit not true )
  2470                                      _DROP_                  ; lodsd        
  2471 00001049 AD                  <1>  lodsd
  2472 0000104A C3                          ret                     ; ret          
  2473                                  
  2474                                  %if 1
  2475                                  ; the various pieces of code used by a! and +! in colorForth blocks 22 and 24
  2476                                   plusStore:  ; ( n a -- )
  2477                                      ;  : a! ?lit if $BA 1, , ; then $D08B 2, drop ;
  2478 0000104B BA78563412                   mov dword edx, 0x12345678                  ; db 0xBA, 0x78, 0x56, 0x34, 0x12
  2479 00001050 89C2                         mov edx, _TOS_                               ; db 0x8B, 0xD0 == db 0x89, 0xC2
  2480                                      ;  : +! ?lit if ?lit if $0581 2, swap a, , ; then $0501 2, a, drop ; then a! $0201 2, drop ;
  2481 00001052 010578563412                 add [ dword 0x12345678 ], _TOS_              ; db 0x01, 0x05, 0x78, 0x56, 0x34, 0x12
  2482 00001058 810578563412325476-          add dword [ dword 0x12345678 ], 0x98765432 ; db 0x81, 0x05, 0x78, 0x56, 0x34, 0x12, 0x32, 0x54, 0x76, 0x98
  2483 00001061 98                 
  2484 00001062 0102                         add [ edx ], _TOS_                           ; db 0x01, 0x02
  2485 00001064 C3                           ret
  2486                                  %endif
  2487                                  
  2488                                  octant:
  2489                                      _DUP_
  2490 00001065 83EE04              <1>  sub esi, byte 0x04
  2491 00001068 8906                <1>  mov [ esi ], _TOS_
  2492 0000106A B843000000                  mov _TOS_, 0x43
  2493 0000106F 8B5604                      mov edx, [ esi + 0x04 ]
  2494 00001072 85D2                        test edx, edx
  2495 00001074 7907                        jns .forward
  2496 00001076 F7DA                        neg edx
  2497 00001078 895604                      mov [ esi + 0x04 ], edx
  2498 0000107B 3401                        xor al, 0x01
  2499                                  .forward:
  2500 0000107D 3B16                        cmp edx, [ esi ]
  2501 0000107F 7902                        jns .forward2
  2502 00001081 3404                        xor al, 0x04
  2503                                  .forward2:
  2504 00001083 C3                          ret
  2505                                  
  2506                                  hicon:
  2507 00001084 18191A1B1C1D1E1F            db 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F
  2508 0000108C 202105130A10040E            db 0x20, 0x21, 0x05, 0x13, 0x0A, 0x10, 0x04, 0x0E
  2509                                  
  2510                                  edig1:
  2511                                      _DUP_
  2512 00001094 83EE04              <1>  sub esi, byte 0x04
  2513 00001097 8906                <1>  mov [ esi ], _TOS_
  2514                                  digit:
  2515 00001099 51                          push ecx
  2516 0000109A 8A80[84100000]              mov al, [ _TOS_ + hicon ]
  2517 000010A0 E8CBFDFFFF                  call emit_
  2518 000010A5 59                          pop ecx
  2519 000010A6 C3                          ret
  2520                                  
  2521                                  odig:
  2522 000010A7 C1C004                      rol _TOS_, 0x04
  2523                                      _DUP_
  2524 000010AA 83EE04              <1>  sub esi, byte 0x04
  2525 000010AD 8906                <1>  mov [ esi ], _TOS_
  2526 000010AF 83E00F                      and _TOS_, byte 0x0F
  2527 000010B2 C3                          ret
  2528                                  
  2529                                  h_dot_n:
  2530 000010B3 89C2                        mov edx, _TOS_
  2531 000010B5 F7D8                        neg _TOS_
  2532 000010B7 8D0C8520000000              lea ecx, [ ( _TOS_ * 4 ) + 0x20 ]
  2533                                      _DROP_
  2534 000010BE AD                  <1>  lodsd
  2535 000010BF D3C0                        rol _TOS_, cl
  2536 000010C1 89D1                        mov ecx, edx
  2537 000010C3 EB05                        jmp short h_dot2
  2538                                  
  2539                                  dotHex8: ; ( u -- )   \ display a hexadecimal number with leading zeros, 8 .hex
  2540 000010C5 B908000000                  mov ecx, 0x08
  2541                                  h_dot2:
  2542 000010CA E8D8FFFFFF                  call odig
  2543 000010CF E8C5FFFFFF                  call digit
  2544 000010D4 E2F4                        loop h_dot2
  2545                                      _DROP_
  2546 000010D6 AD                  <1>  lodsd
  2547 000010D7 C3                          ret
  2548                                  
  2549                                  dotHex:     ; ( u -- )   \ display a hexadecimal number
  2550                                      EMIT_IMM 0x6F ; '$'
  2551                              <1> 
  2552                              <1>  _DUP_
  2553 000010D8 83EE04              <2>  sub esi, byte 0x04
  2554 000010DB 8906                <2>  mov [ esi ], _TOS_
  2555 000010DD B86F000000          <1>  mov _TOS_, %1
  2556 000010E2 E889FDFFFF          <1>  call emit_
  2557                              <1> 
  2558 000010E7 B907000000                  mov ecx, 0x07
  2559                                  .back:
  2560 000010EC E8B6FFFFFF                  call odig
  2561 000010F1 7517                        jnz .forward
  2562                                      _DROP_
  2563 000010F3 AD                  <1>  lodsd
  2564 000010F4 E2F6                        loop .back
  2565 000010F6 41                          inc ecx
  2566                                  .back2:
  2567 000010F7 E8ABFFFFFF                  call odig
  2568                                  .back3:
  2569 000010FC E898FFFFFF                  call digit
  2570 00001101 E2F4                        loop .back2
  2571 00001103 E87AFDFFFF                  call space_
  2572                                      _DROP_
  2573 00001108 AD                  <1>  lodsd
  2574 00001109 C3                          ret
  2575                                  .forward:
  2576 0000110A 41                          inc ecx
  2577 0000110B EBEF                        jmp short .back3
  2578                                  
  2579                                  qdot:   ; ( u -- )   \ display a decimal or hexadecimal number, depending on base
  2580 0000110D 833D[18390000]0A            cmp dword [ base ], byte 10
  2581 00001114 75C2                        jnz dotHex
  2582                                  dotDecimal:                         ; display a decimal number
  2583                                  ;    EMIT_IMM 0x64 ; '#'
  2584 00001116 89C2                        mov edx, _TOS_
  2585 00001118 85D2                        test edx, edx
  2586 0000111A 7911                        jns .forward
  2587 0000111C F7DA                        neg edx                         ; display a negative sign if required
  2588                                      _DUP_
  2589 0000111E 83EE04              <1>  sub esi, byte 0x04
  2590 00001121 8906                <1>  mov [ esi ], _TOS_
  2591 00001123 B823000000                  mov _TOS_, 0x23 ; '-'
  2592 00001128 E843FDFFFF                  call emit_
  2593                                  .forward:
  2594 0000112D B908000000                  mov ecx, 0x08
  2595                                  .back:
  2596 00001132 89D0                        mov _TOS_, edx
  2597 00001134 31D2                        xor edx, edx
  2598 00001136 F7348D[60380000]            div dword [ ecx * 4 + tens ]
  2599 0000113D 85C0                        test _TOS_, _TOS_
  2600 0000113F 7510                        jnz .forward2
  2601 00001141 49                          dec ecx
  2602 00001142 79EE                        jns .back
  2603 00001144 EB13                        jmp short .forward3
  2604                                  .back2:
  2605 00001146 89D0                        mov _TOS_, edx
  2606 00001148 31D2                        xor edx, edx
  2607 0000114A F7348D[60380000]            div dword [ ecx * 4 + tens ]
  2608                                  .forward2:
  2609 00001151 E83EFFFFFF                  call edig1
  2610 00001156 49                          dec ecx
  2611 00001157 79ED                        jns .back2
  2612                                  .forward3:
  2613 00001159 89D0                        mov _TOS_, edx
  2614 0000115B E834FFFFFF                  call edig1
  2615 00001160 E81DFDFFFF                  call space_
  2616                                      _DROP_
  2617 00001165 AD                  <1>  lodsd
  2618 00001166 C3                          ret
  2619                                  
  2620                                  eight:
  2621 00001167 83C70C                      add edi, byte 0x0C
  2622 0000116A E808000000                  call four
  2623 0000116F E80EFDFFFF                  call space_
  2624 00001174 83EF10                      sub edi, byte 0x10
  2625                                  four:
  2626 00001177 B904000000                  mov ecx, 0x04
  2627                                  four1:      ; set ecx to the required number of characters to display, so 'four'1 is a misnomer...
  2628 0000117C 51                          push ecx
  2629                                      _DUP_
  2630 0000117D 83EE04              <1>  sub esi, byte 0x04
  2631 00001180 8906                <1>  mov [ esi ], _TOS_
  2632 00001182 31C0                        xor _TOS_, _TOS_
  2633 00001184 8A4704                      mov al, [edi+0x04]
  2634 00001187 47                          inc edi
  2635 00001188 E8E3FCFFFF                  call emit_
  2636 0000118D 59                          pop ecx
  2637 0000118E E2EC                        loop four1
  2638 00001190 C3                          ret
  2639                                  
  2640                                  displayTheStack:  ; display the stack
  2641 00001191 BFFC750000                  mov edi, ( DATA_STACK_0 - 4 )   ; save empty stack pointer, plus one ( stack grows downwards )
  2642                                  .back:
  2643 00001196 8B15[2F040000]              mov edx, [ God ]        ; copy the current stack pointer
  2644 0000119C 393A                        cmp [edx], edi
  2645 0000119E 7311                        jnc .forward            ; test for empty stack, meaning done
  2646                                      _DUP_
  2647 000011A0 83EE04              <1>  sub esi, byte 0x04
  2648 000011A3 8906                <1>  mov [ esi ], _TOS_
  2649 000011A5 8B07                        mov _TOS_, [edi]          ; fetch the value of the current stack item
  2650 000011A7 83EF04                      sub edi, byte 0x04      ;
  2651 000011AA E85EFFFFFF                  call qdot               ; display one stack item
  2652 000011AF EBE5                        jmp short .back         ; next stack item
  2653                                  .forward:
  2654 000011B1 C3                          ret
  2655                                  
  2656                                  yShift equ 3
  2657                                  
  2658                                  displayBlockNumber:    ;  ( -- )     ; in the top right corner of the screen
  2659                                      _DUP_
  2660 000011B2 83EE04              <1>  sub esi, byte 0x04
  2661 000011B5 8906                <1>  mov [ esi ], _TOS_
  2662 000011B7 A1[C0390000]                mov _TOS_, [ v_foregroundColour ]
  2663                                      _DUP_
  2664 000011BC 83EE04              <1>  sub esi, byte 0x04
  2665 000011BF 8906                <1>  mov [ esi ], _TOS_
  2666 000011C1 A112180000                  mov _TOS_, [ vesa_XResolution ]   ; was this  : mov _TOS_, ( scrnw )
  2667 000011C6 25FFFF0000                  and _TOS_, 0xFFFF
  2668 000011CB 2B05[EC380000]              sub _TOS_, [ v_nine_iconw ]
  2669 000011D1 89C3                        mov _SCRATCH_, _TOS_                ; save for later
  2670 000011D3 A3[B0390000]                mov [ v_leftMargin ], _TOS_
  2671 000011D8 6667A3[AC39]                mov [ word v_y ], ax
  2672 000011DD 0305[EC380000]              add _TOS_, [ v_nine_iconw ]
  2673 000011E3 A3[B4390000]                mov [ v_rightMargin ], _TOS_
  2674 000011E8 89D8                        mov _TOS_, _SCRATCH_
  2675 000011EA C1E010                      shl _TOS_, 16
  2676 000011ED 0503000000                  add _TOS_, yShift
  2677 000011F2 A3[AC390000]                mov [ v_xy ], _TOS_
  2678                                      _DUP_
  2679 000011F7 83EE04              <1>  sub esi, byte 0x04
  2680 000011FA 8906                <1>  mov [ esi ], _TOS_
  2681 000011FC A1[40390000]                mov _TOS_, [ v_washColour ]  ; so we do not see the number yet, just measure its width
  2682                                  ;    mov _TOS_, colour_blockNumber
  2683                                  ;    shr _TOS_, 16                 ; select the background colour in the high 16 bits
  2684 00001201 E8FFF7FFFF                  call color
  2685                                      _DUP_
  2686 00001206 83EE04              <1>  sub esi, byte 0x04
  2687 00001209 8906                <1>  mov [ esi ], _TOS_
  2688 0000120B A1[88380000]                mov _TOS_, [ v_blk ]
  2689 00001210 E8F8FEFFFF                  call qdot
  2690 00001215 8B1D[AC390000]              mov _SCRATCH_, [ v_xy ]            ; current x,y coordinate, x in high 16 bits
  2691 0000121B C1EB10                      shr _SCRATCH_, 16
  2692 0000121E 2B1D[B0390000]              sub _SCRATCH_, [ v_leftMargin ]   ; _SCRATCH_ is now the width of number string, in pixels
  2693 00001224 2B1D[E0380000]              sub _SCRATCH_, [ v_iconw ]        ; correction...
  2694 0000122A C1E310                      shl _SCRATCH_, 16
  2695 0000122D A112180000                  mov _TOS_, [ vesa_XResolution ]   ; screen width in pixels
  2696                                      ; and _TOS_, 0xFFFF   ; not needed because of the  shl  below
  2697 00001232 C1E010                      shl _TOS_, 16
  2698 00001235 0503000000                  add _TOS_, yShift
  2699 0000123A 29D8                        sub _TOS_, _SCRATCH_
  2700 0000123C A3[AC390000]                mov [ v_xy ], _TOS_
  2701                                  
  2702                                      _DUP_
  2703 00001241 83EE04              <1>  sub esi, byte 0x04
  2704 00001244 8906                <1>  mov [ esi ], _TOS_
  2705 00001246 B800E20000                  mov _TOS_, colour_blockNumber
  2706 0000124B C1C810                      ror _TOS_, 16
  2707 0000124E E8B2F7FFFF                  call color
  2708                                      _DUP_
  2709 00001253 83EE04              <1>  sub esi, byte 0x04
  2710 00001256 8906                <1>  mov [ esi ], _TOS_
  2711 00001258 A1[E0380000]                mov _TOS_, [ v_iconw ]
  2712 0000125D 01C0                        add _TOS_, _TOS_
  2713                                      _DUP_
  2714 0000125F 83EE04              <1>  sub esi, byte 0x04
  2715 00001262 8906                <1>  mov [ esi ], _TOS_
  2716 00001264 A1[E4380000]                mov _TOS_, [ v_iconh ]
  2717 00001269 E87BFCFFFF                  call box_
  2718 0000126E A3[AC390000]                mov [ v_xy ], _TOS_
  2719                                  
  2720 00001273 B800E20000                  mov _TOS_, colour_blockNumber
  2721                                      _DUP_
  2722 00001278 83EE04              <1>  sub esi, byte 0x04
  2723 0000127B 8906                <1>  mov [ esi ], _TOS_
  2724 0000127D E883F7FFFF                  call color
  2725                                      _DUP_
  2726 00001282 83EE04              <1>  sub esi, byte 0x04
  2727 00001285 8906                <1>  mov [ esi ], _TOS_
  2728 00001287 A1[88380000]                mov _TOS_, [ v_blk ]
  2729                                  ;    mov _TOS_, [ v_numberOfMagentas ]
  2730                                  
  2731 0000128C E87CFEFFFF                  call qdot
  2732                                      _DROP_
  2733 00001291 AD                  <1>  lodsd
  2734 00001292 A3[C0390000]                mov [ v_foregroundColour ], _TOS_
  2735                                      _DROP_
  2736 00001297 AD                  <1>  lodsd
  2737 00001298 C3                      ret
  2738                                  
  2739                                  ; *****************************************************************************
  2740                                  ; keyboard displays
  2741                                  ; *****************************************************************************
  2742                                  
  2743                                  showEditBox:    ; v_at set up for start coordinate of box, width and height on stack
  2744 00001299 812D[AC390000]0400-         sub dword [ v_xy ], 0x000C0004   ; move the start position left  and up   by 0xXXXXYYYY
  2745 000012A1 0C00               
  2746 000012A3 8B1D[C0390000]              mov dword _SCRATCH_, [ v_foregroundColour ]
  2747 000012A9 C705[C0390000]00E2-         mov dword [ v_foregroundColour ], colour_orange
  2748 000012B1 0000               
  2749 000012B3 B902000000                  mov ecx, 2
  2750                                  .loop:
  2751 000012B8 51                          push ecx
  2752                                      _DUP_
  2753 000012B9 83EE04              <1>  sub esi, byte 0x04
  2754 000012BC 8906                <1>  mov [ esi ], _TOS_
  2755 000012BE B800000000                  mov _TOS_, 0            ; SOS = x start position in pixels, relative to current clip "window"
  2756                                      _DUP_
  2757 000012C3 83EE04              <1>  sub esi, byte 0x04
  2758 000012C6 8906                <1>  mov [ esi ], _TOS_
  2759 000012C8 A1[E0380000]                mov _TOS_, [ v_iconw ]
  2760 000012CD C1E003                      shl _TOS_, 3            ; multiply by 8
  2761 000012D0 0305[E0380000]              add _TOS_, [ v_iconw ]  ; multiply by 9
  2762 000012D6 0305[E0380000]              add _TOS_, [ v_iconw ]  ; multiply by 10
  2763                                      ; TOS = length of horizontal line in pixels
  2764 000012DC E8D7FBFFFF                  call line_
  2765 000012E1 8B0D[E4380000]              mov ecx, [ v_iconh ]
  2766 000012E7 C1E102                      shl ecx, 2              ; multiply by 4
  2767 000012EA 81C104000000                add ecx, 4              ; draw the lower line below the text
  2768 000012F0 010D[AC390000]              add dword [ v_xy ], ecx ; move the start position down by 4 character heights
  2769 000012F6 59                          pop ecx
  2770 000012F7 E2BF                        loop .loop
  2771                                  
  2772 000012F9 891D[C0390000]              mov dword [ v_foregroundColour ], _SCRATCH_
  2773 000012FF C3                          ret
  2774                                  
  2775                                  displayTheKeyboard:   ; the keyboard is the mnemonic at the bottom right of the display, showing the actions of each of the 27 keys used
  2776 00001300 E8A1FBFFFF                  call setupText_
  2777 00001305 8B3D[10390000]              mov edi, [ dword currentKeyboardIcons ]
  2778                                      _DUP_
  2779 0000130B 83EE04              <1>  sub esi, byte 0x04
  2780 0000130E 8906                <1>  mov [ esi ], _TOS_
  2781 00001310 A1[20390000]                mov _TOS_, [ keyboard_colour ]
  2782 00001315 E8EBF6FFFF                  call color
  2783 0000131A A112180000                  mov _TOS_, [ vesa_XResolution ] ; was this  : mov _TOS_, ( scrnw )
  2784 0000131F 25FFFF0000                  and _TOS_, 0xFFFF
  2785 00001324 2B05[EC380000]              sub _TOS_, [ v_nine_iconw ]
  2786 0000132A 2D10000000                  sub _TOS_, 16
  2787 0000132F A3[B0390000]                mov [ v_leftMargin ], _TOS_     ; x coordinate of left margin of keyboard display
  2788 00001334 89C2                        mov edx, _TOS_                  ;
  2789 00001336 0315[EC380000]              add edx, [ v_nine_iconw ]       ; x coordinate of right margin of keyboard display
  2790 0000133C 8915[B4390000]              mov [ v_rightMargin ], edx
  2791 00001342 C1E010                      shl _TOS_, 0x10
  2792 00001345 8B1514180000                mov edx, [ vesa_YResolution ]   ; was this  : mov _TOS_, ( scrnw )
  2793 0000134B 81E2FFFF0000                and edx, 0x0000FFFF
  2794 00001351 53                          push _SCRATCH_
  2795 00001352 8B1D[E8380000]              mov _SCRATCH_, [ v_keypadY_iconh ]
  2796 00001358 81C30A000000                add _SCRATCH_, 10
  2797 0000135E 29DA                        sub edx, _SCRATCH_              ; ( ( keypadY * iconh ) + 10 )
  2798 00001360 01D0                        add _TOS_, edx
  2799                                  
  2800 00001362 A3[AC390000]                mov [ v_xy ], _TOS_
  2801                                  
  2802 00001367 F605[07390000]FF            test byte [ v_acceptMode ], 0xFF
  2803 0000136E 740C                        jz .forward
  2804 00001370 60                          pusha
  2805 00001371 E823FFFFFF                  call showEditBox
  2806 00001376 61                          popa
  2807 00001377 A3[AC390000]                mov [ v_xy ], _TOS_
  2808                                  .forward:
  2809                                  
  2810 0000137C 5B                          pop _SCRATCH_
  2811 0000137D E8E5FDFFFF                  call eight
  2812 00001382 E8E0FDFFFF                  call eight
  2813 00001387 E8DBFDFFFF                  call eight
  2814 0000138C E82EF6FFFF                  call cr_
  2815                                  ;    add dword [ v_xy ],  ( 4 * iconw * 0x10000 )        ; shift horizontal pixels to the right
  2816 00001391 8B1D[E0380000]              mov _SCRATCH_, [ v_iconw ]
  2817 00001397 C1E312                      shl _SCRATCH_, ( 2 + 16 ) ; ( 4 * iconw * 0x10000 )  ; shift horizontal pixels to the right
  2818 0000139A 011D[AC390000]              add dword [ v_xy ], _SCRATCH_
  2819 000013A0 8B3D[14390000]              mov edi, [ shiftAction ]
  2820 000013A6 83C70C                      add edi, byte 0x0C
  2821 000013A9 B903000000                  mov ecx, 0x03
  2822 000013AE E8C9FDFFFF                  call four1
  2823                                  
  2824 000013B3 E8CAFAFFFF                  call space_
  2825                                      _DUP_
  2826 000013B8 83EE04              <1>  sub esi, byte 0x04
  2827 000013BB 8906                <1>  mov [ esi ], _TOS_
  2828 000013BD A1[08390000]                mov _TOS_, [ v_hintChar ]
  2829 000013C2 E8A9FAFFFF                  call emit_
  2830                                  
  2831 000013C7 C705[B0390000]0300-         mov dword [ v_leftMargin ], 0x03
  2832 000013CF 0000               
  2833 000013D1 66C705[AE390000]03-         mov word [ v_x ], 0x03
  2834 000013D9 00                 
  2835 000013DA E8B2FDFFFF                  call displayTheStack
  2836 000013DF A112180000                  mov _TOS_, [ vesa_XResolution ]   ; was this  : mov _TOS_, ( scrnw )
  2837 000013E4 25FFFF0000                  and _TOS_, 0xFFFF
  2838 000013E9 2B05[F0380000]              sub _TOS_, [ v_twentytwo_iconw ]
  2839 000013EF 0503000000                  add _TOS_, 3
  2840 000013F4 66A3[AE390000]              mov word [ v_x ], ax
  2841 000013FA 8D3D[9F0F0000]              lea edi, [ ( history - 4 )]     ; the text entered so far
  2842 00001400 B90B000000                  mov ecx, 0x0B
  2843 00001405 E972FDFFFF                  jmp dword four1
  2844                                  
  2845                                  ; *****************************************************************************
  2846                                  
  2847                                  alphaKeyboard:          ; the 'alpha' character keyboard icons, the start screen for key entry
  2848 0000140A 0D0A010C                    db 0x0D, 0x0A, 0x01, 0x0C  ; g c r l
  2849 0000140E 14020608                    db 0x14, 0x02, 0x06, 0x08  ; h t n s
  2850 00001412 13090F11                    db 0x13, 0x09, 0x0F, 0x11  ; b m w v
  2851 00001416 120B0E07                    db 0x12, 0x0B, 0x0E, 0x07  ; p y f i
  2852 0000141A 05030416                    db 0x05, 0x03, 0x04, 0x16  ; a o e u
  2853 0000141E 17241510                    db 0x17, 0x24, 0x15, 0x10  ; q k x d
  2854                                  
  2855                                  graphicsKeyboard:       ; the 'graphics' character keyboard icons (Note: not numbers, just characters)
  2856 00001422 191A1B00                    db 0x19, 0x1A, 0x1B,    0  ; 1 2 3 _
  2857 00001426 1C1D1E18                    db 0x1C, 0x1D, 0x1E, 0x18  ; 4 5 6 0
  2858 0000142A 1F20212F                    db 0x1F, 0x20, 0x21, 0x2F  ; 7 8 9 ?
  2859 0000142E 29282A2C                    db 0x29, 0x28, 0x2A, 0x2C  ; : ; ! @
  2860 00001432 2622252E                    db 0x26, 0x22, 0x25, 0x2E  ; z j . ,W
  2861 00001436 2D272B23                    db 0x2D, 0x27, 0x2B, 0x23  ; * / + -
  2862                                  
  2863                                  decimalKeyboard:        ; the decimal number entry keyboard icons
  2864 0000143A 191A1B00                    db 0x19, 0x1A, 0x1B,    0  ; 1 2 3 _
  2865 0000143E 1C1D1E18                    db 0x1C, 0x1D, 0x1E, 0x18  ; 4 5 6 0
  2866 00001442 1F202100                    db 0x1F, 0x20, 0x21,    0  ; 7 8 9 _
  2867 00001446 00000000                    db    0,    0,    0,    0  ; _ _ _ _
  2868 0000144A 00000000                    db    0,    0,    0,    0  ; _ _ _ _
  2869 0000144E 00000000                    db    0,    0,    0,    0  ; _ _ _ _
  2870                                  
  2871                                  hexadecimalKeyboard:    ; the hexadecimal number entry keyboard icons
  2872 00001452 191A1B00                    db 0x19, 0x1A, 0x1B,    0  ; 1 2 3 _
  2873 00001456 1C1D1E18                    db 0x1C, 0x1D, 0x1E, 0x18  ; 4 5 6 0
  2874 0000145A 1F202100                    db 0x1F, 0x20, 0x21,    0  ; 7 8 9 _
  2875 0000145E 0005130A                    db    0, 0x05, 0x13, 0x0A  ; _ a b c
  2876 00001462 0010040E                    db    0, 0x10, 0x04, 0x0E  ; _ d e f
  2877 00001466 00000000                    db    0,    0,    0,    0  ; _ _ _ _
  2878                                  
  2879                                  ; *****************************************************************************
  2880                                  ; get keyboard keys
  2881                                  ; *****************************************************************************
  2882                                  
  2883                                  letter:
  2884 0000146A 3C04                        cmp al, 0x04
  2885 0000146C 7809                        js .forward
  2886 0000146E 8B15[10390000]              mov edx, [ currentKeyboardIcons ]
  2887 00001474 8A0410                      mov al, [ _TOS_ + edx ]
  2888                                  .forward:
  2889 00001477 C3                          ret
  2890                                  
  2891                                  key_map_table:   ; map 8042 scan type 1 keycode to colorForth character values
  2892 00001478 1011121300000405            db 16, 17, 18, 19,  0,  0,  4,  5 ; 0x10 - 0x17
  2893 00001480 0607000000001415            db  6,  7,  0,  0,  0,  0, 20, 21 ; 0x18 - 0x1F
  2894 00001488 1617000008090A0B            db 22, 23,  0,  0,  8,  9, 10, 11 ; 0x20 - 0x27
  2895 00001490 0000000018191A1B            db  0,  0,  0,  0, 24, 25, 26, 27 ; 0x28 - 0x2F
  2896 00001498 00010C0D0E0F0000            db  0,  1, 12, 13, 14, 15,  0,  0 ; 0x30 - 0x37 N
  2897 000014A0 0302                        db  3,  2                         ; 0x38 - 0x39 alt space
  2898                                  
  2899                                  ; ToDo: add a timeout to the loop
  2900                                  WaitToReceiveKey:      ; Wait until there is byte to receive from the keyboard controller
  2901                                  .back:
  2902 000014A2 E464                        in al, 0x64     ; On-board controller status read
  2903 000014A4 A801                        test al, 1      ; OBF (Output Buffer Full)
  2904 000014A6 750C                        jnz .forward    ; exit when bit 0 = 1 the On-board controller has a new character for us
  2905 000014A8 31C0                        xor _TOS_, _TOS_
  2906 000014AA E85EEFFFFF                  call pause_    ; not ready yet, so let the other task(s) have a turn
  2907 000014AF E9EEFFFFFF                  jmp  .back      ; jump back and try again
  2908                                  .forward:
  2909                                  ;    call pause_    ; not ready yet, so let the other task(s) have a turn
  2910 000014B4 C3                          ret
  2911                                  
  2912                                  v_lineOffsetTablePtr:
  2913 000014B5 00000000                    dd 0 ; times 16 dd 0
  2914                                  
  2915                                  lineOffsetZero:
  2916 000014B9 C705[5F210000]0000-         mov dword [ v_lineOffset ], 0x00
  2917 000014C1 0000               
  2918 000014C3 C3                          ret
  2919                                  
  2920                                  lineOffsetPlus:
  2921 000014C4 8105[5F210000]0C00-         add dword [ v_lineOffset ], 0x0C
  2922 000014CC 0000               
  2923 000014CE C3                          ret
  2924                                  
  2925                                  lineOffsetMinus:
  2926 000014CF 812D[5F210000]0C00-         sub dword [ v_lineOffset ], 0x0C
  2927 000014D7 0000               
  2928 000014D9 7905                        jns .forward
  2929 000014DB E8D9FFFFFF                  call lineOffsetZero
  2930                                  .forward:
  2931 000014E0 C3                          ret
  2932                                  
  2933                                  ; *****************************************************************************
  2934                                  ; F1 Help screens
  2935                                  ; *****************************************************************************
  2936                                  
  2937                                  help0:  ; save  v_blk , display the first help screen
  2938                                      _DUP_
  2939 000014E1 83EE04              <1>  sub esi, byte 0x04
  2940 000014E4 8906                <1>  mov [ esi ], _TOS_
  2941 000014E6 813D[88380000]FF01-         cmp dword [ v_blk ], LAST_BLOCK_NUMBER     ; we are displaying the first Help screen
  2942 000014EE 0000               
  2943 000014F0 740A                        je .forward
  2944 000014F2 A1[88380000]                mov _TOS_, [ v_blk ]
  2945 000014F7 A3[A4380000]                mov [ v_saved_v_blk ], _TOS_
  2946                                  .forward:
  2947 000014FC C705[88380000]FF01-         mov dword [ v_blk ], LAST_BLOCK_NUMBER
  2948 00001504 0000               
  2949                                      _DROP_
  2950 00001506 AD                  <1>  lodsd
  2951 00001507 C3                          ret
  2952                                  
  2953                                  help1:  ; display the second help screen
  2954 00001508 C705[88380000]2100-         mov dword [ v_blk ], ( START_BLOCK_NUMBER + 1 )
  2955 00001510 0000               
  2956 00001512 C3                          ret
  2957                                  
  2958                                  help2:  ; display the second third screen
  2959 00001513 C705[88380000]2000-         mov dword [ v_blk ], ( START_BLOCK_NUMBER )
  2960 0000151B 0000               
  2961 0000151D C3                          ret
  2962                                  
  2963                                  help3:  ; restore the original screen being edited
  2964                                      _DUP_
  2965 0000151E 83EE04              <1>  sub esi, byte 0x04
  2966 00001521 8906                <1>  mov [ esi ], _TOS_
  2967 00001523 A1[A4380000]                mov _TOS_, [ v_saved_v_blk ]
  2968 00001528 A3[88380000]                mov [ v_blk ], _TOS_
  2969                                      _DROP_
  2970 0000152D AD                  <1>  lodsd
  2971 0000152E C3                          ret
  2972                                  
  2973                                  HelpTable:
  2974 0000152F [E1140000]                  dd help0
  2975 00001533 [08150000]                  dd help1
  2976 00001537 [13150000]                  dd help2
  2977 0000153B [1E150000]                  dd help3
  2978                                  
  2979                                  help:
  2980                                      _DUP_
  2981 0000153F 83EE04              <1>  sub esi, byte 0x04
  2982 00001542 8906                <1>  mov [ esi ], _TOS_
  2983 00001544 A1[A0380000]                mov _TOS_, [ v_help_counter ]
  2984 00001549 2503000000                  and _TOS_, 0x03
  2985 0000154E FF1485[2F150000]            call dword [ ( _TOS_ * 4 ) + HelpTable ]
  2986                                      _DROP_
  2987 00001555 AD                  <1>  lodsd
  2988 00001556 FE05[A0380000]              inc byte [ v_help_counter ]
  2989 0000155C C3                          ret
  2990                                  
  2991                                  ; *****************************************************************************
  2992                                  ; Editor
  2993                                  ; *****************************************************************************
  2994                                  
  2995                                  e_plus:
  2996 0000155D E80E1B0000                  call colourBlindModeToggle
  2997 00001562 E900000000                  jmp abort_e
  2998                                  
  2999                                  abort_e:
  3000                                      ; call abort
  3001 00001567 E86DEFFFFF                  call c_
  3002                                  abort_e2:
  3003 0000156C BC00780000                  mov esp, RETURN_STACK_0
  3004 00001571 E8C5120000                  call e_
  3005 00001576 C3                          ret
  3006                                  
  3007                                  executeToken:   ; ( -- )    \ action when the QWERT enter key is pressed
  3008 00001577 C605[07390000]00            mov byte [ v_acceptMode ], 0x00     ; turn off the edit mode orange lines around the keyboard
  3009 0000157E A1[C8380000]                mov _TOS_, [ v_cad ]
  3010 00001583 2D01000000                  sub _TOS_, 1                ; step to before the token before the cursor
  3011 00001588 C1E002                      shl _TOS_, 2                ; convert cell address to byte address
  3012 0000158B 8B00                        mov _TOS_, [ _TOS_ ]
  3013 0000158D 89C3                        mov _SCRATCH_, _TOS_
  3014 0000158F 81E30F000000                and _SCRATCH_, 0x0F         ; check the token type = 3 == red
  3015 00001595 81FB03000000                cmp _SCRATCH_, 0x03
  3016 0000159B 740D                        je  .forward
  3017 0000159D 81FB0C000000                cmp _SCRATCH_, 0x0C         ; check the token type = 12 == magenta.  NOT WORKING YET ToDo: fix this
  3018 000015A3 7405                        je  .forward
  3019 000015A5 E905000000                  jmp .forward2
  3020                                  .forward:
  3021 000015AA E85BF1FFFF                  call execute
  3022                                  .forward2:
  3023                                      _DROP_
  3024 000015AF AD                  <1>  lodsd
  3025 000015B0 C3                          ret
  3026                                  
  3027                                  %define FirstFkey  (59)     ; F1 = 59
  3028                                  
  3029                                  FkeyTable:  ; ( c -- a )   \ function key action table
  3030                                  ;    dd nul              ; 57
  3031                                  ;    dd nul              ; 58
  3032 000015B1 [3F150000]                  dd help             ; 59 F1
  3033 000015B5 [6E190000]                  dd toggleBase0      ; 60 F2 decimal/hex number display
  3034 000015B9 [69300000]                  dd seeb             ; 61 F3 show/hide blue words
  3035 000015BD [5D150000]                  dd e_plus           ; 62 F4 editor
  3036 000015C1 [A5240000]                  dd otherBlock       ; 63 F5 display the previously edited block
  3037 000015C5 [00040000]                  dd nul              ; 64 F6
  3038 000015C9 [00040000]                  dd nul              ; 65 F7
  3039 000015CD [00040000]                  dd nul              ; 66 F8
  3040 000015D1 [86190000]                  dd toggleBase       ; 67 F9
  3041 000015D5 [D9040000]                  dd c_               ; 68 F10
  3042 000015D9 [00040000]                  dd nul              ; 69 Num Lock
  3043 000015DD [00040000]                  dd nul              ; 70
  3044 000015E1 [5B240000]                  dd cursorHome       ; 71 Home
  3045 000015E5 [0C240000]                  dd cursorUp         ; 72 Up arrow
  3046 000015E9 [82240000]                  dd nextBlock        ; 73 PgUp
  3047 000015ED [00040000]                  dd nul              ; 74 -
  3048 000015F1 [6C220000]                  dd cursorLeft       ; 75 Left arrow
  3049 000015F5 [A5240000]                  dd otherBlock       ; 76    display the previously edited block
  3050 000015F9 [8F220000]                  dd cursorRight      ; 77 Right arrow
  3051 000015FD [00040000]                  dd nul              ; 78 +
  3052 00001601 [44240000]                  dd cursorEnd        ; 79 End
  3053 00001605 [24240000]                  dd cursorDown       ; 80 Down arrow
  3054 00001609 [8F240000]                  dd previousBlock    ; 81 PgDn
  3055 0000160D [2A270000]                  dd destack          ; 82 Insert
  3056 00001611 [42260000]                  dd deleteAction     ; 83 Delete
  3057 00001615 [00040000]                  dd nul              ; 84
  3058 00001619 [00040000]                  dd nul              ; 85
  3059 0000161D [00040000]                  dd nul              ; 86
  3060 00001621 [6E190000]                  dd toggleBase0      ; 87 F11
  3061 00001625 [00040000]                  dd nul              ; 88 F12
  3062 00001629 [77150000]                  dd executeToken     ; 89 really 121 Enter
  3063 0000162D [67150000]                  dd abort_e          ; 90 really 123 Escape
  3064                                  
  3065                                  processFkey:    ; ( n -- )   \ process the given function key code
  3066                                  ;    cmp _TOS_, 121
  3067                                  ;    jne .forward1
  3068                                  ;    sub _TOS_, ( 121 - 89 )
  3069                                  ;.forward1:
  3070 00001631 2D3B000000                  sub _TOS_, FirstFkey   ; convert Fn key value to index from 0
  3071 00001636 251F000000                  and _TOS_, 0x1F
  3072 0000163B FF1485[B1150000]            call dword [ ( _TOS_ * 4 ) + FkeyTable ]
  3073                                  ;    _DROP_
  3074                                      ; call e_
  3075 00001642 C3                          ret
  3076                                  
  3077                                  get_key_:    ; ( -- c )   \ waits for and returns a character from the keyboard, assumes Scan Code Set 1, set up by the BIOS
  3078                                      _DUP_
  3079 00001643 83EE04              <1>  sub esi, byte 0x04
  3080 00001646 8906                <1>  mov [ esi ], _TOS_
  3081 00001648 31C0                        xor _TOS_, _TOS_
  3082                                  .back:
  3083                                      ; check if the key is a function key
  3084 0000164A 3D3B000000                  cmp _TOS_, FirstFkey  ; F1 key
  3085 0000164F 780C                        js .forward4
  3086 00001651 3D5B000000                  cmp _TOS_, FirstFkey + 32  ; Fxx key + 1
  3087 00001656 7905                        jns .forward4
  3088                                   ;    ; jmp dword [ _TOS_ * 4 + qwertyActionTable - 0x200 ]
  3089                                   ;   xor dword [ current], ((setDecimalMode - $$) ^ (setHexMode - $$))
  3090                                   ;   xor byte [ numb0 + 18 ], ( 0x21 ^ 0x0E ) ;  0x21 = '9' , 0x0E = 'f' toggle '9' and 'f' on keypad display line
  3091                                   ;   call [ current ]
  3092                                   ;  call toggleBase
  3093 00001658 E8D4FFFFFF                  call processFkey
  3094                                  .forward4:
  3095                                      _DROP_
  3096 0000165D AD                  <1>  lodsd
  3097 0000165E E87B000000                  call get_qwerty_key_
  3098                                  ;    call WaitToReceiveKey  ; Wait until there is a byte to receive from the keyboard controller
  3099                                  ;    in   al, 0x60       ; read the key value from the Keyboard data port
  3100 00001663 A0[80000000]                mov al, [ v_scanCode ]
  3101                                  ;    test al, 0xF0       ; we are only interested in certain key codes (?)
  3102                                  ;    jz   .back
  3103 00001668 3C3A                        cmp  al, 0x3A       ; exclude keycodes greater than 0x39,  cmp  is like  sub  but only affects the flags
  3104 0000166A 73DE                        jnc  .back
  3105 0000166C 8A80[68140000]              mov  al, [ key_map_table - 0x10 + EAX ] ; convert to the colorForth value using the 'key_map_table' table
  3106 00001672 C3                          ret
  3107                                  
  3108                                  ; *****************************************************************************
  3109                                  ; get qwerty keys
  3110                                  ; *****************************************************************************
  3111                                  
  3112 00001673 00                      align 4, db 0   ; fill the gap with 0's
  3113                                  
  3114                                  ; times 0x40 db 0x00,
  3115                                  
  3116                                  qwerty_key_map_table:
  3117                                  ;         0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F
  3118 00001674 0B180219031A041B05-         db 0x0B, 0x18, 0x02, 0x19, 0x03, 0x1A, 0x04, 0x1B, 0x05, 0x1C, 0x06, 0x1D, 0x07, 0x1E, 0x08, 0x1F ; 0x00
  3119 0000167D 1C061D071E081F     
  3120 00001684 09200A211E0530132E-         db 0x09, 0x20, 0x0A, 0x21, 0x1e, 0x05, 0x30, 0x13, 0x2E, 0x0A, 0x20, 0x10, 0x12, 0x04, 0x21, 0x0E ; 0x10
  3121 0000168D 0A20101204210E     
  3122 00001694 220D23141707242225-         db 0x22, 0x0D, 0x23, 0x14, 0x17, 0x07, 0x24, 0x22, 0x25, 0x24, 0x26, 0x0C, 0x32, 0x09, 0x31, 0x06 ; 0x20
  3123 0000169D 24260C32093106     
  3124 000016A4 18031912101713011F-         db 0x18, 0x03, 0x19, 0x12, 0x10, 0x17, 0x13, 0x01, 0x1F, 0x08, 0x14, 0x02, 0x16, 0x16, 0x2F, 0x11 ; 0x30
  3125 000016AD 08140216162F11     
  3126 000016B4 110F2D15150B2C260C-         db 0x11, 0x0F, 0x2D, 0x15, 0x15, 0x0B, 0x2C, 0x26, 0x0C, 0x23, 0x34, 0x25, 0x35, 0x27, 0x27, 0x28 ; 0x40
  3127 000016BD 23342535272728     
  3128 000016C4 2829822A8D2B832C89-         db 0x28, 0x29, 0x82, 0x2A, 0x8D, 0x2B, 0x83, 0x2C, 0x89, 0x2D, 0x33, 0x2E, 0xB5, 0x2F, 0x39, 0x80 ; 0x50
  3129 000016CD 2D332EB52F3980     
  3130 000016D4 1C810E8201833B8429-         db 0x1C, 0x81, 0x0E, 0x82, 0x01, 0x83, 0x3B, 0x84, 0x29, 0x30
  3131 000016DD 30                 
  3132                                      ; test only
  3133                                  ; times 0x40 db 0x00,
  3134                                      
  3135                                  get_qwerty_key_:           ; get a qwerty key character
  3136                                      _DUP_
  3137 000016DE 83EE04              <1>  sub esi, byte 0x04
  3138 000016E1 8906                <1>  mov [ esi ], _TOS_
  3139                                  .back:
  3140 000016E3 E8BAFDFFFF                  call WaitToReceiveKey
  3141 000016E8 E460                        in al, 0x60
  3142                                  
  3143 000016EA 3D1C000000                  cmp _TOS_, 0x1C     ; the Enter key scan code
  3144 000016EF 7505                        jne .forward1
  3145                                      ; add _TOS_, ( 89 - 0x1C ) ; convert the code for the Enter key to 89
  3146 000016F1 B859000000                  mov _TOS_, 89
  3147                                  .forward1:
  3148                                  
  3149 000016F6 3D81000000                  cmp _TOS_, 0x81     ; the Escape key scan code
  3150 000016FB 7505                        jne .forward2
  3151 000016FD 05D9FFFFFF                  add _TOS_, ( 90 - 0x81 ) ; convert the code for the Escape key to 90
  3152                                  .forward2:
  3153                                  
  3154                                  ;    cmp _TOS_, 0x03     ; the Left Alt key scan code
  3155                                  ;    jne .forward3
  3156                                  ;    add _TOS_, 0x02 ; convert the code for the Left Alt key to a space key
  3157                                  ; .forward3:
  3158                                  
  3159 00001702 A2[80000000]                mov [ v_scanCode ], al
  3160 00001707 89C1                        mov ecx, _TOS_              ; copy keycode into cl
  3161 00001709 80E17F                      and cl, 0x7F                ; filter out key-up bit 7
  3162 0000170C 80F92A                      cmp cl, 0x2A                ; g?
  3163 0000170F 7405                        jz .got_c_or_g
  3164 00001711 80F936                      cmp cl, 0x36                ; c?
  3165 00001714 750B                        jnz .not_c_or_g
  3166                                  .got_c_or_g:
  3167 00001716 2480                        and al, 0x80                ; extract key-up bit
  3168 00001718 3480                        xor al, 0x80                ; complement it
  3169 0000171A A3[34390000]                mov [ v_qwerty_key ], _TOS_
  3170 0000171F EBC2                        jmp short .back
  3171                                  .not_c_or_g:
  3172 00001721 08C0                        or al, al                   ; check if key-up
  3173 00001723 78BE                        js .back                    ; if so, try again to get keydown event
  3174 00001725 247F                        and al, 0x7F                ; filter out key-up bit
  3175 00001727 0B05[34390000]              or _TOS_, [ v_qwerty_key ]
  3176 0000172D BA[74160000]                mov edx, qwerty_key_map_table
  3177 00001732 B935000000                  mov ecx, 0x35
  3178                                  .back2:
  3179 00001737 3802                        cmp [edx], al
  3180 00001739 7408                        jz .forward
  3181 0000173B 83C202                      add edx, byte 0x02
  3182 0000173E E2F7                        loop .back2
  3183 00001740 31C0                        xor _TOS_, _TOS_
  3184 00001742 C3                          ret
  3185                                  .forward:
  3186 00001743 8A4201                      mov al, [edx+0x01]
  3187 00001746 81EA[74160000]              sub edx, qwerty_key_map_table
  3188 0000174C D1EA                        shr edx, 1
  3189 0000174E 8915[38390000]              mov [ v_digin ], edx
  3190 00001754 3D3B000000                  cmp _TOS_, 59  ; F1 key
  3191                                  ;    jnz .forward4
  3192                                  ;    ; jmp dword [ _TOS_ * 4 + qwertyActionTable - 0x200 ]
  3193                                  ;    xor dword [ current], ((setDecimalMode - $$) ^ (setHexMode - $$))
  3194                                  ;    call toggleBase
  3195                                  ;.forward4:
  3196 00001759 C3                          ret
  3197                                  
  3198                                  ; *****************************************************************************
  3199                                  ; keyboard jump tables
  3200                                  ; *****************************************************************************
  3201                                  
  3202                                  graph0:
  3203 0000175A [97190000]-                 dd nul0, nul0, nul0, alph0
  3204 0000175E [97190000]-        
  3205 00001762 [97190000]-        
  3206 00001766 [F5190000]         
  3207 0000176A 00000500                    db 0x00, 0x00, 0x05, 0x00       ; _ _ a _
  3208                                  
  3209                                  graph1:
  3210 0000176E [A0180000]-                 dd word0, x, lj, alph
  3211 00001772 [39180000]-        
  3212 00001776 [DF170000]-        
  3213 0000177A [1A1A0000]         
  3214 0000177E 15250500                    db 0x15, 0x25, 0x05, 0x00       ; x . a _
  3215                                  
  3216                                  alpha0:
  3217 00001782 [97190000]-                 dd nul0, nul0, number, star0
  3218 00001786 [97190000]-        
  3219 0000178A [D1180000]-        
  3220 0000178E [071A0000]         
  3221 00001792 00212D00                    db 0x00, 0x21, 0x2D, 0x00       ; _ 9 * _
  3222                                  
  3223                                  alpha1:
  3224 00001796 [A0180000]-                 dd word0, x, lj, graph
  3225 0000179A [39180000]-        
  3226 0000179E [DF170000]-        
  3227 000017A2 [2C1A0000]         
  3228 000017A6 15252D00                    db 0x15, 0x25, 0x2D, 0x00       ; x . * _
  3229                                  
  3230                                  numb0:
  3231 000017AA [97190000]-                 dd nul0, minus, alphn, toggleBase
  3232 000017AE [C7180000]-        
  3233 000017B2 [F4190000]-        
  3234 000017B6 [86190000]         
  3235 000017BA 23050E00                    db 0x23, 0x05, 0x0E, 0x00       ; - a f _
  3236                                  
  3237                                  numb1:
  3238 000017BE [CE180000]-                 dd number0, xn, endn, number0
  3239 000017C2 [90190000]-        
  3240 000017C6 [24190000]-        
  3241 000017CA [CE180000]         
  3242 000017CE 15250000                    db 0x15, 0x25, 0x00, 0x00       ; x . _ _
  3243                                  
  3244                                  ; *****************************************************************************
  3245                                  ; Shannon-Fano compression
  3246                                  ; *****************************************************************************
  3247                                  
  3248                                  bits_:
  3249 000017D2 1C                          db 0x1C
  3250                                  
  3251                                  lj0:
  3252 000017D3 8A0D[D2170000]              mov cl, [ bits_ ]
  3253 000017D9 80C104                      add cl, 0x04
  3254 000017DC D326                        shl dword [ esi ],cl
  3255 000017DE C3                          ret
  3256                                  
  3257                                  lj:
  3258 000017DF E8EFFFFFFF                  call lj0
  3259                                      _DROP_
  3260 000017E4 AD                  <1>  lodsd
  3261 000017E5 C3                          ret
  3262                                  
  3263                                  full:
  3264 000017E6 E8E8FFFFFF                  call lj0
  3265 000017EB FF05[30390000]              inc dword [ v_words ]
  3266 000017F1 C605[D2170000]1C            mov byte [ bits_ ], 0x1C
  3267 000017F8 282D[D2170000]              sub [ bits_ ], ch
  3268 000017FE 89D0                        mov _TOS_, edx
  3269                                      _DUP_
  3270 00001800 83EE04              <1>  sub esi, byte 0x04
  3271 00001803 8906                <1>  mov [ esi ], _TOS_
  3272 00001805 C3                          ret
  3273                                  
  3274                                  pack0:
  3275 00001806 83C050                      add _TOS_, byte  0x50
  3276 00001809 B107                        mov cl, 0x07
  3277 0000180B EB0D                        jmp short pack1
  3278                                  
  3279                                  pack_:
  3280 0000180D 3C10                        cmp al, 0x10
  3281 0000180F 73F5                        jnc pack0
  3282 00001811 B104                        mov cl, 0x04
  3283 00001813 A808                        test al, 0x08
  3284 00001815 7403                        jz pack1
  3285 00001817 41                          inc ecx
  3286 00001818 3418                        xor al, 0x18
  3287                                  pack1:
  3288 0000181A 89C2                        mov edx, _TOS_
  3289 0000181C 88CD                        mov ch,cl
  3290                                  .back:
  3291 0000181E 380D[D2170000]              cmp [ bits_ ], cl
  3292 00001824 7308                        jnc .forward
  3293 00001826 D0E8                        shr al,1
  3294 00001828 72BC                        jc full
  3295 0000182A FEC9                        dec cl
  3296 0000182C EBF0                        jmp short .back
  3297                                  .forward:
  3298 0000182E D326                        shl dword [ esi ],cl
  3299 00001830 3106                        xor [ esi ], _TOS_
  3300 00001832 280D[D2170000]              sub [ bits_ ], cl
  3301 00001838 C3                          ret
  3302                                  
  3303                                  x:      ; eXit
  3304 00001839 E889F7FFFF                  call right
  3305 0000183E A1[30390000]                mov _TOS_, [ v_words ]
  3306 00001843 8D3486                      lea esi, [esi+_TOS_*4]
  3307                                      _DROP_
  3308 00001846 AD                  <1>  lodsd
  3309 00001847 E95A010000                  jmp accept
  3310                                  
  3311                                  word_:
  3312 0000184C E876F7FFFF                  call right
  3313 00001851 C705[30390000]0100-         mov dword [ v_words ], 0x01
  3314 00001859 0000               
  3315 0000185B C705[24390000]0100-         mov dword [ chars ], 0x01
  3316 00001863 0000               
  3317                                      _DUP_
  3318 00001865 83EE04              <1>  sub esi, byte 0x04
  3319 00001868 8906                <1>  mov [ esi ], _TOS_
  3320 0000186A C70600000000                mov dword [ esi ], 0x00
  3321 00001870 C605[D2170000]1C            mov byte [ bits_ ], 0x1C
  3322                                  word1:
  3323 00001877 E8EEFBFFFF                  call letter
  3324 0000187C 7909                        jns .forward
  3325 0000187E 8B15[14390000]              mov edx, [ shiftAction ]
  3326 00001884 FF2482                      jmp dword [edx+_TOS_*4]
  3327                                  .forward:
  3328 00001887 84C0                        test al,al
  3329 00001889 7415                        jz word0
  3330                                      _DUP_
  3331 0000188B 83EE04              <1>  sub esi, byte 0x04
  3332 0000188E 8906                <1>  mov [ esi ], _TOS_
  3333 00001890 E819F7FFFF                  call echo_
  3334 00001895 E873FFFFFF                  call pack_
  3335 0000189A FF05[24390000]              inc dword [ chars ]
  3336                                  word0:
  3337                                      _DROP_
  3338 000018A0 AD                  <1>  lodsd
  3339 000018A1 E89DFDFFFF                  call get_key_
  3340 000018A6 EBCF                        jmp short word1
  3341                                  
  3342                                  ; *****************************************************************************
  3343                                  ; number display
  3344                                  ; *****************************************************************************
  3345                                  
  3346                                  digitTable:
  3347 000018A8 0E0A0000                    db 14, 10,  0,  0
  3348 000018AC 00000C0000000F00            db  0,  0, 12,  0,  0,  0, 15,  0
  3349 000018B4 0D00000B00000000            db 13,  0,  0, 11,  0,  0,  0,  0
  3350 000018BC 0001020304050607            db  0,  1,  2,  3,  4,  5,  6,  7
  3351 000018C4 0809                        db  8,  9
  3352                                  
  3353                                  v_sign:
  3354 000018C6 00                          db 0x00
  3355                                  
  3356                                  minus:
  3357 000018C7 A2[C6180000]                mov [v_sign ], al
  3358 000018CC EB49                        jmp short number2
  3359                                  
  3360                                  number0:
  3361                                      _DROP_
  3362 000018CE AD                  <1>  lodsd
  3363 000018CF EB0F                        jmp short number3
  3364                                  
  3365                                  number:
  3366 000018D1 FF15[1C390000]              call [ current ]
  3367 000018D7 C605[C6180000]00            mov byte [ v_sign ] , 0x00
  3368 000018DE 31C0                        xor _TOS_, _TOS_
  3369                                  number3:
  3370 000018E0 E85EFDFFFF                  call get_key_
  3371 000018E5 E880FBFFFF                  call letter
  3372 000018EA 7909                        jns .forward
  3373 000018EC 8B15[14390000]              mov edx, [ shiftAction ]
  3374 000018F2 FF2482                      jmp dword [edx+_TOS_*4]
  3375                                  
  3376                                  .forward:
  3377 000018F5 84C0                        test al,al
  3378 000018F7 74D5                        jz number0
  3379 000018F9 8A80[A4180000]              mov al, [ _TOS_ + digitTable - 4 ]
  3380 000018FF F605[C6180000]1F            test byte [ v_sign ], 0x1F
  3381 00001906 7402                        jz .forward2
  3382 00001908 F7D8                        neg _TOS_
  3383                                  .forward2:
  3384 0000190A 8B16                        mov edx, [ esi ]
  3385 0000190C 0FAF15[18390000]            imul edx, [ base ]
  3386 00001913 01C2                        add edx, _TOS_
  3387 00001915 8916                        mov [ esi ], edx
  3388                                  number2:
  3389                                      _DROP_
  3390 00001917 AD                  <1>  lodsd
  3391 00001918 C705[14390000]-             mov dword [ shiftAction ], numb1
  3392 0000191E [BE170000]         
  3393 00001922 EBBC                        jmp short number3
  3394                                  
  3395                                  endn:
  3396                                      _DROP_
  3397 00001924 AD                  <1>  lodsd
  3398 00001925 FF15[2C390000]              call [ anumber]
  3399 0000192B E976000000                  jmp accept
  3400                                  
  3401                                  setDecimalMode:
  3402 00001930 C705[18390000]0A00-         mov dword [ base ], 0x0A
  3403 00001938 0000               
  3404 0000193A C705[14390000]-             mov dword [ shiftAction ], numb0
  3405 00001940 [AA170000]         
  3406 00001944 C705[10390000]-             mov dword [ currentKeyboardIcons], ( decimalKeyboard - 4 )
  3407 0000194A [36140000]         
  3408 0000194E C3                          ret
  3409                                  
  3410                                  setHexMode:
  3411 0000194F C705[18390000]1000-         mov dword [ base ], 0x10
  3412 00001957 0000               
  3413 00001959 C705[14390000]-             mov dword [ shiftAction ], numb0
  3414 0000195F [AA170000]         
  3415 00001963 C705[10390000]-             mov dword [ currentKeyboardIcons], ( hexadecimalKeyboard - 4 )
  3416 00001969 [4E140000]         
  3417 0000196D C3                          ret
  3418                                  
  3419                                  toggleBase0:
  3420 0000196E 8135[1C390000]7F00-         xor dword [ current], ((setDecimalMode - $$) ^ (setHexMode - $$))
  3421 00001976 0000               
  3422 00001978 8035[BC170000]2F            xor byte [ numb0 + 18 ], ( 0x21 ^ 0x0E ) ;  0x21 = '9' , 0x0E = 'f' toggle '9' and 'f' on keypad display line
  3423 0000197F FF15[1C390000]              call [ current ]
  3424 00001985 C3                          ret
  3425                                  
  3426                                  toggleBase:
  3427 00001986 E8E3FFFFFF                  call toggleBase0
  3428 0000198B E93EFFFFFF                  jmp dword number0
  3429                                  
  3430                                  ; *****************************************************************************
  3431                                  ; text entry
  3432                                  ; *****************************************************************************
  3433                                  
  3434                                  xn:
  3435                                      _DROP_
  3436 00001990 AD                  <1>  lodsd
  3437                                      _DROP_
  3438 00001991 AD                  <1>  lodsd
  3439 00001992 E90F000000                  jmp accept
  3440                                  
  3441                                  nul0:
  3442                                      _DROP_
  3443 00001997 AD                  <1>  lodsd
  3444 00001998 EB22                        jmp short accept2
  3445                                  
  3446                                  clearHintChar:
  3447 0000199A 50                          push _TOS_
  3448 0000199B 31C0                        xor _TOS_, _TOS_
  3449 0000199D C605[08390000]00            mov byte [ v_hintChar ], 0x00   ; clear the hint character
  3450 000019A4 58                          pop _TOS_
  3451 000019A5 C3                          ret
  3452                                  
  3453                                  accept:     ; get a word from keyboard
  3454 000019A6 C705[14390000]-             mov dword [ shiftAction ], alpha0
  3455 000019AC [82170000]         
  3456 000019B0 8D3D[06140000]              lea edi, [ alphaKeyboard - 4]
  3457                                  accept1:
  3458 000019B6 893D[10390000]              mov [ dword currentKeyboardIcons ], edi
  3459                                  accept2:
  3460 000019BC F705[F8380000]FFFF-         test dword [ x_qwerty ], 0xFFFFFFFF
  3461 000019C4 FFFF               
  3462 000019C6 7406                        jz .forward
  3463 000019C8 FF25[F8380000]              jmp dword [ x_qwerty ]          ; jump to the address in x_qwerty if it is non-zero
  3464                                  .forward:
  3465 000019CE E870FCFFFF                  call get_key_                    ; calls pause_ while waiting for a character
  3466 000019D3 3C04                        cmp al, 0x04                    ; 
  3467 000019D5 7909                        jns .forward2
  3468 000019D7 8B15[14390000]              mov edx, [ shiftAction ]
  3469 000019DD FF2482                      jmp dword [ edx + _TOS_ * 4 ]   ; alpha0 jump table element 
  3470                                  .forward2:
  3471 000019E0 8305[14390000]14            add dword [ shiftAction ], byte +0x14
  3472 000019E7 E860FEFFFF                  call word_
  3473 000019EC FF15[28390000]              call [ aword ]
  3474 000019F2 EBB2                        jmp short accept                ; endless loop
  3475                                  
  3476                                  alphn:
  3477                                   _DROP_
  3478 000019F4 AD                  <1>  lodsd
  3479                                  
  3480                                  alph0:
  3481 000019F5 C705[14390000]-             mov dword [ shiftAction ], alpha0
  3482 000019FB [82170000]         
  3483 000019FF 8D3D[06140000]              lea edi, [ alphaKeyboard - 4 ]
  3484 00001A05 EB10                        jmp short Xstar0
  3485                                  
  3486                                  star0:
  3487 00001A07 C705[14390000]-             mov dword [ shiftAction ], graph0
  3488 00001A0D [5A170000]         
  3489 00001A11 8D3D[1E140000]              lea edi, [ ( graphicsKeyboard - 4 ) ]
  3490                                      Xstar0:
  3491                                      _DROP_
  3492 00001A17 AD                  <1>  lodsd
  3493 00001A18 EB9C                        jmp short accept1
  3494                                  
  3495                                  alph:
  3496 00001A1A C705[14390000]-             mov dword [ shiftAction ], alpha1
  3497 00001A20 [96170000]         
  3498 00001A24 8D3D[06140000]              lea edi, [ alphaKeyboard - 4]
  3499 00001A2A EB10                        jmp short Xgraph
  3500                                  
  3501                                  graph:
  3502 00001A2C C705[14390000]-             mov dword [ shiftAction ], graph1
  3503 00001A32 [6E170000]         
  3504 00001A36 8D3D[1E140000]              lea edi, [ ( graphicsKeyboard - 4 ) ]
  3505                                      Xgraph:
  3506 00001A3C 893D[10390000]              mov [ currentKeyboardIcons ], edi
  3507 00001A42 E959FEFFFF                  jmp dword word0
  3508                                  
  3509                                  ; *****************************************************************************
  3510                                  ; Shannon-Fano decompression and display
  3511                                  ; *****************************************************************************
  3512                                  
  3513                                  unpack:     ; ( token -- token' nextCharacter )
  3514                                      _DUP_   ; copy TOS to our data stack SOS
  3515 00001A47 83EE04              <1>  sub esi, byte 0x04
  3516 00001A4A 8906                <1>  mov [ esi ], _TOS_
  3517 00001A4C 85C0                        test _TOS_, _TOS_
  3518 00001A4E 780A                        js .forward
  3519 00001A50 C12604                      shl dword [ esi ], 0x04
  3520 00001A53 C1C004                      rol _TOS_, 0x04
  3521 00001A56 83E007                      and _TOS_, byte 0x07
  3522 00001A59 C3                          ret
  3523                                  .forward:
  3524 00001A5A D1E0                        shl _TOS_,1
  3525 00001A5C 780C                        js .forward2
  3526 00001A5E C12605                      shl dword [ esi ], 0x05
  3527 00001A61 C1C004                      rol _TOS_, 0x04
  3528 00001A64 83E007                      and _TOS_, byte 0x07
  3529 00001A67 3408                        xor al, 0x08
  3530 00001A69 C3                          ret
  3531                                  .forward2:
  3532 00001A6A C12607                      shl dword [ esi ], 0x07
  3533 00001A6D C1C006                      rol _TOS_, 0x06
  3534 00001A70 83E03F                      and _TOS_, byte 0x3F
  3535 00001A73 2C10                        sub al, 0x10
  3536 00001A75 C3                          ret
  3537                                  
  3538                                  qring:  ; ( a cursor -- a' )  edx  contains pointer to current address to display
  3539                                      _DUP_
  3540 00001A76 83EE04              <1>  sub esi, byte 0x04
  3541 00001A79 8906                <1>  mov [ esi ], _TOS_
  3542 00001A7B FF06                        inc dword [ esi ]
  3543 00001A7D 393D[A8380000]              cmp [ v_curs ], edi
  3544 00001A83 7505                        jnz .forward                ; address to display = cursor address?
  3545 00001A85 A3[A8380000]                mov [ v_curs ], _TOS_       ; yes,
  3546                                  .forward:
  3547 00001A8A 3B05[A8380000]              cmp _TOS_, [ v_curs ]       ; no
  3548 00001A90 740A                        jz .forward2
  3549 00001A92 7906                        jns .forward4               ; time to draw the cursor?
  3550 00001A94 893D[CC380000]              mov [ v_pcad ], edi         ; no, so exit
  3551                                  .forward4:
  3552                                  ;     _DUP_
  3553                                  ;     mov _TOS_, 0x0F
  3554                                  ;     call doColourBlind             ; display the final colourblind punctuation, set up for next call of plusList
  3555                                      _DROP_
  3556 00001A9A AD                  <1>  lodsd
  3557 00001A9B C3                          ret                             ; exit here
  3558                                  .forward2:
  3559 00001A9C 893D[C8380000]              mov [ v_cad ], edi
  3560 00001AA2 53                          push _SCRATCH_
  3561 00001AA3 8B1D[F4380000]              mov _SCRATCH_, [ v_10000_iconw ]
  3562 00001AA9 291D[AC390000]              sub dword [ v_xy ], _SCRATCH_  ; move one icon's worth of horizontal pixels to the left
  3563                                      _DUP_
  3564 00001AAF 83EE04              <1>  sub esi, byte 0x04
  3565 00001AB2 8906                <1>  mov [ esi ], _TOS_
  3566 00001AB4 8B1D[C0390000]              mov _SCRATCH_, [ v_foregroundColour ]   ; save the current colour
  3567 00001ABA B800E20000                  mov _TOS_, colour_PacMan
  3568 00001ABF E841EFFFFF                  call color
  3569 00001AC4 B830000000                  mov _TOS_, 0x30   ; display the "PacMan" cursor
  3570 00001AC9 668B0D[AE390000]            mov cx, [ v_x ]
  3571 00001AD0 663B0D[B4390000]            cmp cx, [ v_rightMargin ]
  3572 00001AD7 7816                        js .forward5
  3573 00001AD9 E892F3FFFF                  call emit_
  3574 00001ADE 8B1D[F4380000]              mov _SCRATCH_, [ v_10000_iconw ]
  3575 00001AE4 291D[AC390000]              sub dword [ v_xy ], _SCRATCH_  ; move one icon's worth of horizontal pixels to the left
  3576 00001AEA E905000000                  jmp .forward6
  3577                                  .forward5:
  3578 00001AEF E87CF3FFFF                  call emit_
  3579                                  .forward6:
  3580 00001AF4 891D[C0390000]              mov dword [ v_foregroundColour ], _SCRATCH_     ; restore the current colour
  3581 00001AFA 5B                          pop _SCRATCH_
  3582 00001AFB C3                          ret
  3583                                  
  3584                                  ; *****************************************************************************
  3585                                  ; Conventional Forth display (does not require colours)
  3586                                  ; *****************************************************************************
  3587                                  
  3588                                  currentState:
  3589 00001AFC 00000000                    dd 0
  3590                                  
  3591                                  lastState:
  3592 00001B00 00000000                    dd 0
  3593                                  
  3594                                  txt0:
  3595 00001B04 E8F2EEFFFF                  call white
  3596                                      EMIT_IMM( 0x6D )
  3597                              <1> 
  3598                              <1>  _DUP_
  3599 00001B09 83EE04              <2>  sub esi, byte 0x04
  3600 00001B0C 8906                <2>  mov [ esi ], _TOS_
  3601 00001B0E B86D000000          <1>  mov _TOS_, %1
  3602 00001B13 E858F3FFFF          <1>  call emit_
  3603                              <1> 
  3604 00001B18 E865F3FFFF                  call space_
  3605 00001B1D C3                          ret
  3606                                  
  3607                                  txt1:
  3608 00001B1E E8D8EEFFFF                  call white
  3609                                      EMIT_IMM( 0x6E )
  3610                              <1> 
  3611                              <1>  _DUP_
  3612 00001B23 83EE04              <2>  sub esi, byte 0x04
  3613 00001B26 8906                <2>  mov [ esi ], _TOS_
  3614 00001B28 B86E000000          <1>  mov _TOS_, %1
  3615 00001B2D E83EF3FFFF          <1>  call emit_
  3616                              <1> 
  3617 00001B32 E84BF3FFFF                  call space_
  3618 00001B37 C3                          ret
  3619                                  
  3620                                  imm0:
  3621 00001B38 E8AFEEFFFF                  call yellow
  3622                                      EMIT_IMM( 0x58 )
  3623                              <1> 
  3624                              <1>  _DUP_
  3625 00001B3D 83EE04              <2>  sub esi, byte 0x04
  3626 00001B40 8906                <2>  mov [ esi ], _TOS_
  3627 00001B42 B858000000          <1>  mov _TOS_, %1
  3628 00001B47 E824F3FFFF          <1>  call emit_
  3629                              <1> 
  3630 00001B4C E831F3FFFF                  call space_
  3631 00001B51 C3                          ret
  3632                                  
  3633                                  imm1:
  3634 00001B52 E895EEFFFF                  call yellow
  3635                                      EMIT_IMM( 0x59 )
  3636                              <1> 
  3637                              <1>  _DUP_
  3638 00001B57 83EE04              <2>  sub esi, byte 0x04
  3639 00001B5A 8906                <2>  mov [ esi ], _TOS_
  3640 00001B5C B859000000          <1>  mov _TOS_, %1
  3641 00001B61 E80AF3FFFF          <1>  call emit_
  3642                              <1> 
  3643 00001B66 E817F3FFFF                  call space_
  3644 00001B6B C3                          ret
  3645                                  
  3646                                  mvar0:
  3647 00001B6C E87BEEFFFF                  call yellow
  3648                                      EMIT_IMM( 0x58 ) ; '['
  3649                              <1> 
  3650                              <1>  _DUP_
  3651 00001B71 83EE04              <2>  sub esi, byte 0x04
  3652 00001B74 8906                <2>  mov [ esi ], _TOS_
  3653 00001B76 B858000000          <1>  mov _TOS_, %1
  3654 00001B7B E8F0F2FFFF          <1>  call emit_
  3655                              <1> 
  3656 00001B80 E8FDF2FFFF                  call space_
  3657                                      EMIT_IMM( 0x09 ) ; 'm'
  3658                              <1> 
  3659                              <1>  _DUP_
  3660 00001B85 83EE04              <2>  sub esi, byte 0x04
  3661 00001B88 8906                <2>  mov [ esi ], _TOS_
  3662 00001B8A B809000000          <1>  mov _TOS_, %1
  3663 00001B8F E8DCF2FFFF          <1>  call emit_
  3664                              <1> 
  3665                                      EMIT_IMM( 0x11 ) ; 'v'
  3666                              <1> 
  3667                              <1>  _DUP_
  3668 00001B94 83EE04              <2>  sub esi, byte 0x04
  3669 00001B97 8906                <2>  mov [ esi ], _TOS_
  3670 00001B99 B811000000          <1>  mov _TOS_, %1
  3671 00001B9E E8CDF2FFFF          <1>  call emit_
  3672                              <1> 
  3673                                      EMIT_IMM( 0x05 ) ; 'a'
  3674                              <1> 
  3675                              <1>  _DUP_
  3676 00001BA3 83EE04              <2>  sub esi, byte 0x04
  3677 00001BA6 8906                <2>  mov [ esi ], _TOS_
  3678 00001BA8 B805000000          <1>  mov _TOS_, %1
  3679 00001BAD E8BEF2FFFF          <1>  call emit_
  3680                              <1> 
  3681                                      EMIT_IMM( 0x01 ) ; 'r'
  3682                              <1> 
  3683                              <1>  _DUP_
  3684 00001BB2 83EE04              <2>  sub esi, byte 0x04
  3685 00001BB5 8906                <2>  mov [ esi ], _TOS_
  3686 00001BB7 B801000000          <1>  mov _TOS_, %1
  3687 00001BBC E8AFF2FFFF          <1>  call emit_
  3688                              <1> 
  3689 00001BC1 E8BCF2FFFF                  call space_
  3690 00001BC6 C3                          ret
  3691                                  
  3692                                  mvar1:
  3693 00001BC7 E820EEFFFF                  call yellow
  3694                                      EMIT_IMM( 0x59 ) ; ']'
  3695                              <1> 
  3696                              <1>  _DUP_
  3697 00001BCC 83EE04              <2>  sub esi, byte 0x04
  3698 00001BCF 8906                <2>  mov [ esi ], _TOS_
  3699 00001BD1 B859000000          <1>  mov _TOS_, %1
  3700 00001BD6 E895F2FFFF          <1>  call emit_
  3701                              <1> 
  3702 00001BDB E8A2F2FFFF                  call space_
  3703 00001BE0 C3                          ret
  3704                                  
  3705                                  ; unfortunately we need to display the ':' after the CR, so must do this in  redWord , not here
  3706                                  ; colon0:
  3707                                  ;     call red
  3708                                  ;     EMIT_IMM( 0x59 )
  3709                                  ;     call space_
  3710                                  ;     ret
  3711                                  ;
  3712                                  ;     dd nul, imm0, nul, colon0, nul, nul, nul, nul, nul, txt0, nul, nul, mvar0, nul, nul, nul
  3713                                  
  3714                                  txts:
  3715 00001BE1 000101030405060701-         db 0, 1, 1, 3, 4, 5, 6, 7, 1, 9, 9, 9, 12, 13, 14, 15
  3716 00001BEA 0909090C0D0E0F     
  3717                                  
  3718                                  tx:     ; ( c -- c )   \ return the value in the given offset in  txts
  3719 00001BF1 25FF000000                  and _TOS_, 0xFF
  3720 00001BF6 8B80[E11B0000]              mov _TOS_, [ _TOS_ + txts ]
  3721 00001BFC 25FF000000                  and _TOS_, 0xFF
  3722 00001C01 C3                          ret
  3723                                  
  3724                                  newActions:
  3725 00001C02 [00040000]-                 dd nul, imm0, nul, nul, nul, nul, nul, nul, nul, txt0, nul, nul, mvar0, nul, nul, nul
  3726 00001C06 [381B0000]-        
  3727 00001C0A [00040000]-        
  3728 00001C0E [00040000]-        
  3729 00001C12 [00040000]-        
  3730 00001C16 [00040000]-        
  3731 00001C1A [00040000]-        
  3732 00001C1E [00040000]-        
  3733 00001C22 [00040000]-        
  3734 00001C26 [041B0000]-        
  3735 00001C2A [00040000]-        
  3736 00001C2E [00040000]-        
  3737 00001C32 [6C1B0000]-        
  3738 00001C36 [00040000]-        
  3739 00001C3A [00040000]-        
  3740 00001C3E [00040000]         
  3741                                  
  3742                                  dotNew:     ; ( state -- )
  3743 00001C42 FF1485[021C0000]            call [ ( _TOS_ * 4 ) + newActions ]
  3744 00001C49 C3                          ret
  3745                                  
  3746                                  oldActions:
  3747 00001C4A [00040000]-                 dd nul, imm1, nul, nul, nul, nul, nul, nul, nul, txt1, nul, nul, mvar1, nul, nul, nul
  3748 00001C4E [521B0000]-        
  3749 00001C52 [00040000]-        
  3750 00001C56 [00040000]-        
  3751 00001C5A [00040000]-        
  3752 00001C5E [00040000]-        
  3753 00001C62 [00040000]-        
  3754 00001C66 [00040000]-        
  3755 00001C6A [00040000]-        
  3756 00001C6E [1E1B0000]-        
  3757 00001C72 [00040000]-        
  3758 00001C76 [00040000]-        
  3759 00001C7A [C71B0000]-        
  3760 00001C7E [00040000]-        
  3761 00001C82 [00040000]-        
  3762 00001C86 [00040000]         
  3763                                  
  3764                                  dotOld:     ; ( state -- )
  3765 00001C8A FF1485[4A1C0000]            call [ ( _TOS_ * 4 ) + oldActions ]
  3766 00001C91 C3                          ret
  3767                                  
  3768                                  colourBlindAction:  ; ( state -- state )    \ perform the required actionon change of state
  3769 00001C92 53                          push _SCRATCH_
  3770                                      _DUP_
  3771 00001C93 83EE04              <1>  sub esi, byte 0x04
  3772 00001C96 8906                <1>  mov [ esi ], _TOS_
  3773 00001C98 E854FFFFFF                  call tx
  3774 00001C9D 3D00000000                  cmp _TOS_, 0x00
  3775 00001CA2 743F                        jz .end                             ; no action on extension tokens, value 0
  3776 00001CA4 8B1D[FC1A0000]              mov _SCRATCH_, [ currentState ]
  3777 00001CAA A3[FC1A0000]                mov [ currentState ], _TOS_
  3778 00001CAF 3B1D[FC1A0000]              cmp _SCRATCH_, [ currentState ]     ; compare the new state on TOS to the last one saved in currentState
  3779 00001CB5 742C                        jz .end                             ; exit if there has been no change of state
  3780                                      _DUP_
  3781 00001CB7 83EE04              <1>  sub esi, byte 0x04
  3782 00001CBA 8906                <1>  mov [ esi ], _TOS_
  3783 00001CBC 89D8                        mov _TOS_, _SCRATCH_
  3784 00001CBE E8C7FFFFFF                  call dotOld                         ;
  3785 00001CC3 A1[FC1A0000]                mov _TOS_, [ currentState ]
  3786 00001CC8 E875FFFFFF                  call dotNew
  3787                                      _DROP_
  3788 00001CCD AD                  <1>  lodsd
  3789 00001CCE 803D[FC1A0000]00            cmp byte [ currentState ], 0x0000
  3790 00001CD5 740C                        jz .end
  3791 00001CD7 8B1D[FC1A0000]              mov _SCRATCH_, [ currentState ]
  3792 00001CDD 891D[001B0000]              mov [ lastState ], _SCRATCH_
  3793                                   .end:
  3794                                      _DROP_
  3795 00001CE3 AD                  <1>  lodsd
  3796 00001CE4 5B                          pop _SCRATCH_
  3797 00001CE5 C3                          ret
  3798                                  
  3799                                  ; \ Block 70
  3800                                  ; ( Colourblind Editor Display )
  3801                                  ; #1 MagentaV currentState $01 MagentaV lastState
  3802                                  ; : +txt white $6D emit space ;
  3803                                  ; : -txt white $6E emit space ;
  3804                                  ; : +imm yellow $58 emit space ;
  3805                                  ; : -imm yellow $59 emit space ;
  3806                                  ; : +mvar yellow $09 emit $11 emit $05 emit $01 emit space ;
  3807                                  ; : txts string $03010100 , $07060504 , $09090901 , $0F0E0D0C , ( ; )
  3808                                  ; : tx ( c-c ) $0F and txts + 1@ $0F and ;
  3809                                  ; : .new currentState @ $0F and jump nul +imm nul nul nul nul nul nul nul +txt nul nul +mvar nul nul nul ;
  3810                                  ; : .old lastState @ $0F and jump nul -imm nul nul nul nul nul nul nul -txt nul nul nul nul nul nul ;
  3811                                  ; here
  3812                                  ; : cb ( n-n ) #0 + 0if ; then tx
  3813                                  ;    currentState @ swap dup currentState ! - drop if .old .new
  3814                                  ;    currentState @ #0 + if dup lastState ! then then ;
  3815                                  ; : cbs ( -- here ) #0 + $00 + cblind ! ;
  3816                                  
  3817                                  ; colourBlind:    ; ( state -- state )    \ vectored colorForth to display colourBlind extra characters ( e.g. ':' for red words )
  3818                                  ;    call dword [ x_colourBlind ]
  3819                                  ;    ret
  3820                                  
  3821                                  ; *****************************************************************************
  3822                                  
  3823                                  lowercase:   ; display a white text word in normal lower-case letters
  3824 00001CE6 E810EDFFFF                  call white
  3825                                  type_:  ; ( -- )   \ display a Shanon-Fano encoded word pointed to by  edi  in the current colour
  3826                                      _DUP_
  3827 00001CEB 83EE04              <1>  sub esi, byte 0x04
  3828 00001CEE 8906                <1>  mov [ esi ], _TOS_
  3829 00001CF0 8B04BDFCFFFFFF              mov _TOS_, [ ( edi * 4 ) - 0x04 ]
  3830                                  showShannonFano:    ; ( token -- ) \ display the given Shanon-Fano encoded word in the current colour
  3831 00001CF7 83E0F0                      and _TOS_, byte -0x10
  3832                                  lowercasePrimitive:  ; ( token -- ) \ display the given Shanon-Fano encoded word in the current colour
  3833 00001CFA E848FDFFFF                  call unpack
  3834 00001CFF 740A                        jz lowercasePrimitiveEnd
  3835 00001D01 E86AF1FFFF                  call emit_
  3836 00001D06 E9EFFFFFFF                  jmp lowercasePrimitive
  3837                                  lowercasePrimitiveEnd:
  3838 00001D0B E872F1FFFF                  call space_
  3839                                      _DROP_
  3840 00001D10 AD                  <1>  lodsd
  3841                                      _DROP_
  3842 00001D11 AD                  <1>  lodsd
  3843 00001D12 C3                          ret
  3844                                  
  3845                                  typeNumber32tok:     ; ( token -- ) \ display the given Shanon-Fano encoded word as a number in the current colour
  3846                                      _DROP_ ; call dotHex8
  3847 00001D13 AD                  <1>  lodsd
  3848 00001D14 C705[381D0000]FFFF-         mov dword [ lastTokenWasLiteral ], 0xFFFFFFF
  3849 00001D1C FF0F               
  3850 00001D1E C3                          ret
  3851                                  
  3852                                  typeNumber32:     ; ( token -- ) \ display the given Shanon-Fano encoded word as a hex number in the current colour
  3853 00001D1F E8A1F3FFFF                  call dotHex8
  3854 00001D24 C705[381D0000]0000-         mov dword [ lastTokenWasLiteral ], 0x00000000
  3855 00001D2C 0000               
  3856 00001D2E C3                          ret
  3857                                  
  3858                                  typeNumber27:     ; ( token -- ) \ display the given Shanon-Fano encoded word as a 27 bit hex number in the current colour
  3859 00001D2F C1E805                      shr _TOS_, 5
  3860 00001D32 E8A1F3FFFF                  call dotHex
  3861 00001D37 C3                          ret
  3862                                  
  3863                                  lastTokenWasLiteral:
  3864 00001D38 00000000                    dd 0x00
  3865                                  
  3866                                  lastShannonFanoToken:
  3867 00001D3C 00000000                    dd 0x00
  3868                                  
  3869                                  magentaPrimitive:   ; ( token -- )
  3870 00001D40 E8B5FFFFFF                  call lowercasePrimitive
  3871 00001D45 C705[381D0000]FFFF-         mov dword [ lastTokenWasLiteral ], 0xFFFFFFF
  3872 00001D4D FF0F               
  3873 00001D4F C3                          ret
  3874                                  
  3875                                  displayOneShannonFanoActions:   ;    * = number
  3876 00001D50 [FA1C0000]                  dd lowercasePrimitive       ; 0     extension token, remove space from previous word, do not change the colour
  3877 00001D54 [FA1C0000]                  dd lowercasePrimitive       ; 1     yellow "immediate" word
  3878 00001D58 [131D0000]                  dd typeNumber32tok          ; 2  *  yellow "immediate" 32 bit number in the following pre-parsed cell
  3879 00001D5C [FA1C0000]                  dd lowercasePrimitive       ; 3     red forth wordlist "colon" word
  3880 00001D60 [FA1C0000]                  dd lowercasePrimitive       ; 4     green compiled word
  3881 00001D64 [131D0000]                  dd typeNumber32tok          ; 5  *  green compiled 32 bit number in the following pre-parsed cell
  3882 00001D68 [2F1D0000]                  dd typeNumber27             ; 6  *  green compiled 27 bit number in the high bits of the token
  3883 00001D6C [FA1C0000]                  dd lowercasePrimitive       ; 7     cyan macro wordlist "colon" word
  3884 00001D70 [2F1D0000]                  dd typeNumber27             ; 8  *  yellow "immediate" 27 bit number in the high bits of the token
  3885 00001D74 [FA1C0000]                  dd lowercasePrimitive       ; 9     white lower-case comment
  3886 00001D78 [E01E0000]                  dd camelcasePrimitive       ; A     first letter capital comment
  3887 00001D7C [051F0000]                  dd uppercasePrimitive       ; B     white upper-case comment
  3888 00001D80 [401D0000]                  dd magentaPrimitive         ; C     magenta variable
  3889 00001D84 [FA1C0000]                  dd lowercasePrimitive       ; D
  3890 00001D88 [FA1C0000]                  dd lowercasePrimitive       ; E     editor formatting commands
  3891 00001D8C [FA1C0000]                  dd lowercasePrimitive       ; F
  3892                                  
  3893 00001D90 55<rept>                times 0x20 db 0x55
  3894                                  testme:
  3895 00001DB0 FF0C2475                    dd 0x75240CFF ; 0xFF, 0x0C, 0x24, 0x75
  3896 00001DB4 56341200                    dd 0x123456
  3897 00001DB8 C3                          ret
  3898 00001DB9 77<rept>                times 0x20 db 0x77
  3899                                  
  3900                                  leave_:     ; terminate a  for ... next  loop
  3901 00001DD9 C744240401000000            mov dword [ esp + 4 ], 0x01
  3902 00001DE1 C3                          ret
  3903                                  
  3904                                  dotsf_:  ; ( token -- )   \ display the given Shannon-Fano encoded word in the token's colour
  3905 00001DE2 57                          push edi
  3906 00001DE3 89C2                        mov edx , _TOS_
  3907 00001DE5 25F0FFFFFF                  and _TOS_, 0xFFFFFFF0
  3908                                      _DUP_
  3909 00001DEA 83EE04              <1>  sub esi, byte 0x04
  3910 00001DED 8906                <1>  mov [ esi ], _TOS_
  3911 00001DEF 8B3D[381D0000]              mov edi, [ lastTokenWasLiteral ]
  3912 00001DF5 F7C700000000                test edi, 0x00000000
  3913 00001DFB 7405                        jz .forward3
  3914 00001DFD BA00000000                  mov edx, 0
  3915                                  .forward3:
  3916 00001E02 83E20F                      and edx, byte 0x0F
  3917 00001E05 7533                        jnz .forward     ; do not change the colour if this is an extension token
  3918                                          ; this is an extension token
  3919 00001E07 8B15[3C1D0000]                  mov edx, [ lastShannonFanoToken ]
  3920                                          ; if the colour is Camelcase 0x0A, make it lowercase 0x09
  3921                                          ; e.g. Interrupt would be shown as InterrUpt if the exension token is displayed with an initial Capital
  3922 00001E0D 89D3                            mov _SCRATCH_, edx
  3923 00001E0F 81E30F000000                    and _SCRATCH_, 0x0F     ; just the colour
  3924 00001E15 81EB0A000000                    sub _SCRATCH_, 0x0A
  3925 00001E1B 750C                            jne .foward4
  3926 00001E1D 81E2F0FFFFFF                        and edx, 0xFFFFFFF0     ; remove the colour
  3927 00001E23 81CA09000000                        or edx, 0x00000009      ; make it lowercase
  3928                                          .foward4:
  3929 00001E29 8B1D[F4380000]                  mov _SCRATCH_, [ v_10000_iconw ]
  3930 00001E2F 291D[AC390000]                  sub dword [ v_xy ], _SCRATCH_   ; move iconw horizontal pixels back, to remove the space at the end of the last word
  3931 00001E35 E906000000                  jmp .forward2
  3932                                      .forward:
  3933                                          ; this is not an extension token
  3934 00001E3A 8915[3C1D0000]                  mov [ lastShannonFanoToken ], edx
  3935                                      .forward2:
  3936 00001E40 50                          push _TOS_
  3937 00001E41 8B0495[24220000]            mov _TOS_, [ ( edx * 4 ) + actionColourTable ]
  3938 00001E48 E8B8EBFFFF                  call color
  3939 00001E4D 58                          pop _TOS_
  3940 00001E4E FF1495[501D0000]            call [ ( edx * 4 ) + displayOneShannonFanoActions ]
  3941 00001E55 5F                          pop edi
  3942 00001E56 C3                          ret
  3943                                  
  3944                                  redWord:     ; display a red word
  3945 00001E57 668B0D[AE390000]            mov cx, [ v_x ]
  3946 00001E5E 663B0D[B0390000]            cmp cx, [ v_leftMargin ]
  3947 00001E65 7410                        jz .forward     ; do not do a  cr  if we are already at the left margin
  3948 00001E67 8A0D[06390000]              mov cl, [ v_not_cr ]
  3949 00001E6D 80F900                      cmp cl, 0
  3950 00001E70 7505                        jnz .forward    ; do not do a  cr  if it has been disabled by a blue  -cr  token
  3951 00001E72 E848EBFFFF                  call cr_
  3952                                  .forward:
  3953 00001E77 C605[06390000]00            mov byte [ v_not_cr ], 0
  3954 00001E7E E8E4F0FFFF                  call setRed
  3955                                  
  3956 00001E83 803D[05390000]00            cmp byte [ v_colourBlindMode ], 0x00
  3957 00001E8A 741D                        jz .forward2
  3958 00001E8C F605[88380000]01            test byte [ v_blk ], 0x01   ; do not display colourblind characters in odd numbered shadow blocks
  3959 00001E93 7514                        jnz .forward2
  3960                                      EMIT_IMM( 0x29 )    ; emit a ':' if in colourblind mode
  3961                              <1> 
  3962                              <1>  _DUP_
  3963 00001E95 83EE04              <2>  sub esi, byte 0x04
  3964 00001E98 8906                <2>  mov [ esi ], _TOS_
  3965 00001E9A B829000000          <1>  mov _TOS_, %1
  3966 00001E9F E8CCEFFFFF          <1>  call emit_
  3967                              <1> 
  3968 00001EA4 E8D9EFFFFF                  call space_
  3969                                  .forward2:
  3970 00001EA9 E93DFEFFFF                  jmp type_
  3971                                  
  3972                                  greenWord:     ; display a green word
  3973 00001EAE E8C3F0FFFF                  call setGreen  
  3974 00001EB3 E933FEFFFF                  jmp type_
  3975                                  
  3976                                  cyanWord:     ; display a cyan word
  3977 00001EB8 E86EF0FFFF                  call setCyan
  3978 00001EBD E929FEFFFF                  jmp type_
  3979                                  
  3980                                  yellowWord:     ; display a yellow word
  3981 00001EC2 E825EBFFFF                  call yellow
  3982 00001EC7 E91FFEFFFF                  jmp type_
  3983                                  
  3984                                  camelcase:    ; display a white word with the first letter Capitalised
  3985 00001ECC E82AEBFFFF                  call white
  3986                                      _DUP_
  3987 00001ED1 83EE04              <1>  sub esi, byte 0x04
  3988 00001ED4 8906                <1>  mov [ esi ], _TOS_
  3989 00001ED6 8B04BDFCFFFFFF              mov _TOS_, [ ( edi * 4 ) - 0x04 ]
  3990 00001EDD 83E0F0                      and _TOS_, byte -0x10
  3991                                  camelcasePrimitive:
  3992 00001EE0 E862FBFFFF                  call unpack
  3993 00001EE5 0430                        add al, 0x30        ; make the first character upper case
  3994 00001EE7 E884EFFFFF                  call emit_           ; display it
  3995 00001EEC E909FEFFFF                  jmp lowercasePrimitive   ; display the rest of the word
  3996                                  
  3997                                  uppercase:   ; display a white word with all letters CAPITALISED
  3998 00001EF1 E805EBFFFF                  call white
  3999                                      _DUP_
  4000 00001EF6 83EE04              <1>  sub esi, byte 0x04
  4001 00001EF9 8906                <1>  mov [ esi ], _TOS_
  4002 00001EFB 8B04BDFCFFFFFF              mov _TOS_, [ ( edi * 4 ) - 0x04 ]
  4003 00001F02 83E0F0                      and _TOS_, byte -0x10
  4004                                  uppercasePrimitive:
  4005 00001F05 E83DFBFFFF                  call unpack
  4006 00001F0A 0F84FBFDFFFF                jz lowercasePrimitiveEnd
  4007 00001F10 0430                        add al, 0x30
  4008 00001F12 E859EFFFFF                  call emit_
  4009 00001F17 E9E9FFFFFF                  jmp uppercasePrimitive
  4010                                  
  4011                                  extension:  ; display an extension token, do not change the colour
  4012 00001F1C 8B1D[F4380000]              mov _SCRATCH_, [ v_10000_iconw ]
  4013 00001F22 291D[AC390000]              sub dword [ v_xy ], _SCRATCH_   ; move iconw horizontal pixels back, to remove the space at the end of the last word
  4014 00001F28 F704BDFCFFFFFFF0FF-         test dword [ ( edi * 4 ) - 0x04 ], 0xFFFFFFF0
  4015 00001F31 FFFF               
  4016 00001F33 0F85B2FDFFFF                jnz type_
  4017 00001F39 4F                          dec edi
  4018 00001F3A 893D[D0380000]              mov [ v_lcad ], edi
  4019 00001F40 E83DEFFFFF                  call space_
  4020 00001F45 E82CFBFFFF                  call qring
  4021 00001F4A 5A                          pop edx                         ; EXIT from calling word
  4022                                      _DROP_                          ; the ret below will return to the word that called  extension
  4023 00001F4B AD                  <1>  lodsd
  4024 00001F4C C3                          ret                             ; so it looks like it never happened
  4025                                  
  4026                                  greenShortNumber:    ; display the green compiled 27 bit number in the high bits of the token
  4027 00001F4D 8B14BDFCFFFFFF              mov edx, [ ( edi * 4 ) - 0x04 ]
  4028 00001F54 C1FA05                      sar edx, 0x05
  4029 00001F57 EB3E                        jmp short greenNumber1
  4030                                  
  4031                                  magentaVariable:    ; display a magenta variable using the 32 bit number in the following pre-parsed cell
  4032 00001F59 C705[84380000]-             mov dword [ x_numberDisplay ], dotDecimal
  4033 00001F5F [16110000]         
  4034 00001F63 833D[18390000]0A            cmp dword [ base ], byte 0x0A   ; check the current BASE value ( 10 or 16 for decimal or hex)
  4035 00001F6A 740A                        jz .forward
  4036 00001F6C C705[84380000]-             mov dword [ x_numberDisplay ], dotHex
  4037 00001F72 [D8100000]         
  4038                                  .forward:
  4039 00001F76 E8BFEFFFFF                  call setMagenta
  4040 00001F7B E86BFDFFFF                  call type_              ; display the name of the variable
  4041 00001F80 8B14BD00000000              mov edx, [ ( edi * 4 ) + 0x00 ]    ; load the value of the variable from the pre-parsed source
  4042 00001F87 47                          inc edi                 ; step over the variable value in the pre-parsed source
  4043 00001F88 E8BCEFFFFF                  call setMagentaData
  4044 00001F8D EB28                        jmp short displayNumber
  4045                                  
  4046                                  greenNumber:                ; display the value of a hexadecimal/decimal number in green
  4047 00001F8F 8B14BD00000000              mov edx, [ ( edi * 4 ) + 0x00 ]    ; load the value of the variable from the pre-parsed source
  4048 00001F96 47                          inc edi                 ; step over the variable value in the pre-parsed source
  4049                                  greenNumber1:
  4050 00001F97 E841EAFFFF                  call green
  4051 00001F9C EB19                        jmp short displayNumber
  4052                                  
  4053                                  yellowShortNumber:
  4054 00001F9E 8B14BDFCFFFFFF              mov edx, [ ( edi * 4 ) - 0x04 ] ; load the value of the number from the current token in the pre-parsed source
  4055 00001FA5 C1FA05                      sar edx, 0x05                   ; remove the token colour bits
  4056 00001FA8 EB08                        jmp short yellowNumber1
  4057                                  
  4058                                  yellowNumber:     ; ( -- ) display a number word, constant value following in the pre-parsed source
  4059 00001FAA 8B14BD00000000              mov edx, [ ( edi * 4 ) + 0x00 ]    ; load the value of the number from the pre-parsed source
  4060 00001FB1 47                          inc edi                 ; step over the number value in the pre-parsed source
  4061                                  yellowNumber1:    ; ( -- ) display a yellow number word
  4062 00001FB2 E835EAFFFF                  call yellow
  4063                                  displayNumber: ; ( rgb -- )   display the number in edx  with the given colour, using the base implied in  x_numberDisplay
  4064                                      _DUP_
  4065 00001FB7 83EE04              <1>  sub esi, byte 0x04
  4066 00001FBA 8906                <1>  mov [ esi ], _TOS_
  4067 00001FBC 89D0                        mov _TOS_, edx
  4068                                      ; jmp qdot
  4069 00001FBE FF25[84380000]              jmp dword [ x_numberDisplay ]
  4070                                  
  4071                                  ; *****************************************************************************
  4072                                  ; Blue words - formatting the editor display
  4073                                  ; *****************************************************************************
  4074                                  
  4075                                  get_x:  ; ( -- c )  \ return the current x character position
  4076 00001FC4 52                          push edx
  4077                                      _DUP_
  4078 00001FC5 83EE04              <1>  sub esi, byte 0x04
  4079 00001FC8 8906                <1>  mov [ esi ], _TOS_
  4080 00001FCA 31C0                        xor _TOS_, _TOS_
  4081 00001FCC 66A1[AE390000]              mov ax, word [ v_x ]
  4082 00001FD2 31D2                        xor edx, edx                    ; clear high 32 bits of dividend
  4083 00001FD4 F735[E0380000]              div dword [ v_iconw ]           ; EDX:EAX divided by the icon width , EAX now contains the current character position, EDX the remainder
  4084 00001FDA 5A                          pop edx
  4085 00001FDB C3                          ret
  4086                                  
  4087                                  set_x:  ; ( c -- )  \ set the current x character position
  4088 00001FDC 52                          push edx
  4089 00001FDD 31D2                        xor edx, edx
  4090 00001FDF F725[E0380000]              mul dword [ v_iconw ]
  4091 00001FE5 66A3[AE390000]              mov word [ v_x ], ax
  4092 00001FEB 5A                          pop edx
  4093                                      _DROP_
  4094 00001FEC AD                  <1>  lodsd
  4095 00001FED C3                          ret
  4096                                  
  4097                                  %define TAB_SIZE  24
  4098                                  
  4099                                  tab:    ; ( -- )    \ align to the next n character column
  4100                                  ;    _DUP_
  4101 00001FEE 60                          pusha
  4102 00001FEF E8D0FFFFFF                  call get_x
  4103 00001FF4 31D2                        xor edx, edx                    ; clear high 32 bits of dividend
  4104 00001FF6 BB18000000                  mov _SCRATCH_, TAB_SIZE
  4105 00001FFB F7F3                        div _SCRATCH_
  4106 00001FFD F7E3                        mul _SCRATCH_
  4107 00001FFF 0518000000                  add _TOS_, TAB_SIZE
  4108 00002004 E8D3FFFFFF                  call set_x
  4109 00002009 61                          popa
  4110 0000200A C3                          ret
  4111                                  
  4112                                  tab3:
  4113 0000200B 60                          pusha
  4114 0000200C E8B3FFFFFF                  call get_x
  4115 00002011 31D2                        xor edx, edx                    ; clear high 32 bits of dividend
  4116 00002013 BB03000000                  mov _SCRATCH_, 0x03
  4117 00002018 F7F3                        div _SCRATCH_
  4118 0000201A F7E3                        mul _SCRATCH_
  4119 0000201C 0503000000                  add _TOS_, 0x03
  4120 00002021 E8B6FFFFFF                  call set_x
  4121 00002026 61                          popa
  4122 00002027 C3                          ret
  4123                                  
  4124                                  not_cr:
  4125 00002028 F615[06390000]              not byte [ v_not_cr ]
  4126 0000202E C3                          ret
  4127                                  
  4128                                  blueWord:   ; ( -- )    \ format the editor display screen using certain blue tokens
  4129                                      _DUP_
  4130 0000202F 83EE04              <1>  sub esi, byte 0x04
  4131 00002032 8906                <1>  mov [ esi ], _TOS_
  4132 00002034 A0[04390000]                mov al, [ v_seeb ]
  4133 00002039 3C00                        cmp al, 0
  4134 0000203B 740A                        jz .forward
  4135 0000203D E816EFFFFF                  call setBlue
  4136 00002042 E8A4FCFFFF                  call type_
  4137                                  .forward:
  4138 00002047 8B04BDFCFFFFFF              mov _TOS_, [ ( edi * 4 ) - 0x04 ]
  4139 0000204E 3D0E008090                  cmp _TOS_, 0x9080000E  ; cr
  4140 00002053 7505                        jnz .skip1
  4141 00002055 E865E9FFFF                  call cr_
  4142                                  .skip1:
  4143 0000205A 3D0E8C4BE6                  cmp _TOS_, 0xE64B8C0E  ; -tab
  4144 0000205F 750A                        jnz .skip2
  4145 00002061 E8C2FFFFFF                  call not_cr
  4146 00002066 E883FFFFFF                  call tab
  4147                                  .skip2:
  4148 0000206B 3D0E00C625                  cmp _TOS_, 0x25C6000E  ; tab
  4149 00002070 7505                        jnz .skip3
  4150 00002072 E877FFFFFF                  call tab
  4151                                  .skip3:
  4152 00002077 3D0E0020C6                  cmp _TOS_, 0xC620000E  ; br
  4153 0000207C 750A                        jnz .skip4
  4154 0000207E E83CE9FFFF                  call cr_
  4155 00002083 E837E9FFFF                  call cr_
  4156                                  .skip4:
  4157 00002088 3D0E0021E7                  cmp _TOS_, 0xE721000E  ; -cr
  4158 0000208D 7505                        jnz .skip5
  4159 0000208F E894FFFFFF                  call not_cr
  4160                                  .skip5:
  4161 00002094 3D0E00FB90                  cmp _TOS_, 0x90FB000E  ; cr+   cr and 3 spaces
  4162 00002099 7514                        jnz .skip6
  4163 0000209B E81FE9FFFF                  call cr_
  4164 000020A0 E8DDEDFFFF                  call space_
  4165 000020A5 E8D8EDFFFF                  call space_
  4166 000020AA E8D3EDFFFF                  call space_
  4167                                  .skip6:
  4168 000020AF 3D0EACC725                  cmp _TOS_, 0x25C7AC0E  ; tab3   align to next 3 space column
  4169 000020B4 7505                        jnz .skip7
  4170 000020B6 E850FFFFFF                  call tab3
  4171                                  .skip7:
  4172 000020BB 3D0E0000EA                  cmp _TOS_, 0xEA00000E  ; .
  4173 000020C0 7505                        jnz .skip8
  4174 000020C2 E8BBEDFFFF                  call space_
  4175                                  .skip8:
  4176 000020C7 3D0E00D4EB                  cmp _TOS_, 0xEBD4000E  ; ..
  4177 000020CC 750A                        jnz .skip9
  4178 000020CE E8AFEDFFFF                  call space_
  4179 000020D3 E8AAEDFFFF                  call space_
  4180                                  .skip9:
  4181 000020D8 3D0EA8D7EB                  cmp _TOS_, 0xEBD7A80E  ; ...
  4182 000020DD 750F                        jnz .skip10
  4183 000020DF E89EEDFFFF                  call space_
  4184 000020E4 E899EDFFFF                  call space_
  4185 000020E9 E894EDFFFF                  call space_
  4186                                  .skip10:
  4187 000020EE 3D5EAFD7EB                  cmp _TOS_, 0xEBD7AF5E  ; ....
  4188 000020F3 7514                        jnz .skip11
  4189 000020F5 E888EDFFFF                  call space_
  4190 000020FA E883EDFFFF                  call space_
  4191 000020FF E87EEDFFFF                  call space_
  4192 00002104 E879EDFFFF                  call space_
  4193                                  .skip11:
  4194                                      _DROP_
  4195 00002109 AD                  <1>  lodsd
  4196 0000210A C3                          ret
  4197                                  
  4198                                  ; silverWord:   ; ( -- )    ; ToDo: document this
  4199                                  ;     mov edx, [ ( edi * 4 ) - 0x04 ] ; load the value of the action from the current token in the pre-parsed source
  4200                                  ;     sar edx, 0x05                   ; remove the token colour bits
  4201                                  ;     _DUP_
  4202                                  ;     mov _TOS_, colour_white
  4203                                  ;     cmp dword [ x_numberDisplay ], dotDecimal
  4204                                  ;     jz .forward
  4205                                  ;     mov _TOS_, colour_silver
  4206                                  ; .forward:
  4207                                  ;    jmp short displayNumber
  4208                                  ;    ret
  4209                                  
  4210                                  silverWord:     ; display a silver word
  4211 0000210B E875EEFFFF                  call setSilver
  4212 00002110 E9D6FBFFFF                  jmp type_
  4213                                  
  4214                                  taupeWord:     ; display a taupe word
  4215 00002115 E87AEEFFFF                  call setTaupe
  4216 0000211A E9CCFBFFFF                  jmp type_
  4217                                  
  4218                                  displayShannonFanoActions:  ;    * = number
  4219 0000211F [1C1F0000]                  dd extension            ; 0     extension token, remove space from previous word, do not change the colour
  4220 00002123 [C21E0000]                  dd yellowWord           ; 1     yellow "immediate" word
  4221 00002127 [AA1F0000]                  dd yellowNumber         ; 2  *  yellow "immediate" 32 bit number in the following pre-parsed cell
  4222 0000212B [571E0000]                  dd redWord              ; 3     red forth wordlist "colon" word
  4223 0000212F [AE1E0000]                  dd greenWord            ; 4     green compiled word
  4224 00002133 [8F1F0000]                  dd greenNumber          ; 5  *  green compiled 32 bit number in the following pre-parsed cell
  4225 00002137 [4D1F0000]                  dd greenShortNumber     ; 6  *  green compiled 27 bit number in the high bits of the token
  4226 0000213B [B81E0000]                  dd cyanWord             ; 7     cyan macro wordlist "colon" word
  4227 0000213F [9E1F0000]                  dd yellowShortNumber    ; 8  *  yellow "immediate" 27 bit number in the high bits of the token
  4228 00002143 [E61C0000]                  dd lowercase            ; 9     white lower-case comment
  4229 00002147 [CC1E0000]                  dd camelcase            ; A     first letter capital comment
  4230 0000214B [F11E0000]                  dd uppercase            ; B     white upper-case comment
  4231 0000214F [591F0000]                  dd magentaVariable      ; C     magenta variable
  4232 00002153 [0B210000]                  dd silverWord           ; D
  4233 00002157 [2F200000]                  dd blueWord             ; E     editor formatting commands
  4234 0000215B [15210000]                  dd taupeWord            ; F     new "string" token
  4235                                  
  4236                                  v_lineOffset:
  4237 0000215F 01000000                    dd 1    ; the top line of the display
  4238                                  
  4239                                  doColourBlind:  ; ( state -- )   \ add conventional Forth punctuation based on the newand last states
  4240 00002163 803D[05390000]00            cmp byte [ v_colourBlindMode ], 0x00
  4241 0000216A 740E                        jz .forward3
  4242 0000216C F605[88380000]01            test byte [ v_blk ], 0x01       ; do not display colourblind characters in odd numbered shadow blocks
  4243 00002173 7505                        jnz .forward3
  4244 00002175 E818FBFFFF                  call dword colourBlindAction    ; pass the new state to colourBlind so that extra characters can be added to the display
  4245                                      .forward3:
  4246                                      _DROP_
  4247 0000217A AD                  <1>  lodsd
  4248 0000217B C3                          ret
  4249                                  
  4250                                  plusList:   ; ( -- ) display the current colorForth block
  4251                                      _DUP_
  4252 0000217C 83EE04              <1>  sub esi, byte 0x04
  4253 0000217F 8906                <1>  mov [ esi ], _TOS_
  4254 00002181 31C0                        xor _TOS_, _TOS_
  4255 00002183 A3[FC1A0000]                mov [ currentState ], _TOS_
  4256 00002188 A3[001B0000]                mov [ lastState ], _TOS_
  4257                                      _DROP_
  4258 0000218D AD                  <1>  lodsd
  4259                                  
  4260 0000218E E813EDFFFF                  call setupText_                 ; setup the clip window for this display
  4261                                      _DUP_
  4262 00002193 83EE04              <1>  sub esi, byte 0x04
  4263 00002196 8906                <1>  mov [ esi ], _TOS_
  4264 00002198 A1[D0380000]                mov _TOS_, [ v_lcad ]
  4265 0000219D A3[C8380000]                mov [ v_cad ], _TOS_
  4266 000021A2 A1[88380000]                mov _TOS_, [ v_blk ]            ; get the current block number to be edited
  4267 000021A7 E8F8E6FFFF                  call blockToCellAddress         ; add the RELOCATED block number offset and convert to cell address
  4268 000021AC 89C7                        mov edi, _TOS_
  4269 000021AE 31C0                        xor _TOS_, _TOS_
  4270 000021B0 033D[5F210000]              add edi, [ v_lineOffset ]
  4271 000021B6 893D[CC380000]              mov [ v_pcad ], edi
  4272                                  .back:
  4273 000021BC 8B14BD00000000              mov edx, dword [ ( edi * 4 ) + 0x00 ]   ; edi is the display pointer and is a cell address
  4274 000021C3 E8AEF8FFFF                  call qring                      ; show one Shannon-Fano encoded word pointed to by edi
  4275 000021C8 47                          inc edi
  4276                                      ; adjust the number base according to bit 5 of the token value, only used by number display words
  4277 000021C9 C705[84380000]-             mov dword [ x_numberDisplay ], dotDecimal
  4278 000021CF [16110000]         
  4279 000021D3 F6C210                      test dl, 0x10
  4280 000021D6 740A                        jz .forward2
  4281 000021D8 C705[84380000]-             mov dword [ x_numberDisplay ], dotHex
  4282 000021DE [D8100000]         
  4283                                  .forward2:
  4284 000021E2 83E20F                      and edx, byte 0x0F
  4285                                      _DUP_
  4286 000021E5 83EE04              <1>  sub esi, byte 0x04
  4287 000021E8 8906                <1>  mov [ esi ], _TOS_
  4288 000021EA 89D0                        mov _TOS_, edx
  4289 000021EC E872FFFFFF                  call doColourBlind
  4290 000021F1 FF1495[1F210000]            call [ ( edx * 4 ) + displayShannonFanoActions ]
  4291 000021F8 EBC2                        jmp short .back
  4292                                  
  4293                                  refresh:
  4294 000021FA E85AE2FFFF                  call show
  4295 000021FF E8F7ECFFFF                  call page_
  4296 00002204 E8A9EFFFFF                  call displayBlockNumber
  4297 00002209 E86EFFFFFF                  call plusList
  4298                                      _DUP_
  4299 0000220E 83EE04              <1>  sub esi, byte 0x04
  4300 00002211 8906                <1>  mov [ esi ], _TOS_
  4301 00002213 B80F000000                  mov _TOS_, 0x0F
  4302 00002218 E846FFFFFF                  call doColourBlind             ; display the final colourblind punctuation, set up for next call of plusList
  4303 0000221D E9DEF0FFFF                  jmp dword displayTheKeyboard
  4304                                  
  4305 00002222 00<rept>                align 4, db 0   ; fill the gap with 0's
  4306                                  
  4307                                  actionColourTable:          ;    * = number
  4308 00002224 00E20000                    dd colour_orange        ; 0     extension token, remove space from previous word, do not change the colour
  4309 00002228 E0FF0000                    dd colour_yellow        ; 1     yellow "immediate" word
  4310 0000222C E0FF0000                    dd colour_yellow        ; 2  *  yellow "immediate" 32 bit number in the following pre-parsed cell
  4311 00002230 00F80000                    dd colour_red           ; 3     red forth wordlist "colon" word
  4312 00002234 00060000                    dd colour_green         ; 4     green compiled word
  4313 00002238 00060000                    dd colour_green         ; 5  *  green compiled 32 bit number in the following pre-parsed cell
  4314 0000223C 00060000                    dd colour_green         ; 6  *  green compiled 27 bit number in the high bits of the token
  4315 00002240 FF070000                    dd colour_cyan          ; 7     cyan macro wordlist "colon" word
  4316 00002244 E0FF0000                    dd colour_yellow        ; 8  *  yellow "immediate" 27 bit number in the high bits of the token
  4317 00002248 FFFF0000                    dd colour_white         ; 9     white lower-case comment
  4318 0000224C FFFF0000                    dd colour_white         ; A     first letter capital comment
  4319 00002250 FFFF0000                    dd colour_white         ; B     white upper-case comment
  4320 00002254 1FF80000                    dd colour_magenta       ; C     magenta variable
  4321 00002258 18C60000                    dd colour_silver        ; D
  4322 0000225C 1F000000                    dd colour_blue          ; E     editor formatting commands
  4323 00002260 E7B20000                    dd colour_taupe         ; F     new "string" token
  4324                                  
  4325                                  vector:
  4326 00002264 00000000                    dd 0  ; pointer to call table for keypad ( see keypd )
  4327                                  
  4328                                  action:
  4329 00002268 01                          db 1
  4330                                  
  4331 00002269 00<rept>                align 4, db 0   ; fill the gap with 0's
  4332                                  
  4333                                  cursorLeft:     ; ( -- )
  4334 0000226C FF0D[A8380000]              dec dword [ v_curs ]
  4335 00002272 7906                        jns .forward
  4336 00002274 FF05[A8380000]                  inc dword [ v_curs ]
  4337                                      .forward:
  4338 0000227A C3                          ret
  4339                                  
  4340                                  limitToEndOfBlock:
  4341 0000227B E8BF000000                  call countTokens
  4342 00002280 3B05[A8380000]              cmp _TOS_, dword [ v_curs ]
  4343 00002286 7905                        jns .forward
  4344 00002288 A3[A8380000]                    mov dword [ v_curs ], _TOS_
  4345                                      .forward:
  4346                                      _DROP_
  4347 0000228D AD                  <1>  lodsd
  4348 0000228E C3                          ret
  4349                                  
  4350                                  cursorRight:
  4351 0000228F FF05[A8380000]              inc dword [ v_curs ]
  4352 00002295 E8E1FFFFFF                  call limitToEndOfBlock
  4353 0000229A C3                          ret
  4354                                  
  4355                                  countAllTokens:     ; ( -- x ) \ counts red and magenta tokens and all tokens in the current block
  4356                                      _DUP_
  4357 0000229B 83EE04              <1>  sub esi, byte 0x04
  4358 0000229E 8906                <1>  mov [ esi ], _TOS_
  4359 000022A0 31C0                        xor _TOS_, _TOS_
  4360 000022A2 A3[B8380000]                mov dword [ v_numberOfMagentas ], _TOS_
  4361 000022A7 A3[C0380000]                mov dword [ v_numberOfRedAndMagentas ], _TOS_   ; count up Red and Magenta tokens
  4362 000022AC A3[C4380000]                mov dword [ v_numberOfTokens ], _TOS_           ; count all tokens
  4363 000022B1 A3[BC380000]                mov dword [ v_numberOfBigConstants ], _TOS_     ; count of 32 bit literal tokens
  4364                                  
  4365 000022B6 B900010000                  mov ecx, 0x00100      ; 256 x 4 byte cells = 1 block
  4366                                  .loop:
  4367                                  
  4368                                      _DUP_
  4369 000022BB 83EE04              <1>  sub esi, byte 0x04
  4370 000022BE 8906                <1>  mov [ esi ], _TOS_
  4371 000022C0 A1[C4380000]                mov _TOS_, [ v_numberOfTokens ]
  4372 000022C5 E8B7E6FFFF                  call nth_to_token
  4373 000022CA 89C3                        mov _SCRATCH_, _TOS_
  4374                                      _DROP_
  4375 000022CC AD                  <1>  lodsd
  4376 000022CD 81FB00000000                cmp _SCRATCH_, 0x00
  4377 000022D3 745E                        je .forward         ; exit if the token value is 0, means end of block
  4378                                  
  4379 000022D5 FF05[C4380000]              inc dword [ v_numberOfTokens ]
  4380                                  
  4381 000022DB 81E30F000000                and _SCRATCH_, 0x0F     ; look at the token type
  4382                                  
  4383 000022E1 81FB03000000                cmp _SCRATCH_, 0x03     ; red token
  4384 000022E7 7506                        jne .forwardRed
  4385 000022E9 FF05[C0380000]                  inc dword [ v_numberOfRedAndMagentas ]
  4386                                      .forwardRed:
  4387                                  
  4388 000022EF 81FB0C000000                cmp _SCRATCH_, 0x0C     ; magenta token
  4389 000022F5 7512                        jne .forwardMagenta
  4390 000022F7 FF05[C0380000]                  inc dword [ v_numberOfRedAndMagentas ]
  4391 000022FD FF05[B8380000]                  inc dword [ v_numberOfMagentas ]    ; correction for magenta variables
  4392 00002303 FF05[C4380000]                  inc dword [ v_numberOfTokens ]      ; step over the Magenta variable data cell
  4393                                      .forwardMagenta:
  4394                                  
  4395 00002309 81FB02000000                cmp _SCRATCH_, 0x02     ; yellow 32 bit literal
  4396 0000230F 750C                        jne .forwardBig
  4397 00002311 FF05[BC380000]                  inc dword [ v_numberOfBigConstants ]    ; correction for literal constants
  4398 00002317 FF05[C4380000]                  inc dword [ v_numberOfTokens ]          ; step over the data cell
  4399                                      .forwardBig:
  4400                                  
  4401 0000231D 81FB05000000                cmp _SCRATCH_, 0x05     ; green 32 bit literal
  4402 00002323 750C                        jne .forwardBig2
  4403 00002325 FF05[BC380000]                  inc dword [ v_numberOfBigConstants ]    ; correction for literal constants
  4404 0000232B FF05[C4380000]                  inc dword [ v_numberOfTokens ]          ; step over the data cell
  4405                                      .forwardBig2:
  4406                                  
  4407 00002331 E288                        loop .loop
  4408                                  .forward:               ; found the end of the block
  4409                                  ;    mov _TOS_, dword [ v_numberOfRedAndMagentas ]
  4410 00002333 C3                          ret
  4411                                  
  4412                                  countRedAndMagentaTokens:     ; ( -- n ) \ counts red and magenta tokens in the current block
  4413 00002334 E862FFFFFF                  call countAllTokens
  4414 00002339 A1[C0380000]                mov _TOS_, dword [ v_numberOfRedAndMagentas ]
  4415 0000233E C3                          ret
  4416                                  
  4417                                  countTokens:     ; ( -- n ) \ counts all tokens up to the end of the current block
  4418 0000233F E857FFFFFF                  call countAllTokens
  4419 00002344 A1[C4380000]                mov _TOS_, dword [ v_numberOfTokens ]
  4420 00002349 2B05[B8380000]              sub _TOS_, dword [ v_numberOfMagentas ]
  4421 0000234F 2B05[BC380000]              sub _TOS_, dword [ v_numberOfBigConstants ]
  4422 00002355 C3                          ret
  4423                                  
  4424                                  ; *****************************************************************************
  4425                                  
  4426                                  cursorDownToNth:     ; ( -- ) \ step down to after the v_cursLine'th red or magenta token
  4427                                      _DUP_
  4428 00002356 83EE04              <1>  sub esi, byte 0x04
  4429 00002359 8906                <1>  mov [ esi ], _TOS_
  4430 0000235B 31C0                        xor _TOS_, _TOS_
  4431 0000235D A3[B8380000]                mov dword [ v_numberOfMagentas ], _TOS_
  4432 00002362 A3[A8380000]                mov dword [ v_curs ], _TOS_
  4433 00002367 A3[BC380000]                mov dword [ v_numberOfBigConstants ], _TOS_
  4434                                  
  4435 0000236C A1[B0380000]                mov dword _TOS_, [ v_cursLine ]
  4436 00002371 A3[B4380000]                mov dword [ v_curs_number_down ], _TOS_
  4437                                  
  4438 00002376 B900010000                  mov ecx, 0x00100      ; 256 x 4 byte cells = 1 block
  4439                                  .loop:
  4440                                  
  4441 0000237B 813D[B4380000]0000-         cmp dword [ v_curs_number_down ], 0x00  ; test for zero
  4442 00002383 0000               
  4443 00002385 746C                        je .forward     ; jump to the end if  v_curs_number_down  reaches zero
  4444                                  
  4445                                      _DUP_
  4446 00002387 83EE04              <1>  sub esi, byte 0x04
  4447 0000238A 8906                <1>  mov [ esi ], _TOS_
  4448 0000238C A1[A8380000]                mov _TOS_, [ v_curs ]
  4449 00002391 E8EBE5FFFF                  call nth_to_token
  4450 00002396 89C3                        mov _SCRATCH_, _TOS_
  4451                                      _DROP_
  4452 00002398 AD                  <1>  lodsd
  4453 00002399 81FB00000000                cmp _SCRATCH_, 0x00
  4454 0000239F 7464                        je .endOfBlock         ; exit if the token value is 0, means end of block
  4455                                  
  4456 000023A1 FF05[A8380000]              inc dword [ v_curs ]
  4457                                  
  4458 000023A7 81E30F000000                and _SCRATCH_, 0x0F     ; look at the token type
  4459                                  
  4460 000023AD 81FB03000000                cmp _SCRATCH_, 0x03     ; red token
  4461 000023B3 7506                        jne .forwardRed
  4462 000023B5 FF0D[B4380000]                  dec dword [ v_curs_number_down ]
  4463                                      .forwardRed:
  4464                                  
  4465 000023BB 81FB0C000000                cmp _SCRATCH_, 0x0C     ; magenta token
  4466 000023C1 7512                        jne .forwardMagenta
  4467 000023C3 FF0D[B4380000]                  dec dword [ v_curs_number_down ]
  4468 000023C9 FF05[B8380000]                  inc dword [ v_numberOfMagentas ]    ; correction for magenta variables
  4469 000023CF FF05[A8380000]                  inc dword [ v_curs ]                ; step over the Magenta variable data cell
  4470                                      .forwardMagenta:
  4471                                  
  4472 000023D5 81FB02000000                cmp _SCRATCH_, 0x02     ; yellow 32 bit literal
  4473 000023DB 7408                        je .forwardBig
  4474                                  
  4475 000023DD 81FB05000000                cmp _SCRATCH_, 0x05     ; green 32 bit literal
  4476 000023E3 750C                        jne .forwardBig2
  4477                                      .forwardBig:
  4478 000023E5 FF05[BC380000]                  inc dword [ v_numberOfBigConstants ]    ; correction for literal constants
  4479 000023EB FF05[A8380000]                  inc dword [ v_curs ]                    ; step over the data cell
  4480                                      .forwardBig2:
  4481                                  
  4482 000023F1 E288                        loop .loop
  4483                                  .forward:               ; found the right number of red or magenta tokens, so exit
  4484 000023F3 8B1D[B8380000]              mov _SCRATCH_, dword [ v_numberOfMagentas ]
  4485 000023F9 031D[BC380000]              add _SCRATCH_, dword [ v_numberOfBigConstants ]
  4486 000023FF 291D[A8380000]              sub dword [ v_curs ], _SCRATCH_  ; the correction for magenta variables
  4487                                  .endOfBlock:
  4488 00002405 E871FEFFFF                  call limitToEndOfBlock
  4489                                      _DROP_
  4490 0000240A AD                  <1>  lodsd
  4491 0000240B C3                          ret
  4492                                  
  4493                                  cursorUp:     ; ( -- ) \ step down to after the next red token, or after 0x16 steps, or until the end of the block
  4494 0000240C FF0D[B0380000]              dec dword [ v_cursLine ]
  4495 00002412 750A                        jnz .forward
  4496 00002414 C705[B0380000]0000-         mov dword [ v_cursLine ], 0x00
  4497 0000241C 0000               
  4498                                  .forward:
  4499                                  ;    mov dword [ v_cursLine ], 0x03
  4500 0000241E E833FFFFFF                  call cursorDownToNth
  4501 00002423 C3                          ret
  4502                                  
  4503                                  cursorDown:     ; ( -- ) \ step down to after the next red token, or after 0x16 steps, or until the end of the block
  4504 00002424 FF05[B0380000]              inc dword [ v_cursLine ]
  4505 0000242A E805FFFFFF                  call countRedAndMagentaTokens
  4506 0000242F 40                          inc dword _TOS_     ; add one so that we can go past the last token to the end of the block
  4507 00002430 3905[B0380000]              cmp dword [ v_cursLine ], _TOS_
  4508 00002436 7805                        js .forward
  4509 00002438 A3[B0380000]                mov dword [ v_cursLine ], _TOS_
  4510                                  .forward:
  4511                                      _DROP_
  4512 0000243D AD                  <1>  lodsd
  4513                                   ;   mov dword [ v_cursLine ], 0x02
  4514 0000243E E813FFFFFF                  call cursorDownToNth
  4515 00002443 C3                          ret
  4516                                  
  4517                                  cursorEnd:     ; ( -- )
  4518 00002444 E8EBFEFFFF                  call countRedAndMagentaTokens
  4519 00002449 40                          inc dword _TOS_     ; add one so that we can go past the last token to the end of the block
  4520 0000244A A3[B0380000]                mov dword [ v_cursLine ], _TOS_
  4521                                      _DROP_
  4522 0000244F AD                  <1>  lodsd
  4523 00002450 E801FFFFFF                  call cursorDownToNth
  4524 00002455 E821FEFFFF                  call limitToEndOfBlock
  4525 0000245A C3                          ret
  4526                                  
  4527                                  cursorHome:     ; ( -- )
  4528 0000245B 31DB                        xor _SCRATCH_, _SCRATCH_
  4529 0000245D 891D[B8380000]              mov dword [ v_numberOfMagentas ], _SCRATCH_
  4530 00002463 891D[A8380000]              mov dword [ v_curs ], _SCRATCH_                 ; the graphics cursor for drawing the block
  4531 00002469 891D[5F210000]              mov dword [ v_lineOffset ], _SCRATCH_           ; the cursor position to start drawing the block
  4532 0000246F 891D[B5140000]              mov dword [ v_lineOffsetTablePtr ], _SCRATCH_   ; a pointer to the cursor for each line in the display
  4533 00002475 891D[B8380000]              mov dword [ v_numberOfMagentas ], _SCRATCH_     ; count of Magenta variables displayed so far in the edited block
  4534 0000247B 891D[B0380000]              mov dword [ v_cursLine ], _SCRATCH_
  4535 00002481 C3                          ret
  4536                                  
  4537                                  nextBlock:     ; ( -- )
  4538 00002482 8305[88380000]02            add dword [ v_blk ], byte 0x02
  4539 00002489 E82BF0FFFF                  call lineOffsetZero
  4540 0000248E C3                          ret
  4541                                  
  4542                                  previousBlock:
  4543 0000248F 833D[88380000]22            cmp dword [ v_blk ], byte ( START_BLOCK_NUMBER + 2 )
  4544 00002496 7807                        js .forward
  4545 00002498 832D[88380000]02            sub dword [ v_blk ], byte 0x02
  4546                                  .forward:
  4547 0000249F E815F0FFFF                  call lineOffsetZero
  4548 000024A4 C3                          ret
  4549                                  
  4550                                  otherBlock:
  4551 000024A5 8B0D[88380000]              mov ecx, [ v_blk ]
  4552 000024AB 870D[8C380000]              xchg ecx, [ v_otherBlock ]
  4553 000024B1 890D[88380000]              mov [ v_blk ], ecx
  4554 000024B7 C3                          ret
  4555                                  
  4556                                  shadow:     ; alternate between source and shadow blocks
  4557 000024B8 8335[88380000]01            xor dword [ v_blk ], byte 0x01
  4558 000024BF C3                          ret
  4559                                  
  4560                                  insert0:
  4561 000024C0 8B0D[D0380000]              mov ecx, [ v_lcad ]
  4562 000024C6 030D[30390000]              add ecx, [ v_words ]
  4563 000024CC 330D[D0380000]              xor ecx, [ v_lcad ]
  4564 000024D2 81E100FFFFFF                and ecx, 0xFFFFFF00
  4565 000024D8 740A                        jz insert1
  4566 000024DA 8B0D[30390000]              mov ecx, [ v_words ]
  4567                                  .back:
  4568                                      _DROP_
  4569 000024E0 AD                  <1>  lodsd
  4570 000024E1 E2FD                        loop .back
  4571 000024E3 C3                          ret
  4572                                  
  4573                                  insert1:
  4574 000024E4 56                          push esi
  4575 000024E5 8B35[D0380000]              mov esi, [ v_lcad ]
  4576 000024EB 89F1                        mov ecx, esi
  4577 000024ED 4E                          dec esi
  4578 000024EE 89F7                        mov edi, esi
  4579 000024F0 033D[30390000]              add edi, [ v_words ]
  4580 000024F6 C1E702                      shl edi, 0x02
  4581 000024F9 2B0D[C8380000]              sub ecx, [ v_cad ]
  4582 000024FF 7807                        js .forward
  4583 00002501 C1E602                      shl esi, 0x02
  4584 00002504 FD                          std
  4585 00002505 F3A5                        rep  movsd                  ; copy ecx 32 bit words from ds:esi to es:edi
  4586 00002507 FC                          cld
  4587                                  .forward:
  4588 00002508 5E                          pop esi
  4589 00002509 C1EF02                      shr edi, 0x02
  4590 0000250C 47                          inc edi
  4591 0000250D 893D[A8380000]              mov [ v_curs ], edi
  4592 00002513 8B0D[30390000]              mov ecx, [ v_words ]
  4593                                  .back:
  4594 00002519 4F                          dec edi
  4595 0000251A 8904BD00000000              mov [ ( edi * 4 ) + 0x00 ], _TOS_
  4596                                      _DROP_
  4597 00002521 AD                  <1>  lodsd
  4598 00002522 E2F5                        loop .back
  4599 00002524 C3                          ret
  4600                                  
  4601                                  insert:
  4602 00002525 E896FFFFFF                  call insert0
  4603 0000252A 8A0D[68220000]              mov cl, [ action ]
  4604 00002530 300CBD00000000              xor [ edi * 4 + 0x00 ],cl
  4605 00002537 80F903                      cmp cl, 0x03        ; if we are a red token
  4606 0000253A 751A                        jnz .forward
  4607 0000253C C605[68220000]04            mov byte [ action ], 0x04   ; switch to green
  4608 00002543 C705[20390000]0006-         mov dword [ keyboard_colour ], colour_green
  4609 0000254B 0000               
  4610 0000254D 66C705[08390000]0D-         mov word [ v_hintChar ], 0x0D    ; mark the green keypad with a 'g'
  4611 00002555 00                 
  4612                                      .forward:
  4613 00002556 C3                          ret
  4614                                  
  4615                                  _word1:
  4616 00002557 8F05[28390000]              pop dword [ aword ]
  4617 0000255D C705[28390000]-             mov dword [ aword ], ex1
  4618 00002563 [E7060000]         
  4619 00002567 C3                          ret
  4620                                  
  4621                                  _word:
  4622 00002568 C705[28390000]-             mov dword [ aword ], _word1
  4623 0000256E [57250000]         
  4624 00002572 E92FF4FFFF                  jmp dword accept
  4625                                  
  4626                                  tokenAction_1:
  4627                                      _DUP_
  4628 00002577 83EE04              <1>  sub esi, byte 0x04
  4629 0000257A 8906                <1>  mov [ esi ], _TOS_
  4630 0000257C B801000000                  mov _TOS_, 0x01
  4631 00002581 803D[68220000]04            cmp byte [ action ], 0x04
  4632 00002588 7402                        jz .forward2
  4633 0000258A B003                        mov al, 0x03
  4634                                  .forward2:
  4635 0000258C 833D[18390000]0A            cmp dword [ base ], byte 0x0A
  4636 00002593 7402                        jz .forward
  4637 00002595 3410                        xor al, 0x10
  4638                                  .forward:
  4639                                      _SWAP_
  4640 00002597 8706                <1>  xchg _TOS_, [ esi ]
  4641 00002599 C705[30390000]0200-         mov dword [ v_words ], 0x02
  4642 000025A1 0000               
  4643 000025A3 EB80                        jmp short insert
  4644                                  
  4645                                  tokenAction:
  4646 000025A5 F605[68220000]0A            test byte [ action ], 0x0A
  4647 000025AC 753C                        jnz .forward
  4648 000025AE 89C2                        mov edx, _TOS_
  4649 000025B0 81E2000000FC                and edx, 0xFC000000
  4650 000025B6 7408                        jz .forward2
  4651 000025B8 81FA000000FC                cmp edx, 0xFC000000
  4652 000025BE 75B7                        jnz tokenAction_1
  4653                                  .forward2:
  4654 000025C0 C1E005                      shl _TOS_, 0x05
  4655 000025C3 3402                        xor al, 0x02
  4656 000025C5 803D[68220000]04            cmp byte [ action ], 0x04
  4657 000025CC 7402                        jz .forwardBack
  4658 000025CE 340B                        xor al, 0x0B
  4659                                  .forwardBack:
  4660 000025D0 833D[18390000]0A            cmp dword [ base ], byte 0x0A
  4661 000025D7 7402                        jz .forward4
  4662 000025D9 3410                        xor al, 0x10
  4663                                  .forward4:
  4664 000025DB C705[30390000]0100-         mov dword [ v_words ], 0x01
  4665 000025E3 0000               
  4666 000025E5 E93BFFFFFF                  jmp insert
  4667                                  .forward:
  4668 000025EA 803D[68220000]09            cmp byte [ action ],  0x09
  4669 000025F1 750C                        jnz .forward3
  4670 000025F3 89C2                        mov edx, _TOS_
  4671 000025F5 C1E205                      shl edx, 0x05
  4672 000025F8 C1FA05                      sar edx, 0x05
  4673 000025FB 39C2                        cmp edx, _TOS_
  4674 000025FD 7402                        jz .forward5
  4675                                  .forward3:
  4676                                      _DROP_
  4677 000025FF AD                  <1>  lodsd
  4678 00002600 C3                          ret
  4679                                  .forward5:
  4680 00002601 C1E005                      shl _TOS_, 0x05
  4681 00002604 3406                        xor al, 0x06
  4682 00002606 EBC8                        jmp short .forwardBack
  4683                                  
  4684                                  enstack:
  4685                                      _DUP_
  4686 00002608 83EE04              <1>  sub esi, byte 0x04
  4687 0000260B 8906                <1>  mov [ esi ], _TOS_
  4688 0000260D A1[C8380000]                mov _TOS_, [ v_cad ]
  4689 00002612 2B05[CC380000]              sub _TOS_, [ v_pcad ]
  4690 00002618 7426                        jz .forward
  4691 0000261A 89C1                        mov ecx, _TOS_
  4692 0000261C 92                          xchg _TOS_, edx
  4693 0000261D 56                          push esi
  4694 0000261E 8B35[C8380000]              mov esi, [ v_cad ]
  4695 00002624 8D34B5FCFFFFFF              lea esi, [esi*4-0x04]
  4696 0000262B 8B3D[D4380000]              mov edi, [ v_trash ]
  4697                                  .back:
  4698 00002631 FD                          std
  4699                                      _DROP_
  4700 00002632 AD                  <1>  lodsd
  4701 00002633 FC                          cld
  4702 00002634 AB                          stosd
  4703 00002635 E2FA                        loop .back
  4704 00002637 92                          xchg _TOS_, edx
  4705 00002638 AB                          stosd
  4706 00002639 893D[D4380000]              mov [ v_trash], edi
  4707 0000263F 5E                          pop esi
  4708                                  .forward:
  4709                                      _DROP_
  4710 00002640 AD                  <1>  lodsd
  4711 00002641 C3                          ret
  4712                                  
  4713                                  deleteAction:
  4714 00002642 E8C1FFFFFF                  call enstack
  4715 00002647 8B3D[CC380000]              mov edi, [ v_pcad ]
  4716 0000264D 8B0D[D0380000]              mov ecx, [ v_lcad ]
  4717 00002653 29F9                        sub ecx, edi
  4718 00002655 C1E702                      shl edi, 0x02
  4719 00002658 56                          push esi
  4720 00002659 8B35[C8380000]              mov esi, [ v_cad ]
  4721 0000265F C1E602                      shl esi, 0x02
  4722 00002662 F3A5                        rep  movsd                  ; copy ecx 32 bit words from ds:esi to es:edi
  4723 00002664 5E                          pop esi
  4724 00002665 E902FCFFFF                  jmp dword cursorLeft
  4725                                  
  4726                                  act0:
  4727 0000266A E899FFFFFF                  call enstack
  4728 0000266F E9F8FBFFFF                  jmp dword cursorLeft
  4729                                  
  4730                                  yellowAction:
  4731 00002674 B001                        mov al, 0x01
  4732 00002676 EB22                        jmp short actt
  4733                                  
  4734                                  redAction:  ; red : start creating a new definition
  4735 00002678 B003                        mov al, 0x03
  4736 0000267A EB1E                        jmp short actt
  4737                                  
  4738                                  greenAction:   ; green, start compiling an existing definition
  4739 0000267C B004                        mov al, 0x04
  4740 0000267E EB1A                        jmp short actt
  4741                                  
  4742                                  textAction:
  4743 00002680 B009                        mov al, 0x09
  4744 00002682 EB16                        jmp short actt
  4745                                  
  4746                                  CapitalAction:
  4747 00002684 B00A                        mov al, 0x0A
  4748 00002686 EB12                        jmp short actt
  4749                                  
  4750                                  capitalS_Action:
  4751 00002688 B00B                        mov al, 0x0B
  4752 0000268A EB0E                        jmp short actt
  4753                                  
  4754                                  silverAction:
  4755 0000268C B00D                        mov al, 0x0D
  4756 0000268E EB0A                        jmp short actt
  4757                                  
  4758                                  blueAction:
  4759 00002690 B00E                        mov al, 0x0E
  4760 00002692 EB06                        jmp short actt
  4761                                  
  4762                                  cyanAction:
  4763 00002694 B007                        mov al, 0x07
  4764 00002696 EB02                        jmp short actt
  4765                                  
  4766                                  taupeAction:
  4767 00002698 B00F                        mov al, 0x0F
  4768                                  ;    jmp short actt
  4769                                  
  4770                                  
  4771                                  actt:   ; ( action -- )
  4772 0000269A A2[68220000]                mov [ action ], al
  4773 0000269F C705[28390000]-             mov dword [ aword ], insert
  4774 000026A5 [25250000]         
  4775 000026A9 8B0485[24220000]            mov _TOS_, [ ( _TOS_ * 4 ) + actionColourTable ]
  4776                                  actn:
  4777 000026B0 A3[20390000]                mov [ keyboard_colour ], _TOS_
  4778 000026B5 58                          pop _TOS_
  4779                                      _DROP_
  4780 000026B6 AD                  <1>  lodsd
  4781 000026B7 E9EAF2FFFF                  jmp dword accept
  4782                                  
  4783                                  magentaAction:   ; magenta variable action
  4784 000026BC C605[68220000]0C            mov byte [ action ], 0x0C
  4785 000026C3 B81FF80000                  mov _TOS_, colour_magenta
  4786 000026C8 C705[28390000]-             mov dword [ aword ], .forward
  4787 000026CE [D4260000]         
  4788 000026D2 EBDC                        jmp short actn
  4789                                      .forward:
  4790                                      _DUP_
  4791 000026D4 83EE04              <1>  sub esi, byte 0x04
  4792 000026D7 8906                <1>  mov [ esi ], _TOS_
  4793 000026D9 31C0                        xor _TOS_, _TOS_
  4794 000026DB FF05[30390000]              inc dword [ v_words ]
  4795 000026E1 E93FFEFFFF                  jmp dword insert
  4796                                  
  4797                                  editorExit:       ; ( -- )   \ leave the editor
  4798 000026E6 58                          pop _TOS_
  4799                                      _DROP_
  4800 000026E7 AD                  <1>  lodsd
  4801 000026E8 C705[28390000]-             mov dword [ aword ], ex1
  4802 000026EE [E7060000]         
  4803 000026F2 C705[2C390000]-             mov dword [ anumber ], nul
  4804 000026F8 [00040000]         
  4805 000026FC C605[92170000]00            mov byte [ alpha0 + ( 4 * 4 ) ], 0x00
  4806 00002703 C705[86170000]-             mov dword [ alpha0 + 4 ], nul0
  4807 00002709 [97190000]         
  4808 0000270D C705[20390000]E0FF-         mov dword [ keyboard_colour ], colour_yellow
  4809 00002715 0000               
  4810 00002717 C605[07390000]00            mov byte [ v_acceptMode ], 0x00
  4811 0000271E C605[08390000]00            mov byte [ v_hintChar ], 0x00
  4812 00002725 E97CF2FFFF                  jmp dword accept
  4813                                  
  4814                                  destack:
  4815 0000272A 8B15[D4380000]              mov edx, [ v_trash ]
  4816 00002730 81FA60130000                cmp edx, TRASH_BUFFER
  4817 00002736 7501                        jnz .forward
  4818 00002738 C3                          ret
  4819                                  .forward:
  4820 00002739 83EA08                      sub edx, byte 0x08
  4821 0000273C 8B4A04                      mov ecx, [edx+0x04]
  4822 0000273F 890D[30390000]              mov [ v_words ], ecx
  4823                                  .back:
  4824                                      _DUP_
  4825 00002745 83EE04              <1>  sub esi, byte 0x04
  4826 00002748 8906                <1>  mov [ esi ], _TOS_
  4827 0000274A 8B02                        mov _TOS_, [edx]
  4828 0000274C 83EA04                      sub edx, byte 0x04
  4829 0000274F E2F4                        loop .back
  4830 00002751 83C204                      add edx, byte 0x04
  4831 00002754 8915[D4380000]              mov [ v_trash ], edx
  4832 0000275A E961FDFFFF                  jmp dword insert0
  4833                                  
  4834                                  editorActionTable:
  4835 0000275F [00040000]-                 dd nul           , deleteAction    , editorExit    , destack      ;
  4836 00002763 [42260000]-        
  4837 00002767 [E6260000]-        
  4838 0000276B [2A270000]         
  4839 0000276F [74260000]-                 dd yellowAction  , redAction       , greenAction   , shadow       ; y r g *
  4840 00002773 [78260000]-        
  4841 00002777 [7C260000]-        
  4842 0000277B [B8240000]         
  4843 0000277F [6C220000]-                 dd cursorLeft    , cursorUp        , cursorDown    , cursorRight  ; l u d r
  4844 00002783 [0C240000]-        
  4845 00002787 [24240000]-        
  4846 0000278B [8F220000]         
  4847 0000278F [8F240000]-                 dd previousBlock , magentaAction   , cyanAction    , nextBlock    ; - m c +
  4848 00002793 [BC260000]-        
  4849 00002797 [94260000]-        
  4850 0000279B [82240000]         
  4851 0000279F [00040000]-                 dd nul           , capitalS_Action , CapitalAction , textAction   ; _ S C t
  4852 000027A3 [88260000]-        
  4853 000027A7 [84260000]-        
  4854 000027AB [80260000]         
  4855 000027AF [00040000]-                 dd nul           , nul             , nul           , otherBlock   ; _ _ _ j
  4856 000027B3 [00040000]-        
  4857 000027B7 [00040000]-        
  4858 000027BB [A5240000]         
  4859                                  ekbd0:
  4860 000027BF [8C260000]-                 dd silverAction  , blueAction      , taupeAction   , act0         ; a b _ _
  4861 000027C3 [90260000]-        
  4862 000027C7 [98260000]-        
  4863 000027CB [6A260000]         
  4864 000027CF 15250700                    db 0x15          , 0x25            , 0x07          , 0x00         ; four characters to display on the bottom line of the keyboard
  4865                                  
  4866                                  editorKeyTableHintChars:    ; display the current edit colour and mode in the bottom right hand corner of the keyboard
  4867 000027D3 00000000                    db 0x00, 0x00, 0x00, 0x00  ;
  4868 000027D7 0B010D00                    db 0x0B, 0x01, 0x0D, 0x00  ; y r g _    ; yellow red green *toggle            
  4869 000027DB 00000000                    db 0x00, 0x00, 0x00, 0x00  ; l u d r    : left up down right                  
  4870 000027DF 00090A00                    db 0x00, 0x09, 0x0A, 0x00  ; - m c +    ; - magenta cyan +                    
  4871 000027E3 00383A02                    db 0x00, 0x38, 0x3A, 0x02  ; _ S C t    ; ___ CAPITALS Capital text           
  4872 000027E7 00000000                    db 0x00, 0x00, 0x00, 0x00  ; _ _ _ j    ; ___ ___ ___ jump to previous block  
  4873 000027EB 08130200                    db 0x08, 0x13, 0x02, 0x00  ; s b t _    ; silver blue taupe ___               
  4874                                  
  4875                                  ; Editor keypad display
  4876                                  ; _ S C t  y r g *
  4877                                  ; c d f j  l u d r
  4878                                  ; s b t k  - m c +      ; silver blue taupe change-colour
  4879                                  ;     x . i
  4880                                  
  4881                                  editorKeyboard:         ; the main editor keyboard icons
  4882 000027EF 0B010D2D                    db 0x0B, 0x01, 0x0D, 0x2D  ; y r g *    ; yellow red green *toggle
  4883 000027F3 0C161001                    db 0x0C, 0x16, 0x10, 0x01  ; l u d r    : left up down right
  4884 000027F7 23090A2B                    db 0x23, 0x09, 0x0A, 0x2B  ; - m c +    ; - magenta cyan +
  4885 000027FB 00383A02                    db 0x00, 0x38, 0x3A, 0x02  ; _ S C t    ; ___ CAPITALS Capital text
  4886 000027FF 00000022                    db 0x00, 0x00, 0x00, 0x22  ; _ _ _ j    ; ___ ___ ___ jump to previous block  db 0x00, 0x10, 0x0E, 0x22  ; _ d f j
  4887 00002803 08130200                    db 0x08, 0x13, 0x02, 0x00  ; s b t _    ; silver blue taupe ___
  4888                                  
  4889                                  set_e_main:
  4890 00002807 C705[14390000]-             mov dword [ shiftAction ], ekbd0
  4891 0000280D [BF270000]         
  4892 00002811 C705[10390000]-             mov dword [ currentKeyboardIcons ], ( editorKeyboard - 4 )
  4893 00002817 [EB270000]         
  4894 0000281B C705[20390000]E0FF-         mov dword [ keyboard_colour ], colour_yellow
  4895 00002823 0000               
  4896 00002825 C3                          ret
  4897                                  
  4898                                  edit0:
  4899                                      _DROP_
  4900 00002826 AD                  <1>  lodsd
  4901 00002827 EB39                        jmp short edit2
  4902                                  
  4903                                  edit_:   ; ( n -- )   \ edit block n
  4904 00002829 8B0D[88380000]              mov ecx, [ v_blk ]
  4905 0000282F 890D[8C380000]              mov [ v_otherBlock ], ecx
  4906 00002835 A3[88380000]                mov [ v_blk ], _TOS_              ; move TOS to blk variable
  4907                                      _DROP_
  4908 0000283A AD                  <1>  lodsd
  4909                                  e_:
  4910 0000283B C605[07390000]FF            mov byte [ v_acceptMode ], 0xFF
  4911 00002842 E8B3F9FFFF                  call refresh
  4912                                  plus_e:
  4913 00002847 C705[2C390000]-             mov dword [ anumber ], tokenAction
  4914 0000284D [A5250000]         
  4915 00002851 C605[92170000]25            mov byte [ alpha0+4*4 ], 0x25
  4916 00002858 C705[86170000]-             mov dword [ alpha0 + 4 ], edit0
  4917 0000285E [26280000]         
  4918                                  edit2:
  4919 00002862 E8A0FFFFFF                  call set_e_main
  4920                                      .back:
  4921 00002867 E82EF1FFFF                  call clearHintChar
  4922 0000286C E8D2EDFFFF                  call get_key_
  4923 00002871 50                          push _TOS_
  4924 00002872 BB[D3270000]                mov _SCRATCH_, editorKeyTableHintChars
  4925 00002877 8A0403                      mov byte al, [ _SCRATCH_ + _TOS_ ]
  4926 0000287A A3[08390000]                mov [ v_hintChar ], _TOS_
  4927 0000287F 58                          pop _TOS_
  4928 00002880 FF1485[5F270000]            call [ ( _TOS_ * 4 ) + editorActionTable ]
  4929                                      _DROP_
  4930 00002887 AD                  <1>  lodsd
  4931 00002888 EBDD                        jmp short .back
  4932                                  
  4933                                  convertAddress:     ; ( a32 -- )    set up the block at the given 32 bit cell address, including the cursor position
  4934 0000288A 89C3                        mov _SCRATCH_, _TOS_
  4935 0000288C 81E3FF000000                and _SCRATCH_, 0x00FF
  4936 00002892 891D[A8380000]              mov [ v_curs ], _SCRATCH_   ; cell offset in block
  4937 00002898 E811E0FFFF                  call cellAddressToBlock
  4938 0000289D A3[88380000]                mov [ v_blk ], _TOS_
  4939                                      _DROP_
  4940 000028A2 AD                  <1>  lodsd
  4941 000028A3 C3                          ret
  4942                                  
  4943                                  editAddress:    ; ( a32 -- )    edit the block at the given 32 bit cell address, including the cursor position
  4944 000028A4 E8E1FFFFFF                  call convertAddress
  4945 000028A9 E8BEECFFFF                  call abort_e2           ; abort and show the editor display
  4946 000028AE C3                          ret
  4947                                  
  4948                                  keypd:    ; display the keypad vectors and display characters at the address on top of the return stack
  4949 000028AF 5A                          pop edx                             ; keypd is followed by call table then keymap
  4950 000028B0 8915[64220000]              mov [ vector ], edx                 ; edx points to the next colorForth word to be executed
  4951 000028B6 81C28C000000                add edx, ( 28 * 5 )                 ; 28 keys, 5 bytes per compiled call
  4952 000028BC 8915[10390000]              mov [ currentKeyboardIcons ], edx
  4953 000028C2 83EA10                      sub edx, byte +16
  4954 000028C5 8915[14390000]              mov [ shiftAction ], edx
  4955                                  .back:
  4956 000028CB E873EDFFFF                  call get_key_ ; Pause
  4957 000028D0 8B15[64220000]              mov edx, [ vector ]
  4958 000028D6 01C2                        add edx, _TOS_
  4959 000028D8 8D548205                    lea edx, [ ( _TOS_ * 4 ) + edx + 0x05 ]
  4960 000028DC 0352FC                      add edx, [ edx - 0x04 ]
  4961                                      _DROP_
  4962 000028DF AD                  <1>  lodsd
  4963                                  pad1:
  4964 000028E0 FFD2                        call edx
  4965 000028E2 EBE7                        jmp short keypd.back
  4966                                  
  4967                                  ; *****************************************************************************
  4968                                  ; QWERTY support
  4969                                  ; *****************************************************************************
  4970                                  
  4971                                  qwertyKeyboard:
  4972 000028E4 00000000                    dd 0
  4973 000028E8 00000000                    dd 0
  4974 000028EC 00000000                    dd 0
  4975 000028F0 170F0401                    dd 0x01040f17       ; 'qwer'
  4976 000028F4 00000000                    dd 0
  4977 000028F8 00000000                    dd 0
  4978                                  
  4979                                  qwertToggleBase:
  4980 000028FC 8135[1C390000]7F00-         xor dword [ current ], ((setDecimalMode - $$) ^ (setHexMode - $$))
  4981 00002904 0000               
  4982 00002906 8035[B6170000]2F            xor byte [ ( numb0 + 12 ) ], 0x2F
  4983                                  qwertToggleBase1:
  4984                                  ;    call [ current ]
  4985                                  ;    mov dword [ qwertyKeyboard ], 0x00           ; '' => decimal
  4986                                  ;    cmp dword [ base ], byte +0x10
  4987                                  ;    jnz .forward
  4988                                  ;    mov dword [ qwertyKeyboard ], 0x00150414     ; 'hex'
  4989                                  ; .forward:
  4990                                  ;    mov dword [ currentKeyboardIcons ], pad1
  4991                                  ;    mov dword [ shiftAction ], qwertyKeyboard
  4992 0000290D C3                          ret
  4993                                  
  4994                                  qwertyAction4:
  4995 0000290E E8E9FFFFFF                  call qwertToggleBase
  4996 00002913 E979000000                  jmp qwertyAction3
  4997                                  
  4998                                  qwertyActionTable:
  4999 00002918 [24190000]-                 dd endn, endn, xn, qwertyAction3, qwertyAction4
  5000 0000291C [24190000]-        
  5001 00002920 [90190000]-        
  5002 00002924 [91290000]-        
  5003 00002928 [0E290000]         
  5004                                  
  5005                                  qwertFunction1:
  5006 0000292C E896E6FFFF                  call right
  5007 00002931 C7                          db 0xC7
  5008 00002932 05[E8280000]                add _TOS_, ( qwertyKeyboard + 4 )
  5009 00002937 06                          push es
  5010 00002938 16                          push ss
  5011 00002939 0900                        or [_TOS_], _TOS_
  5012 0000293B E8CDFFFFFF                  call qwertToggleBase1
  5013 00002940 C605[C6180000]00            mov byte [ v_sign ], 0x00
  5014 00002947 A1[38390000]                mov _TOS_, [ v_digin ]
  5015                                  qwertyAction5:
  5016 0000294C E88DEDFFFF                  call get_qwerty_key_
  5017 00002951 7407                        jz .forward4
  5018 00002953 FF2485[18270000]            jmp dword [ _TOS_ * 4 + qwertyActionTable - 0x200 ]
  5019                                  .forward4:
  5020 0000295A 85C0                        test _TOS_, _TOS_
  5021 0000295C 7E33                        jng qwertyAction3
  5022 0000295E 3C23                        cmp al, 0x23
  5023 00002960 7427                        jz .forward3
  5024 00002962 A1[38390000]                mov _TOS_, [ v_digin ]
  5025 00002967 3B05[18390000]              cmp _TOS_, [ base ]
  5026 0000296D 7918                        jns .forward2
  5027 0000296F F605[C6180000]FF            test byte [ v_sign ], 0xFF
  5028 00002976 7402                        jz .forward
  5029 00002978 F7D8                        neg _TOS_
  5030                                  .forward:
  5031 0000297A 8B16                        mov edx, [ esi ]
  5032 0000297C 0FAF15[18390000]            imul edx, [ base]
  5033 00002983 01C2                        add edx, _TOS_
  5034 00002985 8916                        mov [ esi ], edx
  5035                                  .forward2:
  5036 00002987 EB08                        jmp short qwertyAction3
  5037                                  .forward3:
  5038 00002989 3105[C6180000]              xor [ v_sign ], _TOS_
  5039 0000298F F71E                        neg dword [ esi ]
  5040                                  
  5041                                  qwertyAction3:
  5042                                      _DROP_
  5043 00002991 AD                  <1>  lodsd
  5044 00002992 EBB8                        jmp short qwertyAction5
  5045                                  
  5046                                  qwertToggleBaseTable2:
  5047 00002994 [DF170000]-                 dd lj, lj, x
  5048 00002998 [DF170000]-        
  5049 0000299C [39180000]         
  5050                                  
  5051                                  qwertyFunction2:
  5052 000029A0 C705[E8280000]0204-         mov dword [ ( qwertyKeyboard + 4 ) ], 0x02150402  ; 'text'
  5053 000029A8 1502               
  5054 000029AA E818E6FFFF                  call right
  5055 000029AF C705[30390000]0100-         mov dword [ v_words ], 0x01
  5056 000029B7 0000               
  5057 000029B9 C705[24390000]0100-         mov dword [ chars], 0x01
  5058 000029C1 0000               
  5059                                      _DUP_
  5060 000029C3 83EE04              <1>  sub esi, byte 0x04
  5061 000029C6 8906                <1>  mov [ esi ], _TOS_
  5062 000029C8 C70600000000                mov dword [ esi ], 0x00
  5063 000029CE C605[D2170000]1C            mov byte [ bits_ ], 0x1C
  5064                                  .back:
  5065 000029D5 740E                        jz .forward
  5066 000029D7 3D83000000                  cmp _TOS_, 0x83
  5067 000029DC 7907                        jns .forward
  5068 000029DE FF2485[94270000]            jmp dword [ _TOS_*4 + qwertToggleBaseTable2 - 0x200 ]
  5069                                  .forward:
  5070 000029E5 85C0                        test _TOS_, _TOS_
  5071 000029E7 7E1C                        jng .forward2
  5072 000029E9 3D30000000                  cmp _TOS_, 0x30
  5073 000029EE 7915                        jns .forward2
  5074                                      _DUP_
  5075 000029F0 83EE04              <1>  sub esi, byte 0x04
  5076 000029F3 8906                <1>  mov [ esi ], _TOS_
  5077 000029F5 E8B4E5FFFF                  call echo_
  5078 000029FA E80EEEFFFF                  call pack_
  5079 000029FF FF05[24390000]              inc dword [ chars]
  5080                                  .forward2:
  5081                                      _DROP_
  5082 00002A05 AD                  <1>  lodsd
  5083 00002A06 E8D3ECFFFF                  call get_qwerty_key_
  5084 00002A0B EBC8                        jmp short .back
  5085                                  
  5086                                  qwertyAction2:
  5087 00002A0D E8EAFEFFFF                  call qwertToggleBase
  5088 00002A12 E980EFFFFF                  jmp dword nul0
  5089                                  
  5090                                  qwertyAction1:
  5091 00002A17 FF25[86170000]              jmp dword [ alpha0 + 4 ]
  5092                                  
  5093                                  qwertyTable1:
  5094 00002A1D [97190000]                  dd nul0
  5095 00002A21 [97190000]                  dd nul0
  5096 00002A25 [97190000]                  dd nul0
  5097 00002A29 [172A0000]                  dd qwertyAction1
  5098 00002A2D [0D2A0000]                  dd qwertyAction2
  5099                                  
  5100                                  qwertyDoAction:
  5101 00002A31 C705[E8280000]0000-         mov dword [ ( qwertyKeyboard + 4 ) ], 0x00   ; clear the 'text' string
  5102 00002A39 0000               
  5103 00002A3B C705[14390000]-             mov dword [ shiftAction ], qwertyKeyboard
  5104 00002A41 [E4280000]         
  5105 00002A45 C705[10390000]-             mov dword [ currentKeyboardIcons ], pad1
  5106 00002A4B [E0280000]         
  5107                                  
  5108                                  .back2:
  5109 00002A4F E88AECFFFF                  call get_qwerty_key_
  5110 00002A54 7407                        jz .forward
  5111 00002A56 FF2485[1D280000]            jmp dword [ ( _TOS_ * 4 ) + qwertyTable1 - 0x0200 ]
  5112                                  
  5113                                  .forward:
  5114 00002A5D 3C30                        cmp al, 0x30
  5115 00002A5F 750D                        jnz .back
  5116 00002A61 C705[E8280000]0204-         mov dword [ ( qwertyKeyboard + 4 ) ], 0x02150402  ; 'text'
  5117 00002A69 1502               
  5118                                      _DROP_
  5119 00002A6B AD                  <1>  lodsd
  5120 00002A6C EBE1                        jmp short .back2
  5121                                  .back:
  5122 00002A6E 85C0                        test _TOS_, _TOS_
  5123 00002A70 7E30                        jng .forward3
  5124 00002A72 F705[E8280000]FFFF-         test dword [ ( qwertyKeyboard + 4 ) ], 0xFFFFFFFF
  5125 00002A7A FFFF               
  5126 00002A7C 750D                        jnz .forward2
  5127 00002A7E 803D[38390000]0A            cmp byte [ v_digin ], 0x0A
  5128 00002A85 0F88A1FEFFFF                js qwertFunction1
  5129                                  .forward2:
  5130 00002A8B 3D30000000                  cmp _TOS_, 0x30
  5131 00002A90 7910                        jns .forward3
  5132 00002A92 E809FFFFFF                  call qwertyFunction2
  5133 00002A97 FF15[28390000]              call [ aword ]
  5134                                      _DUP_
  5135 00002A9D 83EE04              <1>  sub esi, byte 0x04
  5136 00002AA0 8906                <1>  mov [ esi ], _TOS_
  5137                                  .forward3:
  5138                                      _DROP_
  5139 00002AA2 AD                  <1>  lodsd
  5140 00002AA3 E9FEEEFFFF                  jmp dword accept
  5141                                  
  5142                                  qwert:      ; selects QWERTY keyboard entry
  5143 00002AA8 C705[F8380000]-             mov dword [ x_qwerty ], qwertyDoAction
  5144 00002AAE [312A0000]         
  5145 00002AB2 C3                          ret
  5146                                  
  5147                                  ; *****************************************************************************
  5148                                  
  5149                                  abort_action:
  5150 00002AB3 81FF00400000                cmp edi, ( RELOCATED / 4 )  ; if we are compiling a block, show the location of the error
  5151                                      ; edi is a cell address, so divide by 4
  5152 00002AB9 7216                        jc .forward
  5153                                      _DUP_
  5154 00002ABB 83EE04              <1>  sub esi, byte 0x04
  5155 00002ABE 8906                <1>  mov [ esi ], _TOS_
  5156 00002AC0 A1[88380000]                mov _TOS_, [ v_blk ]
  5157 00002AC5 A3[8C380000]                mov [ v_otherBlock ], _TOS_ ; save the last block to be edited
  5158 00002ACA 89F8                        mov _TOS_, edi
  5159 00002ACC E8B9FDFFFF                  call convertAddress
  5160                                  .forward:
  5161 00002AD1 BC00780000                  mov esp, RETURN_STACK_0
  5162 00002AD6 81FE04760000                cmp esi, ( DATA_STACK_0 + 4 )
  5163 00002ADC 7205                        jc .forward2
  5164 00002ADE BE04760000                  mov esi, ( DATA_STACK_0 + 4 )
  5165                                  .forward2:
  5166 00002AE3 C705[78390000]-             mov dword [ tokenActions + ( 3 * 4 ) ], forthd
  5167 00002AE9 [D9050000]         
  5168 00002AED C705[7C390000]-             mov dword [ tokenActions + ( 4 * 4 ) ], qcompile
  5169 00002AF3 [20070000]         
  5170 00002AF7 C705[80390000]-             mov dword [ tokenActions + ( 5 * 4 ) ], cnum
  5171 00002AFD [C0060000]         
  5172 00002B01 C705[84390000]-             mov dword [ tokenActions + ( 6 * 4 ) ], cshort
  5173 00002B07 [D0060000]         
  5174 00002B0B B82F000000                  mov _TOS_, 0x2F     ; '?' character to follow the display of the unknown word
  5175 00002B10 E899E4FFFF                  call echo_
  5176                                  ;    jmp abort_e2
  5177 00002B15 E98CEEFFFF                  jmp dword accept
  5178                                  
  5179                                  ; *****************************************************************************
  5180                                  
  5181                                  rquery: ; r?
  5182                                      _DUP_
  5183 00002B1A 83EE04              <1>  sub esi, byte 0x04
  5184 00002B1D 8906                <1>  mov [ esi ], _TOS_
  5185 00002B1F B800780000                  mov _TOS_, RETURN_STACK_0
  5186 00002B24 29E0                        sub _TOS_, esp
  5187 00002B26 D1E8                        shr _TOS_,1
  5188 00002B28 D1E8                        shr _TOS_,1
  5189 00002B2A C3                          ret
  5190                                  
  5191                                  boot:
  5192                                      ; see http://wiki.osdev.org/PS2_Keyboard#CPU_Reset
  5193 00002B2B B0FE                        mov al, 0xFE
  5194 00002B2D E664                        out 0x64, al
  5195 00002B2F EBFE                        jmp short $         ; we should never get here, because the processor will be rebooted... stop here just in case
  5196                                  
  5197                                  wipe:  ; ( -- )    \ wipe the currently edited block
  5198                                      _DUP_
  5199 00002B31 83EE04              <1>  sub esi, byte 0x04
  5200 00002B34 8906                <1>  mov [ esi ], _TOS_
  5201 00002B36 A1[88380000]                mov _TOS_, [ v_blk ]
  5202 00002B3B B940000000                  mov ecx, 0x40
  5203                                  wipe2:
  5204 00002B40 57                          push edi
  5205 00002B41 E85EDDFFFF                  call blockToCellAddress     ; add the RELOCATED block number offset and convert to cell address
  5206 00002B46 C1E002                      shl _TOS_, 2                ; convert to byte address
  5207 00002B49 89C7                        mov edi, _TOS_
  5208 00002B4B 31C0                        xor _TOS_, _TOS_
  5209 00002B4D F3AB                        rep stosd
  5210 00002B4F 5F                          pop edi
  5211                                      _DROP_
  5212 00002B50 AD                  <1>  lodsd
  5213 00002B51 C3                          ret
  5214                                  
  5215                                  wipes:  ; ( startblock# #blocks -- )    \ wipes #blocks starting from block startblock#   ( was erase )
  5216 00002B52 89C1                        mov ecx, _TOS_
  5217 00002B54 C1E106                      shl ecx, 0x06               ;  convert blocks to cells, multiply by 64
  5218                                      _DROP_
  5219 00002B57 AD                  <1>  lodsd
  5220 00002B58 E9E3FFFFFF                  jmp wipe2
  5221                                  
  5222                                  copy_:   ; ( blk -- )    \ copy the given block (and shadow) to the currently displayed block (and shadow)
  5223 00002B5D 83F80C                      cmp _TOS_, byte 0x0C        ; below block 12 is machine code
  5224 00002B60 0F82F2D9FFFF                jc abort
  5225 00002B66 57                          push edi
  5226 00002B67 56                          push esi
  5227 00002B68 51                          push ecx
  5228 00002B69 E836DDFFFF                  call blockToCellAddress     ; source block
  5229 00002B6E C1E002                      shl _TOS_, 0x02             ; convert cell address to byte address
  5230 00002B71 89C6                        mov esi, _TOS_
  5231 00002B73 A1[88380000]                mov _TOS_, [ v_blk ]
  5232 00002B78 E827DDFFFF                  call blockToCellAddress     ; destination block
  5233 00002B7D C1E002                      shl _TOS_, 0x02             ; convert cell address to byte address
  5234 00002B80 89C7                        mov edi, _TOS_
  5235 00002B82 B900020000                  mov ecx, 0x0200
  5236 00002B87 F3A5                        rep  movsd                  ; copy ecx 32 bit words from ds:esi to es:edi
  5237 00002B89 59                          pop ecx
  5238 00002B8A 5E                          pop esi
  5239 00002B8B 5F                          pop edi
  5240                                      _DROP_
  5241 00002B8C AD                  <1>  lodsd
  5242 00002B8D C3                          ret
  5243                                  
  5244                                  debug:
  5245 00002B8E C705[AC390000]B502-         mov dword [ v_xy ], 0x302B5
  5246 00002B96 0300               
  5247                                      _DUP_
  5248 00002B98 83EE04              <1>  sub esi, byte 0x04
  5249 00002B9B 8906                <1>  mov [ esi ], _TOS_
  5250 00002B9D A1[2F040000]                mov _TOS_, [ God ]
  5251 00002BA2 FF30                        push dword [_TOS_]
  5252 00002BA4 E82FE5FFFF                  call dotHex
  5253                                      _DUP_
  5254 00002BA9 83EE04              <1>  sub esi, byte 0x04
  5255 00002BAC 8906                <1>  mov [ esi ], _TOS_
  5256 00002BAE 58                          pop _TOS_
  5257 00002BAF E824E5FFFF                  call dotHex
  5258                                      _DUP_
  5259 00002BB4 83EE04              <1>  sub esi, byte 0x04
  5260 00002BB7 8906                <1>  mov [ esi ], _TOS_
  5261 00002BB9 A1[38040000]                mov _TOS_, [ main ]
  5262 00002BBE E815E5FFFF                  call dotHex
  5263                                      _DUP_
  5264 00002BC3 83EE04              <1>  sub esi, byte 0x04
  5265 00002BC6 8906                <1>  mov [ esi ], _TOS_
  5266 00002BC8 89F0                        mov _TOS_, esi
  5267 00002BCA E909E5FFFF                  jmp dword dotHex
  5268                                  
  5269                                  ; *****************************************************************************
  5270                                  
  5271                                  tic0:
  5272 00002BCF FF0D[30390000]              dec dword [ v_words ]
  5273 00002BD5 7403                        jz .forward
  5274                                      _DROP_
  5275 00002BD7 AD                  <1>  lodsd
  5276 00002BD8 EBF5                        jmp short tic0
  5277                                  .forward:
  5278 00002BDA C3                          ret
  5279                                  
  5280                                  tic_:   ; ( -- a )   \ return the byte address of the next word entered
  5281 00002BDB E888F9FFFF                  call _word          ; allow user to enter the word to  search for
  5282 00002BE0 E8EAFFFFFF                  call tic0           ; remove the entered word from the stack
  5283 00002BE5 E85AD9FFFF                  call find_          ; find the word in the dictionary, return its index in  ecx
  5284 00002BEA 0F8568D9FFFF                jnz abort
  5285 00002BF0 8B048D00A84600              mov _TOS_, [ ( ecx * 4 ) + ForthJumpTable ]     ; return the word's address from the jump table
  5286 00002BF7 C3                          ret
  5287                                  
  5288                                  itick:
  5289 00002BF8 25F0FFFFFF                  and _TOS_, 0xFFFFFFF0
  5290 00002BFD E842D9FFFF                  call find_
  5291 00002C02 8B048D00A84600              mov _TOS_, [ ( ecx * 4 ) + ForthJumpTable ]
  5292 00002C09 C3                          ret
  5293                                  
  5294                                  ; *****************************************************************************
  5295                                  
  5296                                  ; ToDo: fix this!!!
  5297                                  showWords_:     ; ( -- )   \ show all words in the Forth wordlist
  5298 00002C0A E84AD8FFFF                  call show
  5299 00002C0F 57                          push edi
  5300 00002C10 E852E3FFFF                  call setRed
  5301 00002C15 8D3DFC7F4600                lea edi, [ ForthNames - 4 ]   ; set edi to the bottom of the Forth name table
  5302 00002C1B 8B0D[64390000]              mov ecx, [ v_ForthWordCount ]   ; count of Forth wordlist words
  5303                                  .loop:
  5304 00002C21 E8C5F0FFFF                  call type_            ; show one Shannon-Fano encoded word
  5305 00002C26 E857E2FFFF                  call space_
  5306 00002C2B 47                          inc edi
  5307 00002C2C E2F3                        loop .loop
  5308 00002C2E 5F                          pop edi
  5309 00002C2F C3                          ret
  5310                                  
  5311                                  words_:
  5312 00002C30 E8D5FFFFFF                  call showWords_
  5313 00002C35 C3                          ret
  5314                                  
  5315                                  ; *****************************************************************************
  5316                                  
  5317                                  ; Int 0x13 AH Return Code error type
  5318                                  ; 0x00 Success
  5319                                  ; 0x01 Invalid Command
  5320                                  ; 0x02 Cannot Find Address Mark
  5321                                  ; 0x03 Attempted Write On Write Protected Disk
  5322                                  ; 0x04 Sector Not Found
  5323                                  ; 0x05 Reset Failed
  5324                                  ; 0x06 Disk change line 'active'
  5325                                  ; 0x07 Drive parameter activity failed
  5326                                  ; 0x08 DMA overrun
  5327                                  ; 0x09 Attempt to DMA over 64kb boundary
  5328                                  ; 0x0A Bad sector detected
  5329                                  ; 0x0B Bad cylinder (track) detected
  5330                                  ; 0x0C Media type not found
  5331                                  ; 0x0D Invalid number of sectors
  5332                                  ; 0x0E Control data address mark detected
  5333                                  ; 0x0F DMA out of range
  5334                                  ; 0x10 CRC/ECC data error
  5335                                  ; 0x11 ECC corrected data error
  5336                                  ; 0x20 Controller failure
  5337                                  ; 0x40 Seek failure
  5338                                  ; 0x80 Drive timed out, assumed not ready
  5339                                  ; 0xAA Drive not ready
  5340                                  ; 0xBB Undefined error
  5341                                  ; 0xCC Write fault
  5342                                  ; 0xE0 Status error
  5343                                  ; 0xFF Sense operation failed
  5344                                  
  5345                                  ; *****************************************************************************
  5346                                  ; 16 bit BIOS disk read/write from 32 bit
  5347                                  ; *****************************************************************************
  5348                                  
  5349                                  ; set the required parameters into the DAP buffer for the LBA BIOS extended read/write calls.
  5350                                  ; Also set up the extra DAP buffer values for use by the CHS BIOS calls, if the LBA call fails.
  5351                                  ; This is to avoid returning from 16 bit mode to calculate the values.
  5352                                  setupDAP_:   ; ( sector n cmd -- )   \ setup the DAP for the given LBA sector number
  5353                                  
  5354 00002C36 57                          push edi
  5355                                  
  5356 00002C37 31C9                        xor ecx, ecx
  5357 00002C39 BF687C0000                  mov edi, (data_area - $$ + BOOTOFFSET)   ; setup the data index pointer
  5358 00002C3E 66678B8D0400                mov cx, [ word di + ( driveinfo_Drive_DX - data_area ) ]  ; restore the boot drive into dl
  5359 00002C44 BFE0170000                  mov edi, DAP_BUFFER
  5360 00002C49 66894F12                    mov word [ edi + o_Int13_DAP_saved_DX ], cx     ; setup DX value returned by the BIOS
  5361                                  
  5362 00002C4D 66894710                    mov word [ edi + o_Int13_DAP_readwrite ], ax    ; set the read/write cmd value, 0x0000 or 0x0001
  5363                                      _DROP_
  5364 00002C51 AD                  <1>  lodsd
  5365                                  
  5366                                      ; limit the number of sectors to the size of the SECTOR_BUFFER
  5367 00002C52 3D24000000                  cmp _TOS_, ( SECTOR_BUFFER_SIZE / 0x0200 )
  5368 00002C57 7805                        js .forward
  5369 00002C59 B824000000                      mov _TOS_, ( SECTOR_BUFFER_SIZE / 0x0200 )
  5370                                      .forward:
  5371 00002C5E 66894702                    mov word [ edi + o_Int13_DAP_num_sectors ], ax
  5372                                      _DROP_
  5373 00002C62 AD                  <1>  lodsd
  5374                                  
  5375 00002C63 894708                      mov dword [ edi + o_Int13_DAP_LBA_64_lo ], eax
  5376 00002C66 50                          push eax    ; save for later
  5377                                  
  5378 00002C67 31C0                        xor eax, eax
  5379 00002C69 89470C                      mov dword [ edi + o_Int13_DAP_LBA_64_hi ], eax
  5380                                  
  5381                                      ; buffer within low 16 bits of address space
  5382 00002C6C 66894706                    mov word [ edi + o_Int13_DAP_segment ], ax
  5383 00002C70 66B80020                    mov ax, ( SECTOR_BUFFER )
  5384 00002C74 66894704                    mov word [ edi + o_Int13_DAP_address ], ax
  5385                                  
  5386                                      ; set the configuration buffer values from the registers
  5387 00002C78 B810000000                  mov eax, 0x0010
  5388 00002C7D 668907                      mov word [ edi + o_Int13_DAP_size ], ax  ; setup DAP buffer size
  5389                                  
  5390                                  ; setup values for CHS BIOS disk calls
  5391                                  
  5392 00002C80 58                          pop eax                         ; restore the start sector number
  5393 00002C81 0305687C0000                add eax, [ bootsector - $$ + BOOTOFFSET]    ; add the bootsector from the drive parameter table
  5394                                  
  5395 00002C87 50                          push eax                        ; save it while we calculate heads*sectors-per-track
  5396 00002C88 A0717C0000                  mov al, [ driveinfo_Head - $$ + BOOTOFFSET]      ; index of highest-numbered head
  5397 00002C8D FEC0                        inc al                          ; 1-base the number to make count of heads
  5398 00002C8F F625727C0000                mul byte [ driveinfo_SectorsPertrack - $$ + BOOTOFFSET]     ; sectors per track
  5399 00002C95 89C3                        mov ebx, eax
  5400 00002C97 58                          pop eax
  5401 00002C98 31D2                        xor edx, edx                    ; clear high 32 bits
  5402 00002C9A F7F3                        div ebx                         ; leaves cylinder number in eax, remainder in edx
  5403 00002C9C 89C1                        mov ecx, eax                    ; store cylinder number in another register
  5404 00002C9E 89D0                        mov eax, edx                    ; get remainder into AX
  5405 00002CA0 8A1D727C0000                mov bl, [ driveinfo_SectorsPertrack - $$ + BOOTOFFSET]      ; number of sectors per track
  5406 00002CA6 F6F3                        div bl                          ; head number into AX, remainder into DX
  5407 00002CA8 88C3                        mov bl, al                      ; result must be one byte, so store it in BL
  5408 00002CAA C1C108                      rol ecx, 8                      ; high 2 bits of cylinder number into high 2 bits of CL
  5409 00002CAD C0E106                      shl cl, 6                       ; makes room for sector number
  5410 00002CB0 08E1                        or cl, ah                       ; merge cylinder number with sector number
  5411 00002CB2 FEC1                        inc cl                          ; one-base sector number
  5412 00002CB4 66894F18                    mov word [ edi + o_Int13_DAP_saved_CHS_CX ], cx  ; also save the calculated CX value
  5413 00002CB8 668B0D6C7C0000              mov cx, [ driveinfo_Drive_DX - $$ + BOOTOFFSET]    ; drive number in low 8 bits
  5414 00002CBF 88DD                        mov ch, bl                      ; place head number in high bits
  5415 00002CC1 66894F1A                    mov word [ edi + o_Int13_DAP_saved_CHS_DX ], cx  ; also save the calculated DX value
  5416                                  
  5417 00002CC5 5F                          pop edi
  5418                                      _DROP_
  5419 00002CC6 AD                  <1>  lodsd
  5420                                  
  5421 00002CC7 C3                          ret
  5422                                  
  5423                                  ; *****************************************************************************
  5424                                  ; BIOS read/write 512 byte LBA sectors
  5425                                  ; *****************************************************************************
  5426                                  
  5427                                  BIOS_ReadWrite_Sector_LBA: ; ( -- )   \ try to read or write using the extended disk BIOS calls,
  5428                                  ; \ if that fails, try the CHS BIOS call. Parameters are in the DAP buffer.
  5429                                  
  5430 00002CC8 9C                         pushf   ; save the processor flags, especially interrupt enable
  5431                                  
  5432                                  %ifdef NOT_BOCHS
  5433                                      call restore_BIOS_idt_and_pic   ;
  5434                                  %endif
  5435                                  
  5436                                      _DUP_
  5437 00002CC9 83EE04              <1>  sub esi, byte 0x04
  5438 00002CCC 8906                <1>  mov [ esi ], _TOS_
  5439 00002CCE 31C0                        xor _TOS_, _TOS_
  5440 00002CD0 E83A050000                  call lidt_                      ; Load the BIOS Interrupt Descriptor Table
  5441                                  
  5442 00002CD5 E83CD6FFFF                  call setRealModeAPI
  5443                                  [BITS 16]                           ; Real Mode code (16 bit)
  5444 00002CDA BEE017                      mov si, DAP_BUFFER
  5445 00002CDD 8A6410                      mov byte ah, [ si + o_Int13_DAP_readwrite ]  ; 0x00 for read, 0x01 for write
  5446 00002CE0 80CC42                      or  ah, 0x42                    ; BIOS extended read/write
  5447 00002CE3 B000                        mov al, 0x00
  5448 00002CE5 8B5412                      mov dx, [ si + o_Int13_DAP_saved_DX ]
  5449 00002CE8 CD13                        int 0x13
  5450 00002CEA FA                          cli                             ; BIOS might have left interrupts enabled
  5451                                  
  5452 00002CEB 894414                      mov word [ si + o_Int13_DAP_returned_AX ], ax  ; save the value in AX that the BIOS call returned
  5453 00002CEE 7326                        jnc .forward
  5454 00002CF0 BEE017                          mov si, DAP_BUFFER
  5455                                  
  5456 00002CF3 8A6410                          mov byte ah, [ si + o_Int13_DAP_readwrite ]  ; 0x00 for read, 0x01 for write
  5457 00002CF6 80CC02                          or  ah, 0x02                ; CHS BIOS mode, read  al  sectors, set above
  5458 00002CF9 8A4402                          mov al, byte [ si + o_Int13_DAP_num_sectors ]   ; restore the number of sectors saved by setupDAP_
  5459                                  
  5460 00002CFC 8B4C18                          mov word cx, [ si + o_Int13_DAP_saved_CHS_CX ]  ; restore the CX value calculated by sector_chs
  5461 00002CFF 8B541A                          mov word dx, [ si + o_Int13_DAP_saved_CHS_DX ]  ; restore the DX value calculated by sector_chs
  5462 00002D02 8B5C04                          mov word bx, [ si + o_Int13_DAP_address ]       ; restore the address saved by setupDAP_
  5463 00002D05 CD13                            int 0x13
  5464 00002D07 FA                              cli                         ; BIOS might have left interrupts enabled
  5465                                  
  5466 00002D08 BEE017                          mov si, DAP_BUFFER
  5467 00002D0B 894414                          mov word [ si + o_Int13_DAP_returned_AX ], ax  ; the BIOS call returned AX
  5468 00002D0E B80100                          mov ax, 0x0001
  5469 00002D11 7206                            jc .forward2
  5470 00002D13 B80000                             mov ax, 0x0000
  5471                                          .forward:
  5472 00002D16 894416                          mov [ si + o_Int13_DAP_returned_carry_flag ], ax  ; the BIOS call returned carry flag
  5473                                      .forward2:
  5474 00002D19 894416                      mov [ si + o_Int13_DAP_returned_carry_flag ], ax  ; the BIOS call returned carry flag
  5475                                  
  5476 00002D1C E8CED5                      call setProtectedModeAPI        ; called from 16 bit code, returns to 32 bit code
  5477                                  [BITS 32]                           ; Protected Mode code (32 bit)
  5478                                  
  5479                                  %ifdef NOT_BOCHS
  5480                                      call restore_new_idt_and_pic
  5481                                  %endif
  5482                                  
  5483                                      _DUP_
  5484 00002D1F 83EE04              <1>  sub esi, byte 0x04
  5485 00002D22 8906                <1>  mov [ esi ], _TOS_
  5486 00002D24 B8001C0000                  mov _TOS_, INTERRUPT_VECTORS
  5487 00002D29 E8E1040000                  call lidt_                      ; Load the new Interrupt Descriptor Table
  5488                                  
  5489 00002D2E 9D                          popf   ; restore the processor flags, especially interrupt enable
  5490                                  
  5491 00002D2F C3                          ret
  5492                                  
  5493                                  Read_Sector_LBA:    ; ( sector n -- )   "rlba"   GetFlag returns 0 for success
  5494                                      _DUP_
  5495 00002D30 83EE04              <1>  sub esi, byte 0x04
  5496 00002D33 8906                <1>  mov [ esi ], _TOS_
  5497 00002D35 B800000000                  mov eax, 0x0000                 ; read command
  5498 00002D3A E8F7FEFFFF                  call setupDAP_                  ; setup up the DAP table using 3 items from the stack ( start n cmd -- )
  5499 00002D3F FA                          cli                             ; disable interrupts
  5500 00002D40 60                          pushad                          ; Pushes all general purpose registers onto the stack
  5501 00002D41 E882FFFFFF                  call BIOS_ReadWrite_Sector_LBA
  5502 00002D46 61                          popad                           ; restore the registers pushed by  pushad
  5503 00002D47 C3                          ret
  5504                                  
  5505                                  Write_Sector_LBA:   ; ( sector n -- )   "wlba"
  5506                                      _DUP_
  5507 00002D48 83EE04              <1>  sub esi, byte 0x04
  5508 00002D4B 8906                <1>  mov [ esi ], _TOS_
  5509 00002D4D B801000000                  mov eax, 0x0001                 ; write command
  5510 00002D52 E8DFFEFFFF                  call setupDAP_                  ; setup up the DAP table using 3 items from the stack ( start n cmd -- )
  5511 00002D57 FA                          cli                             ; disable interrupts
  5512 00002D58 60                          pushad                          ; Pushes all general purpose registers onto the stack
  5513 00002D59 E86AFFFFFF                  call BIOS_ReadWrite_Sector_LBA
  5514 00002D5E 61                          popad                           ; restore the registers pushed by  pushad
  5515 00002D5F C3                          ret
  5516                                  
  5517                                  ReadSectors:    ; ( a sector n -- a' )  \ read  n  sectors from  sector  into address  a
  5518 00002D60 E8CBFFFFFF                  call Read_Sector_LBA            ; reads  n  sectors starting from  sector  into the SECTOR_BUFFER
  5519                                  
  5520 00002D65 56                          push esi                        ; esi is changed by rep movsw
  5521                                  
  5522 00002D66 BEE0170000                  mov esi, DAP_BUFFER
  5523 00002D6B 31C9                        xor ecx, ecx
  5524 00002D6D 66678B4C02                  mov word cx, [ si + o_Int13_DAP_num_sectors ]   ; restore the number of sectors saved by setupDAP_
  5525 00002D72 89CB                        mov ebx, ecx                    ; save number of sectors for later
  5526 00002D74 BE00200000                  mov esi, SECTOR_BUFFER          ; source address
  5527 00002D79 89C7                        mov edi, eax                    ; destination address
  5528 00002D7B C1E107                      shl ecx, 0x07                   ; 512 bytes in cells = 2 ** 7
  5529 00002D7E F3A5                        rep movsd                       ; does not change AX , it moves DS:SI to ES:DI and increments SI and DI
  5530                                  
  5531                                      ; ( a -- a' )
  5532 00002D80 89D9                        mov ecx, ebx
  5533 00002D82 C1E109                      shl ecx, 0x09                   ; 512 bytes in bytes = 2 ** 9
  5534 00002D85 01C8                        add eax, ecx                    ; increment the address that is TOS
  5535                                  
  5536 00002D87 5E                          pop esi
  5537                                      ; ( a -- a' sector' )
  5538                                      _DUP_
  5539 00002D88 83EE04              <1>  sub esi, byte 0x04
  5540 00002D8B 8906                <1>  mov [ esi ], _TOS_
  5541 00002D8D 56                          push esi
  5542 00002D8E BEE0170000                  mov esi, DAP_BUFFER             ; esi is changed by rep movsd above
  5543 00002D93 31C9                        xor ecx, ecx
  5544 00002D95 66678B4C08                  mov word cx, [ si + o_Int13_DAP_LBA_64_lo ]   ; restore the start sector
  5545 00002D9A 5E                          pop esi
  5546 00002D9B 89C8                        mov eax, ecx
  5547 00002D9D 01D8                        add eax, ebx
  5548                                  
  5549                                  ;    call GetFlag
  5550 00002D9F C3                          ret
  5551                                  
  5552                                  WriteSectors:    ; ( a sector n -- a' ) \ write  n  sectors starting at  sector  from address  a
  5553                                  
  5554 00002DA0 52                          push edx
  5555                                  
  5556 00002DA1 8B5604                      mov edx, [ esi + 4 ]            ; save  a  from stack in  edx
  5557                                  
  5558 00002DA4 56                          push esi                        ; esi is also changed by rep movsw
  5559 00002DA5 BEE0170000                  mov esi, DAP_BUFFER
  5560 00002DAA 31C9                        xor ecx, ecx
  5561 00002DAC 66678B4C02                  mov word cx, [ si + o_Int13_DAP_num_sectors ]   ; restore the number of sectors saved by setupDAP_
  5562 00002DB1 89CB                        mov ebx, ecx                    ; save number of sectors for later
  5563                                  
  5564 00002DB3 C1E107                      shl ecx, 0x07                   ; 512 bytes in cells = 2 ** 7
  5565                                  
  5566 00002DB6 89D6                        mov esi, edx                    ; source address
  5567 00002DB8 BF00200000                  mov edi, SECTOR_BUFFER          ; destination address
  5568 00002DBD F3A5                        rep movsd                       ; does not change AX , it moves DS:SI to ES:DI and increments SI and DI
  5569                                  
  5570 00002DBF 5E                          pop esi
  5571                                  
  5572 00002DC0 53                          push ebx
  5573 00002DC1 E882FFFFFF                  call Write_Sector_LBA    ; writes  n  sectors starting from  sector  from the SECTOR_BUFFER
  5574 00002DC6 5B                          pop ebx
  5575                                  ;    push esi                        ; esi is also changed by rep movsw
  5576                                  
  5577                                      ; ( a -- a' )
  5578 00002DC7 89D9                        mov ecx, ebx
  5579 00002DC9 C1E109                      shl ecx, 0x09                   ; 512 bytes in bytes = 2 ** 9
  5580 00002DCC 01C8                        add eax, ecx                    ; increment the address that is TOS
  5581                                  
  5582                                  ;    pop esi
  5583                                      ; ( a -- a' sector' )
  5584                                      _DUP_
  5585 00002DCE 83EE04              <1>  sub esi, byte 0x04
  5586 00002DD1 8906                <1>  mov [ esi ], _TOS_
  5587 00002DD3 56                          push esi
  5588 00002DD4 BEE0170000                  mov esi, DAP_BUFFER             ; esi is changed by rep movsd above
  5589 00002DD9 31C9                        xor ecx, ecx
  5590 00002DDB 66678B4C08                  mov word cx, [ si + o_Int13_DAP_LBA_64_lo ]   ; restore the start sector
  5591 00002DE0 5E                          pop esi
  5592 00002DE1 89C8                        mov eax, ecx
  5593 00002DE3 01D8                        add eax, ebx
  5594                                  
  5595 00002DE5 5A                          pop edx
  5596                                  
  5597                                  ;    call GetFlag
  5598 00002DE6 C3                          ret
  5599                                  
  5600                                  SaveAll_:    ; ( -- ) "sss"
  5601 00002DE7 9C                          pushf   ; save the processor flags, especially interrupt enable
  5602 00002DE8 FA                          cli
  5603                                  
  5604                                      _DUP_
  5605 00002DE9 83EE04              <1>  sub esi, byte 0x04
  5606 00002DEC 8906                <1>  mov [ esi ], _TOS_
  5607 00002DEE 31C0                        xor eax, eax
  5608 00002DF0 E80B020000                  call block_
  5609                                      _DUP_
  5610 00002DF5 83EE04              <1>  sub esi, byte 0x04
  5611 00002DF8 8906                <1>  mov [ esi ], _TOS_
  5612 00002DFA 31C0                        xor eax, eax
  5613 00002DFC B920000000                  mov ecx, 0x20   ; 32 x 16 Kbytes= 512 Kbytes
  5614                                      .back:
  5615                                      _DUP_
  5616 00002E01 83EE04              <1>  sub esi, byte 0x04
  5617 00002E04 8906                <1>  mov [ esi ], _TOS_
  5618 00002E06 B820000000                  mov eax, 0x20   ; 32 x 512 byte sectors = 16 Kbytes
  5619                                      ; ( a sector n -- )
  5620                                      ; ( 0block 0 0x20 --)
  5621 00002E0B 51                          push ecx
  5622 00002E0C E88FFFFFFF                  call WriteSectors
  5623 00002E11 59                          pop ecx
  5624 00002E12 E2ED                        loop .back
  5625                                      _DROP_
  5626 00002E14 AD                  <1>  lodsd
  5627                                      _DROP_
  5628 00002E15 AD                  <1>  lodsd
  5629                                  
  5630 00002E16 9D                          popf   ; restore the processor flags, especially interrupt enable
  5631 00002E17 C3                      ret
  5632                                  
  5633                                  GetFlag: ; ( -- error | 0 )   0 for success, else the error type ( eax == 0x100 is Invalid Command )
  5634                                      _DUP_
  5635 00002E18 83EE04              <1>  sub esi, byte 0x04
  5636 00002E1B 8906                <1>  mov [ esi ], _TOS_
  5637 00002E1D 31C0                        xor eax, eax
  5638 00002E1F 57                          push edi
  5639 00002E20 BFE0170000                  mov edi, DAP_BUFFER
  5640 00002E25 668B4716                    mov ax, [ edi + o_Int13_DAP_returned_carry_flag ]  ; the BIOS call returned carry flag
  5641 00002E29 66050000                    add ax, 0
  5642 00002E2D 7404                        jz .forward
  5643 00002E2F 668B4714                        mov ax, [ edi + o_Int13_DAP_returned_AX ]  ; the BIOS call returned error value in ax
  5644                                      .forward:
  5645 00002E33 5F                          pop edi
  5646 00002E34 C3                          ret
  5647                                  
  5648                                  %if 0
  5649                                  BIOS_Read_Sector_CHS:
  5650                                      call setRealModeAPI
  5651                                  [BITS 16]                           ; Real Mode code (16 bit)
  5652                                      mov si, DAP_BUFFER
  5653                                      mov al, byte [ si + o_Int13_DAP_num_sectors ]   ; setup the number of sectors saved by setupDAP_
  5654                                  ;    and al, 0x0F        ; limit to 16 sectors
  5655                                      mov ah, 0x02        ; CHT BIOS mode, read  al  sectors, set above
  5656                                      mov word cx, [ si + o_Int13_DAP_saved_CHS_CX ]  ; setup the CX value calculated by sector_chs
  5657                                      mov word dx, [ si + o_Int13_DAP_saved_CHS_DX ]  ; setup the DX value calculated by sector_chs
  5658                                      mov word bx, [ si + o_Int13_DAP_address ]       ; setup the address saved by setupDAP_
  5659                                      int 0x13
  5660                                      cli                             ; BIOS might have left interrupts enabled
  5661                                  
  5662                                      mov si, DAP_BUFFER
  5663                                      mov word [ si + o_Int13_DAP_returned_AX ], ax  ; the BIOS call returned AX
  5664                                      mov ax, 0x0001
  5665                                      jc .forward
  5666                                         mov ax, 0x0000
  5667                                      .forward:
  5668                                      mov [ si + o_Int13_DAP_returned_carry_flag ], ax  ; the BIOS call returned carry flag
  5669                                  
  5670                                      call setProtectedModeAPI        ; called from 16 bit code, returns to 32 bit code
  5671                                  [BITS 32]                           ; Protected Mode code (32 bit)
  5672                                      ret
  5673                                  
  5674                                  ; rchs:
  5675                                  Read_Sector_CHS:    ; ( sector n -- f )   "rchs"  returns 0 for success
  5676                                      call setupDAP_              ; ( start n -- ) store the sector number into the Disk Address Packet
  5677                                      cli                         ; disable interrupts
  5678                                      pushad                      ; Pushes all general purpose registers onto the stack
  5679                                      call BIOS_Read_Sector_CHS
  5680                                      popad                       ; restore the registers pushed by  pushad
  5681                                  ;    _DROP_
  5682                                      jmp GetFlag
  5683                                  
  5684                                  ; wcht:
  5685                                  Write_Sector_CHS:   ; ( sector -- )   "wcht"
  5686                                      call setupDAP_              ; store the sector number into the Disk Address Packet
  5687                                      cli                         ; disable interrupts
  5688                                      pushad                      ; Pushes all general purpose registers onto the stack
  5689                                      call BIOS_Read_Sector_CHS
  5690                                      popad                       ; restore the registers pushed by  pushad
  5691                                      ret
  5692                                  
  5693                                  %endif
  5694                                  
  5695                                  ; *****************************************************************************
  5696                                  ; *****************************************************************************
  5697                                  
  5698                                  %if 0
  5699                                  [BITS 16]                           ; Real Mode code (16 bit)
  5700                                  storeBefore:    ; ( -- )   \ store registers to the V_REGS array
  5701                                      mov word [ V_REGS + 0x00 ], ax
  5702                                      mov word [ V_REGS + 0x04 ], bx
  5703                                      mov word [ V_REGS + 0x08 ], cx
  5704                                      mov word [ V_REGS + 0x0C ], dx
  5705                                      mov word [ V_REGS + 0x10 ], si
  5706                                      mov word [ V_REGS + 0x14 ], di
  5707                                      mov word [ V_REGS + 0x18 ], bp
  5708                                      push ax                         ; save eax
  5709                                      pushfd                          ; push the 32 bit eflags register onto the stack
  5710                                      pop ax                          ; and pop it off into eax
  5711                                      mov word [ V_REGS + 0x1C ], ax  ; eflags
  5712                                      pop ax
  5713                                      mov word [ V_REGS + 0x1E ], ax  ; eflags top 16 bits
  5714                                      pop ax                          ; restore eax
  5715                                      ret
  5716                                  
  5717                                  storeAfter:     ; ( -- )   \ store registers to the V_REGS array
  5718                                      mov word [ V_REGS + 0x20 ], ax
  5719                                      mov word [ V_REGS + 0x24 ], bx
  5720                                      mov word [ V_REGS + 0x28 ], cx
  5721                                      mov word [ V_REGS + 0x2C ], dx
  5722                                      mov word [ V_REGS + 0x30 ], si
  5723                                      mov word [ V_REGS + 0x34 ], di
  5724                                      mov word [ V_REGS + 0x38 ], bp
  5725                                      push ax                         ; save eax
  5726                                      pushfd                          ; push the 32 bit eflags register onto the stack
  5727                                      pop ax                          ; and pop it off into eax
  5728                                      mov word [ V_REGS + 0x3C ], ax  ; eflags
  5729                                      pop ax
  5730                                      mov word [ V_REGS + 0x3E ], ax  ; eflags top 16 bits
  5731                                      pop ax                          ; restore eax
  5732                                      ret
  5733                                  [BITS 32]                           ; Protected Mode code (32 bit)
  5734                                  
  5735                                  BIOS_thunk:     ; ( -- )   \ call the BIOS - registers will have previously been setup
  5736                                      call setRealModeAPI
  5737                                  [BITS 16]                           ; Real Mode code (16 bit)
  5738                                      push ax
  5739                                      push es                         ; this operation messes with ES
  5740                                      push di                         ; and DI
  5741                                      call storeBefore
  5742                                      int 0x13
  5743                                      jc $                            ; stop here on error
  5744                                      call storeAfter
  5745                                      pop di
  5746                                      pop es
  5747                                      pop ax
  5748                                      cli                             ; BIOS might have left interrupts enabled
  5749                                      call setProtectedModeAPI        ; called from 16 bit code, returns to 32 bit code
  5750                                  [BITS 32]                           ; Protected Mode code (32 bit)
  5751                                      ret
  5752                                  
  5753                                  %endif
  5754                                  
  5755                                  %if 0
  5756                                  th_:        ; ( ax bx cx dx si di es -- w )   \ th ( thunk to BIOS Int 0x13 )
  5757                                              ; eax = 0x DH DL AH AL , returns in same order
  5758                                      cli                             ; disable interrupts
  5759                                      pushad  ; Pushes all general purpose registers onto the stack in the following order:
  5760                                              ; EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI. The value of ESP is the value before the actual push of ESP
  5761                                              ;  7    6    5    4    3    2    1    0   offset in cells from ESP
  5762                                  
  5763                                  ;    call setupDAP_
  5764                                  
  5765                                      push edi
  5766                                      mov di, (data_area - $$ + BOOTOFFSET)   ; setup the data index pointer
  5767                                      mov dx, [ byte di + ( driveinfo_Drive_DX - data_area) ]  ; restore the boot drive from dx (and head? )
  5768                                  ;    mov dl, 0x80
  5769                                      mov ebx, SECTOR_BUFFER
  5770                                      mov eax, ( 0x0200 + ( ( SECTOR_BUFFER_SIZE / 512 ) & 0xFF ) ) ; read n sectors to fill the buffer
  5771                                      mov ecx, 0x0201                  ; cylinder | sector
  5772                                  
  5773                                      call BIOS_thunk
  5774                                  
  5775                                      pop edi
  5776                                      popad   ; restore the stack values pushed by  pushad
  5777                                      ret
  5778                                  %endif
  5779                                  %if 0
  5780                                  XXXrsect_:     ; ( sector -- ax )       pushad  ; Pushes all general purpose registers onto the stack
  5781                                      push edi
  5782                                  
  5783                                  ;    call sector_chs                 ; store th sector number into the Disk Address Packet
  5784                                  
  5785                                      mov di, (data_area - $$ + BOOTOFFSET)   ; setup the data index pointer
  5786                                      mov dx, [ byte di + ( driveinfo_Drive_DX - data_area) ]  ; restore the boot drive from dx (and head? )
  5787                                  ;    mov dl, 0x80
  5788                                  
  5789                                      cli                             ; disable interrupts
  5790                                  ;    mov esi, DAP_BUFFER
  5791                                  ;    _DUP_
  5792                                      mov eax, 0x0201     ; BIOS read, one sector
  5793                                      mov bx, SECTOR_BUFFER
  5794                                      call BIOS_thunk
  5795                                  
  5796                                      pop edi
  5797                                      popad   ; restore the stack values pushed by  pushad
  5798                                      ret
  5799                                  %endif
  5800                                  
  5801                                  ; *****************************************************************************
  5802                                  ; *****************************************************************************
  5803                                  
  5804                                  %define FORTH_INITIAL_WORD_COUNT  ( ( ForthJumpTableROM_end - ForthJumpTableROM ) / 4 )     ; in cells
  5805                                  %define MACRO_INITIAL_WORD_COUNT  ( ( MacroJumpTableROM_end - MacroJumpTableROM ) / 4 )     ; in cells
  5806                                  
  5807                                  warm:   ; warm start
  5808 00002E35 BB006C0000                  mov _SCRATCH_, STACK_MEMORY_START ; start of stack memory area
  5809 00002E3A B900030000                  mov ecx, ( TOTAL_STACK_SIZE >> 2 )  ; number of 32 bit cells to fill with the pattern
  5810                                  .back:
  5811 00002E3F C70355555555                mov dword [ _SCRATCH_ ], 0x55555555             ; fill with this pattern
  5812 00002E45 81C304000000                add _SCRATCH_, 0x04
  5813 00002E4B E2F2                        loop .back
  5814                                  
  5815 00002E4D 31C9                        xor ecx, ecx                       ; assumed by initshow to have been previously zeroed
  5816                                  
  5817 00002E4F E831D6FFFF                  call initshow                       ; sets up do-nothing "show" process
  5818                                  ;    call initserve                      ; sets up do-nothing "serve" process
  5819                                  ;    call stop_                           ; turn off floppy motor and point trash to floppy buffer
  5820                                  ;    mov byte [ dma_ready ], 0x01        ; not ready
  5821 00002E54 C705[64390000]9C00-         mov dword [ v_ForthWordCount ], FORTH_INITIAL_WORD_COUNT ; initial #words
  5822 00002E5C 0000               
  5823 00002E5E C705[68390000]0600-         mov dword [ v_MacroWordCount ], MACRO_INITIAL_WORD_COUNT ; initial #macros
  5824 00002E66 0000               
  5825 00002E68 C705[D4380000]6013-         mov dword [ v_trash], TRASH_BUFFER
  5826 00002E70 0000               
  5827 00002E72 56                          push esi
  5828                                  ;Forth wordlist
  5829 00002E73 8D35[FC390000]              lea esi, [ ForthNamesROM ]
  5830 00002E79 BF00804600                  mov edi, ForthNames
  5831 00002E7E 8B0D[64390000]              mov ecx, [ v_ForthWordCount ]
  5832 00002E84 F3A5                        rep  movsd                  ; copy ecx 32 bit words from ds:esi to es:edi
  5833 00002E86 8D35[703C0000]              lea esi, [ ForthJumpTableROM ]
  5834 00002E8C BF00A84600                  mov edi, ForthJumpTable
  5835 00002E91 8B0D[64390000]              mov ecx, [ v_ForthWordCount ]
  5836 00002E97 F3A5                        rep  movsd                  ; copy ecx 32 bit words from ds:esi to es:edi
  5837                                  ; Macro wordlist
  5838 00002E99 8D35[CC390000]              lea esi, [ MacroNamesROM ]
  5839 00002E9F BF00D04600                  mov edi, MacroNames
  5840 00002EA4 8B0D[68390000]              mov ecx, [ v_MacroWordCount ]
  5841 00002EAA F3A5                        rep  movsd                  ; copy ecx 32 bit words from ds:esi to es:edi
  5842 00002EAC 8D35[E4390000]              lea esi, [ MacroJumpTableROM ]
  5843 00002EB2 BF00F84600                  mov edi, MacroJumpTable
  5844 00002EB7 8B0D[68390000]              mov ecx, [ v_MacroWordCount ]
  5845 00002EBD F3A5                        rep  movsd                  ; copy ecx 32 bit words from ds:esi to es:edi
  5846                                  
  5847 00002EBF 5E                          pop esi
  5848 00002EC0 C705[50390000]0020-         mov dword [ v_H ], H0
  5849 00002EC8 4700               
  5850 00002ECA C705[F8380000]0000-         mov dword [ x_qwerty ], 0x00        ; select non-qwerty mode
  5851 00002ED2 0000               
  5852 00002ED4 C705[D8380000]4000-         mov dword [ v_offset ], ( RELOCATED >> ( 2 + 8 ) ) ; 0x10000 >> 2 >> 8, offset of RELOCATED block 0 as 1024 byte block number
  5853 00002EDC 0000               
  5854                                  
  5855                                      ; setup  v_bytesPerLine
  5856 00002EDE A112180000                  mov _TOS_, [ vesa_XResolution ]
  5857 00002EE3 25FFFF0000                  and _TOS_, 0xFFFF
  5858 00002EE8 69C002000000                imul _TOS_, BYTES_PER_PIXEL
  5859 00002EEE A3[7C000100]                mov [ v_bytesPerLine + RELOCATED ], _TOS_
  5860                                  
  5861                                      ; set up  fov
  5862 00002EF3 A114180000                  mov _TOS_, [ vesa_YResolution ]
  5863 00002EF8 25FFFF0000                  and _TOS_, 0x0000FFFF
  5864 00002EFD 89C3                        mov _SCRATCH_, _TOS_
  5865 00002EFF D1E3                        shl _SCRATCH_, 1
  5866 00002F01 D1E8                        shr _TOS_, 1
  5867 00002F03 01D8                        add _TOS_, _SCRATCH_
  5868 00002F05 69C00A000000                imul _TOS_, 10
  5869 00002F0B A3[B8390100]                mov [ v_fov + RELOCATED ], _TOS_
  5870                                  
  5871                                      ; select which code to use, depending on the display mode
  5872 00002F10 C605[360E0000]00            mov byte [ displayMode ], 0
  5873 00002F17 66813D121800000004          cmp word [ vesa_XResolution ], scrnw1
  5874 00002F20 7407                        jz .forward
  5875 00002F22 C605[360E0000]01            mov byte [ displayMode ], 1
  5876                                  .forward:
  5877                                  
  5878 00002F29 E888040000                  call randInit_      ; initialise the Marsaglia Pseudo Random Number Generator
  5879                                  
  5880 00002F2E E807DFFFFF                  call initIconSize
  5881                                  
  5882 00002F33 E823F5FFFF                  call cursorHome     ; setup the initial display
  5883                                  
  5884 00002F38 E89CD5FFFF                  call c_         ; clear the stack
  5885                                      _DUP_           ;
  5886 00002F3D 83EE04              <1>  sub esi, byte 0x04
  5887 00002F40 8906                <1>  mov [ esi ], _TOS_
  5888                                  
  5889                                  ; *****************************************************************************
  5890                                  ; erase the DAP buffer
  5891                                  ; *****************************************************************************
  5892                                      _DUP_
  5893 00002F42 83EE04              <1>  sub esi, byte 0x04
  5894 00002F45 8906                <1>  mov [ esi ], _TOS_
  5895 00002F47 B800200000                  mov _TOS_, SECTOR_BUFFER
  5896                                      _DUP_
  5897 00002F4C 83EE04              <1>  sub esi, byte 0x04
  5898 00002F4F 8906                <1>  mov [ esi ], _TOS_
  5899 00002F51 B800480000                  mov _TOS_, SECTOR_BUFFER_SIZE
  5900 00002F56 E80ADAFFFF                  call erase_
  5901                                  
  5902                                  ; *****************************************************************************
  5903                                  ; load the colorForth source starting at the first block
  5904                                  ; *****************************************************************************
  5905 00002F5B B820000000                  mov _TOS_, START_BLOCK_NUMBER
  5906 00002F60 E853D9FFFF                  call _load_
  5907 00002F65 E93CEAFFFF                  jmp dword accept
  5908                                  
  5909                                  ; *****************************************************************************
  5910                                  ; *****************************************************************************
  5911                                  
  5912 00002F6A 00<rept>                    align 4, db 0  ; must be on dword boundary for variables
  5913                                  
  5914                                  hsvv:    ; the start address of the pre-assembled high level Forth words
  5915 00002F6C 00000000                    dd 0
  5916 00002F70 00<rept>                    times 0x28 db 0
  5917                                  
  5918                                  xy_:   ; ( -- a )
  5919                                      _DUP_
  5920 00002F98 83EE04              <1>  sub esi, byte 0x04
  5921 00002F9B 8906                <1>  mov [ esi ], _TOS_
  5922                                      LOAD_RELATIVE_ADDRESS v_xy
  5923 00002F9D B8AC390100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  5924 00002FA2 C3                          ret
  5925                                  
  5926                                  fov_:   ; ( -- a )
  5927                                      _DUP_
  5928 00002FA3 83EE04              <1>  sub esi, byte 0x04
  5929 00002FA6 8906                <1>  mov [ esi ], _TOS_
  5930                                      LOAD_RELATIVE_ADDRESS v_fov
  5931 00002FA8 B8B8390100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  5932 00002FAD C3                          ret
  5933                                  
  5934                                  tokenActions_:   ; ( -- a )
  5935                                      _DUP_
  5936 00002FAE 83EE04              <1>  sub esi, byte 0x04
  5937 00002FB1 8906                <1>  mov [ esi ], _TOS_
  5938                                      LOAD_RELATIVE_ADDRESS tokenActions
  5939 00002FB3 B86C390100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  5940 00002FB8 C3                          ret
  5941                                  
  5942                                  last_:   ; ( -- a )
  5943                                      _DUP_
  5944 00002FB9 83EE04              <1>  sub esi, byte 0x04
  5945 00002FBC 8906                <1>  mov [ esi ], _TOS_
  5946                                      LOAD_RELATIVE_ADDRESS last
  5947 00002FBE B853300100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  5948 00002FC3 C3                          ret
  5949                                  
  5950                                  version_:   ; ( -- a )
  5951                                      _DUP_
  5952 00002FC4 83EE04              <1>  sub esi, byte 0x04
  5953 00002FC7 8906                <1>  mov [ esi ], _TOS_
  5954                                      LOAD_RELATIVE_ADDRESS version
  5955 00002FC9 B8C0670100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  5956 00002FCE C3                          ret
  5957                                  
  5958                                  vframe_:     ; ( -- a )  \ return the video frame address, where we create the image to be displayed
  5959                                      _DUP_
  5960 00002FCF 83EE04              <1>  sub esi, byte 0x04
  5961 00002FD2 8906                <1>  mov [ esi ], _TOS_
  5962 00002FD4 A1[BC390000]                mov _TOS_, [ vframe ]
  5963 00002FD9 C3                          ret
  5964                                  
  5965                                  vars_:
  5966                                      _DUP_
  5967 00002FDA 83EE04              <1>  sub esi, byte 0x04
  5968 00002FDD 8906                <1>  mov [ esi ], _TOS_
  5969                                      LOAD_RELATIVE_ADDRESS vars
  5970 00002FDF B818390100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  5971 00002FE4 C3                          ret
  5972                                  
  5973                                  base_:
  5974                                      _DUP_
  5975 00002FE5 83EE04              <1>  sub esi, byte 0x04
  5976 00002FE8 8906                <1>  mov [ esi ], _TOS_
  5977                                      LOAD_RELATIVE_ADDRESS base
  5978 00002FEA B818390100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  5979 00002FEF C3                          ret
  5980                                  
  5981                                  hex_:
  5982 00002FF0 C605[18390000]10            mov byte [ base ], 16
  5983 00002FF7 C3                          ret
  5984                                  
  5985                                  decimal_:
  5986 00002FF8 C605[18390000]0A            mov byte [ base ], 10
  5987 00002FFF C3                          ret
  5988                                  
  5989                                  block_: ; ( block -- address )   \ : block ( n -- n ) $400 * ; address is in bytes
  5990 00003000 C1E00A                      shl _TOS_, 0x0A
  5991 00003003 0500000100                  add _TOS_, RELOCATED
  5992 00003008 C3                          ret
  5993                                  
  5994                                  scrnw_:    ; ( -- n )   screen width ( number of horizontal pixels )
  5995                                      _DUP_
  5996 00003009 83EE04              <1>  sub esi, byte 0x04
  5997 0000300C 8906                <1>  mov [ esi ], _TOS_
  5998 0000300E 31C0                        xor _TOS_, _TOS_
  5999 00003010 66A112180000                mov word ax, [ vesa_XResolution ]
  6000 00003016 C3                          ret
  6001                                  
  6002                                  scrnh_:    ; ( -- n )    screen height ( number of vertical pixels )
  6003                                      _DUP_
  6004 00003017 83EE04              <1>  sub esi, byte 0x04
  6005 0000301A 8906                <1>  mov [ esi ], _TOS_
  6006 0000301C 31C0                        xor _TOS_, _TOS_
  6007 0000301E 66A114180000                mov word ax, [ vesa_YResolution ]     ; v_scrnh
  6008 00003024 C3                          ret
  6009                                  
  6010                                  bpp_:    ; ( -- n )    bits per pixel
  6011                                      _DUP_
  6012 00003025 83EE04              <1>  sub esi, byte 0x04
  6013 00003028 8906                <1>  mov [ esi ], _TOS_
  6014 0000302A 31C0                        xor _TOS_, _TOS_
  6015 0000302C A019180000                  mov byte al, [ vesa_BitsPerPixel ]     ; v_bitsPerPixel
  6016 00003031 C3                          ret
  6017                                  
  6018                                  iconw_:    ; ( -- n )    icon width ( number of pixels between characters, fixed font width )
  6019                                      _DUP_
  6020 00003032 83EE04              <1>  sub esi, byte 0x04
  6021 00003035 8906                <1>  mov [ esi ], _TOS_
  6022 00003037 A1[E0380000]                mov _TOS_, [ v_iconw ]
  6023 0000303C C3                          ret
  6024                                  
  6025                                  iconh_:    ; ( -- n )    icon height ( number of pixels between lines )
  6026                                      _DUP_
  6027 0000303D 83EE04              <1>  sub esi, byte 0x04
  6028 00003040 8906                <1>  mov [ esi ], _TOS_
  6029 00003042 A1[E4380000]                mov _TOS_, [ v_iconh ]
  6030 00003047 C3                          ret
  6031                                  
  6032                                  font_:    ; ( -- n )    font16x24 font address
  6033                                      _DUP_
  6034 00003048 83EE04              <1>  sub esi, byte 0x04
  6035 0000304B 8906                <1>  mov [ esi ], _TOS_
  6036                                      LOAD_RELATIVE_ADDRESS font16x24
  6037 0000304D B800680100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6038 00003052 C3                          ret
  6039                                  
  6040                                  last:   ; ( -- a )
  6041                                      _DUP_
  6042 00003053 83EE04              <1>  sub esi, byte 0x04
  6043 00003056 8906                <1>  mov [ esi ], _TOS_
  6044                                      LOAD_RELATIVE_ADDRESS v_last
  6045 00003058 B854390100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6046 0000305D C3                          ret
  6047                                  
  6048                                  blk_:   ; ( -- a )
  6049                                      _DUP_
  6050 0000305E 83EE04              <1>  sub esi, byte 0x04
  6051 00003061 8906                <1>  mov [ esi ], _TOS_
  6052                                      LOAD_RELATIVE_ADDRESS v_blk
  6053 00003063 B888380100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6054 00003068 C3                          ret
  6055                                  
  6056                                  seeb:   ; ( -- )    \ toggle the display of blue words in the editor
  6057 00003069 F615[04390000]              not byte [ v_seeb ]
  6058 0000306F C3                          ret
  6059                                  
  6060                                  colourBlindModeToggle:   ; ( -- )    \ toggle the editor display colorForth / ANS style
  6061 00003070 F615[05390000]              not byte [ v_colourBlindMode ]
  6062 00003076 C3                          ret
  6063                                  
  6064                                  curs:   ; ( -- a )
  6065                                      _DUP_
  6066 00003077 83EE04              <1>  sub esi, byte 0x04
  6067 0000307A 8906                <1>  mov [ esi ], _TOS_
  6068                                      LOAD_RELATIVE_ADDRESS v_curs
  6069 0000307C B8A8380100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6070 00003081 C3                          ret
  6071                                  
  6072                                  %if 0
  6073                                  stacks_:   ;  ( -- a )   \ return the address of the stack memory information ( see v_stack_info for details )
  6074                                  ;RETURN_STACK_SIZE
  6075                                  ;DATA_STACK_SIZE
  6076                                  ;STACK_MEMORY_START       ; bottom of stack memory
  6077                                  ;TOTAL_STACK_SIZE
  6078                                      _DUP_
  6079                                      mov _TOS_, RETURN_STACK_0 - 0x3C           ; top of task 0 return stack
  6080                                      _DUP_
  6081                                      mov _TOS_, DATA_STACK_0   - 0x3C           ; top of task 0 data stack
  6082                                      _DUP_
  6083                                      mov _TOS_, RETURN_STACK_1 - 0x3C           ; top of task 1 return stack
  6084                                      _DUP_
  6085                                      mov _TOS_, DATA_STACK_1   - 0x3C           ; top of task 1 data stack
  6086                                      _DUP_
  6087                                      mov _TOS_, RETURN_STACK_2 - 0x3C           ; top of task 2 return stack
  6088                                  ;    _DUP_
  6089                                  ;    mov _TOS_, DATA_STACK_2   - 0x3C           ; top of task 2 data stack
  6090                                  ;    LOAD_RELATIVE_ADDRESS v_stack_info
  6091                                      ret
  6092                                  %endif
  6093                                  
  6094                                  ekt:   ; ( -- a ) ; editor key table - variable containing vectors for editor keys beginning with null
  6095                                      ; and the shift keys.  Then follows right hand top, middle, bottom rows,
  6096                                      ; and left hand top, middle, bottom rows. (from ColorForth2.0a.doc)
  6097                                      _DUP_
  6098 00003082 83EE04              <1>  sub esi, byte 0x04
  6099 00003085 8906                <1>  mov [ esi ], _TOS_
  6100                                      LOAD_RELATIVE_ADDRESS editorActionTable
  6101 00003087 B85F270100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6102 0000308C C3                          ret
  6103                                  
  6104                                  vword_:   ; ( -- a )
  6105                                      _DUP_
  6106 0000308D 83EE04              <1>  sub esi, byte 0x04
  6107 00003090 8906                <1>  mov [ esi ], _TOS_
  6108                                      LOAD_RELATIVE_ADDRESS v_words
  6109 00003092 B830390100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6110 00003097 C3                          ret
  6111                                  
  6112                                  ;vregs_:   ; ( -- a )
  6113                                  ;    _DUP_
  6114                                  ;    mov eax, V_REGS
  6115                                  ;    ret
  6116                                  
  6117                                  ivec_:   ; ( -- a )
  6118                                      _DUP_
  6119 00003098 83EE04              <1>  sub esi, byte 0x04
  6120 0000309B 8906                <1>  mov [ esi ], _TOS_
  6121 0000309D B8001C0000                  mov eax, INTERRUPT_VECTORS
  6122 000030A2 C3                          ret
  6123                                  
  6124                                  pic_:   ; ( -- a )
  6125                                      _DUP_
  6126 000030A3 83EE04              <1>  sub esi, byte 0x04
  6127 000030A6 8906                <1>  mov [ esi ], _TOS_
  6128 000030A8 B880170000                  mov eax, IDT_AND_PIC_SETTINGS
  6129 000030AD C3                          ret
  6130                                  
  6131                                  %if 0
  6132                                  
  6133                                  From : https://pdos.csail.mit.edu/6.828/2014/readings/hardware/8259A.pdf
  6134                                  
  6135                                  The following registers can be read via OCW3 (IRR and ISR or OCW1 [IMR]).
  6136                                  
  6137                                  Interrupt Request Register (IRR):
  6138                                  8-bit register which contains the levels requesting an interrupt to be acknowledged.
  6139                                  The highest request level is reset from the IRR when an interrupt is acknowledged. (Not affected by IMR.)
  6140                                  
  6141                                  In-Service Register (ISR):
  6142                                  8-bit register which contains the priority levels that are being serviced.
  6143                                  The ISR is updated when an End of Interrupt Command is issued.
  6144                                  
  6145                                  Interrupt Mask Register:
  6146                                  8-bit register which contains the interrupt request lines which are masked.
  6147                                      The IRR can be read when, prior to the RD pulse, a Read Register Command is issued with OCW3 (RR = 1, RIS = 0.)
  6148                                      The ISR can be read, when, prior to the RD pulse, a Read Register Command is issued with OCW3 (RR = 1, RIS = 1).
  6149                                  There is no need to write an OCW3 before every status read operation,
  6150                                     as long as the status read corresponds with the previous one; i.e., the 8259A remembers whether the IRR or ISR
  6151                                     has been previously selected by the OCW3.
  6152                                     This is not true when poll is used.
  6153                                      After initialization the 8259A is set to IRR.
  6154                                  
  6155                                  For reading the IMR, no OCW3 is needed.
  6156                                  The output data bus will contain the IMR whenever RD is active and A0 = 1 (OCW1).
  6157                                  Polling overrides status read when P = 1, RR = 1 in OCW3.
  6158                                  
  6159                                  From : https://en.wikibooks.org/wiki/X86_Assembly/Programmable_Interrupt_Controller
  6160                                  
  6161                                  Remapping
  6162                                  Another common task, often performed during the initialization of an operating system, is remapping the PICs.
  6163                                  That is, changing their internal vector offsets, thereby altering the interrupt numbers they send.
  6164                                  The initial vector offset of PIC1 is 8, so it raises interrupt numbers 8 to 15.
  6165                                  Unfortunately, some of the low 32 interrupts are used by the CPU for exceptions
  6166                                  (divide-by-zero, page fault, etc.), causing a conflict between hardware and software interrupts.
  6167                                  The usual solution to this is remapping the PIC1 to start at 32, and often the PIC2 right after it at 40.
  6168                                  This requires a complete restart of the PICs, but is not actually too difficult, requiring just eight 'out's.
  6169                                  
  6170                                  mov al, 0x11
  6171                                  out 0x20, al     ;restart PIC1
  6172                                  out 0xA0, al     ;restart PIC2
  6173                                  
  6174                                  mov al, 0x20
  6175                                  out 0x21, al     ;PIC1 now starts at 32
  6176                                  mov al, 0x28
  6177                                  out 0xA1, al     ;PIC2 now starts at 40
  6178                                  
  6179                                  mov al, 0x04
  6180                                  out 0x21, al     ;setup cascading
  6181                                  mov al, 0x02
  6182                                  out 0xA1, al
  6183                                  
  6184                                  mov al, 0x01
  6185                                  out 0x21, al
  6186                                  out 0xA1, al     ;done!
  6187                                  
  6188                                  From: cf2019 Forth block 244
  6189                                  : p!   pc! ;  \ 8 bit port store
  6190                                  : pic1! $21 p! ;
  6191                                  : pic2! $A1 p! ;
  6192                                  
  6193                                  : !pic cli
  6194                                  ( init )       $11 dup $20 p! $A0 p!
  6195                                  ( irq )        $20 pic1! $28 pic2!
  6196                                  ( master )     #4 pic1!
  6197                                  ( slave )      #2 pic2!
  6198                                  ( 8086 mode )  #1 dup pic1! pic2!
  6199                                  ( mask irqs )  $FF pic2! $FA pic1! ;
  6200                                  
  6201                                  Re-factored :
  6202                                  : !pic cli
  6203                                  \ PIC1
  6204                                  ( init )     $11 $20 p!
  6205                                  ( irq )      $20 $21 p!
  6206                                  ( master )   $04 $21 p!
  6207                                  ( 8086 mode) $01 $21 p!
  6208                                  ( mask irqs) $FA $21 p!
  6209                                  \ PIC2
  6210                                  ( init )     $11 $A0 p!
  6211                                  ( irq )      $28 $A1 p!
  6212                                  ( slave )    $02 $A1 p!
  6213                                  ( 8086 mode) $01 $A1 p!
  6214                                  ( mask irqs) $FF $A1 p!
  6215                                  ;
  6216                                  
  6217                                  %endif
  6218                                  
  6219                                  dap_:   ; ( -- a )
  6220                                      _DUP_
  6221 000030AE 83EE04              <1>  sub esi, byte 0x04
  6222 000030B1 8906                <1>  mov [ esi ], _TOS_
  6223 000030B3 B8E0170000                  mov eax, DAP_BUFFER
  6224 000030B8 C3                          ret
  6225                                  
  6226                                  sect_:   ; ( -- a )
  6227                                      _DUP_
  6228 000030B9 83EE04              <1>  sub esi, byte 0x04
  6229 000030BC 8906                <1>  mov [ esi ], _TOS_
  6230 000030BE B800200000                  mov eax, SECTOR_BUFFER
  6231 000030C3 C3                          ret
  6232                                  
  6233                                  digin:   ; ( -- a )
  6234                                      _DUP_
  6235 000030C4 83EE04              <1>  sub esi, byte 0x04
  6236 000030C7 8906                <1>  mov [ esi ], _TOS_
  6237                                      LOAD_RELATIVE_ADDRESS v_digin
  6238 000030C9 B838390100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6239 000030CE C3                          ret
  6240                                  
  6241                                  actc:   ; ( -- a )
  6242                                      _DUP_
  6243 000030CF 83EE04              <1>  sub esi, byte 0x04
  6244 000030D2 8906                <1>  mov [ esi ], _TOS_
  6245                                      LOAD_RELATIVE_ADDRESS actionColourTable
  6246 000030D4 B824220100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6247 000030D9 C3                          ret
  6248                                  
  6249                                  tickh:   ; ( -- a )    HERE variable address
  6250                                      _DUP_
  6251 000030DA 83EE04              <1>  sub esi, byte 0x04
  6252 000030DD 8906                <1>  mov [ esi ], _TOS_
  6253                                      LOAD_RELATIVE_ADDRESS v_H
  6254 000030DF B850390100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6255 000030E4 C3                          ret
  6256                                  
  6257                                  forths_:   ; ( -- a )
  6258                                      _DUP_
  6259 000030E5 83EE04              <1>  sub esi, byte 0x04
  6260 000030E8 8906                <1>  mov [ esi ], _TOS_
  6261                                      LOAD_RELATIVE_ADDRESS v_ForthWordCount
  6262 000030EA B864390100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6263 000030EF C3                          ret
  6264                                  
  6265                                  macros_:   ; ( -- a )
  6266                                      _DUP_
  6267 000030F0 83EE04              <1>  sub esi, byte 0x04
  6268 000030F3 8906                <1>  mov [ esi ], _TOS_
  6269                                      LOAD_RELATIVE_ADDRESS v_MacroWordCount
  6270 000030F5 B868390100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6271 000030FA C3                          ret
  6272                                  
  6273                                  offset_:   ; ( -- a )
  6274                                      _DUP_
  6275 000030FB 83EE04              <1>  sub esi, byte 0x04
  6276 000030FE 8906                <1>  mov [ esi ], _TOS_
  6277                                      LOAD_RELATIVE_ADDRESS v_offset
  6278 00003100 B8D8380100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6279 00003105 C3                          ret
  6280                                  
  6281                                  vesa:   ; ( -- a )
  6282                                      _DUP_
  6283 00003106 83EE04              <1>  sub esi, byte 0x04
  6284 00003109 8906                <1>  mov [ esi ], _TOS_
  6285 0000310B B800180000                  mov _TOS_, VESA_BUFFER
  6286 00003110 C3                          ret
  6287                                  
  6288                                  vesamode_:   ; ( -- u )
  6289                                      _DUP_
  6290 00003111 83EE04              <1>  sub esi, byte 0x04
  6291 00003114 8906                <1>  mov [ esi ], _TOS_
  6292 00003116 31C0                        xor _TOS_, _TOS_
  6293 00003118 66A11E180000                mov word ax, [ vesa_SavedMode ]     ; the saved  VESA video mode value
  6294 0000311E C3                          ret
  6295                                  
  6296                                  fetchDX_:   ; ( -- c )
  6297                                      _DUP_
  6298 0000311F 83EE04              <1>  sub esi, byte 0x04
  6299 00003122 8906                <1>  mov [ esi ], _TOS_
  6300 00003124 31C0                        xor _TOS_, _TOS_
  6301 00003126 57                          push edi
  6302 00003127 BFE0170000                  mov edi, DAP_BUFFER
  6303 0000312C 8A4712                      mov _TOS_l_, [ edi + o_Int13_DAP_saved_DX ]     ; setup DX value returned by the BIOS
  6304 0000312F 5F                          pop edi
  6305 00003130 C3                          ret
  6306                                  
  6307                                  trash_:   ; ( -- a )
  6308                                      _DUP_
  6309 00003131 83EE04              <1>  sub esi, byte 0x04
  6310 00003134 8906                <1>  mov [ esi ], _TOS_
  6311                                      LOAD_RELATIVE_ADDRESS v_trash
  6312 00003136 B8D4380100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6313 0000313B C3                          ret
  6314                                  
  6315                                  buffer_:   ; ( -- a )
  6316                                      _DUP_
  6317 0000313C 83EE04              <1>  sub esi, byte 0x04
  6318 0000313F 8906                <1>  mov [ esi ], _TOS_
  6319 00003141 B800200000                  mov _TOS_, SECTOR_BUFFER ;0x25300
  6320 00003146 C3                          ret
  6321                                  
  6322                                  cad:   ; ( -- a )   , the address of the cursor as an offset from the start of the currently displayed block
  6323                                      _DUP_
  6324 00003147 83EE04              <1>  sub esi, byte 0x04
  6325 0000314A 8906                <1>  mov [ esi ], _TOS_
  6326                                      LOAD_RELATIVE_ADDRESS v_cad
  6327 0000314C B8C8380100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6328 00003151 C3                          ret
  6329                                  
  6330                                  pcad:   ; ( -- a )
  6331                                      _DUP_
  6332 00003152 83EE04              <1>  sub esi, byte 0x04
  6333 00003155 8906                <1>  mov [ esi ], _TOS_
  6334                                      LOAD_RELATIVE_ADDRESS v_pcad
  6335 00003157 B8CC380100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6336 0000315C C3                          ret
  6337                                  
  6338                                  hsvv_:   ; ( -- a )
  6339                                      _DUP_
  6340 0000315D 83EE04              <1>  sub esi, byte 0x04
  6341 00003160 8906                <1>  mov [ esi ], _TOS_
  6342                                      LOAD_RELATIVE_ADDRESS hsvv
  6343 00003162 B86C2F0100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6344 00003167 C3                          ret
  6345                                  
  6346                                  displ:   ; ( -- a )
  6347                                      _DUP_
  6348 00003168 83EE04              <1>  sub esi, byte 0x04
  6349 0000316B 8906                <1>  mov [ esi ], _TOS_
  6350                                      LOAD_RELATIVE_ADDRESS displayShannonFanoActions
  6351 0000316D B81F210100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6352 00003172 C3                          ret
  6353                                  
  6354                                  cBlindAddr_:   ; ( -- a )
  6355                                      _DUP_
  6356 00003173 83EE04              <1>  sub esi, byte 0x04
  6357 00003176 8906                <1>  mov [ esi ], _TOS_
  6358                                      LOAD_RELATIVE_ADDRESS x_colourBlind
  6359 00003178 B800390100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6360 0000317D C3                          ret
  6361                                  
  6362                                  ; *****************************************************************************
  6363                                  ; memory operators
  6364                                  ; *****************************************************************************
  6365                                  
  6366                                  cFetch_:      ; ( a -- c ) \ c@
  6367 0000317E 31DB                        xor _SCRATCH_, _SCRATCH_
  6368 00003180 8A18                        mov byte _SCRATCH_l_, [ _TOS_ ] ;
  6369 00003182 89D8                        mov _TOS_, _SCRATCH_
  6370 00003184 C3                          ret
  6371                                  
  6372                                  wFetch_:      ; ( a -- w ) \ w@
  6373 00003185 31DB                        xor _SCRATCH_, _SCRATCH_
  6374 00003187 668B18                      mov word _SCRATCH_x_, [ _TOS_ ] ;
  6375 0000318A 89D8                        mov _TOS_, _SCRATCH_
  6376 0000318C C3                          ret
  6377                                  
  6378                                  fetch_:       ; ( a -- u ) \ @
  6379 0000318D 8B00                        mov dword _TOS_, [ _TOS_ ] ;
  6380 0000318F C3                          ret
  6381                                  
  6382                                  cStore_:      ; ( c a -- ) \ c!
  6383 00003190 8B1E                        mov _SCRATCH_, [ esi ]
  6384 00003192 8818                        mov byte [ _TOS_ ], _SCRATCH_l_
  6385 00003194 C3                          ret
  6386                                  
  6387                                  wStore_:      ; ( w a -- ) \ w!
  6388 00003195 8B1E                        mov _SCRATCH_, [ esi ]
  6389 00003197 668918                      mov word [ _TOS_ ], _SCRATCH_x_
  6390 0000319A C3                          ret
  6391                                  
  6392                                  store_:       ; ( u a -- ) \ !
  6393 0000319B 8B1E                        mov _SCRATCH_, [ esi ]
  6394 0000319D 8918                        mov dword [ _TOS_ ], _SCRATCH_
  6395 0000319F C3                          ret
  6396                                  
  6397                                  ; *****************************************************************************
  6398                                  ; stack operators
  6399                                  ; *****************************************************************************
  6400                                  
  6401                                  two_dup_:       ; ( a b -- a b a b )
  6402 000031A0 83EE08                      sub esi, byte 0x08 ; lea esi, [ esi - 0x08 ]    ; pre-decrement the stack pointer, adding 2 cells
  6403 000031A3 894604                      mov [ esi + 4 ], _TOS_  ; copy x2 to Third On Stack ( second on the real stack )
  6404 000031A6 8B5E08                      mov _SCRATCH_, [ esi + 8 ]    ; copy x1 to register ebx
  6405 000031A9 891E                        mov [ esi ], _SCRATCH_        ; copy register ebx to Fourth On Stack
  6406 000031AB C3                          ret
  6407                                  
  6408                                  two_drop_:      ; ( a b -- )
  6409                                      _DROP_
  6410 000031AC AD                  <1>  lodsd
  6411                                      _DROP_
  6412 000031AD AD                  <1>  lodsd
  6413 000031AE C3                          ret
  6414                                  
  6415                                  two_swap_:      ; ( a b c d -- c d a b )
  6416 000031AF 8B5E08                      mov _SCRATCH_, [ esi + 8 ]
  6417 000031B2 871E                        xchg _SCRATCH_, [ esi ]
  6418 000031B4 895E08                      mov  [ esi + 8 ], _SCRATCH_
  6419 000031B7 874604                      xchg _TOS_, [ esi + 4 ]
  6420 000031BA C3                          ret
  6421                                  
  6422                                  two_over_:      ; ( a b c d -- a b c d a b )
  6423 000031BB 8D76F8                      lea esi, [ esi - 8 ]
  6424 000031BE 894604                      mov [ esi + 4 ], _TOS_
  6425 000031C1 8B5E10                      mov _SCRATCH_, [ esi + 0x10 ]
  6426 000031C4 891E                        mov [esi], _SCRATCH_
  6427 000031C6 8B460C                      mov _TOS_, [ esi + 0x0C ]
  6428 000031C9 C3                          ret
  6429                                  
  6430                                  rot_:           ; ( a b c -- b c a)
  6431 000031CA 8B5E04                      mov _SCRATCH_,[ esi + 4 ]
  6432 000031CD 8B2E                        mov ebp, [ esi ]
  6433 000031CF 896E04                      mov [ esi + 4 ], ebp
  6434 000031D2 8906                        mov [ esi ],_TOS_
  6435 000031D4 89D8                        mov _TOS_, _SCRATCH_
  6436 000031D6 C3                          ret
  6437                                  
  6438                                  minus_rot_:     ; -rot ( a b c -- c b a)
  6439 000031D7 8B5E04                      mov _SCRATCH_, [ esi + 4 ]
  6440 000031DA 8B2E                        mov ebp, [ esi ]
  6441 000031DC 894604                      mov [ esi + 4 ], _TOS_
  6442 000031DF 891E                        mov [esi], _SCRATCH_
  6443 000031E1 89E8                        mov _TOS_, ebp
  6444 000031E3 C3                          ret
  6445                                  
  6446                                  tuck_:          ; ( a b -- b a b )
  6447                                      _SWAP_
  6448 000031E4 8706                <1>  xchg _TOS_, [ esi ]
  6449                                      _OVER_
  6450 000031E6 83EE04              <1>  sub esi, byte 0x04
  6451 000031E9 8906                <1>  mov [ esi ], _TOS_
  6452 000031EB 8B4604              <1>  mov _TOS_, [ esi + 4 ]
  6453 000031EE C3                          ret
  6454                                  
  6455                                  pick_:          ; ( ... n -- ... u ) where u is the n'th stack item
  6456 000031EF 8B0486                      mov eax, [ esi + ( eax * 4 ) ]
  6457 000031F2 C3                          ret
  6458                                  
  6459                                  %define CELL_WIDTH  0x04    ; this is a 32 bit wide system = 4 bytes
  6460                                  
  6461                                  cell_:          ; ( -- c )
  6462                                      _DUP_
  6463 000031F3 83EE04              <1>  sub esi, byte 0x04
  6464 000031F6 8906                <1>  mov [ esi ], _TOS_
  6465 000031F8 B804000000                  mov _TOS_, CELL_WIDTH
  6466 000031FD C3                          ret
  6467                                  
  6468                                  cell_minus_:    ; ( u -- u' )
  6469 000031FE 2D04000000                  sub _TOS_, CELL_WIDTH
  6470 00003203 C3                          ret
  6471                                  
  6472                                  cell_plus_:    ; ( u -- u' )
  6473 00003204 0504000000                  add _TOS_, CELL_WIDTH
  6474 00003209 C3                          ret
  6475                                  
  6476                                  cells_:         ; ( u -- u' )
  6477 0000320A 01C0                        add _TOS_, _TOS_    ; this code must be changed if CELL_WIDTH is changed
  6478 0000320C 01C0                        add _TOS_, _TOS_
  6479 0000320E C3                          ret
  6480                                  
  6481                                  ; *****************************************************************************
  6482                                  ; save and restore the Interrupt Descriptor Table and Interrupt Mask Registers
  6483                                  ; *****************************************************************************
  6484                                  
  6485                                  lidt_:  ; ( a -- )  \ set a into the Interrupt Descriptor Table (IDT) register
  6486 0000320F FA                          cli
  6487 00003210 55                          push ebp
  6488 00003211 BD80170000                  mov ebp, ( PIC_BIOS_IDT_SETTINGS )   ; 6 bytes of RAM used to store the IDT info
  6489 00003216 66C74500B703                mov word [ ebp ], 0x03B7
  6490 0000321C 894502                      mov [ ebp + 2 ], _TOS_   ; save IDT base address from eax
  6491 0000321F 0F015D00                    lidt [ ebp ]  ; db 0x0F, 0x01, 0x18
  6492                                      _DROP_
  6493 00003223 AD                  <1>  lodsd
  6494 00003224 5D                          pop ebp
  6495 00003225 C3                          ret
  6496                                  
  6497                                  sidt_:  ; ( -- a )  \ return the address contained in the Interrupt Descriptor Table (IDT) register
  6498 00003226 FA                          cli
  6499                                      _DUP_
  6500 00003227 83EE04              <1>  sub esi, byte 0x04
  6501 0000322A 8906                <1>  mov [ esi ], _TOS_
  6502 0000322C 55                          push ebp
  6503 0000322D BDA0170000                  mov ebp, ( IDT_AND_PIC_SETTINGS_PAD )   ; 6 bytes of RAM used to interface to the stack
  6504 00003232 0F014D00                    sidt [ ebp ]        ; write the 6-byte IDT to memory location pointed to by  ebp
  6505 00003236 8B4502                      mov _TOS_, [ ebp + 2 ]   ; save IDT base address to eax
  6506 00003239 5D                          pop ebp
  6507 0000323A C3                          ret
  6508                                  
  6509                                  save_BIOS_idt:  ; ( -- )  \ save the Interrupt Descriptor Table (IDT) register value
  6510 0000323B FA                          cli
  6511 0000323C 55                          push ebp
  6512 0000323D BD80170000                  mov ebp, ( PIC_BIOS_IDT_SETTINGS )   ; 6 bytes of RAM used to save the values in
  6513 00003242 0F014D00                    sidt [ ebp ]        ; write the 6-byte IDT to memory location pointed to by  ebp
  6514 00003246 5D                          pop ebp
  6515 00003247 C3                          ret
  6516                                  
  6517                                  restore_BIOS_idt:  ; ( -- )  \ restore the saved IDT value into the Interrupt Descriptor Table (IDT) register
  6518 00003248 FA                          cli
  6519 00003249 55                          push ebp
  6520 0000324A BD80170000                  mov ebp, ( PIC_BIOS_IDT_SETTINGS )   ; 6 bytes of RAM used to restore from
  6521 0000324F 0F015D00                    lidt [ ebp ]  ; db 0x0F, 0x01, 0x18
  6522 00003253 5D                          pop ebp
  6523 00003254 C3                          ret
  6524                                  
  6525                                  save_BIOS_idt_and_pic: ; ( -- )   \ save the PIC1 and PIC2 IMR values into IDT_AND_PIC_SETTINGS at startup
  6526 00003255 FA                          cli
  6527 00003256 E8E0FFFFFF                  call save_BIOS_idt
  6528 0000325B 55                          push ebp
  6529 0000325C BD86170000                  mov ebp, ( PIC_BIOS_IMR_SETTINGS )   ; 2 bytes of RAM used to save the IMR for PIC1 and PIC2
  6530                                  ; PIC1
  6531 00003261 E421                        in al, 0x21     ; read PIC1's IMR value
  6532 00003263 884500                      mov [ ebp ], al
  6533                                  ; PIC2
  6534 00003266 45                          inc ebp
  6535 00003267 E4A1                        in al, 0xA1     ; read PIC 2's IMR value
  6536 00003269 884500                      mov [ ebp ], al
  6537 0000326C 5D                          pop ebp
  6538 0000326D C3                          ret
  6539                                  
  6540                                  restore_BIOS_idt_and_pic: ; ( -- )   \ restore the saved BIOS PIC and IMR values into PIC1 and PIC2
  6541 0000326E FA                          cli
  6542 0000326F E8D4FFFFFF                  call restore_BIOS_idt
  6543 00003274 55                          push ebp
  6544 00003275 BD86170000                  mov ebp, ( PIC_BIOS_IMR_SETTINGS )   ; 2 bytes of RAM used to save the IMR for PIC1 and PIC2
  6545                                  ; PIC1
  6546 0000327A B011                        mov al, 0x11    ; init command
  6547 0000327C E620                        out 0x20, al    ; init PIC1                 ( $11 $20 p! )
  6548 0000327E B000                        mov al, 0x00    ; PIC1 Interrupt Vector table start address
  6549 00003280 E621                        out 0x21, al    ; PIC1 now starts at 0x00   ( $00 $21 p! )
  6550 00003282 B004                        mov al, 0x04    ; master mode command
  6551 00003284 E621                        out 0x21, al    ; set PIC1 as master, sets up cascading of PIC1 and PIC2 ( $04 $21 p! )
  6552 00003286 B001                        mov al, 0x01    ; 8086 command
  6553 00003288 E621                        out 0x21, al    ; set 8086 mode         ( $01 $21 p! )
  6554 0000328A 8A4500                      mov al, [ ebp ] ; Interrupt Mask Register ( IMR )
  6555 0000328D E621                        out 0x21, al    ; set PIC1's IMR, BIOS = 0xB8 ( $xx $21 p! )
  6556                                  ; PIC2
  6557 0000328F 45                          inc ebp
  6558 00003290 B011                        mov al, 0x11    ; init command
  6559 00003292 E6A0                        out 0xA0, al    ; init PIC2
  6560 00003294 B008                        mov al, 0x08    ; PIC2 Interrupt Vector table start address
  6561 00003296 E6A1                        out 0xA1, al    ; PIC2 now starts at 0x08   $08 $A1 p!
  6562 00003298 B002                        mov al, 0x02    ; slave mode command
  6563 0000329A E6A1                        out 0xA1, al    ; set PIC2 as slave     ( $02 $A1 p! )
  6564 0000329C B001                        mov al, 0x01    ; 8086 command
  6565 0000329E E6A1                        out 0xA1, al    ; set 8086 mode         ( $01 $A1 p! )
  6566 000032A0 8A4500                      mov al, [ ebp ] ; Interrupt Mask Register ( IMR )
  6567 000032A3 E6A1                        out 0xA1, al    ; set PIC2's IMR, BIOS = 0x8F ( $xx $A1 p! )
  6568 000032A5 5D                          pop ebp
  6569 000032A6 C3                          ret
  6570                                  
  6571                                  restore_new_idt_and_pic: ; ( -- )   \ restore the new IDT and PIC IMR values
  6572 000032A7 FA                          cli
  6573 000032A8 55                          push ebp
  6574 000032A9 BD96170000                  mov ebp, ( PIC_NEW_IMR_SETTINGS )   ; 2 bytes of RAM used to save the IMR for PIC1 and PIC2
  6575                                  ; PIC1
  6576 000032AE B011                        mov al, 0x11    ; init command
  6577 000032B0 E620                        out 0x20, al    ; init PIC1                 ( $11 $20 p! )
  6578 000032B2 B020                        mov al, 0x20    ; PIC1 Interrupt Vector table start address
  6579 000032B4 E621                        out 0x21, al    ; PIC1 now starts at 0x20   ( $20 $21 p! )
  6580 000032B6 B004                        mov al, 0x04    ; master mode command
  6581 000032B8 E621                        out 0x21, al    ; set PIC1 as master, sets up cascading of PIC1 and PIC2 ( $04 $21 p! )
  6582 000032BA B001                        mov al, 0x01    ; 8086 command
  6583 000032BC E621                        out 0x21, al    ; set 8086 mode         ( $01 $21 p! )
  6584 000032BE 8A4500                      mov al, [ ebp ] ; Interrupt Mask Register ( IMR )
  6585 000032C1 E621                        out 0x21, al    ; set PIC1's IMR, BIOS = 0xB8 ( $xx $21 p! )
  6586                                  ; PIC2
  6587 000032C3 45                          inc ebp
  6588 000032C4 B011                        mov al, 0x11    ; init command
  6589 000032C6 E6A0                        out 0xA0, al    ; init PIC2
  6590 000032C8 B028                        mov al, 0x28    ; PIC2 Interrupt Vector table start address
  6591 000032CA E6A1                        out 0xA1, al    ; PIC2 now starts at 0x28   $28 $A1 p!
  6592 000032CC B002                        mov al, 0x02    ; slave mode command
  6593 000032CE E6A1                        out 0xA1, al    ; set PIC2 as slave     ( $02 $A1 p! )
  6594 000032D0 B001                        mov al, 0x01    ; 8086 command
  6595 000032D2 E6A1                        out 0xA1, al    ; set 8086 mode         ( $01 $A1 p! )
  6596 000032D4 8A4500                      mov al, [ ebp ] ; Interrupt Mask Register ( IMR )
  6597 000032D7 E6A1                        out 0xA1, al    ; set PIC2's IMR, BIOS = 0x8F ( $xx $A1 p! )
  6598 000032D9 5D                          pop ebp
  6599 000032DA C3                          ret
  6600                                  
  6601                                  init_default_PIC_IMRs:  ; ( -- )
  6602 000032DB 9C                          pushf
  6603 000032DC FA                          cli
  6604                                  
  6605 000032DD 60                          pusha
  6606 000032DE BE00000000                  mov esi, 0x0000                 ; source address = the BIOS interrupt vector table
  6607 000032E3 BF001C0000                  mov edi, INTERRUPT_VECTORS      ; destination address
  6608 000032E8 B900010000                  mov ecx, ( 1024 / 4 )           ; 1024 bytes in cells
  6609 000032ED F3A5                        rep movsd                       ; does not change AX , it moves DS:SI to ES:DI and increments SI and DI
  6610                                      ; now copy Interrupts 0x00 to 0x0F up to 0x20 to 0x2F
  6611 000032EF BE00000000                  mov esi, 0x0000                 ; source address = the BIOS interrupt vector table
  6612 000032F4 BF801C0000                  mov edi, ( INTERRUPT_VECTORS + ( 0x20 * 4 ) )  ; destination address
  6613 000032F9 B910000000                  mov ecx, ( 0x10 )               ; 16 vectors in cells
  6614 000032FE F3A5                        rep movsd                       ; does not change AX , it moves DS:SI to ES:DI and increments SI and DI
  6615                                  
  6616 00003300 61                          popa
  6617                                  
  6618 00003301 55                          push ebp
  6619 00003302 BD96170000                  mov ebp, ( PIC_NEW_IMR_SETTINGS )   ; 2 bytes of RAM used to save the IMR for PIC1 and PIC2
  6620 00003307 C64500FA                    mov byte [ ebp ] , 0xFA   ; Interrupt Mask Register ( IMR ) saved value for PIC1
  6621 0000330B 45                          inc ebp
  6622 0000330C C64500FF                    mov byte [ ebp ] , 0xFF   ; Interrupt Mask Register ( IMR ) saved value for PIC2
  6623 00003310 5D                          pop ebp
  6624 00003311 9D                          popf
  6625 00003312 C3                          ret
  6626                                  
  6627                                  set_PIC1_IMR:   ; ( c -- )   \ set the Interrupt Mask Register for PIC1 and copy to PIC_NEW_IMR_SETTINGS
  6628 00003313 9C                          pushf
  6629 00003314 FA                          cli
  6630 00003315 55                          push ebp
  6631 00003316 BD96170000                  mov ebp, ( PIC_NEW_IMR_SETTINGS )   ; 1 byte of RAM used to save the IMR for PIC1
  6632 0000331B 884500                      mov [ ebp ] , al    ; Interrupt Mask Register ( IMR )
  6633 0000331E E621                        out 0x21, al        ; set PIC1's IMR ( $xx $21 p! )
  6634 00003320 5D                          pop ebp
  6635 00003321 9D                          popf
  6636                                      _DROP_
  6637 00003322 AD                  <1>  lodsd
  6638 00003323 C3                          ret
  6639                                  
  6640                                  set_PIC2_IMR:   ; ( c -- )   \ set the Interrupt Mask Register for PIC2 and copy to PIC_NEW_IMR_SETTINGS+1
  6641 00003324 9C                          pushf
  6642 00003325 FA                          cli
  6643 00003326 55                          push ebp
  6644 00003327 BD97170000                  mov ebp, ( PIC_NEW_IMR_SETTINGS + 1 )   ; 1 byte of RAM used to save the IMR for PIC1
  6645 0000332C 884500                      mov [ ebp ] , al    ; Interrupt Mask Register ( IMR )
  6646 0000332F E6A1                        out 0xA1, al        ; set PIC2's IMR ( $xx $A1 p! )
  6647 00003331 5D                          pop ebp
  6648 00003332 9D                          popf
  6649                                      _DROP_
  6650 00003333 AD                  <1>  lodsd
  6651 00003334 C3                          ret
  6652                                  
  6653                                  ; *****************************************************************************
  6654                                  ; lp support for GRaphics demo
  6655                                  ; *****************************************************************************
  6656                                  
  6657                                  lp_:
  6658 00003335 90                          nop
  6659 00003336 90                          nop
  6660 00003337 90                          nop
  6661 00003338 8BE8                        db 0x8B , 0xE8 ; mov ebp,eax
  6662 0000333A AD                          lodsd
  6663 0000333B 8BC8                        db 0x8B , 0xC8 ; mov ecx,eax
  6664 0000333D AD                          lodsd
  6665 0000333E 8B5A20                      mov ebx,[edx+0x20]
  6666                                      .back:
  6667 00003341 66892B                      mov [ebx],bp
  6668 00003344 23C0                        db 0x23 , 0xC0 ; and eax,eax   21C0                        and eax,eax
  6669 00003346 7805                        js .forward
  6670 00003348 0302                        add eax,[edx]
  6671 0000334A 035A18                      add ebx,[edx+0x18]
  6672                                      .forward:
  6673 0000334D 034208                      add eax,[edx+0x8]
  6674 00003350 035A10                      add ebx,[edx+0x10]
  6675 00003353 E2EC                        loop .back
  6676                                  ;    dd 0x8B909090 , 0xC88BADE8 , 0x205A8BAD , 0x232B8966
  6677                                  ;    dd 0x030578C0 , 0x185A0302 , 0x03084203 , 0xECE2105A
  6678 00003355 C3                          ret
  6679                                  
  6680                                  ; *****************************************************************************
  6681                                  ; maths operators
  6682                                  ; The ANSI/ISO Forth Standard (adopted in 1994) mandates the minimal set
  6683                                  ; of arithmetic operators +  -  *  /  MOD  */  /MOD  */MOD and  M* .
  6684                                  ; *****************************************************************************
  6685                                  
  6686                                  two_slash_:     ;  "2/" arithmetic divide by 2
  6687 00003356 D1F8                        sar _TOS_, 0x01
  6688 00003358 C3                          ret
  6689                                  
  6690                                  cmove_:  ; ( from to count -- )
  6691 00003359 85C0                        test _TOS_, _TOS_
  6692 0000335B 7410                        jz .forward
  6693 0000335D 89C3                            mov _SCRATCH_, _TOS_
  6694 0000335F 8B16                            mov edx, [ esi + 0 ]
  6695 00003361 8B4E04                          mov ecx, [ esi + 0x04 ]
  6696                                          .back:
  6697 00003364 8A01                                mov byte al, [ ecx + 0 ]
  6698 00003366 8802                                mov byte [ edx + 0 ], al
  6699 00003368 41                                  inc ecx
  6700 00003369 42                                  inc edx
  6701 0000336A 4B                                  dec _SCRATCH_
  6702 0000336B 75F7                            jnz .back
  6703                                      .forward:
  6704 0000336D 8B4608                      mov _TOS_, [ esi + 0x08 ]
  6705 00003370 81C60C000000                add esi, 0x0C
  6706 00003376 C3                          ret
  6707                                  
  6708                                  two_star_:  ; ( u -- u' )    u' = 2 * u
  6709 00003377 D1E0                        shl _TOS_, 1
  6710 00003379 C3                          ret
  6711                                  
  6712                                  two_star_star_:     ; ( c -- u )  u  = 2 ** c
  6713 0000337A 89C1                        mov ecx, _TOS_
  6714 0000337C B801000000                  mov eax, 0x00000001
  6715 00003381 D3E0                        shl _TOS_, cl
  6716 00003383 C3                          ret
  6717                                  
  6718                                  ; *****************************************************************************
  6719                                  ; Random and Pseudo Random Number Generators
  6720                                  ; *****************************************************************************
  6721                                  
  6722                                  GetCPUIDsupport:    ; ( -- )  equal flag is set if no CPUID support
  6723                                      ; check to see if CPUID is supported
  6724 00003384 9C                          pushfd              ; save EFLAGS
  6725 00003385 58                          pop eax             ; store EFLAGS in EAX
  6726 00003386 89C3                        mov ebx, eax        ; save in EBX for later testing
  6727 00003388 3500002000                  xor eax, 00200000h  ; toggle bit 21
  6728 0000338D 50                          push eax            ; push to stack
  6729 0000338E 9D                          popfd               ; save changed EAX to EFLAGS
  6730 0000338F 9C                          pushfd              ; push EFLAGS to TOS
  6731 00003390 58                          pop eax             ; store EFLAGS in EAX
  6732 00003391 39D8                        cmp eax, ebx        ; see if bit 21 has changed
  6733 00003393 C3                          ret
  6734                                  
  6735                                  GetRDRANDsupport:   ; zero flag is set if no support for RDRAND, the hardware Random Number generator
  6736 00003394 B801000000                  mov eax, 0x00000001     ; select the 'features' CPU information
  6737 00003399 0FA2                        CPUID           ; get CPU information into eax, ebx, ecx and edx
  6738 0000339B A900000040                  test eax, 0x40000000 ; Bit 30 of ECX returned by CPUID => RDRAND present if true
  6739 000033A0 C3                          ret
  6740                                  
  6741                                  GetCPUID_:   ; ( -- u )
  6742                                      _DUP_
  6743 000033A1 83EE04              <1>  sub esi, byte 0x04
  6744 000033A4 8906                <1>  mov [ esi ], _TOS_
  6745 000033A6 B801000000                  mov eax, 0x00000001     ; select the 'features' CPU information
  6746 000033AB 0FA2                        CPUID           ; get CPU information into eax, ebx, ecx and edx
  6747 000033AD C3                          ret
  6748                                  
  6749                                  rdtsc_:  ; ( -- u )   \ return the current processor instruction counter
  6750                                      _DUP_
  6751 000033AE 83EE04              <1>  sub esi, byte 0x04
  6752 000033B1 8906                <1>  mov [ esi ], _TOS_
  6753 000033B3 0F31                        rdtsc ; db 0x0F, 0x31
  6754 000033B5 C3                          ret
  6755                                  
  6756                                  randInit_:
  6757 000033B6 E8F3FFFFFF                  call rdtsc_
  6758 000033BB 55                          push ebp
  6759 000033BC BD[0C390000]                mov ebp, v_random
  6760 000033C1 314500                      xor [ ebp ], _TOS_      ; vRandom ! , if the value was 0
  6761 000033C4 5D                          pop ebp
  6762                                      _DROP_
  6763 000033C5 AD                  <1>  lodsd
  6764 000033C6 C3                          ret
  6765                                  
  6766                                  %if 0
  6767                                  \ Marsaglia, "Xorshift RNGs".  http://www.jstatsoft.org/v08/i14/paper
  6768                                  : Random32 ( -- u )
  6769                                      vRandom @
  6770                                      dup 0= or
  6771                                      dup 6 lshift xor
  6772                                      dup 21 rshift xor
  6773                                      dup 7 lshift xor
  6774                                      dup vRandom ! ;
  6775                                  %endif
  6776                                  
  6777                                  ; \ Marsaglia, "Xorshift RNGs".  http://www.jstatsoft.org/v08/i14/paper
  6778                                  getRandMarsaglia: ; ( -- u )   \ load a 32 bit pseudo random number into TOS
  6779                                      _DUP_
  6780 000033C7 83EE04              <1>  sub esi, byte 0x04
  6781 000033CA 8906                <1>  mov [ esi ], _TOS_
  6782 000033CC 55                          push ebp
  6783 000033CD BD[0C390000]                mov ebp, v_random
  6784 000033D2 8B4500                      mov _TOS_, [ ebp ]      ; vRandom @
  6785 000033D5 85C0                        test _TOS_, _TOS_
  6786 000033D7 7505                        jnz .forward            ; dup 0= or
  6787 000033D9 B8FFFFFFFF                      mov _TOS_, 0xFFFFFFFF
  6788                                      .forward:
  6789                                  
  6790 000033DE 89C3                        mov _SCRATCH_, _TOS_    ; dup 6 lshift xor
  6791 000033E0 C1E306                      shl _SCRATCH_, 0x06
  6792 000033E3 31D8                        xor _TOS_, _SCRATCH_
  6793                                  
  6794 000033E5 89C3                        mov _SCRATCH_, _TOS_    ; dup 21 rshift xor
  6795 000033E7 C1EB15                      shr _SCRATCH_, 0x15
  6796 000033EA 31D8                        xor _TOS_, _SCRATCH_
  6797                                  
  6798 000033EC 89C3                        mov _SCRATCH_, _TOS_    ; dup 7 lshift xor
  6799 000033EE C1E307                      shl _SCRATCH_, 0x07
  6800 000033F1 31D8                        xor _TOS_, _SCRATCH_
  6801                                  
  6802 000033F3 894500                      mov [ ebp ], _TOS_      ; vRandom !
  6803                                  
  6804 000033F6 5D                          pop ebp
  6805 000033F7 C3                          ret
  6806                                  
  6807                                  rand_:  ; ( -- u )   \ load a 32 bit true random number into TOS
  6808                                      _DUP_
  6809 000033F8 83EE04              <1>  sub esi, byte 0x04
  6810 000033FB 8906                <1>  mov [ esi ], _TOS_
  6811 000033FD E882FFFFFF                  call GetCPUIDsupport
  6812 00003402 740B                        je .NO_CPUID             ; if no change to bit 21, no CPUID
  6813                                          ; CPUID is supported, so check if RDRAND is supported
  6814 00003404 E88BFFFFFF                      call GetRDRANDsupport
  6815 00003409 7404                            jz .NO_CPUID         ; test for RDRAND support
  6816 0000340B 0FC7F0                              RDRAND _TOS_    ; supported, so call the instruction
  6817 0000340E C3                                  ret
  6818                                      .NO_CPUID:
  6819                                      _DROP_
  6820 0000340F AD                  <1>  lodsd
  6821 00003410 E8B2FFFFFF                  call getRandMarsaglia
  6822 00003415 C3                          ret
  6823                                  
  6824                                  randq_:     ; ( -- f )   \ returns true if the processor supports the RDRAND random number instruction
  6825                                      _DUP_
  6826 00003416 83EE04              <1>  sub esi, byte 0x04
  6827 00003419 8906                <1>  mov [ esi ], _TOS_
  6828 0000341B E864FFFFFF                  call GetCPUIDsupport
  6829 00003420 740D                        jz .NO_CPUID             ; if no change, no CPUID
  6830                                          ; CPUID is supported, so check if RDRAND is supported
  6831 00003422 E86DFFFFFF                      call GetRDRANDsupport
  6832 00003427 7406                            jz .NO_CPUID         ; test for RDRAND support
  6833 00003429 B8FFFFFFFF                          mov _TOS_, 0xFFFFFFFF
  6834 0000342E C3                              ret
  6835                                      .NO_CPUID:
  6836 0000342F 31C0                        xor _TOS_, _TOS_
  6837 00003431 C3                          ret
  6838                                  
  6839                                  ; *****************************************************************************
  6840                                  ; CRC32 Cyclic Redundancy Checksum (32 bit)
  6841                                  ; The International Standard 32-bit cyclical redundancy check defined by :
  6842                                  ; [ITU-T-V42] International Telecommunications Union, "Error-correcting
  6843                                  ; Procedures for DCEs Using Asynchronous-to-Synchronous Conversion",
  6844                                  ; ITU-T Recommendation V.42, 1994, Rev. 1.
  6845                                  ; and
  6846                                  ; [ISO-3309]
  6847                                  ; International Organization for Standardization,
  6848                                  ; "Information Processing Systems--Data Communication High-Level Data Link
  6849                                  ; Control Procedure--Frame Structure", IS 3309, October 1984, 3rd Edition.
  6850                                  ; *****************************************************************************
  6851                                  
  6852                                  crc32_table:
  6853 00003432 00000000963007772C-         dd 000000000h, 077073096h, 0EE0E612Ch, 0990951BAh, 0076DC419h, 0706AF48Fh, 0E963A535h, 09E6495A3h, 00EDB8832h, 079DCB8A4h
  6854 0000343B 610EEEBA51099919C4-
  6855 00003444 6D078FF46A7035A563-
  6856 0000344D E9A395649E3288DB0E-
  6857 00003456 A4B8DC79           
  6858 0000345A 1EE9D5E088D9D2972B-         dd 0E0D5E91Eh, 097D2D988h, 009B64C2Bh, 07EB17CBDh, 0E7B82D07h, 090BF1D91h, 01DB71064h, 06AB020F2h, 0F3B97148h, 084BE41DEh
  6859 00003463 4CB609BD7CB17E072D-
  6860 0000346C B8E7911DBF906410B7-
  6861 00003475 1DF220B06A4871B9F3-
  6862 0000347E DE41BE84           
  6863 00003482 7DD4DA1AEBE4DD6D51-         dd 01ADAD47Dh, 06DDDE4EBh, 0F4D4B551h, 083D385C7h, 0136C9856h, 0646BA8C0h, 0FD62F97Ah, 08A65C9ECh, 014015C4Fh, 063066CD9h
  6864 0000348B B5D4F4C785D3835698-
  6865 00003494 6C13C0A86B647AF962-
  6866 0000349D FDECC9658A4F5C0114-
  6867 000034A6 D96C0663           
  6868 000034AA 633D0FFAF50D088DC8-         dd 0FA0F3D63h, 08D080DF5h, 03B6E20C8h, 04C69105Eh, 0D56041E4h, 0A2677172h, 03C03E4D1h, 04B04D447h, 0D20D85FDh, 0A50AB56Bh
  6869 000034B3 206E3B5E10694CE441-
  6870 000034BC 60D5727167A2D1E403-
  6871 000034C5 3C47D4044BFD850DD2-
  6872 000034CE 6BB50AA5           
  6873 000034D2 FAA8B5356C98B242D6-         dd 035B5A8FAh, 042B2986Ch, 0DBBBC9D6h, 0ACBCF940h, 032D86CE3h, 045DF5C75h, 0DCD60DCFh, 0ABD13D59h, 026D930ACh, 051DE003Ah
  6874 000034DB C9BBDB40F9BCACE36C-
  6875 000034E4 D832755CDF45CF0DD6-
  6876 000034ED DC593DD1ABAC30D926-
  6877 000034F6 3A00DE51           
  6878 000034FA 8051D7C81661D0BFB5-         dd 0C8D75180h, 0BFD06116h, 021B4F4B5h, 056B3C423h, 0CFBA9599h, 0B8BDA50Fh, 02802B89Eh, 05F058808h, 0C60CD9B2h, 0B10BE924h
  6879 00003503 F4B42123C4B3569995-
  6880 0000350C BACF0FA5BDB89EB802-
  6881 00003515 280888055FB2D90CC6-
  6882 0000351E 24E90BB1           
  6883 00003522 877C6F2F114C6858AB-         dd 02F6F7C87h, 058684C11h, 0C1611DABh, 0B6662D3Dh, 076DC4190h, 001DB7106h, 098D220BCh, 0EFD5102Ah, 071B18589h, 006B6B51Fh
  6884 0000352B 1D61C13D2D66B69041-
  6885 00003534 DC760671DB01BC20D2-
  6886 0000353D 982A10D5EF8985B171-
  6887 00003546 1FB5B606           
  6888 0000354A A5E4BF9F33D4B8E8A2-         dd 09FBFE4A5h, 0E8B8D433h, 07807C9A2h, 00F00F934h, 09609A88Eh, 0E10E9818h, 07F6A0DBBh, 0086D3D2Dh, 091646C97h, 0E6635C01h
  6889 00003553 C9077834F9000F8EA8-
  6890 0000355C 099618980EE1BB0D6A-
  6891 00003565 7F2D3D6D08976C6491-
  6892 0000356E 015C63E6           
  6893 00003572 F4516B6B62616C1CD8-         dd 06B6B51F4h, 01C6C6162h, 0856530D8h, 0F262004Eh, 06C0695EDh, 01B01A57Bh, 08208F4C1h, 0F50FC457h, 065B0D9C6h, 012B7E950h
  6894 0000357B 3065854E0062F2ED95-
  6895 00003584 066C7BA5011BC1F408-
  6896 0000358D 8257C40FF5C6D9B065-
  6897 00003596 50E9B712           
  6898 0000359A EAB8BE8B7C88B9FCDF-         dd 08BBEB8EAh, 0FCB9887Ch, 062DD1DDFh, 015DA2D49h, 08CD37CF3h, 0FBD44C65h, 04DB26158h, 03AB551CEh, 0A3BC0074h, 0D4BB30E2h
  6899 000035A3 1DDD62492DDA15F37C-
  6900 000035AC D38C654CD4FB5861B2-
  6901 000035B5 4DCE51B53A7400BCA3-
  6902 000035BE E230BBD4           
  6903 000035C2 41A5DF4AD795D83D6D-         dd 04ADFA541h, 03DD895D7h, 0A4D1C46Dh, 0D3D6F4FBh, 04369E96Ah, 0346ED9FCh, 0AD678846h, 0DA60B8D0h, 044042D73h, 033031DE5h
  6904 000035CB C4D1A4FBF4D6D36AE9-
  6905 000035D4 6943FCD96E34468867-
  6906 000035DD ADD0B860DA732D0444-
  6907 000035E6 E51D0333           
  6908 000035EA 5F4C0AAAC97C0DDD3C-         dd 0AA0A4C5Fh, 0DD0D7CC9h, 05005713Ch, 0270241AAh, 0BE0B1010h, 0C90C2086h, 05768B525h, 0206F85B3h, 0B966D409h, 0CE61E49Fh
  6909 000035F3 710550AA4102271010-
  6910 000035FC 0BBE86200CC925B568-
  6911 00003605 57B3856F2009D466B9-
  6912 0000360E 9FE461CE           
  6913 00003612 0EF9DE5E98C9D92922-         dd 05EDEF90Eh, 029D9C998h, 0B0D09822h, 0C7D7A8B4h, 059B33D17h, 02EB40D81h, 0B7BD5C3Bh, 0C0BA6CADh, 0EDB88320h, 09ABFB3B6h
  6914 0000361B 98D0B0B4A8D7C7173D-
  6915 00003624 B359810DB42E3B5CBD-
  6916 0000362D B7AD6CBAC02083B8ED-
  6917 00003636 B6B3BF9A           
  6918 0000363A 0CE2B6039AD2B17439-         dd 003B6E20Ch, 074B1D29Ah, 0EAD54739h, 09DD277AFh, 004DB2615h, 073DC1683h, 0E3630B12h, 094643B84h, 00D6D6A3Eh, 07A6A5AA8h
  6919 00003643 47D5EAAF77D29D1526-
  6920 0000364C DB048316DC73120B63-
  6921 00003655 E3843B64943E6A6D0D-
  6922 0000365E A85A6A7A           
  6923 00003662 0BCF0EE49DFF099327-         dd 0E40ECF0Bh, 09309FF9Dh, 00A00AE27h, 07D079EB1h, 0F00F9344h, 08708A3D2h, 01E01F268h, 06906C2FEh, 0F762575Dh, 0806567CBh
  6924 0000366B AE000AB19E077D4493-
  6925 00003674 0FF0D2A3088768F201-
  6926 0000367D 1EFEC206695D5762F7-
  6927 00003686 CB676580           
  6928 0000368A 71366C19E7066B6E76-         dd 0196C3671h, 06E6B06E7h, 0FED41B76h, 089D32BE0h, 010DA7A5Ah, 067DD4ACCh, 0F9B9DF6Fh, 08EBEEFF9h, 017B7BE43h, 060B08ED5h
  6929 00003693 1BD4FEE02BD3895A7A-
  6930 0000369C DA10CC4ADD676FDFB9-
  6931 000036A5 F9F9EFBE8E43BEB717-
  6932 000036AE D58EB060           
  6933 000036B2 E8A3D6D67E93D1A1C4-         dd 0D6D6A3E8h, 0A1D1937Eh, 038D8C2C4h, 04FDFF252h, 0D1BB67F1h, 0A6BC5767h, 03FB506DDh, 048B2364Bh, 0D80D2BDAh, 0AF0A1B4Ch
  6934 000036BB C2D83852F2DF4FF167-
  6935 000036C4 BBD16757BCA6DD06B5-
  6936 000036CD 3F4B36B248DA2B0DD8-
  6937 000036D6 4C1B0AAF           
  6938 000036DA F64A0336607A0441C3-         dd 036034AF6h, 041047A60h, 0DF60EFC3h, 0A867DF55h, 0316E8EEFh, 04669BE79h, 0CB61B38Ch, 0BC66831Ah, 0256FD2A0h, 05268E236h
  6939 000036E3 EF60DF55DF67A8EF8E-
  6940 000036EC 6E3179BE69468CB361-
  6941 000036F5 CB1A8366BCA0D26F25-
  6942 000036FE 36E26852           
  6943 00003702 95770CCC03470BBBB9-         dd 0CC0C7795h, 0BB0B4703h, 0220216B9h, 05505262Fh, 0C5BA3BBEh, 0B2BD0B28h, 02BB45A92h, 05CB36A04h, 0C2D7FFA7h, 0B5D0CF31h
  6944 0000370B 1602222F260555BE3B-
  6945 00003714 BAC5280BBDB2925AB4-
  6946 0000371D 2B046AB35CA7FFD7C2-
  6947 00003726 31CFD0B5           
  6948 0000372A 8B9ED92C1DAEDE5BB0-         dd 02CD99E8Bh, 05BDEAE1Dh, 09B64C2B0h, 0EC63F226h, 0756AA39Ch, 0026D930Ah, 09C0906A9h, 0EB0E363Fh, 072076785h, 005005713h
  6949 00003733 C2649B26F263EC9CA3-
  6950 0000373C 6A750A936D02A90609-
  6951 00003745 9C3F360EEB85670772-
  6952 0000374E 13570005           
  6953 00003752 824ABF95147AB8E2AE-         dd 095BF4A82h, 0E2B87A14h, 07BB12BAEh, 00CB61B38h, 092D28E9Bh, 0E5D5BE0Dh, 07CDCEFB7h, 00BDBDF21h, 086D3D2D4h, 0F1D4E242h
  6954 0000375B 2BB17B381BB60C9B8E-
  6955 00003764 D2920DBED5E5B7EFDC-
  6956 0000376D 7C21DFDB0BD4D2D386-
  6957 00003776 42E2D4F1           
  6958 0000377A F8B3DD686E83DA1FCD-         dd 068DDB3F8h, 01FDA836Eh, 081BE16CDh, 0F6B9265Bh, 06FB077E1h, 018B74777h, 088085AE6h, 0FF0F6A70h, 066063BCAh, 011010B5Ch
  6959 00003783 16BE815B26B9F6E177-
  6960 0000378C B06F7747B718E65A08-
  6961 00003795 88706A0FFFCA3B0666-
  6962 0000379E 5C0B0111           
  6963 000037A2 FF9E658F69AE62F8D3-         dd 08F659EFFh, 0F862AE69h, 0616BFFD3h, 0166CCF45h, 0A00AE278h, 0D70DD2EEh, 04E048354h, 03903B3C2h, 0A7672661h, 0D06016F7h
  6964 000037AB FF6B6145CF6C1678E2-
  6965 000037B4 0AA0EED20DD7548304-
  6966 000037BD 4EC2B30339612667A7-
  6967 000037C6 F71660D0           
  6968 000037CA 4D476949DB776E3E4A-         dd 04969474Dh, 03E6E77DBh, 0AED16A4Ah, 0D9D65ADCh, 040DF0B66h, 037D83BF0h, 0A9BCAE53h, 0DEBB9EC5h, 047B2CF7Fh, 030B5FFE9h
  6969 000037D3 6AD1AEDC5AD6D9660B-
  6970 000037DC DF40F03BD83753AEBC-
  6971 000037E5 A9C59EBBDE7FCFB247-
  6972 000037EE E9FFB530           
  6973 000037F2 1CF2BDBD8AC2BACA30-         dd 0BDBDF21Ch, 0CABAC28Ah, 053B39330h, 024B4A3A6h, 0BAD03605h, 0CDD70693h, 054DE5729h, 023D967BFh, 0B3667A2Eh, 0C4614AB8h
  6974 000037FB 93B353A6A3B4240536-
  6975 00003804 D0BA9306D7CD2957DE-
  6976 0000380D 54BF67D9232E7A66B3-
  6977 00003816 B84A61C4           
  6978 0000381A 021B685D942B6F2A37-         dd 05D681B02h, 02A6F2B94h, 0B40BBE37h, 0C30C8EA1h, 05A05DF1Bh, 02D02EF8Dh
  6979 00003823 BE0BB4A18E0CC31BDF-
  6980 0000382C 055A8DEF022D       
  6981                                  
  6982                                  ; CRC-32 with polynomial $04c11db7, as specified in IEEE 802.3 ( Ethernet )
  6983                                   crc32_:    ; ( a n -- u )   \ CRC32 Cyclic Redundancy Checksum
  6984 00003832 53                          push    _SCRATCH_
  6985 00003833 51                          push    ecx
  6986 00003834 52                          push    edx
  6987                                  
  6988 00003835 89C1                        mov ecx, _TOS_
  6989                                      _DROP_
  6990 00003837 AD                  <1>  lodsd
  6991 00003838 89C3                        mov _SCRATCH_, _TOS_
  6992                                      ; address in ebx, count in ecx, result in eax
  6993                                  
  6994 0000383A 31D2                        xor edx, edx
  6995                                  
  6996 0000383C B8FFFFFFFF                  mov  _TOS_, 0xFFFFFFFF     ; initial CRC value
  6997                                  
  6998 00003841 85C9                        test ecx, ecx
  6999 00003843 7414                        jz .forward
  7000                                  
  7001                                          .back:
  7002 00003845 8A13                            mov dl, byte [_SCRATCH_]
  7003 00003847 30C2                            xor dl, al
  7004 00003849 C1E808                          shr _TOS_, 8
  7005 0000384C 330495[32340000]                xor _TOS_, dword [ crc32_table + ( 4 * edx ) ]
  7006 00003853 43                              inc _SCRATCH_
  7007 00003854 49                              dec ecx
  7008 00003855 75EE                            jnz .back
  7009                                  
  7010 00003857 F7D0                            not _TOS_     ; invert the final CRC value
  7011                                      .forward:
  7012                                  
  7013 00003859 5A                          pop edx
  7014 0000385A 59                          pop ecx
  7015 0000385B 5B                          pop _SCRATCH_
  7016 0000385C C3                          ret
  7017                                  
  7018                                  ; *****************************************************************************
  7019                                  ; *****************************************************************************
  7020                                  
  7021 0000385D 90<rept>                align 4, nop
  7022                                  
  7023                                  tens:
  7024 00003860 0A000000                    dd 10
  7025 00003864 64000000                    dd 100
  7026 00003868 E8030000                    dd 1000
  7027 0000386C 10270000                    dd 10000
  7028 00003870 A0860100                    dd 100000
  7029 00003874 40420F00                    dd 1000000
  7030 00003878 80969800                    dd 10000000
  7031 0000387C 00E1F505                    dd 100000000
  7032 00003880 00CA9A3B                    dd 1000000000
  7033                                  
  7034                                  x_numberDisplay:    ; either dotDecimal or dotHex , depending on the BASE to use to display numbers
  7035 00003884 [16110000]                  dd dotDecimal
  7036                                  
  7037                                  v_blk:          ; the currently edited block
  7038 00003888 20000000                    dd START_BLOCK_NUMBER           ; the default edited block
  7039                                  
  7040                                  v_otherBlock:   ; the previously edited block
  7041 0000388C 21000000                    dd START_BLOCK_NUMBER + 1       ; the default other block is the shadow of the default edited block
  7042                                  
  7043                                  v_otherBlocks:   ; the previously edited block array
  7044 00003890 20000000                    dd START_BLOCK_NUMBER           ; the default edited block
  7045 00003894 21000000                    dd START_BLOCK_NUMBER + 1       ; the default other block is the shadow of the default edited block
  7046 00003898 22000000                    dd START_BLOCK_NUMBER + 2       ; the default other block is the shadow of the default edited block
  7047 0000389C 23000000                    dd START_BLOCK_NUMBER + 3       ; the default other block is the shadow of the default edited block
  7048                                  
  7049                                  v_help_counter:     ; cycles through the help screens used by "help" ( F1 key )
  7050 000038A0 00000000                    dd 0
  7051                                  
  7052                                  v_saved_v_blk:      ; the block number saved by "help"
  7053 000038A4 FF000000                    dd 0xFF
  7054                                  
  7055                                  v_curs:             ; the offset in cells of the cursor within a block
  7056 000038A8 00000000                    dd 0
  7057                                  
  7058                                  v_cursPtr:          ; variable to count the cursor offset from the start of the block
  7059 000038AC 00000000                    dd 0
  7060                                  
  7061                                  v_cursLine:         ; which line we want to display the cursor on
  7062 000038B0 00000000                    dd 0
  7063                                  
  7064                                  v_curs_number_down: ; to limit the steps down
  7065 000038B4 00000000                    dd 0
  7066                                  
  7067                                  v_numberOfMagentas:
  7068 000038B8 00000000                    dd 0
  7069                                  
  7070                                  v_numberOfBigConstants:
  7071 000038BC 00000000                    dd 0
  7072                                  
  7073                                  v_numberOfRedAndMagentas:
  7074 000038C0 00000000                    dd 0
  7075                                  
  7076                                  v_numberOfTokens:   ; in the current block
  7077 000038C4 00000000                    dd 0
  7078                                  
  7079                                  v_cad:
  7080 000038C8 00000000                    dd 0
  7081                                  
  7082                                  v_pcad:
  7083 000038CC 00000000                    dd 0
  7084                                  
  7085                                  v_lcad:
  7086 000038D0 00000000                    dd 0
  7087                                  
  7088                                  v_trash:                            ; pointer to "trash" buffer, saves words deleted while editing
  7089 000038D4 60130000                    dd TRASH_BUFFER
  7090                                  
  7091                                  v_offset:
  7092 000038D8 40000000                    dd ( RELOCATED >> ( 2 + 8 ) )
  7093                                  
  7094                                  v_bitsPerPixel:
  7095 000038DC 10000000                    dd 16   ; default, set using VESA info
  7096                                  
  7097                                  v_iconw:
  7098 000038E0 00000000                    dd 0 ; iconw
  7099                                  
  7100                                  v_iconh:
  7101 000038E4 00000000                    dd 0 ; iconh
  7102                                  
  7103                                  v_keypadY_iconh:
  7104 000038E8 00000000                    dd 0    ; keypadY * iconh
  7105                                  
  7106                                  v_nine_iconw:
  7107 000038EC 00000000                    dd 0
  7108                                  
  7109                                  v_twentytwo_iconw:  ; width of 12 history characters, 1 space and 9 keypad characters
  7110 000038F0 00000000                    dd 0            ; to calculate the start of the history display, subtracted from the right edge of the screen
  7111                                  
  7112                                  v_10000_iconw:
  7113 000038F4 00000000                    dd 0    ; iconw*0x10000
  7114                                  
  7115                                  x_qwerty:           ; selects non-QWERTY if set to 0, else jumps to the address
  7116 000038F8 FFFFFFFF                    dd 0xFFFFFFFF   ;
  7117                                  
  7118                                  x_abort:
  7119 000038FC [B32A0000]                  dd abort_action
  7120                                  
  7121                                  x_colourBlind:  ; ( state -- state )
  7122 00003900 [921C0000]                  dd colourBlindAction
  7123                                  
  7124                                  ; byte variables
  7125                                  v_seeb:             ; if = 255, show blue words in editor
  7126 00003904 00                          db 0            ; 255 enable, 0 disable
  7127                                  
  7128                                  v_colourBlindMode:  ; if = 255, select ANS style editor display
  7129 00003905 00                          db 0            ; 255 enable, 0 disable
  7130                                  
  7131                                  v_not_cr:   ; true to disable the  cr  before a red word is displayed in the editor
  7132 00003906 00                          db 0
  7133                                  
  7134                                  v_acceptMode:       ; if non zero, the keypad is in Edit mode, else  TIB mode
  7135 00003907 00                          db 0            ; 255 enable, 0 disable
  7136                                  
  7137                                  v_hintChar:   ; the character to display in the bottom right hand corner of the keyboard as a hint to the colour being used
  7138 00003908 00000000                    dd 0
  7139                                  
  7140                                  v_random:       ; the current Marsaglia Pseudo Random Number Generator state
  7141 0000390C 00000000                    dd 0
  7142                                  
  7143                                  align 4
  7144                                  
  7145                                  currentKeyboardIcons:
  7146 00003910 [06140000]                  dd ( alphaKeyboard - 4 )
  7147                                  
  7148                                  shiftAction:
  7149 00003914 [82170000]                  dd alpha0
  7150                                  
  7151                                  vars:       ; colorForth system variables start here
  7152                                  base:
  7153 00003918 0A000000                    dd 10
  7154                                  
  7155                                  current:
  7156 0000391C [30190000]                  dd setDecimalMode
  7157                                  
  7158                                  keyboard_colour:
  7159 00003920 E0FF0000                    dd colour_yellow   ; current key colour for displaying key presses
  7160                                  
  7161                                  chars:
  7162 00003924 01000000                    dd 1
  7163                                  
  7164                                  aword:
  7165 00003928 [E7060000]                  dd ex1
  7166                                  
  7167                                  anumber:
  7168 0000392C [00040000]                  dd nul
  7169                                  
  7170                                  v_words:
  7171 00003930 01000000                    dd 1
  7172                                  
  7173                                  v_qwerty_key:
  7174 00003934 00000000                    dd 0
  7175                                  
  7176                                  v_digin:
  7177 00003938 00000000                    dd 0
  7178                                  
  7179                                  lit:
  7180 0000393C [A7050000]                  dd adup
  7181                                  
  7182                                  v_washColour:
  7183 00003940 00000000                    dd colour_background
  7184                                  
  7185                                  mark_MacroWordCount:
  7186 00003944 06000000                    dd MACRO_INITIAL_WORD_COUNT ; initial #macros
  7187                                      ; number of Macro words, saved by  mark , empty restores to this value
  7188                                  mark_v_ForthWordCount:
  7189 00003948 9C000000                    dd FORTH_INITIAL_WORD_COUNT ; initial #words
  7190                                      ; number of Forth words, saved by  mark , empty restores to this value
  7191                                  
  7192                                  mark_H:
  7193 0000394C 00204700                    dd H0   ; 0x100000     ; top of dictionary pointer H , saved by  mark , empty restores to this value
  7194                                  
  7195                                  v_H:
  7196 00003950 00204700                    dd H0   ; 0x40000*4    ; variable H , dictionary pointer HERE, where new definitions go
  7197                                  
  7198                                  v_last:
  7199 00003954 00000000                    dd 0
  7200                                  
  7201                                  class:
  7202 00003958 00000000                    dd 0
  7203                                  
  7204                                  list:
  7205 0000395C 00000000                    dd 0
  7206                                  ; ( list + 4 )
  7207 00003960 00000000                    dd 0
  7208                                  
  7209                                  v_ForthWordCount:
  7210 00003964 9C000000                 dd FORTH_INITIAL_WORD_COUNT ; initial #words  ; number of words in the Forth wordlist, empty resets this value
  7211                                  
  7212                                  v_MacroWordCount:
  7213 00003968 06000000                 dd MACRO_INITIAL_WORD_COUNT ; initial #macros  ; number of words in the Macro wordlist, empty resets this value
  7214                                  
  7215                                  tokenActions:       ;
  7216 0000396C [87080000]                  dd qignore      ; 0  extension token
  7217 00003970 [F4060000]                  dd execute_lit  ; 1
  7218 00003974 [A8070000]                  dd num          ; 2
  7219                                  adefine: ; where definitions go, either in the Macro Dictionary or Forth Dictionary
  7220 00003978 [D9050000]                  dd forthd       ; 3
  7221 0000397C [20070000]                  dd qcompile     ; 4
  7222 00003980 [C0060000]                  dd cnum         ; 5
  7223 00003984 [D0060000]                  dd cshort       ; 6
  7224 00003988 [70070000]                  dd compile      ; 7
  7225 0000398C [8E070000]                  dd short_       ; 8
  7226 00003990 [00040000]                  dd nul          ; 9
  7227 00003994 [00040000]                  dd nul          ; A
  7228 00003998 [00040000]                  dd nul          ; B
  7229 0000399C [47060000]                  dd m_variable   ; C magenta variable
  7230 000039A0 [00040000]                  dd nul          ; D
  7231 000039A4 [00040000]                  dd nul          ; E
  7232 000039A8 [00040000]                  dd nul          ; F
  7233                                  
  7234                                  v_xy:  ; variable that holds the XY position for drawing characters, ( 0, 0 ) is top left
  7235                                  v_y:
  7236 000039AC 0300                        dw 0x0003
  7237                                  v_x:
  7238 000039AE 0300                        dw 0x0003
  7239                                  
  7240                                  v_leftMargin:
  7241 000039B0 03000000                    dd 0x00000003  ; left margin
  7242                                  
  7243                                  v_rightMargin:
  7244 000039B4 00000000                    dd 0           ; right margin
  7245                                  
  7246                                  ; xycr:
  7247                                      ; dd 0
  7248                                  
  7249                                  v_fov:  ; abstract display scale
  7250 000039B8 00000000                    dd 0    ; 10 * ( 2 * scrnh + scrnh / 2 )
  7251                                  
  7252                                  vframe:  ; pointer to display frame buffer where we create our image, down from top of 32 Mbytes RAM ( 0x2000000 )
  7253 000039BC 0000E801                    dd 0x2000000 - ( MAX_SCREEN_WIDTH * MAX_SCREEN_HEIGHT * BYTES_PER_PIXEL )
  7254                                  
  7255                                  ; v_frameBuffer:          ; framebuffer address
  7256                                  ;    dd 0x00000000       ;
  7257                                  
  7258                                  v_foregroundColour:
  7259 000039C0 00000000                    dd 0x00000000       ; the display foreground colour, set by  color
  7260                                  
  7261                                  v_xc:
  7262 000039C4 00000000                    dd 0x00000000       ;
  7263                                  v_yc:
  7264 000039C8 00000000                    dd 0x00000000          ;
  7265                                  
  7266                                  MacroNamesROM:
  7267 000039CC 000000F0                    dd 0xF0000000       ; semicolon ";"
  7268 000039D0 00109BC1                    dd 0xC19B1000       ; dup
  7269 000039D4 203683CF                    dd 0xCF833620       ; qdup
  7270                                  ;    dd 0xFF833620       ; ?dup
  7271 000039D8 008827C0                    dd 0xC0278800       ; drop
  7272 000039DC 00C0882C                    dd 0x2C88C000       ; then
  7273 000039E0 007695C6                    dd 0xC6957600       ; begin_
  7274                                  ; MacroNamesROM_end:
  7275                                  
  7276                                  MacroJumpTableROM:         ; jump table for the macro wordlist
  7277 000039E4 [F1070000]                  dd semicolon        ; ;
  7278 000039E8 [8F050000]                  dd cdup             ; compile dup
  7279 000039EC [74050000]                  dd qdup             ; qdup
  7280                                  ;    dd qdup             ; ?dup
  7281 000039F0 [5E050000]                  dd cdrop            ; compile drop
  7282 000039F4 [15080000]                  dd then             ;
  7283 000039F8 [28080000]                  dd begin_           ;
  7284                                  MacroJumpTableROM_end:
  7285                                  
  7286                                  ForthNamesROM:      ; displayed using cf2ansi
  7287 000039FC 004066C6                    dd 0xC6664000   ; boot
  7288 00003A00 00408CBA                    dd 0xBA8C4000   ; warm
  7289 00003A04 80A0B9C4                    dd 0xC4B9A080   ; pause
  7290 00003A08 004CC88A                    dd 0x8AC84C00   ; macro
  7291 00003A0C 006489B1                    dd 0xB1896400   ; forth
  7292 00003A10 00000090                    dd 0x90000000   ; c
  7293 00003A14 0050631A                    dd 0x1A635000   ; rlba      Read_Sector_LBA
  7294 00003A18 00A831BD                    dd 0xBD31A800   ; wlba      Write_Sector_LBA
  7295 00003A1C 00105C14                    dd 0x145C1000   ; reads     ReadSectors
  7296 00003A20 0024B9B8                    dd 0xB8B92400   ; writes    WriteSectors
  7297 00003A24 00002084                    dd 0x84200000   ; sss       SaveAll_
  7298                                  ;    dd 0x2C800000   ; th        th_ ( thunk to BIOS Int 0x13 )
  7299 00003A28 00005C14                    dd 0x145C0000   ; read      bios_read
  7300 00003A2C 0020B9B8                    dd 0xB8B92000   ; write     bios_write
  7301                                  ;    dd 0x18248800   ; rsect
  7302 00003A30 002883F9                    dd 0xF9832800   ; @dx       fetchDX_
  7303 00003A34 007181F5                    dd 0xF5817100   ; !dap
  7304 00003A38 00001059                    dd 0x59100000   ; act(tivate)
  7305 00003A3C 00B84386                    dd 0x8643B800   ; show
  7306 00003A40 0000AEA1                    dd 0xA1AE0000   ; load
  7307 00003A44 00E01A6A                    dd 0x6A1AE000   ; nload
  7308 00003A48 005C43F7                    dd 0xF7435C00   ; +load
  7309 00003A4C 0098832C                    dd 0x2C839800   ; thru
  7310 00003A50 300759F6                    dd 0xF6590730   ; +thru
  7311 00003A54 00743A96                    dd 0x963A7400   ; cblk      return the block number currently being compiled, calculated from  edi
  7312 00003A58 00E8741C                    dd 0x1C74E800   ; rblk      return the block number offset of the RELOCATED address
  7313 00003A5C 00E8745C                    dd 0x5C74E800   ; ablk      4 / cellAddressToBlock
  7314 00003A60 00205841                    dd 0x41582000   ; erase
  7315 00003A64 008082C8                    dd 0xC8828000   ; here
  7316 00003A68 002047FF                    dd 0xFF472000   ; ?lit
  7317 00003A6C 0000F8D7                    dd 0xD7F80000   ; 3,
  7318 00003A70 0000F8D5                    dd 0xD5F80000   ; 2,
  7319 00003A74 0000F8D3                    dd 0xD3F80000   ; 1,
  7320 00003A78 000000FC                    dd 0xFC000000   ; ,
  7321 00003A7C 000042A2                    dd 0xA2420000   ; less
  7322 00003A80 80389AE5                    dd 0xE59A3880   ; jump
  7323 00003A84 10314959                    dd 0x59493110   ; accept
  7324 00003A88 0000B8C4                    dd 0xC4B80000   ; pad
  7325 00003A8C 80C593E8                    dd 0xE893C580   ; keypd
  7326 00003A90 0040E2BB                    dd 0xBBE24000   ; wipe
  7327 00003A94 0048E2BB                    dd 0xBBE24800   ; wipes     was erase
  7328 00003A98 0098E291                    dd 0x91E29800   ; copy
  7329 00003A9C 00408F8A                    dd 0x8A8F4000   ; mark
  7330 00003AA0 8029E248                    dd 0x48E22980   ; empty
  7331 00003AA4 0000B948                    dd 0x48B90000   ; emit
  7332 00003AA8 0072F5C0                    dd 0xC0F57200   ; digit
  7333 00003AAC 007291D4                    dd 0xD4917200   ; 2emit
  7334 00003AB0 000000EA                    dd 0xEA000000   ; .
  7335 00003AB4 0000D4C9                    dd 0xC9D40000   ; h.
  7336 00003AB8 0080D5C9                    dd 0xC9D58000   ; h.n
  7337 00003ABC 00008090                    dd 0x90800000   ; cr
  7338 00003AC0 00922586                    dd 0x86259200   ; space
  7339 00003AC4 006077C0                    dd 0xC0776000   ; down
  7340 00003AC8 00400E4C                    dd 0x4C0E4000   ; edit
  7341 00003ACC 00000040                    dd 0x40000000   ; e
  7342 00003AD0 000040A4                    dd 0xA4400000   ; lm
  7343 00003AD4 00008018                    dd 0x18800000   ; rm
  7344 00003AD8 802CAEA8                    dd 0xA8AE2C80   ; graph
  7345 00003ADC 0040CA24                    dd 0x24CA4000   ; text
  7346 00003AE0 60C693E8                    dd 0xE893C660   ; keybo(ard)
  7347 00003AE4 00F398C0                    dd 0xC098F300   ; debu(g)
  7348 00003AE8 00000052                    dd 0x52000000   ; at
  7349 00003AEC 0000A4F6                    dd 0xF6A40000   ; +at
  7350 00003AF0 000030CB                    dd 0xCB300000   ; xy
  7351 00003AF4 0040B5C4                    dd 0xC4B54000   ; page
  7352 00003AF8 80118584                    dd 0x84851180   ; screen
  7353 00003AFC 0000E1B1                    dd 0xB1E10000   ; fov
  7354                                  ;    dd 0xB3D8C000   ; fifo
  7355 00003B00 004079C6                    dd 0xC6794000   ; box
  7356 00003B04 0000B2A3                    dd 0xA3B20000   ; line
  7357 00003B08 00C4D091                    dd 0x91D0C400   ; color
  7358 00003B0C 00B11239                    dd 0x3912B100   ; octant
  7359 00003B10 00002086                    dd 0x86200000   ; sp
  7360 00003B14 0080C0A2                    dd 0xA2C08000   ; last
  7361 00003B18 4096D8CC                    dd 0xCCD89640   ; unpac(k)
  7362 00003B1C 00E8B2C4                    dd 0xC4B2E800   ; pack
  7363 00003B20 00804EC7                    dd 0xC74E8000   ; blk
  7364 00003B24 00AE8584                    dd 0x8485AE00   ; scrnw  screen width in pixels
  7365 00003B28 00B28584                    dd 0x8485B200   ; scrnh  screen height in pixels
  7366 00003B2C 00108BC7                    dd 0xC78B1000   ; bpp    bits per pixel
  7367 00003B30 0000B1B1                    dd 0xB1B10000   ; font   address of font16x24
  7368 00003B34 005C1B79                    dd 0x791B5C00   ; iconw  icon width in pixels
  7369 00003B38 00641B79                    dd 0x791B6400   ; iconh  icon height in pixels
  7370 00003B3C 000082C2                    dd 0xC2820000   ; ver
  7371 00003B40 00806196                    dd 0x96618000   ; curs
  7372 00003B44 409743C7                    dd 0xC7439740   ; block
  7373 00003B48 A05861C3                    dd 0xC36158A0   ; vframe  video frame address, where we create the image to be displayed
  7374 00003B4C 0000A3C2                    dd 0xC2A30000   ; vars
  7375                                  ; new words
  7376 00003B50 00302682                    dd 0x82263000   ; seeb      ( see blue words, toggle )
  7377                                  ;    dd 0x812CBA40   ; stacks_
  7378 00003B54 000B65C0                    dd 0xC0650B00   ; dotsf     type a ShannonFano token
  7379 00003B58 00142EA2                    dd 0xA22E1400   ; leave
  7380                                  ;    dd 0x12312310   ; txtq
  7381 00003B5C 0000E31A                    dd 0x1AE30000   ; rgb
  7382 00003B60 000034C7                    dd 0xC7340000   ; bye
  7383 00003B64 00008EB9                    dd 0xB98E0000   ; word
  7384 00003B68 0000844E                    dd 0x4E840000   ; ekt
  7385 00003B6C 0024665C                    dd 0x5C662400   ; abort
  7386 00003B70 804C9727                    dd 0x27974C80   ; tickh  HERE variable address
  7387 00003B74 40D69AC7                    dd 0xC79AD640   ; buffe(r)  buffer_
  7388 00003B78 40085A3B                    dd 0x3B5A0840   ; offset
  7389 00003B7C 00009027                    dd 0x27900000   ; tic   tic_
  7390 00003B80 005090C2                    dd 0xC2905000   ; vesa
  7391 00003B84 805890C2                    dd 0xC2905880   ; vesam
  7392 00003B88 00645821                    dd 0x21586400   ; trash trash_
  7393                                  ;    dd 0xC90C3840   ; hsvv_
  7394 00003B8C 001C73C3                    dd 0xC3731C00   ; vword
  7395                                  ;    dd 0xC2295800   ; vregs
  7396 00003B90 0020297C                    dd 0x7C292000   ; ivec
  7397 00003B94 00308614                    dd 0x14863000   ; resb  restore_BIOS_idt_and_pic
  7398 00003B98 0000F2C4                    dd 0xC4F20000   ; pic
  7399 00003B9C 0080B8C0                    dd 0xC0B88000   ; dap
  7400 00003BA0 00804882                    dd 0x82488000   ; sect
  7401 00003BA4 00088EB9                    dd 0xB98E0800   ; words
  7402 00003BA8 000093E8                    dd 0xE8930000   ; key
  7403 00003BAC 0026D1CF                    dd 0xCFD12600   ; qkey
  7404 00003BB0 0076F5C0                    dd 0xC0F57600   ; digin
  7405 00003BB4 001274CF                    dd 0xCF741200   ; qwert
  7406 00003BB8 0000E01F                    dd 0x1FE00000   ; r?
  7407 00003BBC 0000D46C                    dd 0x6CD40000   ; nul
  7408 00003BC0 0000E092                    dd 0x92E00000   ; cad
  7409 00003BC4 00C025C5                    dd 0xC525C000   ; pcad
  7410 00003BC8 40C5F0C0                    dd 0xC0F0C540   ; displ(ay)
  7411 00003BCC 00801459                    dd 0x59148000   ; actc
  7412 00003BD0 008147F7                    dd 0xF7478100   ; +list
  7413 00003BD4 00747972                    dd 0x72797400   ; itick
  7414 00003BD8 0000C0A3                    dd 0xA3C00000   ; lis
  7415 00003BDC 000080F6                    dd 0xF6800000   ; +e
  7416 00003BE0 00140E82                    dd 0x820E1400   ; serve
  7417 00003BE4 004A0E4C                    dd 0x4C0E4A00   ; edita     editAddress
  7418 00003BE8 603B3A96                    dd 0x963A3B60   ; cblind
  7419                                  
  7420 00003BEC 0000C097                    dd 0x97C00000   ; c@        cFetch_
  7421 00003BF0 0000C0BF                    dd 0xBFC00000   ; w@        wFetch_
  7422                                   ;   dd 0xF8000000   ; @         fetch_     replaced by optimising verson in block 24
  7423 00003BF4 0000A097                    dd 0x97A00000   ; c!        cStore_
  7424 00003BF8 0000A0BF                    dd 0xBFA00000   ; w!        wStore_
  7425                                   ;   dd 0xF4000000   ; !         store_     replaced by optimising verson in block 24
  7426                                  
  7427 00003BFC 203683D5                    dd 0xD5833620   ; 2dup      two_dup_
  7428                                  
  7429 00003C00 203683D5                    dd 0xD5833620   ; 2drop     two_drop_
  7430 00003C04 20AE0BD5                    dd 0xD50BAE20   ; 2swap     two_swap_
  7431 00003C08 405078D4                    dd 0xD4785040   ; 2over     two_over_
  7432 00003C0C 00002013                    dd 0x13200000   ; rot       rot_
  7433 00003C10 004026E6                    dd 0xE6264000   ; -rot      minus_rot_
  7434 00003C14 00E8D22C                    dd 0x2CD2E800   ; tuck      tuck_
  7435 00003C18 00E8F2C4                    dd 0xC4F2E800   ; pick      pick_
  7436                                  
  7437 00003C1C 00805292                    dd 0x92528000   ; cell      cell_
  7438 00003C20 C09C5292                    dd 0x92529CC0   ; cell-     cell_minus_
  7439 00003C24 C09E5292                    dd 0x92529EC0   ; cell+     cell_plus_
  7440 00003C28 00905292                    dd 0x92529000   ; cells     cells_
  7441                                  
  7442 00003C2C 000020A6                    dd 0xA6200000   ; lp        lp_
  7443                                  
  7444 00003C30 0020E0A3                    dd 0xA3E02000   ; lidt      lidt_
  7445 00003C34 0020E083                    dd 0x83E02000   ; sidt      sidt_
  7446                                  
  7447 00003C38 0000DCD5                    dd 0xD5DC0000   ; 2/        two_slash_
  7448 00003C3C 000A4F94                    dd 0x944F0A00   ; cmove_
  7449 00003C40 0000F4D5                    dd 0xD5F40000   ; 2*        two_star_
  7450 00003C44 00E8F7D5                    dd 0xD5F7E800   ; 2**       two_star_star_
  7451                                  ;    dd 0xD5DC0000  ; u/        u/_
  7452 00003C48 80CF2C96                    dd 0x962CCF80   ; cpuid     GetCPUID_
  7453 00003C4C 0009051C                    dd 0x1C050900   ; rdtsc
  7454 00003C50 00006C15                    dd 0x156C0000   ; rand
  7455 00003C54 C01D6C15                    dd 0x156C1DC0   ; rand/     randInit_
  7456 00003C58 C0196C15                    dd 0x156C19C0   ; randq
  7457 00003C5C A05ECB90                    dd 0x90CB5EA0   ; crc32
  7458                                  
  7459                                  ;    dd 0xB18C5480   ; format
  7460                                  ;    dd 0xC5270000   ; pci
  7461                                  ;    dd 0x68248000   ; nsec      was devic(e)
  7462 00003C60 90A5DC85                    dd 0x85DCA590   ; switch
  7463 00003C64 4076A2B0                    dd 0xB0A27640   ; freeze
  7464 00003C68 0000C423                    dd 0x23C40000   ; top
  7465                                  ;    dd 0xB1896480   ; forths
  7466                                  ;    dd 0x8AC84E00   ; macros
  7467 00003C6C 00000000                    dd 0
  7468                                  
  7469                                  ForthJumpTableROM:  ; jumptable:
  7470 00003C70 [2B2B0000]                  dd boot         ;
  7471 00003C74 [352E0000]                  dd warm         ;
  7472 00003C78 [0D040000]                  dd pause_       ; pause
  7473 00003C7C [B4050000]                  dd macro        ;
  7474 00003C80 [D4050000]                  dd forth        ;
  7475 00003C84 [D9040000]                  dd c_           ; c
  7476 00003C88 30A90000                    dd Read_Sector_LBA   - $$ + BOOTOFFSET  ; jmp Read_Sector_LBA
  7477 00003C8C 48A90000                    dd Write_Sector_LBA  - $$ + BOOTOFFSET  ; jmp Write_Sector_LBA
  7478 00003C90 60A90000                    dd ReadSectors  - $$ + BOOTOFFSET  ; jmp ReadSectors    reads
  7479 00003C94 A0A90000                    dd WriteSectors - $$ + BOOTOFFSET  ; jmp WriteSectors   writes
  7480 00003C98 E7A90000                    dd SaveAll_     - $$ + BOOTOFFSET  ; jmp SaveAll_
  7481                                  ;    dd th_        - $$ + BOOTOFFSET ; jmp th_ ( thunk to BIOS Int 0x13 )
  7482 00003C9C 497F0000                    dd bios_read  - $$ + BOOTOFFSET ; jmp bios_read   'read'
  7483 00003CA0 917F0000                    dd bios_write - $$ + BOOTOFFSET ; jmp bios_write  'write'
  7484                                  ;    dd XXXrsect_  - $$ + BOOTOFFSET ; jmp rsect_  'rsect'
  7485 00003CA4 [1F310000]                  dd fetchDX_     ; @dx
  7486 00003CA8 [362C0000]                  dd setupDAP_    ; !dap
  7487 00003CAC [3E040000]                  dd activate     ; act
  7488 00003CB0 [59040000]                  dd show         ;
  7489 00003CB4 [B8080000]                  dd _load_       ;
  7490 00003CB8 [D8080000]                  dd nload        ; nload
  7491 00003CBC [E7080000]                  dd plusLoad     ; +load
  7492 00003CC0 [F6080000]                  dd thru_        ; thru
  7493 00003CC4 [29090000]                  dd plusThru_    ; +thru
  7494 00003CC8 [44090000]                  dd cblk_        ;           return the block number currently being compiled, calculated from  edi
  7495 00003CCC [51090000]                  dd rblk_        ;           return the block number offset of the RELOCATED address
  7496 00003CD0 [5C090000]                  dd ablk_        ;           convert byte address to block number
  7497 00003CD4 [65090000]                  dd erase_       ;
  7498 00003CD8 [2E080000]                  dd here         ;
  7499 00003CDC [39080000]                  dd qlit         ;
  7500 00003CE0 [EA070000]                  dd comma3_      ;
  7501 00003CE4 [E3070000]                  dd comma2_      ;
  7502 00003CE8 [DC070000]                  dd comma1_      ;
  7503 00003CEC [C0070000]                  dd comma_       ;
  7504 00003CF0 [80080000]                  dd less         ;
  7505 00003CF4 [97080000]                  dd jump         ;
  7506 00003CF8 [A6190000]                  dd accept       ;
  7507 00003CFC [AF280000]                  dd keypd        ;
  7508 00003D00 [AF280000]                  dd keypd        ;
  7509 00003D04 [312B0000]                  dd wipe         ;
  7510 00003D08 [522B0000]                  dd wipes        ;
  7511 00003D0C [5D2B0000]                  dd copy_        ; copy
  7512 00003D10 [DF040000]                  dd mark         ;
  7513 00003D14 [04050000]                  dd empty_       ; empty
  7514 00003D18 [700E0000]                  dd emit_        ; emit
  7515 00003D1C [99100000]                  dd digit        ;
  7516 00003D20 [940E0000]                  dd two_emit     ; 2emit
  7517 00003D24 [16110000]                  dd dotDecimal   ; .
  7518 00003D28 [C5100000]                  dd dotHex8      ; h.
  7519 00003D2C [B3100000]                  dd h_dot_n      ; h.n
  7520 00003D30 [BF090000]                  dd cr_          ; cr
  7521 00003D34 [820E0000]                  dd space_       ; space
  7522 00003D38 [DD0F0000]                  dd down         ;
  7523 00003D3C [29280000]                  dd edit_        ;
  7524 00003D40 [3B280000]                  dd e_           ; e
  7525 00003D44 [0B100000]                  dd lm           ;
  7526 00003D48 [12100000]                  dd rm           ;
  7527 00003D4C [2E0A0000]                  dd graphAction  ; graph
  7528 00003D50 [A60E0000]                  dd setupText_   ; text
  7529 00003D54 [00130000]                  dd displayTheKeyboard ;
  7530 00003D58 [8E2B0000]                  dd debug        ;
  7531 00003D5C [19100000]                  dd _at          ; at
  7532 00003D60 [28100000]                  dd plus_at      ; +at
  7533 00003D64 [982F0000]                  dd xy_          ;
  7534 00003D68 [FB0E0000]                  dd page_        ; page
  7535 00003D6C [0A0F0000]                  dd screen_      ; screen
  7536 00003D70 [A32F0000]                  dd fov_         ;
  7537                                  ;    dd fifo         ;
  7538 00003D74 [E90E0000]                  dd box_         ; box
  7539 00003D78 [B80E0000]                  dd line_        ; line
  7540 00003D7C [050A0000]                  dd color        ;
  7541 00003D80 [65100000]                  dd octant       ;
  7542 00003D84 [AE2F0000]                  dd tokenActions_ ; tokenActions table
  7543 00003D88 [53300000]                  dd last         ;
  7544 00003D8C [471A0000]                  dd unpack       ;
  7545 00003D90 [0D180000]                  dd pack_        ;
  7546 00003D94 [5E300000]                  dd blk_         ;
  7547 00003D98 [09300000]                  dd scrnw_       ; scrnw  screen width in pixels
  7548 00003D9C [17300000]                  dd scrnh_       ; scrnh  screen height in pixels
  7549 00003DA0 [25300000]                  dd bpp_         ; bpp    bits per pixel
  7550 00003DA4 [48300000]                  dd font_        ; font   address of font16x24
  7551 00003DA8 [32300000]                  dd iconw_       ; iconw  icon width in pixels
  7552 00003DAC [3D300000]                  dd iconh_       ; iconh  icon height in pixels
  7553 00003DB0 [C42F0000]                  dd version_     ; ver
  7554 00003DB4 [77300000]                  dd curs         ; curs
  7555 00003DB8 [00300000]                  dd block_       ; block
  7556 00003DBC [CF2F0000]                  dd vframe_      ; vframe
  7557 00003DC0 [DA2F0000]                  dd vars_        ; vars
  7558                                  ; new words
  7559 00003DC4 [69300000]                  dd seeb         ; seeb
  7560                                  ;    dd stacks_      ;
  7561 00003DC8 [E21D0000]                  dd dotsf_       ; dotsf
  7562 00003DCC [D91D0000]                  dd leave_       ; leave
  7563                                  ;    dd txtq_        ;
  7564 00003DD0 [0C0A0000]                  dd rgb          ; rgb
  7565 00003DD4 [220A0000]                  dd bye_         ; bye
  7566 00003DD8 [68250000]                  dd _word        ;
  7567 00003DDC [82300000]                  dd ekt          ;
  7568 00003DE0 [58050000]                  dd abort        ;
  7569 00003DE4 [DA300000]                  dd tickh        ;
  7570 00003DE8 [3C310000]                  dd buffer_      ; buffe(r)
  7571 00003DEC [FB300000]                  dd offset_      ;
  7572 00003DF0 [DB2B0000]                  dd tic_         ; tic
  7573 00003DF4 [06310000]                  dd vesa         ;
  7574 00003DF8 [11310000]                  dd vesamode_    ;
  7575 00003DFC [31310000]                  dd trash_       ; trash
  7576                                  ;    dd hsvv_        ; hsvv
  7577 00003E00 [8D300000]                  dd vword_       ; ('%s')", DB_NAME,
  7578                                  ;    dd vregs_       ; vregs
  7579 00003E04 [98300000]                  dd ivec_         ; ivec
  7580 00003E08 [6E320000]                  dd restore_BIOS_idt_and_pic ; resb
  7581 00003E0C [A3300000]                  dd pic_         ; pic  Programmable Interrupt Controller settings, as set by the BIOS
  7582 00003E10 [AE300000]                  dd dap_         ; dap
  7583 00003E14 [B9300000]                  dd sect_        ; sect
  7584 00003E18 [302C0000]                  dd words_       ; words
  7585 00003E1C [43160000]                  dd get_key_     ; key
  7586 00003E20 [DE160000]                  dd get_qwerty_key_ ; qkey
  7587 00003E24 [C4300000]                  dd digin        ;
  7588 00003E28 [A82A0000]                  dd qwert        ;
  7589 00003E2C [1A2B0000]                  dd rquery       ; r?
  7590 00003E30 [00040000]                  dd nul          ;
  7591 00003E34 [47310000]                  dd cad          ;
  7592 00003E38 [52310000]                  dd pcad         ;
  7593 00003E3C [68310000]                  dd displ        ;
  7594 00003E40 [CF300000]                  dd actc         ;
  7595 00003E44 [7C210000]                  dd plusList     ; +list
  7596 00003E48 [F82B0000]                  dd itick        ;
  7597 00003E4C [FA210000]                  dd refresh      ; lis
  7598 00003E50 [47280000]                  dd plus_e       ; +e
  7599 00003E54 [B9040000]                  dd serve        ;
  7600 00003E58 [A4280000]                  dd editAddress  ; edita
  7601 00003E5C [73310000]                  dd cBlindAddr_  ; cblind
  7602                                  
  7603 00003E60 [7E310000]                  dd cFetch_      ; c@
  7604 00003E64 [85310000]                  dd wFetch_      ; w@
  7605                                  ;    dd fetch_       ; @    replaced by optimising verson in block 24
  7606 00003E68 [90310000]                  dd cStore_      ; c!
  7607 00003E6C [95310000]                  dd wStore_      ; w!
  7608                                  ;    dd store_       ; !    replaced by optimising verson in block 24
  7609                                  
  7610 00003E70 [A0310000]                  dd two_dup_     ; 2dup
  7611 00003E74 [AC310000]                  dd two_drop_    ; 2drop
  7612 00003E78 [AF310000]                  dd two_swap_    ; 2swap
  7613 00003E7C [BB310000]                  dd two_over_    ; 2over
  7614 00003E80 [CA310000]                  dd rot_         ; rot
  7615 00003E84 [D7310000]                  dd minus_rot_   ; -rot
  7616 00003E88 [E4310000]                  dd tuck_        ; tuck
  7617 00003E8C [EF310000]                  dd pick_        ; pick
  7618                                  
  7619 00003E90 [F3310000]                  dd cell_        ; cell
  7620 00003E94 [FE310000]                  dd cell_minus_  ; cell-
  7621 00003E98 [04320000]                  dd cell_plus_   ; cell+
  7622 00003E9C [0A320000]                  dd cells_       ; cells
  7623 00003EA0 [35330000]                  dd lp_          ; lp
  7624 00003EA4 [0F320000]                  dd lidt_        ; lidt
  7625 00003EA8 [26320000]                  dd sidt_        ; sidt
  7626 00003EAC [56330000]                  dd two_slash_   ; 2/        two_slash_
  7627 00003EB0 [59330000]                  dd cmove_       ; cmove
  7628 00003EB4 [77330000]                  dd two_star_    ; 2*        two_star_
  7629 00003EB8 [7A330000]                  dd two_star_star_ ; 2**     two_star_star_
  7630                                  ;    dd u/_          ; u/        u/_
  7631                                  
  7632 00003EBC [A1330000]                  dd GetCPUID_    ; cpuid
  7633 00003EC0 [AE330000]                  dd rdtsc_       ; rdtsc
  7634 00003EC4 [F8330000]                  dd rand_        ; rand
  7635 00003EC8 [B6330000]                  dd randInit_    ; rand/
  7636 00003ECC [16340000]                  dd randq_       ; randq
  7637 00003ED0 [32380000]                  dd crc32_       ; crc32
  7638                                  
  7639                                  ;    dd format       ;
  7640                                  ;    dd pci          ;
  7641                                  ;    dd device       ;
  7642 00003ED4 [4C0E0000]                  dd switch       ;
  7643 00003ED8 [A6040000]                  dd freeze       ;
  7644 00003EDC [9C090000]                  dd top_         ;
  7645                                  ;    dd forths_      ;
  7646                                  ;    dd macros_      ;
  7647                                  
  7648                                  ForthJumpTableROM_end:
  7649                                  
  7650                                  ; times 200 NOP   ;  enable this line to see how much space is left. If NASM reports :
  7651                                  ; "cf2019.nasm:6282: error: TIMES value -28 is negative" with "times 200" you have (200 - 28) bytes left
  7652                                  
  7653                                  ; fill with no-ops to 55AA at end of boot sector, less $40 for the info string
  7654 00003EE0 90<rept>                times ( ( START_BLOCK_NUMBER - SIZE_OF_FONT_IN_BLOCKS ) * 0x400 ) - 0x40 - ($ - $$)  NOP
  7655                                  
  7656                                  version:
  7657 000067C0 636632303139203176-         db 'cf2019 1v0 2019Sep14 Chuck Moore' , 0x00    ; 0x20 + 1 bytes
  7658 000067C9 302032303139536570-
  7659 000067D2 313420436875636B20-
  7660 000067DB 4D6F6F726500       
  7661 000067E1 20486F77657264204F-         db ' Howerd Oakford inventio.co.uk' ,  0x00     ; 0x1E + 1 bytes, total 0x40
  7662 000067EA 616B666F726420696E-
  7663 000067F3 76656E74696F2E636F-
  7664 000067FC 2E756B00           
  7665                                  
  7666                                  ; the above produces a 22K boot image, we then add :
  7667                                  font16x24:
  7668                                  ; colorForth:                         ; the colorForth source blocks
  7669 00006800 <incbin>                incbin "cf2019Ref.img",OFFSET_OF_FONT, ( 512 * 1024 ) ; append the font and colorForth source blocks from the reference image, skip the kernel code
  7670                                  
  7671                                  ; end of file
