     1                                  ; cf2019.nasm 2019 Sep 14  "" (512K byte image size) with arrow, Enter and Escape keys
     2                                  ; colorForth for 80x86 PC for NASM , with 1024x768 and 800x600 graphics options
     3                                  ; Adapted by Howerd Oakford from code by :
     4                                  ; Chuck Moore : inventor, MASM
     5                                  ; Mark Slicker : ported to GNU Assembler
     6                                  ; Peter Appelman : ported to NASM with qwerty keyboard
     7                                  ; John Comeau : BIOS boot from ClusterFix
     8                                  ; and others... Thanks to all!!!
     9                                  ; Feedback welcome : howerd@inventio.co.uk www.inventio.co.uk
    10                                  
    11                                  ; %define NOT_BOCHS     Bochs cannot handle resetting of the PIT chips, so we can optionally disable this
    12                                  
    13                                  ; CPU 386 ; Assemble instructions for the 386 instruction set
    14                                  
    15                                  %define FORCE_800x600_VESA  0   ; true to force 800 x 600 x 16 bits for testing in  bochs
    16                                  
    17                                  %define START_BLOCK_NUMBER      32 ; must be an even number
    18                                  
    19                                  %define SIZE_OF_FONT_IN_BLOCKS   6
    20                                  %define OFFSET_OF_FONT          ( ( START_BLOCK_NUMBER - SIZE_OF_FONT_IN_BLOCKS ) * 0x400 )
    21                                  %define LAST_BLOCK_NUMBER       511  ; must be an odd number
    22                                  
    23                                  %define SECTORS_TO_LOAD ( ( LAST_BLOCK_NUMBER + 1 ) * 2 )   ; number of 512 octet sectors
    24                                  
    25                                  %define BITS_PER_PIXEL  16  ; MUST BE 16 !!! display pixel sizes, colour depth = 16 bit ( 2 bytes )
    26                                  
    27                                  ; for the maximum supported screen : 1024 x 768 pixels :
    28                                  %define MAX_SCREEN_WIDTH ( 1024 )   ; maximum screen width in pixels
    29                                  %define MAX_SCREEN_HEIGHT ( 768 )   ; maximum screen height in pixels
    30                                  
    31                                  %define BYTES_PER_PIXEL ( BITS_PER_PIXEL / 8 )
    32                                  
    33                                  PIXEL_SHIFT equ 1           ; how many bits to shift to scale by BYTES_PER_PIXEL
    34                                  
    35                                  ; Memory Map
    36                                  ; start   length
    37                                  ; 0x100000 ....   RAM
    38                                  ; 0xC0000 0xFFFFF BIOS video ROM - its not RAM!
    39                                  ; 0xB8000 0x08000 BIOS video RAM
    40                                  ; 0x10000 0xA8000 COLORFTH.CFX file is copied here
    41                                  ; 0x0F000 0x01000 BIOS shadow RAM - its OK to use this if we do not call the video BIOS
    42                                  ; 0x0A000 0x05000 BIOS video RAM - do not use until we have changed video mode
    43                                  ; 0x07c00 0x00200 BPB Boot sector after loading by BIOS
    44                                  ; 0x07c0b <----- di points here, the BPB ( + offset )  and variables ( - offset ) are accessed via [di]
    45                                  ; 0x07b8c 0x00080 variables referenced via [di], followed by BPB variables referenced via [di]
    46                                  ; 0x07800         Stacks, size = 0x0200 each , growing downwards
    47                                  ; 0x02000 0x06800 SECTOR_BUFFER
    48                                  ; 0x00000 0x02000 BIOS RAM
    49                                  
    50                                  %define SECTOR_BUFFER           0x00002000              ; buffer for disk reads and writes
    51                                  %define SECTOR_BUFFER_SIZE      0x4800                  ; 18 K bytes, 36 x 512 byte sectors
    52                                  %define INTERRUPT_VECTORS       ( SECTOR_BUFFER - 0x0400 ) ; the IDT register points to these interrupt vectors
    53                                  %define VESA_BUFFER             ( INTERRUPT_VECTORS - 0x0400 ) ; for the VESA mode information
    54                                  %define DAP_BUFFER              ( VESA_BUFFER   - 0x0020 ) ; 0x1BE0 for the Int 0x13 Disk Address Packet (DAP)
    55                                  %define DISK_INFO               ( DAP_BUFFER    - 0x0020 ) ; for the Int 0x13 AH=08h get info
    56                                  %define IDT_AND_PIC_SETTINGS    ( DISK_INFO     - 0x0040 ) ; bytes 0x00 - 0x05 SIDT value, 0x06 PIC1 IMR , 0x07 PIC2 IMR values saved at startup
    57                                  %define V_REGS                  ( IDT_AND_PIC_SETTINGS - 0x0020 ) ; test only - registers before and after thunk call
    58                                  %define TRASH_BUFFER            ( V_REGS        - 0x0400 ) ; saves words deleted while editing
    59                                  
    60                                  %define PIC_BIOS_IDT_SETTINGS   ( IDT_AND_PIC_SETTINGS )   ; bytes 0x00 - 0x05 SIDT value, 0x06 PIC1 IMR , 0x07 PIC2 IMR values saved at startup
    61                                  %define PIC_BIOS_IMR_SETTINGS   ( IDT_AND_PIC_SETTINGS + 6 ) ; bytes 0x00 - 0x05 SIDT value, 0x06 PIC1 IMR , 0x07 PIC2 IMR
    62                                  
    63                                  %define PIC_NEW_IDT_SETTINGS    ( IDT_AND_PIC_SETTINGS + 0x10 )   ; bytes 0x00 - 0x05 SIDT value, 0x08 new PIC1 IMR , 0x09 new PIC2 IMR
    64                                  %define PIC_NEW_IMR_SETTINGS    ( IDT_AND_PIC_SETTINGS + 0x16 )   ; bytes 0x00 - 0x05 SIDT value, 0x08 new PIC1 IMR , 0x09 new PIC2 IMR
    65                                  
    66                                  %define IDT_AND_PIC_SETTINGS_PAD ( IDT_AND_PIC_SETTINGS + 0x20 )
    67                                  
    68                                  %define vesa_BytesPerScanLine   ( VESA_BUFFER + 0x0E )  ; screen width ( number of horizontal pixels )
    69                                  %define vesa_XResolution        ( VESA_BUFFER + 0x12 )  ; screen width ( number of horizontal pixels )
    70                                  %define vesa_YResolution        ( VESA_BUFFER + 0x14 )  ; screen height ( number of vertical pixels )
    71                                  %define vesa_BitsPerPixel       ( VESA_BUFFER + 0x19 )  ; bits per pixel
    72                                  %define vesa_SavedMode          ( VESA_BUFFER + 0x1E )  ; "Reserved" - we save the VESA mode here
    73                                  %define vesa_PhysBasePtr        ( VESA_BUFFER + 0x28 )  ; address of linear frame buffer
    74                                  
    75                                  %define BOOTOFFSET      0x7C00
    76                                  
    77                                  %assign RELOC_BIT 16                            ; the relocation address must be a power of 2
    78                                  %assign RELOCATED 1 << RELOC_BIT                ; 0x10000
    79                                  
    80                                  ; stack allocation, three pairs of data and return stacks
    81                                  ; Note : the return stack must be in the lowest 64K byte segment, for the BIOS calls to work.
    82                                  %define RETURN_STACK_0      0x7800 ; top of stack memory area ; 0xa0000 in CM's code, 0x10000 in JC's code
    83                                  %define DATA_STACK_SIZE     0x0200
    84                                  %define RETURN_STACK_SIZE   0x0200
    85                                  ; combined stack sizes
    86                                  %define STACK_SIZE          ( DATA_STACK_SIZE + RETURN_STACK_SIZE )
    87                                  %define TWOxSTACK_SIZE      ( STACK_SIZE * 2 )
    88                                  %define TOTAL_STACK_SIZE    ( STACK_SIZE * 3 )      ; three pairs of stacks, one for each task
    89                                  %define STACK_MEMORY_START  ( RETURN_STACK_0 - TOTAL_STACK_SIZE )
    90                                  ; data stacks
    91                                  %define DATA_STACK_0        ( RETURN_STACK_0 - RETURN_STACK_SIZE ) ; 0x9f400 in CM's code
    92                                  %define DATA_STACK_1        ( DATA_STACK_0 - STACK_SIZE )
    93                                  %define DATA_STACK_2        ( DATA_STACK_0 - TWOxSTACK_SIZE )
    94                                  ; return stacks
    95                                  %define RETURN_STACK_1      ( RETURN_STACK_0 - STACK_SIZE )
    96                                  %define RETURN_STACK_2      ( RETURN_STACK_0 - TWOxSTACK_SIZE )
    97                                  
    98                                  %define _TOS_  eax
    99                                  %define _TOS_x_  ax
   100                                  %define _TOS_l_  al
   101                                  
   102                                  %define _SCRATCH_  ebx
   103                                  %define _SCRATCH_x_  bx
   104                                  %define _SCRATCH_l_  bl
   105                                  
   106                                  %define _MOV_TOS_LIT_  (0xB8)   ; the opcode for mov eax, 32_bit_literal  (in next 32 bit cell)
   107                                  
   108                                  %macro _DUP_  0                 ; Top Of Stack is in the  _TOS_  register
   109                                      sub esi, byte 0x04 ; lea esi, [ esi - 0x04 ]     ; pre-decrement the stack pointer
   110                                      mov [ esi ], _TOS_          ; copy the Top Of Stack ( TOS ) register to Second On Stack ( on the real stack )
   111                                  %endmacro
   112                                  
   113                                  %macro _SWAP_  0
   114                                      xchg _TOS_, [ esi ]
   115                                  %endmacro
   116                                  
   117                                  %macro _OVER_  0
   118                                      sub esi, byte 0x04 ; lea esi, [ esi - 0x04 ]     ; pre-decrement the stack pointer
   119                                      mov [ esi ], _TOS_          ; copy the Top Of Stack ( TOS ) register to Second On Stack ( on the real stack )
   120                                      mov _TOS_, [ esi + 4 ]
   121                                  %endmacro
   122                                  
   123                                  %macro _DROP_ 0
   124                                      lodsd
   125                                  %endmacro
   126                                  
   127                                  %define START_OF_RAM    0x00468000
   128                                  %define ForthNames      START_OF_RAM                ; copied to RAM here from ROM ( i.e. boot program ) version
   129                                  %define ForthJumpTable  ( ForthNames + 0x2800 )     ; copied to RAM here from ROM ( i.e. boot program ) version
   130                                  %define MacroNames      ( ForthJumpTable + 0x2800 ) ; copied to RAM here from ROM ( i.e. boot program ) version
   131                                  %define MacroJumpTable  ( MacroNames + 0x2800 )     ; copied to RAM here from ROM ( i.e. boot program ) version
   132                                  
   133                                  %define H0              ( MacroJumpTable + 0x2800 ) ; initial value of the dictionary pointer
   134                                  
   135                                  %define SECTOR  512     ; bytes per floppy sector
   136                                  %define HEADS   2       ; heads on 1.44M floppy drive
   137                                  %define SECTORS 18      ; floppy sectors per track
   138                                  %define CYLINDER (SECTOR * SECTORS * HEADS)
   139                                  %define CELL 4          ; bytes per cell
   140                                  %define DEBUGGER 0xe1   ; port to hardware debugger?
   141                                  
   142                                  ; int 0x13 Disk Address Packet (DAP) pointed to by  si  :
   143                                  %define o_Int13_DAP_size           ( 0x00 ) ; 2  0x0010
   144                                  %define o_Int13_DAP_num_sectors    ( 0x02 ) ; 2  0x0001
   145                                  %define o_Int13_DAP_address        ( 0x04 ) ; 2  0x2000
   146                                  %define o_Int13_DAP_segment        ( 0x06 ) ; 2  0x0000
   147                                  %define o_Int13_DAP_LBA_64_lo      ( 0x08 ) ; 4  0x00000028
   148                                  %define o_Int13_DAP_LBA_64_hi      ( 0x0C ) ; 4  0x00000000
   149                                  ; extended DAP values
   150                                  %define o_Int13_DAP_readwrite      ( 0x10 ) ; 2  0x0000
   151                                  %define o_Int13_DAP_saved_DX       ( 0x12 ) ; 2  0x0000
   152                                  %define o_Int13_DAP_returned_AX    ( 0x14 ) ; 2  0xHH00 see AH Return Code below
   153                                  %define o_Int13_DAP_returned_carry_flag ( 0x16 ) ; 2  0x0000
   154                                  %define o_Int13_DAP_saved_CHS_CX   ( 0x18 ) ; 2  0x0000
   155                                  %define o_Int13_DAP_saved_CHS_DX   ( 0x1A ) ; 2  0x0000
   156                                  
   157                                  %macro LOAD_RELATIVE_ADDRESS  1
   158                                      mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
   159                                  %endmacro
   160                                  
   161                                  ; emit the given following character
   162                                  %macro EMIT_IMM 1
   163                                  ;    push esi
   164                                      _DUP_
   165                                      mov _TOS_, %1
   166                                      call emit_
   167                                  ;    pop esi
   168                                  %endmacro
   169                                  
   170                                  ; *****************************************************************************
   171                                  ; Registers used
   172                                  ; *****************************************************************************
   173                                  ; _TOS_ is the top stack item ( eax --> ebx )
   174                                  ; esp the call ... ret  return stack pointer
   175                                  ; edi  dictionary pointer ( H --> : HERE ( -- a )   H @ ; )
   176                                  ; esi is the stack pointer, also needed by lods and movs
   177                                  ; e.g. lodsd  loads a 32 bit dword from [ds:esi] into _TOS_, increments  esi  by 4
   178                                  ; ebx  scratch register
   179                                  ; ecx  counter and scratch register
   180                                  ; edx  run-time pointer (?), "a register" used by  a!  , otherwise scratch register
   181                                  ; ebp  variable pointer register
   182                                  ; "ds" = selector 0x10 ==> 0x0000:0000
   183                                  ; "es" = selector 0x10 ==> 0x0000:0000
   184                                  ; "ss" = selector 0x10 ==> 0x0000:0000
   185                                  
   186                                  ; colours RGB in 16 bits
   187                                  colour_background   equ 0x0000
   188                                  colour_yellow       equ 0xFFE0
   189                                  colour_black        equ 0x0000
   190                                  colour_red          equ 0xF800
   191                                  colour_green        equ 0x0600
   192                                  colour_cyan         equ 0x07FF
   193                                  colour_white        equ 0xFFFF
   194                                  colour_light_blue   equ 0x841F
   195                                  colour_silver       equ 0xC618
   196                                  colour_magenta      equ 0xF81F
   197                                  colour_magentaData  equ 0xD010
   198                                  colour_blue         equ 0x001F
   199                                  colour_orange       equ 0xE200
   200                                  colour_dark_yellow  equ 0xFFE0
   201                                  colour_dark_green   equ 0x07C0
   202                                  colour_PacMan       equ 0xE200
   203                                  colour_blockNumber  equ 0xE200
   204                                  colour_taupe        equ 0xB2E7
   205                                  colour_taupeData    equ 0xB2E7
   206                                  
   207                                  [BITS 16]                           ; Real Mode code (16 bit)
   208                                  
   209                                  org RELOCATED
   210                                  
   211                                  start:
   212                                  codeStart:
   213 00000000 E98100                      jmp  main_16bit    ; 0x03 bytes |  EB 58 90  00 Jump to boot code
   214                                      times 3 - ($ - $$) nop        ; fill with 1 or 0 no-ops to address 3
   215                                      ; BIOS boot parameter table = 0x25 bytes
   216 00000003 6366323031392030            db 'cf2019 0'      ; 03 Eight byte OEM name
   217 0000000B 0002                        dw 0x0200          ; 11 Number of Bytes Per Sector
   218 0000000D 08                          db 0x08            ; 13 Number of Sectors Per Cluster
   219 0000000E E005                        dw 0x05E0          ; 14 Number of Reserved Sectors until the FAT
   220 00000010 02                          db 0x02            ; 16 Number of Copies of FAT : always = 2
   221 00000011 0000                        dw 0x0000          ; 17 Maximum number of Root Directory Entries
   222 00000013 0000                        dw 0x0000          ; 19 Not used for FAT32
   223 00000015 F8                          db 0xF8            ; 21 Media type F0 = 1.44M 3.5 inch floppy disk, F8 = hard disk
   224 00000016 0000                        dw 0x0000          ; 22 Sectors Per FAT for FAT12 and FAT16 - not used for FAT32
   225 00000018 3F00                        dw 0x003F          ; 24 Sectors per Track
   226 0000001A FF00                        dw 0x00FF          ; 26 Number of heads
   227 0000001C 38000000                    dd 0x00000038      ; 28 Hidden sectors preceding the partition that contains this FAT volume
   228 00000020 C8777400                    dd 0x007477C8      ; 32
   229 00000024 101D0000                    dd 0x00001D10      ; 36 Sectors Per FAT for FAT32
   230 00000028 0000                        dw 0x0000          ; 40
   231 0000002A 0000                        dw 0x0000          ; 42
   232 0000002C 02000000                    dd 0x00000002      ; 44 Start of all directories, including root.
   233 00000030 0100                        dw 0x0001          ; 48
   234 00000032 0600                        dw 0x0006          ; 50 Offset in sectors from this sector to the backup BPB sector
   235                                  ;    times 12 db 0      ; 0x0C bytes |  00 00 00 00 00 00 00 00 00 00 00 00  52
   236                                  ;    db 0x00            ; 64
   237                                  ;    db 0x00            ; 65
   238                                  ;    db 0x29            ; 66 Extended Boot Signature
   239                                  ;    dd 0x44444444      ; 67 serial number
   240                                  ;    db 'colorForth '   ; 71 Eleven byte Volume Label
   241                                  ;    db 'cFblocks'      ; 82 Eight byte File System name
   242                                  
   243                                  ; ******************************************************************************
   244                                  ; ******************************************************************************
   245                                  
   246 00000034 90<rept>                align 8, nop    ; has to be aligned to 8 for GDT
   247                                      ; Note : we are NOT using null descriptor as GDT descriptor, see: http://wiki.osdev.org/GDT_Tutorial
   248                                      ; "The null descriptor which is never referenced by the processor. Certain emulators, like Bochs, will complain about limit exceptions if you do not have one present.
   249                                      ; Some use this descriptor to store a pointer to the GDT itself (to use with the LGDT instruction).
   250                                      ; The null descriptor is 8 bytes wide and the pointer is 6 bytes wide so it might just be the perfect place for this."
   251                                  
   252                                  gdt:                                ; the GDT descriptor
   253 00000038 2F00                        dw gdt_end - gdt - 1            ; GDT limit
   254 0000003A [407C]                      dw gdt0 + BOOTOFFSET            ; pointer to start of table, low 16 bits
   255 0000003C 00000000                    dw 0 , 0                        ; the high bits of the longword pointer to gdt
   256                                  
   257                                  gdt0:                               ; null descriptor
   258 00000040 0000                        dw 0    ; 0,1 limit 15:0
   259 00000042 0000                            dw 0    ; 2,3 base  15:0
   260 00000044 00                              db 0    ; 4   base  23:16
   261 00000045 00                              db 0    ; 5   type
   262 00000046 00                              db 0    ; 6   limit 19:16, flags
   263 00000047 00                              db 0    ; 7   base  31:24
   264                                  code32p_SELECTOR_0x08 equ $ - gdt0
   265                                  ; bytes   1 0     3 2     5 4     7 6
   266 00000048 FFFF0000009ACF00            dw 0xFFFF, 0x0000, 0x9A00, 0x00CF   ; 32-bit protected-mode code, limit 0xFFFFF
   267                                  data32p_SELECTOR_0x10 equ $ - gdt0
   268 00000050 FFFF00000092CF00            dw 0xFFFF, 0x0000, 0x9200, 0x00CF   ; 32-bit protected-mode data, limit 0xFFFFF
   269                                  code16r_SELECTOR_0x18 equ $ - gdt0
   270 00000058 FFFF0000009A0000            dw 0xFFFF, 0x0000, 0x9A00, 0x0000   ; 16-bit real-mode code, limit 0xFFFFF
   271                                  data16r_SELECTOR_0x20 equ $ - gdt0
   272 00000060 FFFF000000920000            dw 0xFFFF, 0x0000, 0x9200, 0x0000   ; 16-bit real-mode data, limit 0xFFFFF
   273                                  gdt_end:
   274                                  
   275                                  ; ******************************************************************************
   276                                  ; ******************************************************************************
   277                                  
   278                                  ; align to 4 so we can access variables from high-level Forth
   279                                  align 4, nop
   280                                  
   281                                  data_area:   ; data area begins here
   282                                  
   283                                  bootsector:                         ; LBA of boot sector
   284 00000068 00000000                    dd 0
   285                                  
   286                                  ; save disk information, cylinder, sector, head and drive from BIOS call
   287                                  driveinfo_Drive_DX:                 ; use low byte to store boot Drive into from BIOS DL
   288 0000006C 0000                        dw 0
   289                                  
   290                                  driveinfo_CX:         ; [7:6] [15:8][7] logical last index of cylinders = number_of - 1 (because index starts with 0)
   291                                                        ; [5:0][7] logical last index of sectors per track = number_of (because index starts with 1)
   292 0000006E 0000                        dw 0
   293                                  
   294                                  ; cylinders, sectors, heads of boot drive
   295                                  ; low word: high byte is head
   296                                  ; high word: cylinder and sector: C76543210 C98S543210
   297                                  driveinfo_Cylinder:
   298 00000070 00                          db 0
   299                                  driveinfo_Head:
   300 00000071 00                          db 0
   301                                  driveinfo_SectorsPertrack:
   302 00000072 0000                        dw 0
   303                                  
   304                                  align 4, nop
   305                                  
   306                                  destination:
   307 00000074 00000100                    dd RELOCATED
   308                                  
   309                                  dispPtr:
   310 00000078 40010000                    dd 0x00000140
   311                                  
   312                                  v_bytesPerLine:
   313 0000007C 00000000                    dd 0x00
   314                                  
   315                                  v_scanCode:
   316 00000080 00000000                    dd 0x00
   317                                  
   318                                  align 4
   319                                  
   320                                  ; ******************************************************************************
   321                                  ; the main program called from initial 16 bit mode
   322                                  ; ******************************************************************************
   323                                  
   324                                  main_16bit:
   325                                  
   326 00000084 FA                          cli                         ; clear interrupts
   327                                                                  ; turns out we don't need interrupts at all, even when using BIOS routines
   328                                                                  ; but we need to turn them off after disk calls because BIOS leaves them on
   329                                  
   330 00000085 56                          push si                     ; need to transfer SI to unused register BX later
   331                                  
   332                                  ; note: cannot touch DX or BP registers until we've checked for partition boot
   333                                  ; (SI could be used as well as BP but we use SI for relocation)
   334                                  
   335                                   ;see mbrboot.nasm
   336                                                                  ; Note : relocate the bootblock before we do anything else
   337 00000086 5B                          pop bx                      ; we cannot use the current stack after changing SS or SP
   338                                                                  ; ... because mbrboot.nasm places stack at 0x7c00, in SECTOR_BUFFER
   339                                                                  ; and we cannot use BP because its default segment is SS
   340 00000087 31C0                        xor ax, ax
   341 00000089 8ED8                        mov ds, ax
   342 0000008B 8EC0                        mov es, ax
   343                                  
   344 0000008D BE007C                      mov si, BOOTOFFSET
   345 00000090 BF0020                      mov di, SECTOR_BUFFER
   346 00000093 89FC                        mov sp, di
   347 00000095 B90001                      mov cx, 0x100
   348 00000098 F3A5                        rep movsw                   ; note that this instruction doesn't change AX , it moves DS:SI to ES:DI and increments SI and DI
   349                                  
   350 0000009A 8ED0                        mov ss, ax                  ; stack segment also zero
   351 0000009C B4B8                        mov ah, 0xb8                ; video RAM
   352 0000009E 8EE8                        mov gs, ax                  ; store in unused segment register
   353                                  
   354 000000A0 0F0116387C                  lgdt [gdt - $$ + BOOTOFFSET]
   355                                  
   356 000000A5 E82E01                      call SetupUnrealMode     ; gs and ss must be initialized before going to Unreal Mode
   357                                  
   358                                  ; *****************************************************************************
   359                                  ; Enable the A20 address line, otherwise all odd 1 MByte pages are disabled
   360                                  ; Using the "PS/2 Controller" or 8042 "Keyboard controller"
   361                                  ; *****************************************************************************
   362                                      ; from  http://wiki.osdev.org/%228042%22_PS/2_Controller#Step_1:_Initialise_USB_Controllers
   363                                      ; Write a command to the on-board 8042 "Keyboard controller" port 0x64 :
   364                                      ; 0x20     Read "byte 0" from internal RAM     Controller Configuration Byte
   365                                      ; 0x21 to 0x3F    Read "byte N" from internal RAM (where 'N' is the command byte & 0x1F)
   366                                      ; 0x60    Write next byte to "byte 0" of internal RAM (Controller Configuration Byte)
   367                                      ; 0x61 to 0x7F    Write next byte to "byte N" of internal RAM (where 'N' is the command byte & 0x1F)
   368                                      ; 0xA7    Disable second PS/2 port
   369                                      ; 0xA8    Enable second PS/2 port
   370                                      ; 0xA9    Test second PS/2 port
   371                                      ;     0x00 test passed
   372                                      ;     0x01 clock line stuck low
   373                                      ;     0x02 clock line stuck high
   374                                      ;     0x03 data line stuck low
   375                                      ;     0x04 data line stuck high
   376                                      ; 0xAA    Test PS/2 Controller
   377                                      ;     0x55 test passed
   378                                      ;     0xFC test failed
   379                                      ; 0xAB    Test first PS/2 port
   380                                      ;     0x00 test passed
   381                                      ;     0x01 clock line stuck low
   382                                      ;     0x02 clock line stuck high
   383                                      ;     0x03 data line stuck low
   384                                      ;     0x04 data line stuck high
   385                                      ; 0xAC    Diagnostic dump (real all bytes of internal RAM)    Unknown
   386                                      ; 0xAD    Disable first PS/2 port     None
   387                                      ; 0xAE    Enable first PS/2 port  None
   388                                      ; 0xC0    Read controller input port  Unknown (none of these bits have a standard/defined purpose)
   389                                      ; 0xC1    Copy bits 0 to 3 of input port to status bits 4 to 7    None
   390                                      ; 0xC2    Copy bits 4 to 7 of input port to status bits 4 to 7    None
   391                                      ; 0xD0    Read Controller Output Port     Controller Output Port (see below)
   392                                      ; 0xD1    Write next byte to Keyboard Controller Output Port Note: Check if output buffer is empty first
   393                                      ; 0xD2    Write next byte to first PS/2 port output buffer
   394                                      ; 0xD3    Write next byte to second PS/2 port output buffer
   395                                      ; 0xD4    Write next byte to second PS/2 port input buffer
   396                                      ; 0xF0 to 0xFF  Pulse output line low for 6 ms.
   397                                      ;     Bits 0 to 3 are used as a mask (0 = pulse line, 1 = do not pulse line) and correspond to 4 different output lines.
   398                                      ;     Bit 0 is the "reset" line, active low.
   399 000000A8 B0D1                        mov al, 0xD1    ; 0xD1 = Write next byte to Keyboard Controller Output Port
   400 000000AA E664                        out 0x64, al    ; On-board controller Command Write
   401                                  .back:
   402 000000AC E464                        in al, 0x64
   403 000000AE 2402                        and al, 0x02
   404 000000B0 75FA                        jnz .back
   405 000000B2 B04B                        mov al, 0x4B
   406 000000B4 E660                        out 0x60, al
   407                                  
   408                                  ; *****************************************************************************
   409                                  ; Get disk drive parameters from the BIOS
   410                                  ; *****************************************************************************
   411                                  
   412 000000B6 BF687C                      mov di, (data_area - $$ + BOOTOFFSET)   ; setup the data index pointer
   413 000000B9 6631C0                      xor eax, eax
   414 000000BC 660FBAE810                  bts eax, 16                     ; in case NOT booted from partition: sector 1, head 0, cylinder 0
   415 000000C1 08F6                        or dh, dh                       ; booted from partition?
   416 000000C3 740B                        jz .forward3
   417 000000C5 668B4708                    mov eax, [ bx + 8 ]             ; SI (now BX) contains pointer to partition record
   418 000000C9 66894500                    mov [ byte di + (bootsector - data_area) ], eax     ; offset 8 was LBA of first absolute sector
   419 000000CD 668B07                      mov eax, [bx]                   ; CHS of first sector in partition
   420                                  .forward3:
   421 000000D0 88D0                        mov al, dl                      ; bootdrive into AL
   422 000000D2 6689850400                  mov [ word di + ( driveinfo_Drive_DX - data_area) ], eax    ; save the Drive info from BIOS
   423 000000D7 B408                        mov ah, 8                       ; get drive parameters
   424 000000D9 06                          push es                         ; this operation messes with ES
   425 000000DA 57                          push di                         ; and DI
   426 000000DB BFC017                      mov di, DISK_INFO               ; point di at the table returned by this software interrupt
   427 000000DE CD13                        int 0x13
   428 000000E0 72FE                        jc $                            ; stop here on error
   429                                  
   430 000000E2 E80601                      call ReSetupUnrealMode
   431 000000E5 5F                          pop di
   432 000000E6 07                          pop es
   433                                  
   434                                  ; ******************************************************************************
   435                                  ; load the bootdisk into both low and high RAM
   436                                  ; ******************************************************************************
   437                                  
   438 000000E7 895508                      mov [ byte di + ( driveinfo_Cylinder - data_area) ], dx             ; heads in high byte
   439 000000EA 80E13F                      and cl, 0x3F                    ; we don't care about two high bits of cylinder count
   440 000000ED 894D0A                      mov [ byte di + ( driveinfo_SectorsPertrack - data_area) ], cx     ; cylinders and sectors/track
   441 000000F0 8B5504                      mov dx, [ byte di + ( driveinfo_Drive_DX - data_area) ]         ; restore dl Drive value from BIOS, dh = 0
   442                                  ;    mov dl, 0x80
   443 000000F3 8B4D06                      mov cx, [ di + ( driveinfo_CX - data_area) ]               ; restore cl value, ch = 0
   444 000000F6 BE0004                      mov si, SECTORS_TO_LOAD
   445                                  
   446 000000F9 BB0020                      mov bx, SECTOR_BUFFER            ; relocate the sector we are running from
   447 000000FC E89800                      call relocate
   448                                  
   449 000000FF BB007C                      mov bx, BOOTOFFSET              ; we will fix this below by adding 0x200
   450                                                                      ; remember the sector is 1-based, head and cylinder both 0-based
   451                                  
   452                                  .nextsector:
   453 00000102 FEC1                        inc cl
   454 00000104 4E                          dec si
   455 00000105 747D                        jz setVideoMode    ; success, so setup the video now...
   456                                  
   457                                  .bootload:
   458 00000107 B80102                      mov ax, 0x201                   ; read 1 sector
   459 0000010A 80C702                      add bh, 0x02                    ; into next available slot in RAM
   460 0000010D 7503                        jnz .forward
   461 0000010F 80EF02                      sub bh, 0x02                    ; at 0x10000 we go back to 0xfe00
   462                                  .forward:
   463 00000112 CD13                        int 0x13
   464 00000114 E8D400                      call ReSetupUnrealMode
   465 00000117 72FE                        jc $                            ; stop here on error
   466 00000119 E87B00                      call relocate
   467 0000011C 88C8                        mov al, cl
   468 0000011E 243F                        and al, 0x3F                    ; low 6 bits
   469 00000120 3A450A                      cmp al, [ byte di + ( driveinfo_SectorsPertrack - data_area) ]
   470 00000123 75DD                        jnz .nextsector
   471 00000125 FEC6                        inc dh                          ; next head
   472 00000127 3A7509                      cmp dh, [ byte di + ( driveinfo_Head - data_area) ]
   473 0000012A 7609                        jna .forward2                   ; not JNZ, the head index is 1 less than head count
   474 0000012C 30F6                        xor dh, dh
   475 0000012E FEC5                        inc ch                          ; next cylinder
   476 00000130 7503                        jnz .forward2
   477 00000132 80C140                      add cl, 0x40                    ; bit 8 of cylinder count
   478                                  .forward2:
   479 00000135 80E1C0                      and cl, 0xC0                    ; clear sector count, low 6 bits of cl
   480 00000138 EBC8                        jmp short .nextsector
   481                                  
   482                                  ; ******************************************************************************
   483                                  ; ******************************************************************************
   484                                  ; Start here after loading the program
   485                                  ; ******************************************************************************
   486                                  ; ******************************************************************************
   487                                  
   488                                  ; From : VESA BIOS EXTENSION (VBE) Core Functions Standard Version: 3.0 Date: September 16, 1998
   489                                  ; Mandatory information for all VBE revisions
   490                                  ; dw ModeAttributes         ; 0x00 mode attributes
   491                                  ; db WinAAttributes         ; 0x02 window A attributes
   492                                  ; db WinBAttributes         ; 0x03 window B attributes
   493                                  ; dw WinGranularity         ; 0x04 window granularity
   494                                  ; dw WinSize                ; 0x06 window size
   495                                  ; dw WinASegment            ; 0x08 window A start segment
   496                                  ; dw WinBSegment            ; 0x0A window B start segment
   497                                  ; dd WinFuncPtr             ; 0x0C real mode pointer to window function
   498                                  ; dw BytesPerScanLine       ; 0x10 bytes per scan line               <--------------
   499                                  ; Mandatory information for VBE 1.2 and above
   500                                  ; dw XResolution            ; 0x12 horizontal resolution in pixels   <-------------- scrnw
   501                                  ; dw YResolution            ; 0x14 vertical resolution in pixels     <-------------- scrnh
   502                                  ; db XCharSize              ; 0x16 character cell width in pixels
   503                                  ; db YCharSize              ; 0x17 character cell height in pixels
   504                                  ; db NumberOfPlanes         ; 0x18 number of memory planes
   505                                  ; db BitsPerPixel           ; 0x19 bits per pixel                    <-------------- bpp
   506                                  ; db NumberOfBanks          ; 0x1A number of banks
   507                                  ; db MemoryModel            ; 0x1B memory model type
   508                                  ; db BankSize               ; 0x1C bank size in KB
   509                                  ; db NumberOfImagePages     ; 0x1D number of images
   510                                  ; db Reserved               ; 0x1E reserved for page function        <-------------- mode (we copy it here)
   511                                  ; Direct Color fields (required for direct/6 and YUV/7 memory models)
   512                                  ; db RedMaskSize            ; 0x1F size of direct color red mask in bits
   513                                  ; db RedFieldPosition       ; 0x20 bit position of lsb of red mask
   514                                  ; db GreenMaskSize          ; 0x21 size of direct color green mask in bits
   515                                  ; db GreenFieldPosition     ; 0x22 bit position of lsb of green mask
   516                                  ; db BlueMaskSize           ; 0x23 size of direct color blue mask in bits
   517                                  ; db BlueFieldPosition      ; 0x24 bit position of lsb of blue mask
   518                                  ; db RsvdMaskSize           ; 0x25 size of direct color reserved mask in bits
   519                                  ; db RsvdFieldPosition      ; 0x26 bit position of lsb of reserved mask
   520                                  ; db DirectColorModeInfo    ; 0x27 direct color mode attributes
   521                                  ; Mandatory information for VBE 2.0 and above
   522                                  ; dd PhysBasePtr            ; 0x28 physical address for flat memory frame buffer  <-------------- vframe
   523                                  ; dd Reserved               ; 0x2C Reserved - always set to 0
   524                                  ; dw Reserved               ; 0x30 Reserved - always set to 0
   525                                  ; Mandatory information for VBE 3.0 and above
   526                                  ; dw LinBytesPerScanLine    ; 0x32 bytes per scan line for linear modes
   527                                  ; db BnkNumberOfImagePages  ; 0x34 number of images for banked modes
   528                                  ; db LinNumberOfImagePages  ; 0x35 number of images for linear modes
   529                                  ; db LinRedMaskSize         ; 0x36 size of direct color red mask (linear modes)
   530                                  ; db LinRedFieldPosition    ; 0x37 bit position of lsb of red mask (linear modes)
   531                                  ; db LinGreenMaskSize       ; 0x38 size of direct color green mask  (linear modes)
   532                                  ; db LinGreenFieldPosition  ; 0x39 bit position of lsb of green mask (linear modes)
   533                                  ; db LinBlueMaskSize        ; 0x3A size of direct color blue mask  (linear modes)
   534                                  ; db LinBlueFieldPosition   ; 0x3B bit position of lsb of blue mask (linear modes)
   535                                  ; db LinRsvdMaskSize        ; 0x3C size of direct color reserved mask (linear modes)
   536                                  ; db LinRsvdFieldPosition   ; 0x3D bit position of lsb of reserved mask (linear modes)
   537                                  ; dd MaxPixelClock          ; 0x3E maximum pixel clock (in Hz) for graphics mode
   538                                  ; times 189 db 0            ; 0x42 remainder of ModeInfoBlock
   539                                  ; End                       ; 0xFF
   540                                  
   541                                  scanVESA:   ; ( w+h+b -- )  in ax
   542 0000013A 89C3                        mov bx, ax
   543 0000013C 57                          push di                         ; save di
   544 0000013D B91641                      mov cx, ( 0x4117 - 1 )          ; start scanning from the expected VESA mode 0x4117 ( the -1 is because of the  inc cx  below )
   545                                  .back:
   546 00000140 FEC1                        inc cl                          ; increment just the bottom byte, we test 0x41xx
   547 00000142 80F916                      cmp cl, 0x16                    ; scanned from 0x4117 to 0x4116, not found, so show error
   548 00000145 741B                        jz .failure
   549 00000147 BF0018                      mov di, VESA_BUFFER             ; buffer for the VESA mode information block
   550 0000014A B8014F                      mov ax, 0x4F01                  ; INT 0x10, AX=0x4F01, CX=mode Get Mode Info
   551 0000014D CD10                        int 0x10
   552 0000014F 3C4F                        cmp al, 0x4F                    ; success code = 0x4F
   553 00000151 75ED                        jne .back                       ; try the next VESA mode
   554 00000153 8B4512                      mov ax, [di + 0x12]             ; width
   555 00000156 034514                      add ax, [di + 0x14]             ; height
   556 00000159 024519                      add al, [di + 0x19]             ; bits per pixel
   557                                  ;    adc ah, 0                       ; should not be necessary for the expected result, 0x400+0x300+0x10
   558 0000015C 39D8                        cmp ax, bx                      ; width + height + bits per pixel
   559 0000015E 740A                        je .success
   560 00000160 75DE                        jne .back                       ; try the next VESA mode
   561                                  .failure:                           ; VESA mode not found, so continue
   562 00000162 5F                          pop di                          ; restore di
   563 00000163 B80000                      mov ax, 0                       ; return flag false
   564 00000166 050000                      add ax, 0                       ; set the zero flag
   565 00000169 C3                          ret
   566                                  .success:
   567 0000016A 894D1E                      mov [ di + ( vesa_SavedMode - VESA_BUFFER ) ], cx ; save the VESA mode in the VESA_BUFFER at offset 0x1E "Reserved"
   568 0000016D B80100                      mov ax, 1                       ; return flag true
   569 00000170 050000                      add ax, 0                       ; set the zero flag
   570 00000173 5F                          pop di                          ; restore di
   571 00000174 C3                          ret
   572                                  
   573                                  setVESA:    ; we found a valid VESA mode
   574                                  
   575 00000175 1E                          push ds                         ; clear all flags including Interrupt using DS, known to be zero
   576 00000176 9D                          popf                            ; this is necessary to clear T flag also, end register display
   577                                  
   578 00000177 E8E000                      call greet      ; show greeting message
   579                                  
   580 0000017A 89CB                        mov bx, cx
   581 0000017C B8024F                      mov ax, 0x4F02  ; INT 0x10, AX=0x4F02, BX=mode, ES:DI=CRTCInfoBlock Set Video Mode
   582 0000017F CD10                        int 0x10
   583                                  
   584 00000181 E9E400                      jmp main_32bit
   585                                  
   586                                  setVideoMode:
   587                                  %if ( FORCE_800x600_VESA == 0 )     ; test the 800x600 mode in bochs, which supports 1024x768
   588 00000184 B81007                      mov ax, ( 1024 + 768 + BITS_PER_PIXEL ) ; try the highest resolution first
   589 00000187 E8B0FF                      call scanVESA                   ; if VESA mode is found, jump to setVESA
   590 0000018A 75E9                        jnz setVESA                     ; success - we found the requested VESA mode
   591                                  %endif
   592 0000018C B88805                      mov ax, ( 800 + 600 + BITS_PER_PIXEL ) ; then try a lower resolution
   593 0000018F E8A8FF                      call scanVESA                   ; if VESA mode is found, jump to setVESA
   594 00000192 75E1                        jnz setVESA                     ; success - we found the requested VESA mode
   595                                  
   596                                  ;    mov ax, 640 + 480 + BITS_PER_PIXEL  ; then try an even lower resolution
   597                                  ;    call scanVESA                   ; if VESA mode is found, jump to setVESA
   598                                  ;    jnz setVESA                     ; success - we found the requested VESA mode
   599 00000194 E9B200                      jmp showVESAerror               ; we have tried all VESA modes without success, so report an error
   600                                  
   601                                  ; ******************************************************************************
   602                                  ; ******************************************************************************
   603                                  
   604                                  relocate:                   ; copy 512 bytes from  [bx]  to FS:[destination]
   605 00000197 60                          pusha
   606 00000198 B90001                      mov cx, 0x200 / 2
   607 0000019B 89DE                        mov si, bx
   608 0000019D 668B5D0C                    mov ebx, [ byte di + ( destination - data_area) ]
   609                                  .back:
   610 000001A1 AD                          lodsw               ; load the 16 bit value pointed to by SI into  ax
   611 000001A2 64678903                    mov [fs:ebx], ax    ; Note : the  fs:  uses the 32 bit FS value setup in Unreal Mode to move the data outside of the 1 Mbyte Real Mode address range
   612 000001A6 6683C302                    add ebx, byte +2
   613 000001AA E2F5                        loop .back
   614                                  
   615 000001AC 66895D0C                    mov [ byte di + ( destination - data_area) ], ebx
   616 000001B0 61                          popa
   617 000001B1 C3                          ret
   618                                  
   619                                      ; not used because it is very slow :
   620                                  ; now set up for trap displaying registers on screen during bootup
   621                                  ;    push cs
   622                                  ;    push showstate - $$ + BOOTOFFSET
   623                                  ;    pop dword [word +4]
   624                                  
   625                                  ; ******************************************************************************
   626                                  ; ******************************************************************************
   627                                  ;1. MasterBoot Record - MBR   at Sector     0 (decimal 0)        MBR
   628                                  ; Partition at offset 1BE
   629                                  ;   BootSignature                0
   630                                  ;   Start Head|Sector|Cylinder   1   1     0
   631                                  ;   Partition Type               B  DOS 7.1+
   632                                  ;   End   Head|Sector|Cylinder  FE  3F   3E5
   633                                  ;   BPBsectorNumber                   00  \ was 3F
   634                                  ;   Size of partition (decimal)  16035777 sectors,  8210317824 bytes,  8017889 Ki bytes,  7830 Mi bytes,  8 Gi bytes
   635                                  ; Partition at offset 1CE
   636                                  ;   BootSignature                0
   637                                  ;   Start Head|Sector|Cylinder   0   0     0
   638                                  ;   Partition Type               0  Empty partition
   639                                  ;   End   Head|Sector|Cylinder   0   0     0
   640                                  ;   BPBsectorNumber                    0
   641                                  ;   Size of partition (decimal)         0 sectors,           0 bytes,  0 Ki bytes,  0 Mi bytes,
   642                                  
   643                                  ; pretend to be a Master Boot Record so that the BIOS will load us
   644 000001B2 77<rept>                times ( 0x000001BE - ( $ - $$ ) ) db 0x77
   645 000001BE 800101000BFEFFE500-         db 0x80, 0x01, 0x01, 0x00, 0x0B, 0xFE, 0xFF, 0xE5, 0x00, 0x00, 0x00, 0x00, 0xC1, 0xAF, 0xF4, 0x00 ; 0x1BE DOS partition 0  working on PC
   646 000001C7 000000C1AFF400     
   647 000001CE 0000000000000000            db 00, 00, 00, 00, 00, 00, 00, 00   ; 0x1CE first 8 bytes of empty partition 1
   648                                  
   649                                  SetupUnrealMode:
   650                                      ; set the FS segment in "unreal" mode, must be done before the Trap Flag is set in EFLAGS register
   651 000001D6 0F20C0                      mov eax, cr0
   652 000001D9 0C01                        or al, 1    ; set the "protected mode enable" bit => "unreal mode"
   653 000001DB 0F22C0                      mov cr0, eax
   654 000001DE 681000                      push word data32p_SELECTOR_0x10 ; set the FS segment
   655 000001E1 0FA1                        pop fs
   656 000001E3 FEC8                        dec al      ; clear the "protected mode enable" bit
   657 000001E5 0F22C0                      mov cr0, eax
   658 000001E8 1E                          push ds                         ; now set FS to 0
   659 000001E9 0FA1                        pop fs
   660                                  
   661                                  ReSetupUnrealMode:
   662 000001EB 0E                          push cs                         ; for iret
   663 000001EC 9C                          pushf                           ; for iret
   664 000001ED 60                          pusha
   665 000001EE 89E5                        mov bp, sp
   666 000001F0 8B4610                      mov ax, [bp + 16]               ; get flags
   667                                  ;    or ah, 0x01                    ; set Trap Flag, bit 8 in the EFLAGS register ; debug only - very slow!
   668 000001F3 80E4FD                      and ah, ~0x02                   ; reset interrupt flag
   669 000001F6 874614                      xchg ax, [ bp + 20 ]            ; swap flags with return address
   670 000001F9 894610                      mov [ bp + 16 ], ax             ; return address at top of stack after popa
   671 000001FC 61                          popa
   672 000001FD CF                          iret
   673                                  
   674                                  ; ******************************************************************************
   675                                  ; ******************************************************************************
   676                                  
   677                                  times 512 - 2 - ($ - $$) nop        ; fill with no-ops to 55AA at end of boot sector
   678 000001FE 55AA                        db 0x55 , 0xAA  ; boot sector terminating bytes
   679                                  
   680                                  ; ******************************************************************************
   681                                  ; End of Boot Sector
   682                                  ; ******************************************************************************
   683                                  
   684                                  ; ******************************************************************************
   685                                  ; Show the user a null terminated string - writes directly into video RAM
   686                                  ; ******************************************************************************
   687                                  
   688                                  displayString:
   689                                  
   690                                      ; restore the pointer to screen memory into di
   691 00000200 BF687C                      mov di, (data_area - $$ + BOOTOFFSET)
   692 00000203 8B4510                      mov ax, [ di + ( dispPtr - data_area) ]
   693 00000206 89C7                        mov di, ax
   694                                  
   695 00000208 06                          push es         ; save es
   696 00000209 B800B8                      mov ax, 0xb800  ; video RAM segment
   697 0000020C 8EC0                        mov es, ax
   698                                  
   699                                  backhere2:
   700 0000020E AC                          lodsb               ; loads a byte from [ds:si] into al, then increments  si
   701 0000020F 3C00                        cmp al, 0
   702 00000211 7406                        jz forward1     ; If al = 0 then leave the loop
   703 00000213 B40D                        mov ah, 0x0D    ; text colour, magenta on black background
   704 00000215 AB                          stosw               ; stores  ax  into  [es:di]  then increments  di
   705 00000216 E9F5FF                      jmp backhere2
   706                                  forward1:
   707                                      ; save the pointer to screen memory from di
   708 00000219 89F8                        mov ax, di
   709 0000021B BF687C                      mov di, (data_area - $$ + BOOTOFFSET)
   710 0000021E 894510                      mov [ di + ( dispPtr - data_area) ], ax
   711 00000221 07                          pop es          ; restore es
   712 00000222 C3                          ret
   713                                  
   714                                  ; display a string then Wait for a key press
   715                                  displayStringW:
   716                                  
   717 00000223 60                          pusha
   718 00000224 E8D9FF                      call displayString
   719                                  
   720 00000227 31C0                        xor  ax, ax     ; wait for and get a key press ( AX = 0 )
   721 00000229 CD16                        int  0x16       ; BIOS interrupt Read a Key From the Keyboard
   722 0000022B 61                          popa
   723 0000022C C3                          ret
   724                                  
   725                                  ; msg_greeting2:
   726                                  ;     db ' Press any key : ' , 0x00
   727                                  
   728                                  msg_VESAerror:
   729 0000022D 4E6F2076616C696420-         db 'No valid VESA mode found! ' , 0x02, 0x00
   730 00000236 56455341206D6F6465-
   731 0000023F 20666F756E64212002-
   732 00000248 00                 
   733                                  ;    db ' No VESA mode ' , 0x02, 0x00
   734                                  
   735                                  [BITS 16]                           ; Real Mode code (16 bit)
   736                                  
   737                                  showVESAerror:
   738 00000249 E80E00                      call greet
   739 0000024C 56                          push si
   740 0000024D C74510E001                  mov word [ di + ( dispPtr - data_area) ] , 0x000001E0    ; line 3 0x50 x 2 x 3 = 0x1E0
   741 00000252 BE2D7E                      mov si, ( msg_VESAerror - $$ + BOOTOFFSET )  ; string to display
   742 00000255 E8CBFF                      call displayStringW
   743 00000258 5E                          pop si
   744 00000259 C3                          ret
   745                                  
   746                                  greet:     ; jump here to show 16 bit version text
   747 0000025A 56                          push si
   748 0000025B C745104001                  mov word [ di + ( dispPtr - data_area) ] , 0x00000140    ; line 2 0x50 x 2 x 2 = 0x140
   749 00000260 BEC0E3                      mov si, ( version - $$ + BOOTOFFSET )  ; string to display
   750 00000263 E89AFF                      call displayString
   751                                  ;    mov si, ( msg_greeting2 - $$ + BOOTOFFSET )  ; string to display
   752                                  ;    call displayStringW
   753 00000266 5E                          pop si
   754 00000267 C3                          ret
   755                                  
   756                                  ; ******************************************************************************
   757                                  ; the main program in 32 bit ( protected ) mode
   758                                  ; ******************************************************************************
   759                                  
   760                                  main_32bit:
   761                                  
   762 00000268 E88200                      call setProtectedModeAPI        ; called from 16 bit code, returns in 32 bit code
   763                                  
   764                                  [BITS 32]                           ; Protected Mode code (32 bit) - assemble for 32 bit mode from now on
   765                                  
   766 0000026B BC00780000                  mov esp, RETURN_STACK_0         ; setup the return stack pointer
   767 00000270 BE04760000                  mov esi, ( DATA_STACK_0 + 4 )   ; setup our data stack pointer
   768                                  
   769 00000275 E863300000                  call save_BIOS_idt_and_pic      ; to be restored later, when making BIOS calls
   770 0000027A E8E4300000                  call init_default_PIC_IMRs      ; set the default values and copy the BIOS Interrupt Vectors to our new table
   771                                      _DUP_
   772 0000027F 83EE04              <1>  sub esi, byte 0x04
   773 00000282 8906                <1>  mov [ esi ], _TOS_
   774 00000284 B8001C0000                  mov _TOS_, INTERRUPT_VECTORS
   775 00000289 E809300000                  call lidt_                      ; Load the new Interrupt Descriptor Table
   776                                  
   777 0000028E E92A2C0000                  jmp dword warm
   778                                  
   779                                  ; *****************************************************************************
   780                                  ; calculate Cylinder, Head and Sector from zero-based sector number
   781                                  ; see http://teaching.idallen.com/dat2343/00f/calculating_cylinder.htm
   782                                  ; Note : uses pushad to copy registers onto the ESP stack, stores the
   783                                  ; calculated values onto the stack at the correct offsets, then restores the
   784                                  ; stack back to the registers.
   785                                  ; *****************************************************************************
   786                                  
   787                                  sector_chs:  ; ( sector -- eax ) calculate CHS from a sector number in eax,
   788                                      ; returns with DX = HHDD, CX = CCSS where HH=head, DD=drive, CC=cylinder, SS=sector
   789                                      ; Note that the input sector number is zero based, and that the high 16 bits of EAX must be 0
   790 00000293 60                          pushad  ; Pushes all general purpose registers onto the stack in the following order:
   791                                          ; EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI. The value of ESP is the value before the actual push of ESP
   792                                          ;  7    6    5    4    3    2    1    0   offset in cells from ESP
   793 00000294 89E5                        mov ebp, esp    ; copy the original ESP stack pointer to EBP so we can access items on the stack easily
   794                                  
   795                                      ; save the register values in the DAP buffer for use later, via ESI
   796 00000296 BEE0170000                  mov esi, DAP_BUFFER
   797                                  
   798 0000029B 0305687C0000                add eax, [ bootsector - $$ + BOOTOFFSET]
   799 000002A1 50                          push eax                            ; save it while we calculate heads*sectors-per-track
   800 000002A2 A0717C0000                  mov al, [ driveinfo_Head - $$ + BOOTOFFSET]      ; index of highest-numbered head
   801 000002A7 FEC0                        inc al                              ; 1-base the number to make count of heads
   802 000002A9 F625727C0000                mul byte [ driveinfo_SectorsPertrack - $$ + BOOTOFFSET]     ; sectors per track
   803 000002AF 89C3                        mov ebx, eax
   804 000002B1 58                          pop eax
   805 000002B2 31D2                        xor edx, edx                        ; clear high 32 bits
   806 000002B4 F7F3                        div ebx                             ; leaves cylinder number in eax, remainder in edx
   807 000002B6 89C1                        mov ecx, eax                        ; store cylinder number in another register
   808 000002B8 89D0                        mov eax, edx                        ; get remainder into AX
   809 000002BA 8A1D727C0000                mov bl, [ driveinfo_SectorsPertrack - $$ + BOOTOFFSET]      ; number of sectors per track
   810 000002C0 F6F3                        div bl                              ; head number into AX, remainder into DX
   811 000002C2 88C3                        mov bl, al                          ; result must be one byte, so store it in BL
   812 000002C4 C1C108                      rol ecx, 8                          ; high 2 bits of cylinder number into high 2 bits of CL
   813 000002C7 C0E106                      shl cl, 6                           ; makes room for sector number
   814 000002CA 08E1                        or cl, ah                           ; merge cylinder number with sector number
   815 000002CC FEC1                        inc cl                              ; one-base sector number
   816 000002CE 894D18                      mov [ ebp + ( 6 * 4 ) ], ecx        ; store the result in ECX position on esp stack
   817 000002D1 66894E18                    mov word [ esi + o_Int13_DAP_saved_CHS_CX ], cx  ; also save the calculated CX value
   818 000002D5 668B0D6C7C0000              mov cx, [ driveinfo_Drive_DX - $$ + BOOTOFFSET]    ; drive number in low 8 bits
   819 000002DC 88DD                        mov ch, bl                          ; place head number in high bits
   820                                  ;    mov cl, 0x80
   821 000002DE 894D14                      mov [ ebp + ( 5 * 4 ) ], ecx    ; store the result in EDX position on esp stack
   822 000002E1 66894E1A                    mov word [ esi + o_Int13_DAP_saved_CHS_DX ], cx  ; also save the calculated DX value
   823 000002E5 61                          popad                           ; restore registers from esp stack
   824 000002E6 C3                          ret
   825                                  
   826                                  ; *****************************************************************************
   827                                  ; enter Protected Mode (32 bit) and Real Mode (16 bit)
   828                                  ; from http://ringzero.free.fr/os/protected%20mode/Pm/PM1.ASM
   829                                  ; *****************************************************************************
   830                                  
   831                                  [BITS 16]   ; Real Mode code (16 bit)
   832                                  
   833                                  enterProtectedMode:                 ; must come from a 'call' , can not be inlined
   834 000002E7 58                          pop ax
   835 000002E8 680800                      push code32p_SELECTOR_0x08
   836 000002EB 50                          push ax
   837 000002EC CB                          retf
   838                                  
   839                                  setProtectedModeAPI:                ; set protected mode from 'Real' mode. Called from 16 bit code, returns to 32 bit code
   840 000002ED 6660                        pushad                          ; save all registers as doublewords
   841 000002EF 0F20C0                      mov eax, cr0
   842 000002F2 0C01                        or al, 1
   843 000002F4 0F22C0                      mov cr0, eax                    ; set the Protected Mode bit in the Control Register
   844 000002F7 6631C0                      xor eax, eax                    ; clear high bits of eax
   845 000002FA E8EAFF                      call enterProtectedMode
   846                                  
   847                                  [BITS 32]                           ; Protected Mode code (32 bit)
   848                                  
   849 000002FD B810000000                  mov eax, data32p_SELECTOR_0x10  ; Protected Mode data segment
   850 00000302 668EC0                      mov es, ax
   851 00000305 668ED8                      mov ds, ax
   852 00000308 668ED0                      mov ss, ax                      ; this makes stack segment 32 bits
   853 0000030B 61                          popad
   854 0000030C 66C3                        o16 ret
   855                                  
   856                                  enter16bitProtectedMode:            ; 32 bit code. Must come from a 'call' , can not be inlined
   857 0000030E 58                          pop eax                         ; return address
   858 0000030F 6818000000                  push dword code16r_SELECTOR_0x18    ; select 16-bit Protected Mode AKA 'Real' Mode
   859 00000314 50                          push eax
   860 00000315 CB                          retf
   861                                  
   862                                  setRealModeAPI:                     ; set 'Real' mode from protected mode.
   863                                                                      ; Called from 32 bit code, returns to 16 bit code
   864                                                                      ; assumed that protected-mode stack is based at 0
   865                                                                      ; and that bits 16 through 19 will not change during time in realmode
   866 00000316 60                          pushad                          ; save 32-bit values of registers
   867 00000317 89E1                        mov ecx, esp                    ; do all possible 32-bit ops before going to 16 bits
   868 00000319 0F20C2                      mov edx, cr0
   869 0000031C E8EDFFFFFF                  call enter16bitProtectedMode
   870                                  
   871                                  [BITS 16]                           ; Real Mode code (16 bit)
   872                                  
   873 00000321 B82000                      mov ax, data16r_SELECTOR_0x20
   874 00000324 8ED8                        mov ds, ax
   875 00000326 8EC0                        mov es, ax
   876 00000328 8ED0                        mov ss, ax                      ; here the stack becomes 16 bits based at 0, and SP used not ESP
   877                                                                      ; *** consider stack to be invalid from here until we reach real mode ***
   878 0000032A 31C9                        xor cx, cx                      ; clear low 16 bits
   879 0000032C 66C1E904                    shr ecx, 4                      ; move high 4 bits into cl
   880 00000330 FECA                        dec dl                          ; leave protected mode, only works if we KNOW bit 0 is set
   881 00000332 0F22C2                      mov cr0, edx
   882 00000335 E80C00                      call enterRealMode
   883 00000338 31C0                        xor ax, ax
   884 0000033A 8ED8                        mov ds, ax
   885 0000033C 8EC0                        mov es, ax
   886 0000033E 8ED1                        mov ss, cx
   887                                      ; note we don't need to set SP to 8xxx if ESP is b8xxx, since
   888                                      ; the b000 is now in SS, and the b of b8xxx is ignored in real mode
   889 00000340 6661                        popad
   890 00000342 66C3                        o32 ret
   891                                  
   892                                  enterRealMode:                      ; 16 bit code. Must come from a 'call' , can not be inlined
   893 00000344 58                          pop ax
   894 00000345 0FA0                        push fs                         ; real-mode code segment
   895 00000347 50                          push ax
   896 00000348 CB                          retf
   897                                  
   898                                  [BITS 32]                           ; Protected Mode code (32 bit)
   899                                  
   900                                  ; *****************************************************************************
   901                                  ; *****************************************************************************
   902                                  
   903                                  ;%include "JCreadwrite.nasm"
   904                                  ; JCreadwrite.nasm 2012 Oct 23   read and write the disk using 16 bit BIOS calls
   905                                  ; BIOS read and write routines for colorForth
   906                                  
   907                                  [BITS 32]                           ; Protected Mode code (32 bit)
   908                                  
   909                                  bios_read:  ; ( a c -- a' c' )   \  read cylinder c into address a , leave next address and cylinder
   910                                                                      ; c is cylinder, we will use 1.44Mb floppy's idea of cylinder regardless
   911                                                                      ; a is byte address
   912                                                                      ; leave updated c and a on stack as c' and a'
   913                                                                      ; a cylinder is 36 tracks of 512 bytes each, 0x4800 bytes, 0x1200 cells (words)
   914                                  
   915 00000349 FA                          cli                             ; disable interrupts
   916 0000034A 60                          pushad                          ; push all registers ( except esp ) and flags onto the stack
   917 0000034B 89E5                        mov ebp, esp                    ; copy of stack pointer for use below ( * ), points to registers copied by pushad , above
   918                                  
   919 0000034D B924000000                  mov ecx, HEADS * SECTORS        ; sectors per track (both heads)
   920 00000352 F6E1                        mul cl                          ; sector number goes into AX
   921                                                                      ; note that resultant sector number is zero-based going into sector_chs!
   922                                                                      ; set up loop to read one floppy cylinder's worth
   923                                  
   924 00000354 50                          push eax                        ; absolute sector number to start
   925                                  .back:
   926 00000355 51                          push ecx
   927 00000356 E838FFFFFF                  call sector_chs                 ; convert to Cylinder-Head-Sector in CX-DX
   928 0000035B E81F000000                  call .readsector
   929                                  
   930 00000360 8B5D04                      mov ebx, [ ebp + ( 1 * 4 ) ]    ; ( * ) get ESI stored on stack, via stack pointer saved in ebp
   931 00000363 8B3B                        mov edi, [ebx]                  ; destination index address for movsd
   932 00000365 B980000000                  mov ecx, ( 512 >> 2 )           ; number of 32-bit words to move, 512 bytes
   933 0000036A BE00200000                  mov esi, SECTOR_BUFFER          ; source index for movsd
   934 0000036F F3A5                        rep  movsd                      ; copy ecx 32 bit words from ds:esi to es:edi
   935 00000371 893B                        mov [ebx], edi
   936 00000373 59                          pop ecx
   937 00000374 58                          pop eax
   938 00000375 40                          inc eax
   939 00000376 50                          push eax
   940 00000377 E2DC                        loop .back
   941 00000379 58                          pop eax
   942 0000037A FF451C                      inc dword [ebp + 7 * 4]         ; for updated cylinder number after return
   943 0000037D 61                          popad
   944 0000037E C3                          ret
   945                                  
   946                                  .readsector:                        ; no need to save registers because we take care of them in calling routine
   947 0000037F E892FFFFFF                  call setRealModeAPI
   948                                  [BITS 16]                           ; Real Mode code (16 bit)
   949 00000384 BB0020                      mov bx, SECTOR_BUFFER
   950 00000387 B80102                      mov ax, 0x0201                  ; read 1 sector
   951 0000038A CD13                        int 0x13
   952 0000038C FA                          cli                             ; BIOS might have left interrupts enabled
   953 0000038D E85DFF                      call setProtectedModeAPI        ; called from 16 bit code, returns to 32 bit code
   954                                  [BITS 32]                           ; Protected Mode code (32 bit)
   955 00000390 C3                          ret
   956                                  
   957                                  bios_write:     ; ( a c -- a' c' )   \  write cylinder c from address a , leave next address and cylinder
   958 00000391 FA                          cli                             ; disable interrupts
   959 00000392 60                          pushad
   960 00000393 89E5                        mov ebp, esp
   961                                                                      ; eax contains cylinder to start, the 'c' parameter
   962 00000395 B924000000                  mov ecx, HEADS * SECTORS        ; sectors per track (both heads)
   963 0000039A F6E1                        mul cl                          ; absolute sector number goes into AX
   964                                  
   965 0000039C 8B5D04                      mov ebx, [ebp + ( 1 * 4 ) ]     ; stored ESI on stack
   966 0000039F 8B33                        mov esi, [ebx]                  ; word address, 'a' parameter
   967                                  ;        shl esi, 2                 ; change word address into byte address
   968                                                                      ; set up loop to write one floppy cylinder's worth
   969 000003A1 50                          push eax                        ; absolute sector number to start
   970                                  
   971                                  .back:
   972 000003A2 51                          push ecx
   973                                                                      ; load sector data into buffer
   974                                                                      ; DO NOT take advantage of knowing ECX only has byte value
   975 000003A3 B980000000                  mov ecx, 128 ; ( 512 >> 2 )     ; number of 32-bit words to move
   976 000003A8 BF00200000                  mov edi, SECTOR_BUFFER
   977 000003AD F3A5                        rep  movsd                      ; copy ecx 32 bit words from ds:esi to es:edi
   978 000003AF E8DFFEFFFF                  call sector_chs                 ; convert to Cylinder-Head-Sector in CX-DX
   979 000003B4 E811000000                  call .writesector
   980 000003B9 59                          pop ecx
   981 000003BA 58                          pop eax
   982 000003BB 40                          inc eax
   983 000003BC 50                          push eax
   984 000003BD E2E3                        loop .back
   985 000003BF 58                          pop eax
   986 000003C0 FF451C                      inc dword [ ebp + ( 7 * 4 ) ]   ; for updated cylinder after return (EAX)
   987 000003C3 8B5D04                      mov ebx, [ ebp + ( 1 * 4 ) ]    ; stored ESI on stack
   988 000003C6 8933                        mov [ebx], esi                  ; updated address
   989 000003C8 61                          popad
   990 000003C9 C3                          ret
   991                                  
   992                                  .writesector:                       ; no need to save registers because we take care of them in calling routine
   993 000003CA E847FFFFFF                  call setRealModeAPI
   994                                  [BITS 16]                           ; Real Mode code (16 bit)
   995 000003CF BB0020                      mov bx, SECTOR_BUFFER
   996 000003D2 B80103                      mov ax, 0x0301                  ; write 1 sector
   997 000003D5 CD13                        int 0x13
   998 000003D7 FA                          cli                             ; BIOS might have left interrupts enabled
   999 000003D8 E812FF                      call setProtectedModeAPI        ; called from 16 bit code, returns to 32 bit code
  1000                                  [BITS 32]                           ; Protected Mode code (32 bit)
  1001 000003DB C3                          ret
  1002                                  
  1003 000003DC 90<rept>                 times (0x400 - ($ - $$)) nop
  1004                                  
  1005                                  ; *****************************************************************************
  1006                                  ; *****************************************************************************
  1007                                  ; After Two Sectors
  1008                                  ; *****************************************************************************
  1009                                  ; *****************************************************************************
  1010                                  
  1011                                  nul:
  1012 00000400 C3                          ret
  1013                                  
  1014                                  ; *****************************************************************************
  1015                                  ; cooperative multi-tasker
  1016                                  ; *****************************************************************************
  1017                                  
  1018                                  me:
  1019 00000401 [2F040000]                  dd God
  1020                                  x_screenTask:
  1021 00000405 [00040000]                  dd nul
  1022                                  x_serverTask:
  1023 00000409 [00040000]                  dd nul
  1024                                  
  1025                                  pause_:
  1026                                      _DUP_
  1027 0000040D 83EE04              <1>  sub esi, byte 0x04
  1028 00000410 8906                <1>  mov [ esi ], _TOS_
  1029 00000412 56                          push esi
  1030 00000413 A1[01040000]                mov _TOS_, [ me ]  ; points to God at startup
  1031 00000418 8920                        mov [_TOS_], esp
  1032 0000041A 83C004                      add _TOS_, byte 0x04
  1033 0000041D FFE0                        jmp _TOS_
  1034                                  
  1035                                  unpause:
  1036 0000041F 58                          pop _TOS_
  1037 00000420 8B20                        mov esp, [_TOS_]
  1038 00000422 A3[01040000]                mov [ me ], _TOS_
  1039 00000427 5E                          pop esi
  1040                                      _DROP_
  1041 00000428 AD                  <1>  lodsd
  1042 00000429 C3                          ret
  1043                                  
  1044                                  round:
  1045 0000042A E8F0FFFFFF                      call unpause
  1046                                  God:                                ; graphics update task
  1047 0000042F 00000000                    dd 0                            ; new stack location
  1048 00000433 E8E7FFFFFF                  call unpause
  1049                                  main:                               ; main program task
  1050 00000438 00000000                    dd 0                            ; new stack location
  1051                                  ;    call unpause
  1052                                  otherTask:
  1053                                  ;    dd RETURN_STACK_2 - 8          ; new stack location
  1054 0000043C EBEC                        jmp short round                 ; loop forever between 3 stacks
  1055                                  
  1056                                  activate:   ; ( a -- )    \ activate the main task to execute colorForth code at the given address
  1057 0000043E BAFC710000                  mov edx, DATA_STACK_1 - 4
  1058 00000443 890A                        mov [edx], ecx
  1059 00000445 B9FC730000                  mov ecx, RETURN_STACK_1 - 4
  1060 0000044A 8F01                        pop dword [ecx]
  1061 0000044C 8D49FC                      lea ecx, [ ecx - 0x04 ]
  1062 0000044F 8911                        mov [ecx], edx
  1063 00000451 890D[38040000]              mov dword [ main ], ecx
  1064                                      _DROP_
  1065 00000457 AD                  <1>  lodsd
  1066 00000458 C3                          ret
  1067                                  
  1068                                  show:   ; ( -- )    \ set the screen task to execute the code following  show
  1069 00000459 8F05[05040000]              pop dword [ x_screenTask ]      ; copy the return address of the calling word into the screenTask variable
  1070                                      _DUP_
  1071 0000045F 83EE04              <1>  sub esi, byte 0x04
  1072 00000462 8906                <1>  mov [ esi ], _TOS_
  1073 00000464 31C0                        xor _TOS_, _TOS_
  1074 00000466 E8D3FFFFFF                  call activate
  1075                                  .show:
  1076 0000046B E8CD050000                  call graphAction                ; perform a graphical update
  1077 00000470 FF15[05040000]              call [ x_screenTask ]           ; execute the code that called show, saved on entry
  1078 00000476 E8E0090000                  call switch                     ; copy the screen image to the VESA buffer
  1079 0000047B 31C0                        xor _TOS_, _TOS_
  1080 0000047D E88BFFFFFF                  call pause_
  1081 00000482 40                          inc _TOS_
  1082 00000483 EBE6                        jmp short .show
  1083                                  
  1084                                  initshow:                           ; called by warm
  1085 00000485 E8CFFFFFFF                  call show
  1086                                      ; <--- this address ( on the return stack from the preceding call ) goes into  x_screenTask
  1087 0000048A C3                          ret                 ; makes this a no-op "show"
  1088                                  
  1089                                  ; *****************************************************************************
  1090                                  ; "other" task execution
  1091                                  ; *****************************************************************************
  1092                                  
  1093                                  activate2:  ; ( a -- )    \ activate the  other  task to execute colorForth code at the given address
  1094 0000048B BAFC6D0000                  mov edx, DATA_STACK_2 - 4
  1095 00000490 890A                        mov [edx], ecx
  1096 00000492 B9FC6F0000                  mov ecx, RETURN_STACK_2 - 4
  1097 00000497 8F01                        pop dword [ecx]
  1098 00000499 8D49FC                      lea ecx, [ ecx - 0x04 ]
  1099 0000049C 8911                        mov [ecx], edx
  1100 0000049E 890D[3C040000]              mov [ otherTask ], ecx
  1101                                      _DROP_
  1102 000004A4 AD                  <1>  lodsd
  1103 000004A5 C3                          ret
  1104                                  
  1105                                  freeze:
  1106 000004A6 8F05[05040000]              pop dword [ x_screenTask ]
  1107 000004AC E88DFFFFFF                  call activate
  1108                                  .back:
  1109 000004B1 FF15[05040000]              call [ x_screenTask ]
  1110 000004B7 EBF8                        jmp short .back
  1111                                  
  1112                                  serve:
  1113 000004B9 8F05[09040000]              pop dword [ x_serverTask ]
  1114 000004BF E8C7FFFFFF                  call activate2
  1115                                  .back:
  1116 000004C4 31C0                        xor _TOS_, _TOS_
  1117 000004C6 E842FFFFFF                  call pause_
  1118 000004CB FF15[09040000]              call [ x_serverTask ]
  1119 000004D1 EBF1                        jmp short .back
  1120                                  
  1121                                  initserve:
  1122 000004D3 E8E1FFFFFF                  call serve
  1123 000004D8 C3                          ret
  1124                                  
  1125                                  ; *****************************************************************************
  1126                                  ; *****************************************************************************
  1127                                  
  1128                                  c_:     ; ( -- )   \ clear the data stack for keyboard task
  1129 000004D9 BE04760000                  mov esi, ( DATA_STACK_0 + 4 )
  1130 000004DE C3                          ret
  1131                                  
  1132                                  ; *****************************************************************************
  1133                                  ; *****************************************************************************
  1134                                  
  1135                                  mark:
  1136 000004DF 8B0D[F0390000]              mov ecx, [ v_MacroWordCount]
  1137 000004E5 890D[CC390000]              mov [ mark_MacroWordCount], ecx
  1138 000004EB 8B0D[EC390000]              mov ecx, [ v_ForthWordCount ]
  1139 000004F1 890D[D0390000]              mov [ mark_v_ForthWordCount], ecx
  1140 000004F7 8B0D[D8390000]              mov ecx, [ v_H ]
  1141 000004FD 890D[D4390000]              mov [ mark_H ], ecx
  1142 00000503 C3                          ret
  1143                                  
  1144                                  empty_:
  1145 00000504 FA                          cli                             ; disable interrupts
  1146 00000505 8B0D[D4390000]              mov ecx, [ mark_H ]
  1147 0000050B 890D[D8390000]              mov [ v_H ], ecx
  1148 00000511 8B0D[D0390000]              mov ecx, [ mark_v_ForthWordCount]
  1149 00000517 890D[EC390000]              mov [ v_ForthWordCount ], ecx
  1150 0000051D 8B0D[CC390000]              mov ecx, [ mark_MacroWordCount]
  1151 00000523 890D[F0390000]              mov [ v_MacroWordCount ], ecx
  1152 00000529 C705[E0390000]0000-         mov dword [ class], 0x00
  1153 00000531 0000               
  1154 00000533 C3                          ret
  1155                                  
  1156                                  ; *****************************************************************************
  1157                                  ; *****************************************************************************
  1158                                  
  1159                                  mfind:  ; ( sf -- )   \ ecx = index ; find the Shannon-Fano word sf in the Macro wordlist, return its index in ecx
  1160 00000534 8B0D[F0390000]              mov ecx, [ v_MacroWordCount ]   ; count of Macro wordlist words
  1161 0000053A 57                          push edi
  1162 0000053B 8D3C8DFCCF4600              lea edi, [ ( ecx * 4 ) + MacroNames - 4 ]
  1163 00000542 EB0E                        jmp short ffind
  1164                                  
  1165                                  find_:   ; ( sf -- )   \ ecx = index ; find the Shannon-Fano word sf in the Forth wordlist, return its index in ecx
  1166 00000544 8B0D[EC390000]              mov ecx, [ v_ForthWordCount ]   ; count of Forth wordlist words
  1167 0000054A 57                          push edi
  1168 0000054B 8D3C8DFC7F4600              lea edi, [ ( ecx * 4 ) + ForthNames - 4 ]   ; set edi to the top of the Forth name table
  1169                                  ffind:
  1170 00000552 FD                          std                    ; scan backwards
  1171 00000553 F2AF                        repne scasd            ; locate the 32 bit Shanon-Fano encoded name, compare eax with doubleword at es:edi and set status flags.
  1172 00000555 FC                          cld                    ; reset the direction flag
  1173 00000556 5F                          pop edi
  1174 00000557 C3                          ret
  1175                                  
  1176                                  ; *****************************************************************************
  1177                                  ; *****************************************************************************
  1178                                  
  1179                                  abort:
  1180 00000558 FF25[84390000]              jmp dword [ x_abort ]
  1181                                  
  1182                                  ; *****************************************************************************
  1183                                  ; *****************************************************************************
  1184                                  
  1185                                  cdrop:
  1186 0000055E 8B15[D8390000]              mov edx, [ v_H ]
  1187 00000564 8915[E4390000]              mov [ list ], edx
  1188 0000056A C602AD                      mov byte [edx], 0xAD            ; 0xAD is the opcode for 'lodsd'
  1189 0000056D FF05[D8390000]              inc dword [ v_H ]
  1190 00000573 C3                          ret
  1191                                  
  1192                                  ; *****************************************************************************
  1193                                  ; *****************************************************************************
  1194                                  
  1195                                  qdup:
  1196 00000574 8B15[D8390000]              mov edx, [ v_H ]
  1197 0000057A 4A                          dec edx
  1198 0000057B 3915[E4390000]              cmp dword [ list ], edx
  1199 00000581 750C                        jnz cdup
  1200 00000583 803AAD                      cmp byte [edx], 0xAD            ; 0xAD is the opcode for 'lodsd'
  1201 00000586 7507                        jnz cdup
  1202 00000588 8915[D8390000]              mov [ v_H ], edx
  1203 0000058E C3                          ret
  1204                                  
  1205                                  cdup:   ; compile action of  dup  macro
  1206 0000058F 8B15[D8390000]              mov edx, [ v_H ]
  1207 00000595 C7028D76FC89                mov dword [edx], 0x89FC768D     ; assemble the instruction sequence for  DUP  "lea esi, [ esi - 4 ]" , "mov [esi], eax"
  1208 0000059B C6420406                    mov byte [ edx + 4 ], 0x006     ;  "8d 76 fc" , "89 06" ( the first 4 are expressed in little endian format above )
  1209 0000059F 8305[D8390000]05            add dword [ v_H ], byte 0x05
  1210 000005A6 C3                          ret
  1211                                  
  1212                                  adup:
  1213                                      _DUP_   ; interpret action of  dup  macro
  1214 000005A7 83EE04              <1>  sub esi, byte 0x04
  1215 000005AA 8906                <1>  mov [ esi ], _TOS_
  1216 000005AC C3                          ret
  1217                                  
  1218                                  ; *****************************************************************************
  1219                                  ; *****************************************************************************
  1220                                  
  1221                                  sdefine:
  1222 000005AD 8F05[003A0000]              pop dword [ adefine ]
  1223 000005B3 C3                          ret
  1224                                  
  1225                                  macro:     ; select the Macro wordlist
  1226 000005B4 E8F4FFFFFF                  call sdefine
  1227                                  macrod:
  1228 000005B9 50                          push _TOS_
  1229 000005BA 8B0D[F0390000]              mov ecx, [ v_MacroWordCount]
  1230 000005C0 FF05[F0390000]              inc dword [ v_MacroWordCount]
  1231 000005C6 8D0C8D00D04600              lea ecx, [ ( ecx * 4 ) + MacroNames ]
  1232 000005CD B800280000                  mov _TOS_, ( MacroJumpTable - MacroNames ) ; mov _TOS_, 0x218
  1233 000005D2 EB1E                        jmp short forthdd
  1234                                  
  1235                                  forth:      ; select the Forth wordlist
  1236 000005D4 E8D4FFFFFF                  call sdefine
  1237                                  forthd:
  1238 000005D9 50                          push _TOS_
  1239 000005DA 8B0D[EC390000]              mov ecx, [ v_ForthWordCount ]
  1240 000005E0 FF05[EC390000]              inc dword [ v_ForthWordCount ]
  1241 000005E6 8D0C8D00804600              lea ecx, [ ( ecx * 4 ) + ForthNames ]
  1242 000005ED B800280000                  mov _TOS_, ( ForthJumpTable - ForthNames )
  1243                                  forthdd:
  1244 000005F2 8B14BDFCFFFFFF              mov edx, [ ( edi * 4 ) - 0x04 ]
  1245 000005F9 83E2F0                      and edx, byte -0x10
  1246 000005FC 8911                        mov [ecx], edx
  1247 000005FE 8B15[D8390000]              mov edx, [ v_H ]
  1248 00000604 891401                      mov [ecx+_TOS_], edx
  1249 00000607 8D1401                      lea edx, [ecx+_TOS_]
  1250 0000060A C1EA02                      shr edx, 0x02
  1251 0000060D 8915[DC390000]              mov [ v_last ], edx
  1252 00000613 58                          pop _TOS_
  1253 00000614 8925[E4390000]              mov [ list ], esp
  1254 0000061A C705[C4390000]-             mov dword [ lit ], adup
  1255 00000620 [A7050000]         
  1256 00000624 F705[E0390000]FFFF-         test dword [ class ], -1
  1257 0000062C FFFF               
  1258 0000062E 7406                        jz .fthd
  1259 00000630 FF25[E0390000]              jmp dword [ class ]
  1260                                  .fthd:
  1261 00000636 C3                          ret
  1262                                  
  1263                                  ; *****************************************************************************
  1264                                  ; *****************************************************************************
  1265                                  
  1266                                  var1:   ; interpret time code for magenta variable
  1267                                      _DUP_
  1268 00000637 83EE04              <1>  sub esi, byte 0x04
  1269 0000063A 8906                <1>  mov [ esi ], _TOS_
  1270 0000063C 8B048D04804600              mov _TOS_, [ 4 + ForthNames + ( ecx * 4 ) ]
  1271 00000643 C1E002                      shl _TOS_, 2
  1272 00000646 C3                          ret
  1273                                  
  1274                                  m_variable:   ; create a magenta variable
  1275 00000647 E88DFFFFFF                  call forthd
  1276 0000064C C78100280000-               mov dword [ ForthJumpTable - ForthNames + ecx ], var1
  1277 00000652 [37060000]         
  1278 00000656 FF05[EC390000]              inc dword [ v_ForthWordCount ]      ; dummy entry for source address
  1279 0000065C 897904                      mov [ 4 + ecx ], edi
  1280 0000065F E855FFFFFF                  call macrod
  1281 00000664 C78100280000-               mov dword [ MacroJumpTable - MacroNames + ecx ], .var
  1282 0000066A [79060000]         
  1283 0000066E FF05[F0390000]              inc dword [ v_MacroWordCount ]
  1284 00000674 897904                      mov [ 4 + ecx ], edi
  1285 00000677 47                          inc edi
  1286 00000678 C3                          ret
  1287                                  
  1288                                  .var:   ; compile time code for magenta variable in Macro dictionary
  1289 00000679 FF15[C4390000]              call [ lit ]
  1290 0000067F 8B048D04D04600              mov _TOS_, [ 4 + MacroNames + ( ecx * 4 ) ]
  1291 00000686 C1E002                      shl _TOS_, 2
  1292 00000689 EB55                        jmp short cshrt
  1293                                  
  1294                                  ; *****************************************************************************
  1295                                  ; *****************************************************************************
  1296                                  
  1297                                  alit:
  1298 0000068B C705[C4390000]-             mov dword [ lit ], adup
  1299 00000691 [A7050000]         
  1300                                  
  1301                                  literal:
  1302 00000695 E8DAFEFFFF                  call qdup
  1303 0000069A 8B15[E4390000]              mov edx, [ list ]               ; select the wordlist to add the literal to
  1304 000006A0 8915[E8390000]              mov [ list + 4 ], edx
  1305 000006A6 8B15[D8390000]              mov edx, [ v_H ]
  1306 000006AC 8915[E4390000]              mov [ list ], edx
  1307 000006B2 C602B8                      mov byte [edx], _MOV_TOS_LIT_   ; the opcode for mov eax, 32_bit_literal  (in next 32 bit cell)
  1308 000006B5 894201                      mov [ edx + 0x01 ], _TOS_       ; the literal value follows in the next 4 bytes in the dictionary
  1309 000006B8 8305[D8390000]05            add dword [ v_H ], byte 0x05    ; move the dictionary pointer forward 5 bytes
  1310 000006BF C3                          ret
  1311                                  
  1312                                  ; *****************************************************************************
  1313                                  ; *****************************************************************************
  1314                                  
  1315                                  cnum:
  1316 000006C0 FF15[C4390000]              call [ lit ]
  1317 000006C6 8B04BD00000000              mov _TOS_, [ ( edi * 4 ) + 0x00 ]
  1318 000006CD 47                          inc edi
  1319 000006CE EB10                        jmp short cshrt
  1320                                  
  1321                                  cshort:
  1322 000006D0 FF15[C4390000]              call [ lit]
  1323 000006D6 8B04BDFCFFFFFF              mov _TOS_, [ ( edi * 4 ) - 0x04 ]
  1324 000006DD C1F805                      sar _TOS_, 0x05
  1325                                  cshrt:
  1326 000006E0 E8B0FFFFFF                  call literal
  1327                                      _DROP_
  1328 000006E5 AD                  <1>  lodsd
  1329 000006E6 C3                          ret
  1330                                  
  1331                                  ; *****************************************************************************
  1332                                  ; *****************************************************************************
  1333                                  
  1334                                  ex1:
  1335 000006E7 31FF                        xor edi, edi
  1336                                  .back:
  1337 000006E9 FF0D[B8390000]              dec dword [ v_words ]
  1338 000006EF 741C                        jz ex2
  1339                                      _DROP_
  1340 000006F1 AD                  <1>  lodsd
  1341 000006F2 EBF5                        jmp short .back
  1342                                  
  1343                                  execute_lit:    ; ( -- )
  1344 000006F4 C705[C4390000]-             mov dword [ lit ], alit
  1345 000006FA [8B060000]         
  1346                                      _DUP_
  1347 000006FE 83EE04              <1>  sub esi, byte 0x04
  1348 00000701 8906                <1>  mov [ esi ], _TOS_
  1349 00000703 8B04BDFCFFFFFF              mov _TOS_, [ ( edi * 4 ) - 0x04 ]
  1350                                  execute:    ; ( name -- )
  1351 0000070A 83E0F0                      and _TOS_, byte -0x10
  1352                                  ex2:
  1353 0000070D E832FEFFFF                  call find_
  1354 00000712 0F8540FEFFFF                jnz abort
  1355                                      _DROP_
  1356 00000718 AD                  <1>  lodsd
  1357 00000719 FF248D00A84600              jmp dword [ ( ecx * 4 ) + ForthJumpTable ]
  1358                                  
  1359                                  ; *****************************************************************************
  1360                                  ; *****************************************************************************
  1361                                  
  1362                                  qcompile:
  1363 00000720 FF15[C4390000]              call [ lit ]
  1364 00000726 8B04BDFCFFFFFF              mov _TOS_, [ ( edi * 4 ) - 0x04 ]
  1365 0000072D 83E0F0                      and _TOS_, byte -0x10
  1366 00000730 E8FFFDFFFF                  call mfind
  1367 00000735 7508                        jnz .forward
  1368                                      _DROP_
  1369 00000737 AD                  <1>  lodsd
  1370 00000738 FF248D00F84600              jmp dword [ ( ecx * 4 ) + MacroJumpTable ]
  1371                                  .forward:
  1372 0000073F E800FEFFFF                  call find_
  1373 00000744 8B048D00A84600              mov _TOS_, [ ( ecx * 4 ) + ForthJumpTable ]
  1374                                  
  1375                                  qcom1:
  1376 0000074B 0F8507FEFFFF                jnz abort
  1377                                  call_:
  1378 00000751 8B15[D8390000]              mov edx, [ v_H ]
  1379 00000757 8915[E4390000]              mov [ list ], edx
  1380 0000075D C602E8                      mov byte [edx], 0xE8        ; 0xE8 is the opcode for 'call immediate'
  1381 00000760 83C205                      add edx, byte 0x05
  1382 00000763 29D0                        sub _TOS_, edx
  1383 00000765 8942FC                      mov [ edx - 0x04 ], _TOS_
  1384 00000768 8915[D8390000]              mov [ v_H ], edx
  1385                                      _DROP_
  1386 0000076E AD                  <1>  lodsd
  1387 0000076F C3                       ret
  1388                                  
  1389                                  ; *****************************************************************************
  1390                                  ; *****************************************************************************
  1391                                  
  1392                                  compile:
  1393 00000770 FF15[C4390000]              call [ lit]
  1394 00000776 8B04BDFCFFFFFF              mov _TOS_, [ ( edi * 4 ) - 0x04 ]
  1395 0000077D 83E0F0                      and _TOS_, byte -0x10
  1396 00000780 E8AFFDFFFF                  call mfind
  1397 00000785 8B048D00F84600              mov _TOS_, [ ( ecx * 4 ) + MacroJumpTable ]
  1398 0000078C EBBD                        jmp short qcom1
  1399                                  
  1400                                  ; *****************************************************************************
  1401                                  ; *****************************************************************************
  1402                                  
  1403                                  short_:
  1404 0000078E C705[C4390000]-             mov dword [ lit], alit
  1405 00000794 [8B060000]         
  1406                                      _DUP_
  1407 00000798 83EE04              <1>  sub esi, byte 0x04
  1408 0000079B 8906                <1>  mov [ esi ], _TOS_
  1409 0000079D 8B04BDFCFFFFFF              mov _TOS_, [ ( edi * 4 ) - 0x04 ]
  1410 000007A4 C1F805                      sar _TOS_, 0x05
  1411 000007A7 C3                          ret
  1412                                  
  1413                                  ; *****************************************************************************
  1414                                  ; *****************************************************************************
  1415                                  
  1416                                  num:
  1417 000007A8 C705[C4390000]-             mov dword [ lit], alit
  1418 000007AE [8B060000]         
  1419                                      _DUP_
  1420 000007B2 83EE04              <1>  sub esi, byte 0x04
  1421 000007B5 8906                <1>  mov [ esi ], _TOS_
  1422 000007B7 8B04BD00000000              mov _TOS_, [ ( edi * 4 ) + 0x00 ]
  1423 000007BE 47                          inc edi
  1424 000007BF C3                          ret
  1425                                  
  1426                                  ; *****************************************************************************
  1427                                  ; *****************************************************************************
  1428                                  
  1429                                  comma_:          ; 4 byte  ,
  1430 000007C0 B904000000                  mov ecx, 0x04
  1431                                  dcomma:     ; c,  performed n times ( n in ecx )
  1432 000007C5 8B15[D8390000]              mov edx, [ v_H ]
  1433 000007CB 8902                        mov [edx], _TOS_
  1434 000007CD 8B06                        mov _TOS_, [ esi ]
  1435 000007CF 8D1411                      lea edx, [ ecx + edx ]
  1436 000007D2 8D7604                      lea esi, [ esi + 0x04 ]
  1437 000007D5 8915[D8390000]              mov [ v_H ], edx
  1438 000007DB C3                          ret
  1439                                  
  1440                                  comma1_:     ; 1 byte  c,
  1441 000007DC B901000000                  mov ecx, 0x01
  1442 000007E1 EBE2                        jmp short dcomma
  1443                                  
  1444                                  comma2_:     ; 2 byte  w,
  1445 000007E3 B902000000                  mov ecx, 0x02
  1446 000007E8 EBDB                        jmp short dcomma
  1447                                  
  1448                                  comma3_:     ; 3 byte  c, c, c,
  1449 000007EA B903000000                  mov ecx, 0x03
  1450 000007EF EBD4                        jmp short dcomma
  1451                                  
  1452                                  ; *****************************************************************************
  1453                                  ; *****************************************************************************
  1454                                  
  1455                                  semicolon:
  1456 000007F1 8B15[D8390000]              mov edx, [ v_H ]
  1457 000007F7 83EA05                      sub edx, byte 0x05
  1458 000007FA 3915[E4390000]              cmp [ list ], edx
  1459 00000800 7508                        jnz .forward
  1460 00000802 803AE8                      cmp byte [edx], 0xE8            ; 0xE8 is the opcode for 'call immediate'
  1461 00000805 7503                        jnz .forward
  1462 00000807 FE02                        inc byte [edx]
  1463 00000809 C3                          ret
  1464                                  .forward:
  1465 0000080A C64205C3                    mov byte [ edx + 0x05 ], 0xC3   ; 0xC3 is the opcode for 'ret'
  1466 0000080E FF05[D8390000]              inc dword [ v_H ]
  1467 00000814 C3                          ret
  1468                                  
  1469                                  ; *****************************************************************************
  1470                                  ; *****************************************************************************
  1471                                  
  1472                                  then:
  1473 00000815 8925[E4390000]              mov [ list ], esp
  1474 0000081B 8B15[D8390000]              mov edx, [ v_H ]
  1475 00000821 29C2                        sub edx, _TOS_
  1476 00000823 8850FF                      mov [ _TOS_ - 0x01 ], dl
  1477                                      _DROP_
  1478 00000826 AD                  <1>  lodsd
  1479 00000827 C3                          ret
  1480                                  
  1481                                  begin_:
  1482 00000828 8925[E4390000]              mov [ list ], esp
  1483                                  here:
  1484                                      _DUP_
  1485 0000082E 83EE04              <1>  sub esi, byte 0x04
  1486 00000831 8906                <1>  mov [ esi ], _TOS_
  1487 00000833 A1[D8390000]                mov _TOS_, [v_H]
  1488 00000838 C3                          ret
  1489                                  
  1490                                  ; *****************************************************************************
  1491                                  ; *****************************************************************************
  1492                                  
  1493                                  qlit:  ; ?lit
  1494 00000839 8B15[D8390000]              mov edx, [ v_H ]
  1495 0000083F 8D52FB                      lea edx, [ edx - 0x05 ]
  1496 00000842 3915[E4390000]              cmp [ list ], edx
  1497 00000848 7533                        jnz .forward
  1498 0000084A 803AB8                      cmp byte [edx], _MOV_TOS_LIT_   ; the opcode for mov eax, 32_bit_literal  (in next 32 bit cell)
  1499 0000084D 752E                        jnz .forward
  1500                                      _DUP_
  1501 0000084F 83EE04              <1>  sub esi, byte 0x04
  1502 00000852 8906                <1>  mov [ esi ], _TOS_
  1503 00000854 A1[E8390000]                mov _TOS_, [ list + 4 ]
  1504 00000859 A3[E4390000]                mov [ list ], _TOS_
  1505 0000085E 8B4201                      mov _TOS_, [ edx + 0x01 ]
  1506 00000861 817AFB8D76FC89              cmp dword [ edx - 5 ], 0x89FC768D   ; assemble code 8D 76 FC 89 rr => lea esi, [ esi - 0x04 ] ;  mov [ esi ], register
  1507                                      ; like dup but with the register value still to follow in the next byte
  1508 00000868 740B                        jz .forward2
  1509 0000086A 8915[D8390000]              mov [ v_H ], edx
  1510 00000870 E9E9FCFFFF                  jmp dword cdrop
  1511                                  .forward2:
  1512 00000875 8305[D8390000]F6            add dword [ v_H ], byte -0x0A
  1513 0000087C C3                          ret
  1514                                  .forward:
  1515 0000087D 31D2                        xor edx, edx
  1516 0000087F C3                          ret
  1517                                  
  1518                                  less:
  1519 00000880 3906                        cmp [ esi ], _TOS_
  1520 00000882 7802                        js .forward
  1521 00000884 31C9                        xor ecx, ecx
  1522                                  .forward:
  1523 00000886 C3                          ret
  1524                                  
  1525                                  qignore:
  1526 00000887 F704BDFCFFFFFFF0FF-         test dword [ ( edi * 4 ) - 0x04 ], 0xFFFFFFF0
  1527 00000890 FFFF               
  1528 00000892 7502                        jnz .forward
  1529 00000894 5F                          pop edi
  1530 00000895 5F                          pop edi
  1531                                  .forward:
  1532 00000896 C3                          ret
  1533                                  
  1534                                  jump:
  1535 00000897 5A                          pop edx
  1536 00000898 01C2                        add edx, _TOS_
  1537 0000089A 8D548205                    lea edx, [ edx + ( _TOS_ * 4 ) + 0x05 ]
  1538 0000089E 0352FC                      add edx, [ edx - 0x04 ]
  1539                                      _DROP_
  1540 000008A1 AD                  <1>  lodsd
  1541 000008A2 FFE2                        jmp edx
  1542                                  
  1543                                  ; convert block start address to cell address, add the RELOCATED colorForth system base
  1544                                  blockToCellAddress:  ; ( blk -- a' )   \ add the RELOCATED offset and convert to cell address
  1545 000008A4 0305[60390000]              add _TOS_, [ v_offset ]   ; add the RELOCATED block number offset
  1546 000008AA C1E008                      shl _TOS_, 0x08           ; convert to cell address
  1547 000008AD C3                          ret
  1548                                  
  1549                                  cellAddressToBlock:   ; ( a -- blk )  \ convert cell address to block number and subtract the RELOCATED block number offset
  1550 000008AE C1E808                      shr _TOS_, 0x08           ;  convert cell address to block number
  1551 000008B1 2B05[60390000]              sub _TOS_, [ v_offset ]   ; subtract the block number of block 0
  1552 000008B7 C3                          ret
  1553                                  
  1554                                  _load_:   ; ( blk -- )    \ load the given block number
  1555 000008B8 E8E7FFFFFF                  call blockToCellAddress   ; add the RELOCATED block number offset and convert to cell address
  1556 000008BD 57                          push edi
  1557 000008BE 89C7                        mov edi, _TOS_
  1558                                      _DROP_
  1559 000008C0 AD                  <1>  lodsd
  1560                                  interpret:
  1561 000008C1 8B14BD00000000              mov edx, [ ( edi * 4 ) + 0x00 ]
  1562 000008C8 47                          inc edi
  1563 000008C9 83E20F                      and edx, byte 0x0F
  1564 000008CC FF1495[F4390000]            call [ ( edx * 4 ) + tokenActions ]
  1565 000008D3 EBEC                        jmp short interpret
  1566                                  
  1567 000008D5 00<rept>                    align 4, db 0   ; fill the gap with 0's
  1568                                  
  1569                                  ; : r@ qdup $8B 1, $C7 1, ;    \ mov _TOS_, edi  also db 0x89, 0xF8
  1570                                  ; : nload r@ $0100 / #2 + load ;
  1571                                  ; : +load ( n -- ) r@ $0100 / + load ;
  1572                                  nload:  ; ( -- )    \ load the next source block following the one currently being loaded
  1573 000008D8 E867000000                  call cblk_
  1574 000008DD 0502000000                  add _TOS_, 0x02
  1575 000008E2 E9D1FFFFFF                  jmp _load_
  1576                                  
  1577                                  plusLoad:   ; ( n -- )    \ load the n'th source block following the one currently being loaded
  1578 000008E7 89C3                        mov _SCRATCH_, _TOS_    ; save the required offset
  1579                                      _DROP_
  1580 000008E9 AD                  <1>  lodsd
  1581 000008EA E855000000                  call cblk_
  1582 000008EF 01D8                        add _TOS_, _SCRATCH_
  1583 000008F1 E9C2FFFFFF                  jmp _load_
  1584                                  
  1585                                  ; : THRU ( f l -- )   1+ SWAP DO  I LOAD  LOOP ;
  1586                                  thru_:  ; ( first last -- )   \ load from the first to the last block
  1587 000008F6 0502000000                  add _TOS_, 0x02
  1588 000008FB 89C3                        mov _SCRATCH_, _TOS_
  1589                                      _DROP_                          ; TOS = first, SCRATCH = last
  1590 000008FD AD                  <1>  lodsd
  1591 000008FE 89D9                        mov ecx, _SCRATCH_
  1592 00000900 29C1                        sub ecx, _TOS_                  ; ecx = count
  1593 00000902 741F                        jz .end                         ; exit if count is zero
  1594 00000904 721D                        jc .end                         ; exit if count is negative
  1595 00000906 D1E9                        shr ecx, 1                      ; divide by 2, as we skip 2 blocks each time round the loop
  1596                                  .back:
  1597                                      _DUP_
  1598 00000908 83EE04              <1>  sub esi, byte 0x04
  1599 0000090B 8906                <1>  mov [ esi ], _TOS_
  1600                                      _DUP_   ; just to be safe...
  1601 0000090D 83EE04              <1>  sub esi, byte 0x04
  1602 00000910 8906                <1>  mov [ esi ], _TOS_
  1603 00000912 51                          push ecx
  1604 00000913 53                          push _SCRATCH_
  1605 00000914 E89FFFFFFF                  call _load_
  1606 00000919 5B                          pop _SCRATCH_
  1607 0000091A 59                          pop ecx
  1608                                      _DROP_  ; just to be safe...
  1609 0000091B AD                  <1>  lodsd
  1610 0000091C 0502000000                  add _TOS_, 0x02
  1611 00000921 E2E5                        loop .back
  1612                                  .end:
  1613                                      _DROP_
  1614 00000923 AD                  <1>  lodsd
  1615 00000924 C3                          ret
  1616                                  
  1617                                  v_temp:
  1618 00000925 00000000                    dd 0
  1619                                  
  1620                                  plusThru_:  ; ( first+ last+ -- )   \ load from the first to the last block relative to the current block being loaded
  1621 00000929 E816000000                  call cblk_
  1622 0000092E A3[25090000]                mov [ v_temp ], _TOS_
  1623                                      _DROP_
  1624 00000933 AD                  <1>  lodsd
  1625 00000934 8B1D[25090000]              mov _SCRATCH_, [ v_temp ]
  1626 0000093A 011E                        add [ esi ], _SCRATCH_          ; add current block to second on stack
  1627 0000093C 01D8                        add _TOS_, _SCRATCH_            ; add current block to top of stack
  1628 0000093E E8B3FFFFFF                  call thru_
  1629 00000943 C3                          ret
  1630                                  
  1631                                  cblk_:   ; ( -- n )  \ return the currently compiling block number - only valid while compiling
  1632                                      _DUP_
  1633 00000944 83EE04              <1>  sub esi, byte 0x04
  1634 00000947 8906                <1>  mov [ esi ], _TOS_
  1635 00000949 89F8                        mov _TOS_, edi            ; edi  contains the cell address in the block currently being compiled
  1636 0000094B E85EFFFFFF                  call cellAddressToBlock   ; convert to block number relative to block 0
  1637 00000950 C3                          ret
  1638                                  
  1639                                  rblk_:   ; ( -- n )  \ return the block number offset of the RELOCATED address
  1640                                      _DUP_
  1641 00000951 83EE04              <1>  sub esi, byte 0x04
  1642 00000954 8906                <1>  mov [ esi ], _TOS_
  1643 00000956 B840000000                  mov _TOS_, ( RELOCATED >> ( 2 + 8 ) )
  1644 0000095B C3                          ret
  1645                                  
  1646                                  ablk_:   ; ( a -- n )  \ convert byte address to block number
  1647 0000095C C1E802                      shr _TOS_, 0x02
  1648 0000095F E84AFFFFFF                  call cellAddressToBlock
  1649 00000964 C3                          ret
  1650                                  
  1651                                  erase_:   ; ( a n -- )  \ erase n bytes starting at address a
  1652 00000965 89C1                        mov ecx, eax
  1653                                      _DROP_
  1654 00000967 AD                  <1>  lodsd
  1655 00000968 57                          push edi
  1656 00000969 89C7                        mov edi, eax
  1657 0000096B 31C0                        xor eax, eax
  1658 0000096D F3AA                        rep stosb
  1659 0000096F 5F                          pop edi
  1660                                      _DROP_
  1661 00000970 AD                  <1>  lodsd
  1662 00000971 C3                          ret
  1663                                  
  1664                                  v_curs_to_source:   ; ( n -- a32 )   \ return the cell address of the current cursor position in the current block being edited
  1665 00000972 89C3                        mov _SCRATCH_, _TOS_
  1666 00000974 A1[10390000]                mov _TOS_, [ v_blk ]            ; get the currently edited block number
  1667 00000979 E826FFFFFF                  call blockToCellAddress
  1668 0000097E 01D8                        add _TOS_, _SCRATCH_            ; add the cursor position (cell address) in the block
  1669 00000980 C3                          ret
  1670                                  
  1671                                  nth_to_token:   ; ( n -- tok )   \ return the token at the n'th cursor position in the current block being edited
  1672 00000981 E8ECFFFFFF                  call v_curs_to_source
  1673 00000986 C1E002                      shl _TOS_, 0x02                 ; convert cell address to byte address
  1674 00000989 8B00                        mov _TOS_, [ _TOS_ ]            ; fetch the token
  1675 0000098B C3                          ret
  1676                                  
  1677                                  v_curs_to_token:   ; ( -- tok )   \ return the token at the current cursor position in the current block being edited
  1678                                      _DUP_
  1679 0000098C 83EE04              <1>  sub esi, byte 0x04
  1680 0000098F 8906                <1>  mov [ esi ], _TOS_
  1681 00000991 A1[10390000]                mov _TOS_, [ v_blk ]            ; get the currently edited block number
  1682 00000996 E8E6FFFFFF                  call nth_to_token
  1683 0000099B C3                          ret
  1684                                  
  1685                                  ; : ?f $C021 2, ;
  1686                                  ;qf:
  1687                                  ;    db 0x21, 0xC0   ; and _TOS_, _TOS_
  1688                                  ;    ret
  1689                                  
  1690                                  ; *****************************************************************************
  1691                                  ; *****************************************************************************
  1692                                  
  1693                                  top_:   ; ( -- )   \ set the cursor to the left margin horizontally and 3 pixels down from the top vertically
  1694 0000099C 8B0D[383A0000]              mov ecx, [ v_leftMargin ]
  1695 000009A2 C1E110                      shl ecx, 0x10
  1696 000009A5 83C103                      add ecx, byte 0x03
  1697 000009A8 890D[343A0000]              mov [ v_xy ], ecx
  1698                                      ; mov [ xycr], ecx
  1699 000009AE C3                          ret
  1700                                  
  1701                                  qcr: ; ( -- )   \ ?cr  do a  CR  if the cursor has gone past the right margin
  1702 000009AF 668B0D[363A0000]            mov cx, [ v_x ]
  1703 000009B6 663B0D[3C3A0000]            cmp cx, [ v_rightMargin ]
  1704 000009BD 781D                        js cr_forward
  1705                                  cr_:  ; ( -- )
  1706 000009BF 8B0D[383A0000]              mov ecx, [ v_leftMargin ]
  1707 000009C5 C1E110                      shl ecx, 0x10
  1708 000009C8 668B0D[343A0000]            mov cx, [ v_xy ]
  1709 000009CF 66030D[6C390000]            add cx, [ v_iconh ]
  1710 000009D6 890D[343A0000]              mov [ v_xy ], ecx
  1711                                  cr_forward:
  1712 000009DC C3                          ret
  1713                                  
  1714                                  green:  ; ( -- )
  1715                                      _DUP_
  1716 000009DD 83EE04              <1>  sub esi, byte 0x04
  1717 000009E0 8906                <1>  mov [ esi ], _TOS_
  1718 000009E2 B800060000                  mov _TOS_, colour_green
  1719 000009E7 E928000000                  jmp color
  1720                                  
  1721                                  yellow:  ; ( -- )
  1722                                      _DUP_
  1723 000009EC 83EE04              <1>  sub esi, byte 0x04
  1724 000009EF 8906                <1>  mov [ esi ], _TOS_
  1725 000009F1 B8E0FF0000                  mov _TOS_, colour_yellow
  1726 000009F6 E919000000                  jmp color
  1727                                  
  1728                                  taupe:  ; ( -- )
  1729                                      _DUP_
  1730 000009FB 83EE04              <1>  sub esi, byte 0x04
  1731 000009FE 8906                <1>  mov [ esi ], _TOS_
  1732 00000A00 B8E7B20000                  mov _TOS_, colour_taupe
  1733 00000A05 E90A000000                  jmp color
  1734                                  
  1735                                  ; red:  ; ( -- )    ; see redWord:
  1736                                  ;    _DUP_
  1737                                  ;    mov _TOS_, colour_red
  1738                                  ;    jmp color
  1739                                  
  1740                                  white:  ; ( -- )
  1741                                      _DUP_
  1742 00000A0A 83EE04              <1>  sub esi, byte 0x04
  1743 00000A0D 8906                <1>  mov [ esi ], _TOS_
  1744 00000A0F B8FFFF0000                  mov _TOS_, colour_white
  1745                                  color:  ; ( rgb16 -- )
  1746 00000A14 A3[483A0000]                mov [ v_foregroundColour ], _TOS_
  1747                                      _DROP_
  1748 00000A19 AD                  <1>  lodsd
  1749 00000A1A C3                          ret
  1750                                  
  1751                                  rgb:    ; ( rgb32 -- rgb16 )    ; convert from 32 bit ( 8:8:8:8 _RGB ) colour to 16 bit ( 5:6:5 RGB ) colour value
  1752 00000A1B C1C808                      ror _TOS_, 8
  1753 00000A1E 66C1E802                    shr ax, 2
  1754 00000A22 C1C806                      ror _TOS_, 6
  1755 00000A25 C0E803                      shr al, 3
  1756 00000A28 C1C00B                      rol _TOS_, ( 6 + 5 )
  1757 00000A2B 25FFFF0000                  and _TOS_, 0x0000FFFF
  1758 00000A30 C3                          ret
  1759                                  
  1760                                  bye_:  ; ( -- )   \ exit colorForth
  1761 00000A31 E8E0F8FFFF                  call setRealModeAPI
  1762                                  [BITS 16]                           ; Real Mode code (16 bit)
  1763 00000A36 CD19                        int 0x19    ; reboot the computer
  1764                                      ; should never get past this point.... but in case we do...
  1765 00000A38 FA                          cli                             ; BIOS might have left interrupts enabled
  1766 00000A39 E8B1F8                      call setProtectedModeAPI        ; called from 16 bit code, returns to 32 bit code
  1767                                  [BITS 32]                           ; Protected Mode code (32 bit)
  1768 00000A3C C3                          ret
  1769                                  
  1770                                  %if 0
  1771                                  pci:
  1772                                      mov edx, 0x0CF8
  1773                                      out dx, _TOS_
  1774                                      lea edx, [ edx + 0x04 ]
  1775                                      in _TOS_, dx
  1776                                      ret
  1777                                  
  1778                                  device:
  1779                                      times ( 0x93a - ( $ - $$ ) ) nop  ; fill with nops to find_display ???
  1780                                  
  1781                                  find_display:                       ; called by warm
  1782                                      mov _TOS_, 0x3000000            ; PCI class code 3 = display controller
  1783                                      call device                     ; returns header address
  1784                                      lea _TOS_, [ _TOS_ + 0x10 ]     ; point to Base Address #0 (BAR0)
  1785                                      mov cl, 0x06
  1786                                  .next:
  1787                                      _DUP_
  1788                                      call pci
  1789                                      and al, 0xFB
  1790                                      xor al, 0x08
  1791                                      jz .forward
  1792                                      _DROP_
  1793                                      lea _TOS_, [ _TOS_ + 0x04 ]
  1794                                      loop .next
  1795                                      lea _TOS_, [ _TOS_ - 0x18 ]
  1796                                      _DUP_
  1797                                      call pci
  1798                                      and al, 0xF0
  1799                                  .forward:
  1800                                      mov [ v_frameBuffer ], _TOS_     ; set framebuffer address
  1801                                      _DROP_
  1802                                      ret
  1803                                  
  1804                                  fifo:
  1805                                      _DROP_
  1806                                      ret
  1807                                  
  1808                                  %endif
  1809                                  
  1810                                  graphAction:
  1811 00000A3D C3                          ret
  1812                                  
  1813                                  ; *****************************************************************************
  1814                                  ; *****************************************************************************
  1815                                  ; grapics mode dependent code
  1816                                  ; *****************************************************************************
  1817                                  ; *****************************************************************************
  1818                                  
  1819                                  ; *****************************************************************************
  1820                                  ; 1024x768 display
  1821                                  ; *****************************************************************************
  1822                                  
  1823                                  scrnw1 equ 1024              ; screen width in pixels
  1824                                  scrnh1 equ 768               ; screen height in pixels
  1825                                  iconw1 equ ( 16 + 4 )        ; icon width
  1826                                  iconh1 equ ( 24 + 4 )        ; icon height for 768 pixel high screen
  1827                                  
  1828                                  keypadY1 equ 4               ; location of keyboard display vertically in lines from the bottom
  1829                                  
  1830                                  initIconSize1:
  1831 00000A3E C705[68390000]1400-         mov dword [ v_iconw ], iconw1
  1832 00000A46 0000               
  1833 00000A48 C705[74390000]B400-         mov dword [ v_nine_iconw ], ( iconw1 * 9 )
  1834 00000A50 0000               
  1835 00000A52 C705[78390000]B801-         mov dword [ v_twentytwo_iconw ], ( iconw1 * ( 13 + 9 ) )
  1836 00000A5A 0000               
  1837 00000A5C C705[7C390000]0000-         mov dword [ v_10000_iconw ], ( iconw1 * 0x10000 )
  1838 00000A64 1400               
  1839 00000A66 C705[6C390000]1C00-         mov dword [ v_iconh ], iconh1
  1840 00000A6E 0000               
  1841 00000A70 C705[70390000]7000-         mov dword [ v_keypadY_iconh ], keypadY1 * iconh1
  1842 00000A78 0000               
  1843 00000A7A C3                          ret
  1844                                  
  1845                                  switch1:     ; copy our created image to the real display buffer
  1846 00000A7B 56                          push esi
  1847 00000A7C 57                          push edi
  1848 00000A7D 8B35[443A0000]              mov  esi, dword [ vframe ]   ; vframe  points to where we create our image
  1849 00000A83 8B3D28180000                mov  edi, [ vesa_PhysBasePtr ]    ; VESA frame buffer, saved by VESA BIOS call, the address in RAM that is displayed by the hardware
  1850 00000A89 B900000600                  mov  ecx, ( ( scrnw1 * scrnh1 ) / 4 ) * BYTES_PER_PIXEL   ; the / 4 is because we are moving doubles = 4 bytes each
  1851 00000A8E F3A5                        rep  movsd                  ; copy ecx 32 bit words from ds:esi to es:edi
  1852 00000A90 5F                          pop  edi
  1853 00000A91 5E                          pop  esi
  1854 00000A92 C3                          ret
  1855                                  
  1856                                  clip1:
  1857 00000A93 8B3D[343A0000]              mov  edi, [ v_xy ]
  1858 00000A99 89F9                        mov  ecx, edi
  1859 00000A9B 6685C9                      test cx, cx
  1860 00000A9E 7902                        jns  .forward
  1861 00000AA0 31C9                        xor  ecx, ecx
  1862                                  .forward:
  1863 00000AA2 81E1FFFF0000                and  ecx, 0x0000FFFF
  1864 00000AA8 890D[503A0000]              mov  [ v_yc ], ecx
  1865 00000AAE 69C900080000                imul ecx, ( scrnw1 * BYTES_PER_PIXEL )
  1866 00000AB4 C1FF10                      sar  edi, 16
  1867 00000AB7 7902                        jns  .forward2
  1868 00000AB9 31FF                        xor  edi, edi
  1869                                  .forward2:
  1870 00000ABB 893D[4C3A0000]              mov  [ v_xc ], edi
  1871 00000AC1 8D3C79                      lea  edi, [ edi * BYTES_PER_PIXEL + ecx ]
  1872 00000AC4 033D[443A0000]              add  edi, [ vframe ]
  1873 00000ACA C3                          ret
  1874                                  
  1875                                  bit16:                    ; write a 16 x 24 glyph to the graphic screen
  1876 00000ACB 66AD                        lodsw                 ; load the 16 bit value pointed to by SI into  ax
  1877 00000ACD 86C4                        xchg al, ah             ; eax_TOS_
  1878                                  .back:
  1879 00000ACF 66D1E0                      shl ax, 0x01            ; eax_TOS_
  1880 00000AD2 7308                        jnc  .forward
  1881 00000AD4 668917                      mov  [ edi ], dx        ;
  1882 00000AD7 E906000000                  jmp .forward2
  1883                                  .forward:
  1884 00000ADC C1CA10                      ror edx, 0x10           ; use the background colour, in the high 16 bits
  1885                                  ;    mov [ edi ], dx        ;
  1886 00000ADF C1CA10                      ror edx, 0x10           ; return to the foreground colour, in the low 16 bits
  1887                                  .forward2:
  1888 00000AE2 83C702                      add edi, byte BYTES_PER_PIXEL
  1889 00000AE5 E2E8                        loop .back
  1890 00000AE7 C3                          ret
  1891                                  
  1892                                  ; write the background after the glyph
  1893                                  bit16Background:          ; number of pixels to write in  ecx ,  screen address in  edi , colours in edx
  1894 00000AE8 C1CA10                      ror edx, 0x10           ; use the background colour, in the high 16 bits
  1895                                  .back:
  1896                                  ;    mov [ edi ], dx        ;
  1897 00000AEB 83C702                      add edi, byte BYTES_PER_PIXEL
  1898 00000AEE E2FB                        loop .back
  1899 00000AF0 C1CA10                      ror edx, 0x10           ; return to the foreground colour, in the low 16 bits
  1900 00000AF3 C3                          ret
  1901                                  
  1902                                  bit32:                          ; write a 32 x 48 double size glyph to the graphic screen
  1903 00000AF4 66AD                        lodsw                   ; load the 16 bit value pointed to by SI into  ax
  1904 00000AF6 86C4                        xchg al, ah             ; eax_TOS_
  1905 00000AF8 B910000000                  mov ecx, 0x10
  1906                                  .back:
  1907 00000AFD D1E0                        shl  _TOS_, 1           ; eax_TOS_
  1908 00000AFF 7331                        jnc  .forward
  1909 00000B01 668917                      mov  [ edi ], dx
  1910 00000B04 66895702                    mov  [ edi + BYTES_PER_PIXEL ], dx
  1911                                  
  1912 00000B08 803D[450E0000]00            cmp byte [ displayMode ], 0
  1913 00000B0F 7513                        jnz .width2
  1914 00000B11 66899700080000              mov  [ edi + ( scrnw1 * BYTES_PER_PIXEL ) ], dx
  1915 00000B18 66899702080000              mov  [ edi + ( scrnw1 * BYTES_PER_PIXEL ) + BYTES_PER_PIXEL ], dx
  1916 00000B1F E90E000000                  jmp .widthEnd
  1917                                  .width2:
  1918 00000B24 66899740060000              mov  [ edi + ( scrnw2 * BYTES_PER_PIXEL ) ], dx
  1919 00000B2B 66899742060000              mov  [ edi + ( scrnw2 * BYTES_PER_PIXEL ) + BYTES_PER_PIXEL ], dx
  1920                                  .widthEnd:
  1921                                  .forward:
  1922 00000B32 83C704                      add edi, byte ( BYTES_PER_PIXEL * 2 )
  1923 00000B35 E2C6                        loop .back
  1924 00000B37 C3                          ret
  1925                                  
  1926                                  emit1:      ; ( c -- )   \ display a single width and height character
  1927 00000B38 E872FEFFFF                  call qcr
  1928 00000B3D 56                          push esi
  1929 00000B3E 57                          push edi
  1930 00000B3F 52                          push edx
  1931 00000B40 6BC030                      imul _TOS_, byte 16*24/8
  1932 00000B43 8DB0[00680000]              lea esi, [ _TOS_ + font16x24 ]
  1933 00000B49 E845FFFFFF                  call clip1
  1934 00000B4E 8B15[483A0000]              mov edx, [ v_foregroundColour ]
  1935 00000B54 B918000000                  mov ecx, 0x18   ; 24 lines
  1936                                  .back:
  1937 00000B59 51                          push ecx
  1938 00000B5A B910000000                  mov ecx, 0x10
  1939 00000B5F E867FFFFFF                  call bit16
  1940 00000B64 B904000000                  mov ecx, 0x04
  1941 00000B69 57                          push edi
  1942 00000B6A E879FFFFFF                  call bit16Background
  1943 00000B6F 5F                          pop edi
  1944 00000B70 59                          pop ecx
  1945 00000B71 81C7E0070000                add edi, ( scrnw1 - 16 ) * BYTES_PER_PIXEL  ; address of the next line of the glyph
  1946 00000B77 E2E0                        loop .back      ; next horizontal line
  1947                                  
  1948 00000B79 B904000000                  mov ecx, 0x04   ; 4 background lines
  1949                                  .back2:
  1950 00000B7E 51                          push ecx
  1951 00000B7F B910000000                  mov ecx, 0x10
  1952 00000B84 E85FFFFFFF                  call bit16Background
  1953 00000B89 B904000000                  mov ecx, 0x04
  1954 00000B8E 57                          push edi
  1955 00000B8F E854FFFFFF                  call bit16Background
  1956 00000B94 5F                          pop edi
  1957 00000B95 59                          pop ecx
  1958 00000B96 81C7E0070000                add edi, ( scrnw1 - 16 ) * BYTES_PER_PIXEL  ; address of the next line of the glyph
  1959 00000B9C E2E0                        loop .back2      ; next horizontal line
  1960                                  
  1961 00000B9E 5A                          pop edx
  1962 00000B9F 5F                          pop edi
  1963 00000BA0 5E                          pop esi
  1964                                      _DROP_
  1965 00000BA1 AD                  <1>  lodsd
  1966                                  space1:
  1967 00000BA2 8105[343A0000]0000-         add dword [ v_xy ], iconw1 * 0x10000 ; 22 horizontal pixels
  1968 00000BAA 1400               
  1969 00000BAC C3                          ret
  1970                                  
  1971                                  two_emit1:  ; double width and height character
  1972 00000BAD 56                          push esi
  1973 00000BAE 57                          push edi
  1974 00000BAF 52                          push edx
  1975 00000BB0 6BC030                      imul _TOS_, byte 16*24/8
  1976 00000BB3 8DB0[00680000]              lea esi, [ _TOS_ + font16x24 ]
  1977 00000BB9 E8D5FEFFFF                  call clip1
  1978 00000BBE 8B15[483A0000]              mov edx, [ v_foregroundColour ]
  1979 00000BC4 B918000000                  mov ecx, 24
  1980                                  .back:
  1981 00000BC9 51                          push ecx
  1982 00000BCA E825FFFFFF                  call bit32
  1983 00000BCF 81C7C00F0000                add edi, (2*scrnw1-16*2)*BYTES_PER_PIXEL
  1984 00000BD5 59                          pop ecx
  1985 00000BD6 E2F1                        loop .back
  1986 00000BD8 5A                          pop edx
  1987 00000BD9 5F                          pop edi
  1988 00000BDA 5E                          pop esi
  1989 00000BDB 8105[343A0000]0000-         add dword [ v_xy ], iconw1 * 2 * 0x10000 ; 44 horizontal pixels
  1990 00000BE3 2800               
  1991                                      _DROP_
  1992 00000BE5 AD                  <1>  lodsd
  1993 00000BE6 C3                          ret
  1994                                  
  1995                                  setupText__1:   ; setup for full screen text window display
  1996 00000BE7 E81EFEFFFF                  call white
  1997 00000BEC C705[383A0000]0300-         mov dword [ v_leftMargin ], 0x03
  1998 00000BF4 0000               
  1999 00000BF6 C705[3C3A0000]EC03-         mov dword [ v_rightMargin ], ( scrnw1 - iconw1 )
  2000 00000BFE 0000               
  2001 00000C00 E997FDFFFF                  jmp dword top_
  2002                                  
  2003                                  box1: ; ( width height -- )
  2004 00000C05 E889FEFFFF                  call clip1
  2005 00000C0A 3D01030000                  cmp _TOS_, scrnh1+1
  2006 00000C0F 7805                        js .forward
  2007 00000C11 B800030000                  mov _TOS_, scrnh1
  2008                                  .forward:
  2009 00000C16 89C1                        mov ecx, _TOS_
  2010 00000C18 2B0D[503A0000]              sub ecx, [ v_yc ]
  2011 00000C1E 7E30                        jng .forward3
  2012 00000C20 813E01040000                cmp dword [esi], scrnw1+1
  2013 00000C26 7806                        js .forward2
  2014 00000C28 C70600040000                mov dword [esi], scrnw1
  2015                                  .forward2:
  2016 00000C2E A1[4C3A0000]                mov _TOS_, [ v_xc ]
  2017 00000C33 2906                        sub [esi], _TOS_
  2018 00000C35 7E19                        jng .forward3
  2019 00000C37 BA00040000                  mov edx, scrnw1
  2020 00000C3C 2B16                        sub edx, [esi]
  2021 00000C3E D1E2                        shl edx, PIXEL_SHIFT
  2022 00000C40 A1[483A0000]                mov _TOS_, [ v_foregroundColour ]
  2023                                  .back:
  2024 00000C45 51                          push ecx
  2025 00000C46 8B0E                        mov ecx, [esi]
  2026 00000C48 F366AB                      rep stosw   ; stosw depends on BYTES_PER_PIXEL, either stosw or stosd
  2027 00000C4B 01D7                        add edi, edx
  2028 00000C4D 59                          pop ecx
  2029 00000C4E E2F5                        loop .back
  2030                                  .forward3:
  2031                                      _DROP_
  2032 00000C50 AD                  <1>  lodsd
  2033                                      _DROP_
  2034 00000C51 AD                  <1>  lodsd
  2035 00000C52 C3                          ret
  2036                                  
  2037                                  wash1:   ; ( colour -- )   \ fill the full screeen with the given colour
  2038 00000C53 E8BCFDFFFF                  call color
  2039                                      _DUP_
  2040 00000C58 83EE04              <1>  sub esi, byte 0x04
  2041 00000C5B 8906                <1>  mov [ esi ], _TOS_
  2042                                  
  2043 00000C5D 31C0                        xor _TOS_, _TOS_     ; x,y = 0,0 top left corner
  2044 00000C5F A3[343A0000]                mov [ v_xy ], _TOS_
  2045                                  
  2046 00000C64 B800040000                  mov _TOS_, scrnw1
  2047                                      _DUP_
  2048 00000C69 83EE04              <1>  sub esi, byte 0x04
  2049 00000C6C 8906                <1>  mov [ esi ], _TOS_
  2050 00000C6E B800030000                  mov _TOS_, scrnh1
  2051 00000C73 E980020000                  jmp dword box_
  2052                                  
  2053                                  ; *****************************************************************************
  2054                                  ; 800x600 screen
  2055                                  ; *****************************************************************************
  2056                                  
  2057                                  scrnw2 equ 800               ; screen width in pixels
  2058                                  scrnh2 equ 600               ; screen height in pixels
  2059                                  iconw2 equ ( 16 + 1 )        ; icon width
  2060                                  iconh2 equ ( 24 - 1 )        ; icon height for NC10 600 pixel high screen
  2061                                  
  2062                                  keypadY2 equ 4               ; location of keyboard display vertically in lines from the bottom
  2063                                  
  2064                                  initIconSize2:
  2065 00000C78 C705[68390000]1100-         mov dword [ v_iconw ], iconw2
  2066 00000C80 0000               
  2067 00000C82 C705[74390000]9900-         mov dword [ v_nine_iconw ], ( iconw2 * 9 )
  2068 00000C8A 0000               
  2069 00000C8C C705[78390000]7601-         mov dword [ v_twentytwo_iconw ], ( iconw2 * ( 13 + 9 ) )
  2070 00000C94 0000               
  2071 00000C96 C705[7C390000]0000-         mov dword [ v_10000_iconw ], ( iconw2 * 0x10000 )
  2072 00000C9E 1100               
  2073 00000CA0 C705[6C390000]1700-         mov dword [ v_iconh ], iconh2
  2074 00000CA8 0000               
  2075 00000CAA C705[70390000]5C00-         mov dword [ v_keypadY_iconh ], keypadY2 * iconh2
  2076 00000CB2 0000               
  2077 00000CB4 C3                          ret
  2078                                  
  2079                                  switch2:     ; copy our created image to the real display buffer
  2080 00000CB5 56                          push esi
  2081 00000CB6 57                          push edi
  2082 00000CB7 8B35[443A0000]              mov  esi, dword [ vframe ]   ; vframe  points to where we create our image
  2083 00000CBD 8B3D28180000                mov  edi, [ vesa_PhysBasePtr ]    ; VESA frame buffer, saved by VESA BIOS call, the address in RAM that is displayed by the hardware
  2084 00000CC3 B980A90300                  mov  ecx, ( ( scrnw2 * scrnh2 ) / 4 ) * BYTES_PER_PIXEL   ; the / 4 is because we are moving doubles = 4 bytes each
  2085 00000CC8 F3A5                        rep  movsd                  ; copy ecx 32 bit words from ds:esi to es:edi
  2086 00000CCA 5F                          pop  edi
  2087 00000CCB 5E                          pop  esi
  2088 00000CCC C3                          ret
  2089                                  
  2090                                  clip2:
  2091 00000CCD 8B3D[343A0000]              mov  edi, [ v_xy ]
  2092 00000CD3 89F9                        mov  ecx, edi
  2093 00000CD5 6685C9                      test cx, cx
  2094 00000CD8 7902                        jns  .forward
  2095 00000CDA 31C9                        xor  ecx, ecx
  2096                                  .forward:
  2097 00000CDC 81E1FFFF0000                and  ecx, 0x0000FFFF
  2098 00000CE2 890D[503A0000]              mov  [ v_yc ], ecx
  2099 00000CE8 69C940060000                imul ecx, ( scrnw2 * BYTES_PER_PIXEL )
  2100 00000CEE C1FF10                      sar  edi, 16
  2101 00000CF1 7902                        jns  .forward2
  2102 00000CF3 31FF                        xor  edi, edi
  2103                                  .forward2:
  2104 00000CF5 893D[4C3A0000]              mov  [ v_xc ], edi
  2105 00000CFB 8D3C79                      lea  edi, [ edi * BYTES_PER_PIXEL + ecx ]
  2106 00000CFE 033D[443A0000]              add  edi, [ vframe ]
  2107 00000D04 C3                          ret
  2108                                  
  2109                                  emit2:      ; ( c -- )   \ display a single width and height character
  2110 00000D05 E8A5FCFFFF                  call qcr
  2111 00000D0A 56                          push esi
  2112 00000D0B 57                          push edi
  2113 00000D0C 52                          push edx
  2114 00000D0D 6BC030                      imul _TOS_, byte 16*24/8
  2115 00000D10 8DB0[00680000]              lea esi, [ _TOS_ + font16x24 ]
  2116 00000D16 E8B2FFFFFF                  call clip2
  2117 00000D1B 8B15[483A0000]              mov edx, [ v_foregroundColour ]
  2118 00000D21 B918000000                  mov ecx, 0x18   ; 24 lines
  2119                                  .back:
  2120 00000D26 51                          push ecx
  2121 00000D27 B910000000                  mov ecx, 0x10
  2122 00000D2C E89AFDFFFF                  call bit16
  2123 00000D31 B904000000                  mov ecx, 0x04
  2124 00000D36 57                          push edi
  2125 00000D37 E8ACFDFFFF                  call bit16Background
  2126 00000D3C 5F                          pop edi
  2127 00000D3D 59                          pop ecx
  2128 00000D3E 81C720060000                add edi, ( scrnw2 - 16 ) * BYTES_PER_PIXEL  ; address of the next line of the glyph
  2129 00000D44 E2E0                        loop .back      ; next horizontal line
  2130                                  
  2131 00000D46 B904000000                  mov ecx, 0x04   ; 4 background lines
  2132                                  .back2:
  2133 00000D4B 51                          push ecx
  2134 00000D4C B910000000                  mov ecx, 0x10
  2135 00000D51 E892FDFFFF                  call bit16Background
  2136 00000D56 B904000000                  mov ecx, 0x04
  2137 00000D5B 57                          push edi
  2138 00000D5C E887FDFFFF                  call bit16Background
  2139 00000D61 5F                          pop edi
  2140 00000D62 59                          pop ecx
  2141 00000D63 81C720060000                add edi, ( scrnw2 - 16 ) * BYTES_PER_PIXEL  ; address of the next line of the glyph
  2142 00000D69 E2E0                        loop .back2      ; next horizontal line
  2143                                  
  2144 00000D6B 5A                          pop edx
  2145 00000D6C 5F                          pop edi
  2146 00000D6D 5E                          pop esi
  2147                                      _DROP_
  2148 00000D6E AD                  <1>  lodsd
  2149                                  space2:
  2150 00000D6F 8105[343A0000]0000-         add dword [ v_xy ], iconw2 * 0x10000 ; 22 horizontal pixels
  2151 00000D77 1100               
  2152 00000D79 C3                          ret
  2153                                  
  2154                                  two_emit2:  ; double width and height character
  2155 00000D7A 56                          push esi
  2156 00000D7B 57                          push edi
  2157 00000D7C 52                          push edx
  2158 00000D7D 6BC030                      imul _TOS_, byte 16*24/8
  2159 00000D80 8DB0[00680000]              lea esi, [ _TOS_ + font16x24 ]
  2160 00000D86 E842FFFFFF                  call clip2
  2161 00000D8B 8B15[483A0000]              mov edx, [ v_foregroundColour ]
  2162 00000D91 B918000000                  mov ecx, 24
  2163                                  .back:
  2164 00000D96 51                          push ecx
  2165 00000D97 E858FDFFFF                  call bit32
  2166 00000D9C 81C7400C0000                add edi, (2*scrnw2-16*2)*BYTES_PER_PIXEL
  2167 00000DA2 59                          pop ecx
  2168 00000DA3 E2F1                        loop .back
  2169 00000DA5 5A                          pop edx
  2170 00000DA6 5F                          pop edi
  2171 00000DA7 5E                          pop esi
  2172 00000DA8 8105[343A0000]0000-         add dword [ v_xy ], iconw2 * 2 * 0x10000 ; 44 horizontal pixels
  2173 00000DB0 2200               
  2174                                      _DROP_
  2175 00000DB2 AD                  <1>  lodsd
  2176 00000DB3 C3                          ret
  2177                                  
  2178                                  setupText__2:   ; setup for full screen text window display
  2179 00000DB4 E851FCFFFF                  call white
  2180 00000DB9 C705[383A0000]0300-         mov dword [ v_leftMargin ], 0x03
  2181 00000DC1 0000               
  2182 00000DC3 C705[3C3A0000]0F03-         mov dword [ v_rightMargin ], ( scrnw2 - iconw2 )
  2183 00000DCB 0000               
  2184 00000DCD E9CAFBFFFF                  jmp dword top_
  2185                                  
  2186                                  box2: ; ( width height -- )
  2187 00000DD2 E8F6FEFFFF                  call clip2
  2188 00000DD7 3D59020000                  cmp _TOS_, scrnh2+1
  2189 00000DDC 7805                        js .forward
  2190 00000DDE B858020000                  mov _TOS_, scrnh2
  2191                                  .forward:
  2192 00000DE3 89C1                        mov ecx, _TOS_
  2193 00000DE5 2B0D[503A0000]              sub ecx, [ v_yc ]
  2194 00000DEB 7E30                        jng .forward3
  2195 00000DED 813E21030000                cmp dword [esi], scrnw2+1
  2196 00000DF3 7806                        js .forward2
  2197 00000DF5 C70620030000                mov dword [esi], scrnw2
  2198                                  .forward2:
  2199 00000DFB A1[4C3A0000]                mov _TOS_, [ v_xc ]
  2200 00000E00 2906                        sub [esi], _TOS_
  2201 00000E02 7E19                        jng .forward3
  2202 00000E04 BA20030000                  mov edx, scrnw2
  2203 00000E09 2B16                        sub edx, [esi]
  2204 00000E0B D1E2                        shl edx, PIXEL_SHIFT
  2205 00000E0D A1[483A0000]                mov _TOS_, [ v_foregroundColour ]
  2206                                  .back:
  2207 00000E12 51                          push ecx
  2208 00000E13 8B0E                        mov ecx, [esi]
  2209 00000E15 F366AB                      rep stosw   ; stosw depends on BYTES_PER_PIXEL, either stosw or stosd
  2210 00000E18 01D7                        add edi, edx
  2211 00000E1A 59                          pop ecx
  2212 00000E1B E2F5                        loop .back
  2213                                  .forward3:
  2214                                      _DROP_
  2215 00000E1D AD                  <1>  lodsd
  2216                                      _DROP_
  2217 00000E1E AD                  <1>  lodsd
  2218 00000E1F C3                          ret
  2219                                  
  2220                                  wash2:    ; ( colour -- )   \ fill the full screeen with the given colour
  2221 00000E20 E8EFFBFFFF                  call color
  2222                                      _DUP_
  2223 00000E25 83EE04              <1>  sub esi, byte 0x04
  2224 00000E28 8906                <1>  mov [ esi ], _TOS_
  2225                                  
  2226 00000E2A 31C0                        xor _TOS_, _TOS_     ; x,y = 0,0 top left corner
  2227 00000E2C A3[343A0000]                mov [ v_xy ], _TOS_
  2228                                  
  2229 00000E31 B820030000                  mov _TOS_, scrnw2
  2230                                      _DUP_
  2231 00000E36 83EE04              <1>  sub esi, byte 0x04
  2232 00000E39 8906                <1>  mov [ esi ], _TOS_
  2233 00000E3B B858020000                  mov _TOS_, scrnh2
  2234 00000E40 E9B3000000                  jmp dword box_
  2235                                  
  2236                                  ; *****************************************************************************
  2237                                  ; select which display mode code to use
  2238                                  ; *****************************************************************************
  2239                                  
  2240                                  displayMode:
  2241 00000E45 01000000                    dd 1    ; 0 = 1024x768x16, 1 = 800x600x16
  2242                                  
  2243                                  initIconSize:
  2244 00000E49 803D[450E0000]00            cmp byte [ displayMode ], 0
  2245 00000E50 0F84E8FBFFFF                jz initIconSize1
  2246 00000E56 E91DFEFFFF                  jmp initIconSize2
  2247                                  
  2248                                  switch:
  2249 00000E5B 803D[450E0000]00            cmp byte [ displayMode ], 0
  2250 00000E62 0F8413FCFFFF                jz switch1
  2251 00000E68 E948FEFFFF                  jmp switch2
  2252                                  
  2253                                  clip:
  2254 00000E6D 803D[450E0000]00            cmp byte [ displayMode ], 0
  2255 00000E74 0F8419FCFFFF                jz clip1
  2256 00000E7A E94EFEFFFF                  jmp clip2
  2257                                  
  2258                                  emit_:
  2259 00000E7F 803D[450E0000]00            cmp byte [ displayMode ], 0
  2260 00000E86 0F84ACFCFFFF                jz emit1
  2261 00000E8C E974FEFFFF                  jmp emit2
  2262                                  
  2263                                  space_:
  2264 00000E91 803D[450E0000]00            cmp byte [ displayMode ], 0
  2265 00000E98 0F8404FDFFFF                jz space1
  2266 00000E9E E9CCFEFFFF                  jmp space2
  2267                                  
  2268                                  two_emit:
  2269 00000EA3 803D[450E0000]00            cmp byte [ displayMode ], 0
  2270 00000EAA 0F84FDFCFFFF                jz two_emit1
  2271 00000EB0 E9C5FEFFFF                  jmp two_emit2
  2272                                  
  2273                                  setupText_:     ; setup for full screen text window display
  2274 00000EB5 803D[450E0000]00            cmp byte [ displayMode ], 0
  2275 00000EBC 0F8425FDFFFF                jz setupText__1
  2276 00000EC2 E9EDFEFFFF                  jmp setupText__2
  2277                                  
  2278                                  line_:  ; ( startX length -- )   \ draw a horizontal line in the current colour, from startX relative to current clip window, of given length in pixels
  2279 00000EC7 803D[450E0000]00            cmp byte [ displayMode ], 0
  2280 00000ECE 750A                        jnz .forward
  2281 00000ED0 E8BEFBFFFF                  call clip1
  2282 00000ED5 E905000000                  jmp .common
  2283                                  .forward:
  2284 00000EDA E8EEFDFFFF                  call clip2
  2285                                  .common:
  2286 00000EDF 8B0E                        mov ecx, [esi]
  2287 00000EE1 D1E1                        shl ecx, PIXEL_SHIFT
  2288 00000EE3 29CF                        sub edi, ecx
  2289 00000EE5 89C1                        mov ecx, _TOS_
  2290 00000EE7 A1[483A0000]                mov _TOS_, [ v_foregroundColour ]
  2291 00000EEC F366AB                      rep stosw   ;
  2292 00000EEF FF05[343A0000]              inc dword [ v_xy ]
  2293                                      _DROP_
  2294 00000EF5 AD                  <1>  lodsd
  2295                                      _DROP_
  2296 00000EF6 AD                  <1>  lodsd
  2297 00000EF7 C3                          ret
  2298                                  
  2299                                  box_:
  2300 00000EF8 803D[450E0000]00            cmp byte [ displayMode ], 0
  2301 00000EFF 0F8400FDFFFF                jz box1
  2302 00000F05 E9C8FEFFFF                  jmp box2
  2303                                  
  2304                                  page_:    ; ( -- )    \ fill the full screen with the current background colour
  2305                                      _DUP_
  2306 00000F0A 83EE04              <1>  sub esi, byte 0x04
  2307 00000F0D 8906                <1>  mov [ esi ], _TOS_
  2308 00000F0F B800000000                  mov _TOS_, colour_background   ;
  2309 00000F14 E90A000000                  jmp wash_
  2310                                  
  2311                                  screen_:    ; ( -- )   \ fill the full screen with the current foreground colour
  2312                                      _DUP_
  2313 00000F19 83EE04              <1>  sub esi, byte 0x04
  2314 00000F1C 8906                <1>  mov [ esi ], _TOS_
  2315 00000F1E A1[483A0000]                mov _TOS_, [ v_foregroundColour ]  ;     ; select the foreground colour in the low 16 bits
  2316                                  ;    jmp wash_                      ; fall through to wash1
  2317                                  
  2318                                  wash_:  ; ( colour -- )   \ fill the full screeen with the given colour
  2319 00000F23 A3[C8390000]                mov [ v_washColour ], _TOS_
  2320 00000F28 803D[450E0000]00            cmp byte [ displayMode ], 0
  2321 00000F2F 0F841EFDFFFF                jz wash1
  2322 00000F35 E9E6FEFFFF                  jmp wash2
  2323                                  
  2324                                  ; *****************************************************************************
  2325                                  ; *****************************************************************************
  2326                                  ; *****************************************************************************
  2327                                  
  2328                                  setCyan:
  2329                                      _DUP_
  2330 00000F3A 83EE04              <1>  sub esi, byte 0x04
  2331 00000F3D 8906                <1>  mov [ esi ], _TOS_
  2332 00000F3F B8FF070000                  mov _TOS_, colour_cyan
  2333 00000F44 E9CBFAFFFF                  jmp dword color
  2334                                  
  2335                                  setMagenta:
  2336                                      _DUP_
  2337 00000F49 83EE04              <1>  sub esi, byte 0x04
  2338 00000F4C 8906                <1>  mov [ esi ], _TOS_
  2339 00000F4E B81FF80000                  mov _TOS_, colour_magenta
  2340 00000F53 E9BCFAFFFF                  jmp dword color
  2341                                  
  2342                                  setMagentaData:
  2343                                      _DUP_
  2344 00000F58 83EE04              <1>  sub esi, byte 0x04
  2345 00000F5B 8906                <1>  mov [ esi ], _TOS_
  2346 00000F5D B810D00000                  mov _TOS_, colour_magentaData
  2347 00000F62 E9ADFAFFFF                  jmp dword color
  2348                                  
  2349                                  setBlue:
  2350                                      _DUP_
  2351 00000F67 83EE04              <1>  sub esi, byte 0x04
  2352 00000F6A 8906                <1>  mov [ esi ], _TOS_
  2353 00000F6C B81F000000                  mov _TOS_, colour_blue
  2354 00000F71 E99EFAFFFF                  jmp dword color
  2355                                  
  2356                                  setRed:
  2357                                      _DUP_
  2358 00000F76 83EE04              <1>  sub esi, byte 0x04
  2359 00000F79 8906                <1>  mov [ esi ], _TOS_
  2360 00000F7B B800F80000                  mov _TOS_, colour_red
  2361 00000F80 E98FFAFFFF                  jmp dword color
  2362                                  
  2363                                  setGreen:
  2364                                      _DUP_
  2365 00000F85 83EE04              <1>  sub esi, byte 0x04
  2366 00000F88 8906                <1>  mov [ esi ], _TOS_
  2367 00000F8A B800060000                  mov _TOS_, colour_green
  2368 00000F8F E980FAFFFF                  jmp dword color
  2369                                  
  2370                                  setSilver:
  2371                                      _DUP_
  2372 00000F94 83EE04              <1>  sub esi, byte 0x04
  2373 00000F97 8906                <1>  mov [ esi ], _TOS_
  2374 00000F99 B818C60000                  mov _TOS_, colour_silver
  2375 00000F9E E971FAFFFF                  jmp dword color
  2376                                  
  2377                                  setTaupe:
  2378                                      _DUP_
  2379 00000FA3 83EE04              <1>  sub esi, byte 0x04
  2380 00000FA6 8906                <1>  mov [ esi ], _TOS_
  2381 00000FA8 B8E7B20000                  mov _TOS_, colour_taupe
  2382 00000FAD E962FAFFFF                  jmp dword color
  2383                                  
  2384                                  setTaupeData:
  2385                                      _DUP_
  2386 00000FB2 83EE04              <1>  sub esi, byte 0x04
  2387 00000FB5 8906                <1>  mov [ esi ], _TOS_
  2388 00000FB7 B8E7B20000                  mov _TOS_, colour_taupeData
  2389 00000FBC E953FAFFFF                  jmp dword color
  2390                                  
  2391                                  
  2392                                  history:
  2393 00000FC1 00<rept>                    times 11 db 0
  2394                                  
  2395                                  echo_:
  2396 00000FCC 56                          push esi
  2397 00000FCD B90A000000                  mov ecx, 11-1
  2398 00000FD2 8D3D[C10F0000]              lea edi, [ history ]
  2399 00000FD8 8D7701                      lea esi, [edi+1]
  2400 00000FDB F3A4                        rep movsb
  2401 00000FDD 5E                          pop esi
  2402 00000FDE A2[CB0F0000]                mov byte [ history+11-1 ], al
  2403                                      _DROP_
  2404 00000FE3 AD                  <1>  lodsd
  2405 00000FE4 C3                          ret
  2406                                  
  2407                                  right:
  2408                                      _DUP_
  2409 00000FE5 83EE04              <1>  sub esi, byte 0x04
  2410 00000FE8 8906                <1>  mov [ esi ], _TOS_
  2411 00000FEA B90B000000                  mov ecx, 11
  2412 00000FEF 8D3D[C10F0000]              lea edi, [history]
  2413 00000FF5 31C0                        xor _TOS_, _TOS_
  2414 00000FF7 F3AA                        rep stosb
  2415                                      _DROP_
  2416 00000FF9 AD                  <1>  lodsd
  2417 00000FFA C3                          ret
  2418                                  
  2419                                  down:
  2420                                      _DUP_
  2421 00000FFB 83EE04              <1>  sub esi, byte 0x04
  2422 00000FFE 8906                <1>  mov [ esi ], _TOS_
  2423 00001000 31D2                        xor edx, edx
  2424 00001002 8B0D[6C390000]              mov ecx, [ v_iconh ]
  2425 00001008 F7F1                        div ecx
  2426 0000100A 89D0                        mov _TOS_, edx
  2427 0000100C 2B15[6C390000]              sub edx, [ v_iconh ]
  2428 00001012 81C203800300                add edx, ( 3 * 0x10000 )+ 0x8000 + 3
  2429 00001018 8915[343A0000]              mov [ v_xy ], edx
  2430                                  ; zero:
  2431 0000101E 85C0                        test _TOS_, _TOS_
  2432 00001020 B800000000                  mov _TOS_, 0
  2433 00001025 7501                        jnz .dw
  2434 00001027 40                          inc _TOS_
  2435                                  .dw:
  2436 00001028 C3                          ret
  2437                                  
  2438                                  lm:     ; ( leftMargin -- )
  2439 00001029 A3[383A0000]                mov [ v_leftMargin ], _TOS_
  2440                                      _DROP_
  2441 0000102E AD                  <1>  lodsd
  2442 0000102F C3                          ret
  2443                                  
  2444                                  rm:     ; ( rightMargin -- )
  2445 00001030 A3[3C3A0000]                mov [ v_rightMargin ], _TOS_
  2446                                      _DROP_
  2447 00001035 AD                  <1>  lodsd
  2448 00001036 C3                          ret
  2449                                  
  2450                                  _at:    ; ( y x -- )
  2451 00001037 66A3[343A0000]              mov word [ v_y ], ax
  2452                                      _DROP_
  2453 0000103D AD                  <1>  lodsd
  2454 0000103E 66A3[363A0000]              mov word [ v_x ], ax
  2455                                      _DROP_
  2456 00001044 AD                  <1>  lodsd
  2457 00001045 C3                          ret
  2458                                  
  2459                                  plus_at:    ; ( y x -- )
  2460 00001046 660105[343A0000]            add word [ v_y ], ax
  2461                                      _DROP_
  2462 0000104D AD                  <1>  lodsd
  2463 0000104E 660105[363A0000]            add word [ v_x ], ax
  2464                                      _DROP_
  2465 00001055 AD                  <1>  lodsd
  2466 00001056 C3                          ret
  2467                                  
  2468                                  
  2469                                  storew_:    ; ( w a -- ) \  ; : !w a! $00028966 3, drop ; 
  2470 00001057 8BD0                        db 0x8B, 0xD0           ; mov edx,eax       a! $D08B 2,   ( ?lit not true )
  2471 00001059 668902                      db 0x66, 0x89, 0x02     ; mov [edx],ax      $00028966 3,
  2472                                      _DROP_                  ; lodsd        
  2473 0000105C AD                  <1>  lodsd
  2474 0000105D C3                          ret                     ; ret          
  2475                                  
  2476                                  
  2477                                  storeu_:    ; ( u a -- ) \  ; : !l a! $0289 2, drop ; forth
  2478 0000105E 8BD0                        db 0x8B, 0xD0           ; mov edx,eax       a! $D08B 2,   ( ?lit not true )
  2479 00001060 8902                        db 0x89, 0x02           ; mov [edx],eax     $0289 2,
  2480                                      _DROP_                  ; lodsd         
  2481 00001062 AD                  <1>  lodsd
  2482 00001063 C3                          ret                     ; ret           
  2483                                  
  2484                                  uplus_: ; ( u u -- u )   \ : u+ ?lit if $0681 2, , ; then $00044601 3, drop ;
  2485 00001064 014604                      db 0x01, 0x46, 0x04     ; add [esi+0x4],eax   $00044601 3,   ( ?lit not true )
  2486                                      _DROP_                  ; lodsd        
  2487 00001067 AD                  <1>  lodsd
  2488 00001068 C3                          ret                     ; ret          
  2489                                  
  2490                                  %if 1
  2491                                  ; the various pieces of code used by a! and +! in colorForth blocks 22 and 24
  2492                                   plusStore:  ; ( n a -- )
  2493                                      ;  : a! ?lit if $BA 1, , ; then $D08B 2, drop ;
  2494 00001069 BA78563412                   mov dword edx, 0x12345678                  ; db 0xBA, 0x78, 0x56, 0x34, 0x12
  2495 0000106E 89C2                         mov edx, _TOS_                               ; db 0x8B, 0xD0 == db 0x89, 0xC2
  2496                                      ;  : +! ?lit if ?lit if $0581 2, swap a, , ; then $0501 2, a, drop ; then a! $0201 2, drop ;
  2497 00001070 010578563412                 add [ dword 0x12345678 ], _TOS_              ; db 0x01, 0x05, 0x78, 0x56, 0x34, 0x12
  2498 00001076 810578563412325476-          add dword [ dword 0x12345678 ], 0x98765432 ; db 0x81, 0x05, 0x78, 0x56, 0x34, 0x12, 0x32, 0x54, 0x76, 0x98
  2499 0000107F 98                 
  2500 00001080 0102                         add [ edx ], _TOS_                           ; db 0x01, 0x02
  2501 00001082 C3                           ret
  2502                                  %endif
  2503                                  
  2504                                  octant:
  2505                                      _DUP_
  2506 00001083 83EE04              <1>  sub esi, byte 0x04
  2507 00001086 8906                <1>  mov [ esi ], _TOS_
  2508 00001088 B843000000                  mov _TOS_, 0x43
  2509 0000108D 8B5604                      mov edx, [ esi + 0x04 ]
  2510 00001090 85D2                        test edx, edx
  2511 00001092 7907                        jns .forward
  2512 00001094 F7DA                        neg edx
  2513 00001096 895604                      mov [ esi + 0x04 ], edx
  2514 00001099 3401                        xor al, 0x01
  2515                                  .forward:
  2516 0000109B 3B16                        cmp edx, [ esi ]
  2517 0000109D 7902                        jns .forward2
  2518 0000109F 3404                        xor al, 0x04
  2519                                  .forward2:
  2520 000010A1 C3                          ret
  2521                                  
  2522                                  hicon:
  2523 000010A2 18191A1B1C1D1E1F            db 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F
  2524 000010AA 202105130A10040E            db 0x20, 0x21, 0x05, 0x13, 0x0A, 0x10, 0x04, 0x0E
  2525                                  
  2526                                  edig1:
  2527                                      _DUP_
  2528 000010B2 83EE04              <1>  sub esi, byte 0x04
  2529 000010B5 8906                <1>  mov [ esi ], _TOS_
  2530                                  digit:
  2531 000010B7 51                          push ecx
  2532 000010B8 8A80[A2100000]              mov al, [ _TOS_ + hicon ]
  2533 000010BE E8BCFDFFFF                  call emit_
  2534 000010C3 59                          pop ecx
  2535 000010C4 C3                          ret
  2536                                  
  2537                                  odig:
  2538 000010C5 C1C004                      rol _TOS_, 0x04
  2539                                      _DUP_
  2540 000010C8 83EE04              <1>  sub esi, byte 0x04
  2541 000010CB 8906                <1>  mov [ esi ], _TOS_
  2542 000010CD 83E00F                      and _TOS_, byte 0x0F
  2543 000010D0 C3                          ret
  2544                                  
  2545                                  h_dot_n:
  2546 000010D1 89C2                        mov edx, _TOS_
  2547 000010D3 F7D8                        neg _TOS_
  2548 000010D5 8D0C8520000000              lea ecx, [ ( _TOS_ * 4 ) + 0x20 ]
  2549                                      _DROP_
  2550 000010DC AD                  <1>  lodsd
  2551 000010DD D3C0                        rol _TOS_, cl
  2552 000010DF 89D1                        mov ecx, edx
  2553 000010E1 EB05                        jmp short h_dot2
  2554                                  
  2555                                  dotHex8: ; ( u -- )   \ display a hexadecimal number with leading zeros, 8 .hex
  2556 000010E3 B908000000                  mov ecx, 0x08
  2557                                  h_dot2:
  2558 000010E8 E8D8FFFFFF                  call odig
  2559 000010ED E8C5FFFFFF                  call digit
  2560 000010F2 E2F4                        loop h_dot2
  2561                                      _DROP_
  2562 000010F4 AD                  <1>  lodsd
  2563 000010F5 C3                          ret
  2564                                  
  2565                                  dotHex:     ; ( u -- )   \ display a hexadecimal number
  2566                                      EMIT_IMM 0x6F ; '$'
  2567                              <1> 
  2568                              <1>  _DUP_
  2569 000010F6 83EE04              <2>  sub esi, byte 0x04
  2570 000010F9 8906                <2>  mov [ esi ], _TOS_
  2571 000010FB B86F000000          <1>  mov _TOS_, %1
  2572 00001100 E87AFDFFFF          <1>  call emit_
  2573                              <1> 
  2574 00001105 B907000000                  mov ecx, 0x07
  2575                                  .back:
  2576 0000110A E8B6FFFFFF                  call odig
  2577 0000110F 7517                        jnz .forward
  2578                                      _DROP_
  2579 00001111 AD                  <1>  lodsd
  2580 00001112 E2F6                        loop .back
  2581 00001114 41                          inc ecx
  2582                                  .back2:
  2583 00001115 E8ABFFFFFF                  call odig
  2584                                  .back3:
  2585 0000111A E898FFFFFF                  call digit
  2586 0000111F E2F4                        loop .back2
  2587 00001121 E86BFDFFFF                  call space_
  2588                                      _DROP_
  2589 00001126 AD                  <1>  lodsd
  2590 00001127 C3                          ret
  2591                                  .forward:
  2592 00001128 41                          inc ecx
  2593 00001129 EBEF                        jmp short .back3
  2594                                  
  2595                                  qdot:   ; ( u -- )   \ display a decimal or hexadecimal number, depending on base
  2596 0000112B 833D[A0390000]0A            cmp dword [ base ], byte 10
  2597 00001132 75C2                        jnz dotHex
  2598                                  dotDecimal:                         ; display a decimal number
  2599                                  ;    EMIT_IMM 0x64 ; '#'
  2600 00001134 89C2                        mov edx, _TOS_
  2601 00001136 85D2                        test edx, edx
  2602 00001138 7911                        jns .forward
  2603 0000113A F7DA                        neg edx                         ; display a negative sign if required
  2604                                      _DUP_
  2605 0000113C 83EE04              <1>  sub esi, byte 0x04
  2606 0000113F 8906                <1>  mov [ esi ], _TOS_
  2607 00001141 B823000000                  mov _TOS_, 0x23 ; '-'
  2608 00001146 E834FDFFFF                  call emit_
  2609                                  .forward:
  2610 0000114B B908000000                  mov ecx, 0x08
  2611                                  .back:
  2612 00001150 89D0                        mov _TOS_, edx
  2613 00001152 31D2                        xor edx, edx
  2614 00001154 F7348D[E8380000]            div dword [ ecx * 4 + tens ]
  2615 0000115B 85C0                        test _TOS_, _TOS_
  2616 0000115D 7510                        jnz .forward2
  2617 0000115F 49                          dec ecx
  2618 00001160 79EE                        jns .back
  2619 00001162 EB13                        jmp short .forward3
  2620                                  .back2:
  2621 00001164 89D0                        mov _TOS_, edx
  2622 00001166 31D2                        xor edx, edx
  2623 00001168 F7348D[E8380000]            div dword [ ecx * 4 + tens ]
  2624                                  .forward2:
  2625 0000116F E83EFFFFFF                  call edig1
  2626 00001174 49                          dec ecx
  2627 00001175 79ED                        jns .back2
  2628                                  .forward3:
  2629 00001177 89D0                        mov _TOS_, edx
  2630 00001179 E834FFFFFF                  call edig1
  2631 0000117E E80EFDFFFF                  call space_
  2632                                      _DROP_
  2633 00001183 AD                  <1>  lodsd
  2634 00001184 C3                          ret
  2635                                  
  2636                                  eight:
  2637 00001185 83C70C                      add edi, byte 0x0C
  2638 00001188 E808000000                  call four
  2639 0000118D E8FFFCFFFF                  call space_
  2640 00001192 83EF10                      sub edi, byte 0x10
  2641                                  four:
  2642 00001195 B904000000                  mov ecx, 0x04
  2643                                  four1:      ; set ecx to the required number of characters to display, so 'four'1 is a misnomer...
  2644 0000119A 51                          push ecx
  2645                                      _DUP_
  2646 0000119B 83EE04              <1>  sub esi, byte 0x04
  2647 0000119E 8906                <1>  mov [ esi ], _TOS_
  2648 000011A0 31C0                        xor _TOS_, _TOS_
  2649 000011A2 8A4704                      mov al, [edi+0x04]
  2650 000011A5 47                          inc edi
  2651 000011A6 E8D4FCFFFF                  call emit_
  2652 000011AB 59                          pop ecx
  2653 000011AC E2EC                        loop four1
  2654 000011AE C3                          ret
  2655                                  
  2656                                  displayTheStack:  ; display the stack
  2657 000011AF BFFC750000                  mov edi, ( DATA_STACK_0 - 4 )   ; save empty stack pointer, plus one ( stack grows downwards )
  2658                                  .back:
  2659 000011B4 8B15[2F040000]              mov edx, [ God ]        ; copy the current stack pointer
  2660 000011BA 393A                        cmp [edx], edi
  2661 000011BC 7311                        jnc .forward            ; test for empty stack, meaning done
  2662                                      _DUP_
  2663 000011BE 83EE04              <1>  sub esi, byte 0x04
  2664 000011C1 8906                <1>  mov [ esi ], _TOS_
  2665 000011C3 8B07                        mov _TOS_, [edi]          ; fetch the value of the current stack item
  2666 000011C5 83EF04                      sub edi, byte 0x04      ;
  2667 000011C8 E85EFFFFFF                  call qdot               ; display one stack item
  2668 000011CD EBE5                        jmp short .back         ; next stack item
  2669                                  .forward:
  2670 000011CF C3                          ret
  2671                                  
  2672                                  yShift equ 3
  2673                                  
  2674                                  displayBlockNumber:    ;  ( -- )     ; in the top right corner of the screen
  2675                                      _DUP_
  2676 000011D0 83EE04              <1>  sub esi, byte 0x04
  2677 000011D3 8906                <1>  mov [ esi ], _TOS_
  2678 000011D5 A1[483A0000]                mov _TOS_, [ v_foregroundColour ]
  2679                                      _DUP_
  2680 000011DA 83EE04              <1>  sub esi, byte 0x04
  2681 000011DD 8906                <1>  mov [ esi ], _TOS_
  2682 000011DF A112180000                  mov _TOS_, [ vesa_XResolution ]   ; was this  : mov _TOS_, ( scrnw )
  2683 000011E4 25FFFF0000                  and _TOS_, 0xFFFF
  2684 000011E9 2B05[74390000]              sub _TOS_, [ v_nine_iconw ]
  2685 000011EF 89C3                        mov _SCRATCH_, _TOS_                ; save for later
  2686 000011F1 A3[383A0000]                mov [ v_leftMargin ], _TOS_
  2687 000011F6 6667A3[343A]                mov [ word v_y ], ax
  2688 000011FB 0305[74390000]              add _TOS_, [ v_nine_iconw ]
  2689 00001201 A3[3C3A0000]                mov [ v_rightMargin ], _TOS_
  2690 00001206 89D8                        mov _TOS_, _SCRATCH_
  2691 00001208 C1E010                      shl _TOS_, 16
  2692 0000120B 0503000000                  add _TOS_, yShift
  2693 00001210 A3[343A0000]                mov [ v_xy ], _TOS_
  2694                                      _DUP_
  2695 00001215 83EE04              <1>  sub esi, byte 0x04
  2696 00001218 8906                <1>  mov [ esi ], _TOS_
  2697 0000121A A1[C8390000]                mov _TOS_, [ v_washColour ]  ; so we do not see the number yet, just measure its width
  2698                                  ;    mov _TOS_, colour_blockNumber
  2699                                  ;    shr _TOS_, 16                 ; select the background colour in the high 16 bits
  2700 0000121F E8F0F7FFFF                  call color
  2701                                      _DUP_
  2702 00001224 83EE04              <1>  sub esi, byte 0x04
  2703 00001227 8906                <1>  mov [ esi ], _TOS_
  2704 00001229 A1[10390000]                mov _TOS_, [ v_blk ]
  2705 0000122E E8F8FEFFFF                  call qdot
  2706 00001233 8B1D[343A0000]              mov _SCRATCH_, [ v_xy ]            ; current x,y coordinate, x in high 16 bits
  2707 00001239 C1EB10                      shr _SCRATCH_, 16
  2708 0000123C 2B1D[383A0000]              sub _SCRATCH_, [ v_leftMargin ]   ; _SCRATCH_ is now the width of number string, in pixels
  2709 00001242 2B1D[68390000]              sub _SCRATCH_, [ v_iconw ]        ; correction...
  2710 00001248 C1E310                      shl _SCRATCH_, 16
  2711 0000124B A112180000                  mov _TOS_, [ vesa_XResolution ]   ; screen width in pixels
  2712                                      ; and _TOS_, 0xFFFF   ; not needed because of the  shl  below
  2713 00001250 C1E010                      shl _TOS_, 16
  2714 00001253 0503000000                  add _TOS_, yShift
  2715 00001258 29D8                        sub _TOS_, _SCRATCH_
  2716 0000125A A3[343A0000]                mov [ v_xy ], _TOS_
  2717                                  
  2718                                      _DUP_
  2719 0000125F 83EE04              <1>  sub esi, byte 0x04
  2720 00001262 8906                <1>  mov [ esi ], _TOS_
  2721 00001264 B800E20000                  mov _TOS_, colour_blockNumber
  2722 00001269 C1C810                      ror _TOS_, 16
  2723 0000126C E8A3F7FFFF                  call color
  2724                                      _DUP_
  2725 00001271 83EE04              <1>  sub esi, byte 0x04
  2726 00001274 8906                <1>  mov [ esi ], _TOS_
  2727 00001276 A1[68390000]                mov _TOS_, [ v_iconw ]
  2728 0000127B 01C0                        add _TOS_, _TOS_
  2729                                      _DUP_
  2730 0000127D 83EE04              <1>  sub esi, byte 0x04
  2731 00001280 8906                <1>  mov [ esi ], _TOS_
  2732 00001282 A1[6C390000]                mov _TOS_, [ v_iconh ]
  2733 00001287 E86CFCFFFF                  call box_
  2734 0000128C A3[343A0000]                mov [ v_xy ], _TOS_
  2735                                  
  2736 00001291 B800E20000                  mov _TOS_, colour_blockNumber
  2737                                      _DUP_
  2738 00001296 83EE04              <1>  sub esi, byte 0x04
  2739 00001299 8906                <1>  mov [ esi ], _TOS_
  2740 0000129B E874F7FFFF                  call color
  2741                                      _DUP_
  2742 000012A0 83EE04              <1>  sub esi, byte 0x04
  2743 000012A3 8906                <1>  mov [ esi ], _TOS_
  2744 000012A5 A1[10390000]                mov _TOS_, [ v_blk ]
  2745                                  ;    mov _TOS_, [ v_numberOfMagentas ]
  2746                                  
  2747 000012AA E87CFEFFFF                  call qdot
  2748                                      _DROP_
  2749 000012AF AD                  <1>  lodsd
  2750 000012B0 A3[483A0000]                mov [ v_foregroundColour ], _TOS_
  2751                                      _DROP_
  2752 000012B5 AD                  <1>  lodsd
  2753 000012B6 C3                      ret
  2754                                  
  2755                                  ; *****************************************************************************
  2756                                  ; keyboard displays
  2757                                  ; *****************************************************************************
  2758                                  
  2759                                  showEditBox:    ; v_at set up for start coordinate of box, width and height on stack
  2760 000012B7 812D[343A0000]0400-         sub dword [ v_xy ], 0x000C0004   ; move the start position left  and up   by 0xXXXXYYYY
  2761 000012BF 0C00               
  2762 000012C1 8B1D[483A0000]              mov dword _SCRATCH_, [ v_foregroundColour ]
  2763 000012C7 C705[483A0000]00E2-         mov dword [ v_foregroundColour ], colour_orange
  2764 000012CF 0000               
  2765 000012D1 B902000000                  mov ecx, 2
  2766                                  .loop:
  2767 000012D6 51                          push ecx
  2768                                      _DUP_
  2769 000012D7 83EE04              <1>  sub esi, byte 0x04
  2770 000012DA 8906                <1>  mov [ esi ], _TOS_
  2771 000012DC B800000000                  mov _TOS_, 0            ; SOS = x start position in pixels, relative to current clip "window"
  2772                                      _DUP_
  2773 000012E1 83EE04              <1>  sub esi, byte 0x04
  2774 000012E4 8906                <1>  mov [ esi ], _TOS_
  2775 000012E6 A1[68390000]                mov _TOS_, [ v_iconw ]
  2776 000012EB C1E003                      shl _TOS_, 3            ; multiply by 8
  2777 000012EE 0305[68390000]              add _TOS_, [ v_iconw ]  ; multiply by 9
  2778 000012F4 0305[68390000]              add _TOS_, [ v_iconw ]  ; multiply by 10
  2779                                      ; TOS = length of horizontal line in pixels
  2780 000012FA E8C8FBFFFF                  call line_
  2781 000012FF 8B0D[6C390000]              mov ecx, [ v_iconh ]
  2782 00001305 C1E102                      shl ecx, 2              ; multiply by 4
  2783 00001308 81C104000000                add ecx, 4              ; draw the lower line below the text
  2784 0000130E 010D[343A0000]              add dword [ v_xy ], ecx ; move the start position down by 4 character heights
  2785 00001314 59                          pop ecx
  2786 00001315 E2BF                        loop .loop
  2787                                  
  2788 00001317 891D[483A0000]              mov dword [ v_foregroundColour ], _SCRATCH_
  2789 0000131D C3                          ret
  2790                                  
  2791                                  displayTheKeyboard:   ; the keyboard is the mnemonic at the bottom right of the display, showing the actions of each of the 27 keys used
  2792 0000131E E892FBFFFF                  call setupText_
  2793 00001323 8B3D[98390000]              mov edi, [ dword currentKeyboardIcons ]
  2794                                      _DUP_
  2795 00001329 83EE04              <1>  sub esi, byte 0x04
  2796 0000132C 8906                <1>  mov [ esi ], _TOS_
  2797 0000132E A1[A8390000]                mov _TOS_, [ keyboard_colour ]
  2798 00001333 E8DCF6FFFF                  call color
  2799 00001338 A112180000                  mov _TOS_, [ vesa_XResolution ] ; was this  : mov _TOS_, ( scrnw )
  2800 0000133D 25FFFF0000                  and _TOS_, 0xFFFF
  2801 00001342 2B05[74390000]              sub _TOS_, [ v_nine_iconw ]
  2802 00001348 2D10000000                  sub _TOS_, 16
  2803 0000134D A3[383A0000]                mov [ v_leftMargin ], _TOS_     ; x coordinate of left margin of keyboard display
  2804 00001352 89C2                        mov edx, _TOS_                  ;
  2805 00001354 0315[74390000]              add edx, [ v_nine_iconw ]       ; x coordinate of right margin of keyboard display
  2806 0000135A 8915[3C3A0000]              mov [ v_rightMargin ], edx
  2807 00001360 C1E010                      shl _TOS_, 0x10
  2808 00001363 8B1514180000                mov edx, [ vesa_YResolution ]   ; was this  : mov _TOS_, ( scrnw )
  2809 00001369 81E2FFFF0000                and edx, 0x0000FFFF
  2810 0000136F 53                          push _SCRATCH_
  2811 00001370 8B1D[70390000]              mov _SCRATCH_, [ v_keypadY_iconh ]
  2812 00001376 81C30A000000                add _SCRATCH_, 10
  2813 0000137C 29DA                        sub edx, _SCRATCH_              ; ( ( keypadY * iconh ) + 10 )
  2814 0000137E 01D0                        add _TOS_, edx
  2815                                  
  2816 00001380 A3[343A0000]                mov [ v_xy ], _TOS_
  2817                                  
  2818 00001385 F605[8F390000]FF            test byte [ v_acceptMode ], 0xFF
  2819 0000138C 740C                        jz .forward
  2820 0000138E 60                          pusha
  2821 0000138F E823FFFFFF                  call showEditBox
  2822 00001394 61                          popa
  2823 00001395 A3[343A0000]                mov [ v_xy ], _TOS_
  2824                                  .forward:
  2825                                  
  2826 0000139A 5B                          pop _SCRATCH_
  2827 0000139B E8E5FDFFFF                  call eight
  2828 000013A0 E8E0FDFFFF                  call eight
  2829 000013A5 E8DBFDFFFF                  call eight
  2830 000013AA E810F6FFFF                  call cr_
  2831                                  ;    add dword [ v_xy ],  ( 4 * iconw * 0x10000 )        ; shift horizontal pixels to the right
  2832 000013AF 8B1D[68390000]              mov _SCRATCH_, [ v_iconw ]
  2833 000013B5 C1E312                      shl _SCRATCH_, ( 2 + 16 ) ; ( 4 * iconw * 0x10000 )  ; shift horizontal pixels to the right
  2834 000013B8 011D[343A0000]              add dword [ v_xy ], _SCRATCH_
  2835 000013BE 8B3D[9C390000]              mov edi, [ shiftAction ]
  2836 000013C4 83C70C                      add edi, byte 0x0C
  2837 000013C7 B903000000                  mov ecx, 0x03
  2838 000013CC E8C9FDFFFF                  call four1
  2839                                  
  2840 000013D1 E8BBFAFFFF                  call space_
  2841                                      _DUP_
  2842 000013D6 83EE04              <1>  sub esi, byte 0x04
  2843 000013D9 8906                <1>  mov [ esi ], _TOS_
  2844 000013DB A1[90390000]                mov _TOS_, [ v_hintChar ]
  2845 000013E0 E89AFAFFFF                  call emit_
  2846                                  
  2847 000013E5 C705[383A0000]0300-         mov dword [ v_leftMargin ], 0x03
  2848 000013ED 0000               
  2849 000013EF 66C705[363A0000]03-         mov word [ v_x ], 0x03
  2850 000013F7 00                 
  2851 000013F8 E8B2FDFFFF                  call displayTheStack
  2852 000013FD A112180000                  mov _TOS_, [ vesa_XResolution ]   ; was this  : mov _TOS_, ( scrnw )
  2853 00001402 25FFFF0000                  and _TOS_, 0xFFFF
  2854 00001407 2B05[78390000]              sub _TOS_, [ v_twentytwo_iconw ]
  2855 0000140D 0503000000                  add _TOS_, 3
  2856 00001412 66A3[363A0000]              mov word [ v_x ], ax
  2857 00001418 8D3D[BD0F0000]              lea edi, [ ( history - 4 )]     ; the text entered so far
  2858 0000141E B90B000000                  mov ecx, 0x0B
  2859 00001423 E972FDFFFF                  jmp dword four1
  2860                                  
  2861                                  ; *****************************************************************************
  2862                                  
  2863                                  alphaKeyboard:          ; the 'alpha' character keyboard icons, the start screen for key entry
  2864 00001428 0D0A010C                    db 0x0D, 0x0A, 0x01, 0x0C  ; g c r l
  2865 0000142C 14020608                    db 0x14, 0x02, 0x06, 0x08  ; h t n s
  2866 00001430 13090F11                    db 0x13, 0x09, 0x0F, 0x11  ; b m w v
  2867 00001434 120B0E07                    db 0x12, 0x0B, 0x0E, 0x07  ; p y f i
  2868 00001438 05030416                    db 0x05, 0x03, 0x04, 0x16  ; a o e u
  2869 0000143C 17241510                    db 0x17, 0x24, 0x15, 0x10  ; q k x d
  2870                                  
  2871                                  graphicsKeyboard:       ; the 'graphics' character keyboard icons (Note: not numbers, just characters)
  2872 00001440 191A1B00                    db 0x19, 0x1A, 0x1B,    0  ; 1 2 3 _
  2873 00001444 1C1D1E18                    db 0x1C, 0x1D, 0x1E, 0x18  ; 4 5 6 0
  2874 00001448 1F20212F                    db 0x1F, 0x20, 0x21, 0x2F  ; 7 8 9 ?
  2875 0000144C 29282A2C                    db 0x29, 0x28, 0x2A, 0x2C  ; : ; ! @
  2876 00001450 2622252E                    db 0x26, 0x22, 0x25, 0x2E  ; z j . ,W
  2877 00001454 2D272B23                    db 0x2D, 0x27, 0x2B, 0x23  ; * / + -
  2878                                  
  2879                                  decimalKeyboard:        ; the decimal number entry keyboard icons
  2880 00001458 191A1B00                    db 0x19, 0x1A, 0x1B,    0  ; 1 2 3 _
  2881 0000145C 1C1D1E18                    db 0x1C, 0x1D, 0x1E, 0x18  ; 4 5 6 0
  2882 00001460 1F202100                    db 0x1F, 0x20, 0x21,    0  ; 7 8 9 _
  2883 00001464 00000000                    db    0,    0,    0,    0  ; _ _ _ _
  2884 00001468 00000000                    db    0,    0,    0,    0  ; _ _ _ _
  2885 0000146C 00000000                    db    0,    0,    0,    0  ; _ _ _ _
  2886                                  
  2887                                  hexadecimalKeyboard:    ; the hexadecimal number entry keyboard icons
  2888 00001470 191A1B00                    db 0x19, 0x1A, 0x1B,    0  ; 1 2 3 _
  2889 00001474 1C1D1E18                    db 0x1C, 0x1D, 0x1E, 0x18  ; 4 5 6 0
  2890 00001478 1F202100                    db 0x1F, 0x20, 0x21,    0  ; 7 8 9 _
  2891 0000147C 0005130A                    db    0, 0x05, 0x13, 0x0A  ; _ a b c
  2892 00001480 0010040E                    db    0, 0x10, 0x04, 0x0E  ; _ d e f
  2893 00001484 00000000                    db    0,    0,    0,    0  ; _ _ _ _
  2894                                  
  2895                                  ; *****************************************************************************
  2896                                  ; get keyboard keys
  2897                                  ; *****************************************************************************
  2898                                  
  2899                                  letter:
  2900 00001488 3C04                        cmp al, 0x04
  2901 0000148A 7809                        js .forward
  2902 0000148C 8B15[98390000]              mov edx, [ currentKeyboardIcons ]
  2903 00001492 8A0410                      mov al, [ _TOS_ + edx ]
  2904                                  .forward:
  2905 00001495 C3                          ret
  2906                                  
  2907                                  key_map_table:   ; map 8042 scan type 1 keycode to colorForth character values
  2908 00001496 1011121300000405            db 16, 17, 18, 19,  0,  0,  4,  5 ; 0x10 - 0x17
  2909 0000149E 0607000000001415            db  6,  7,  0,  0,  0,  0, 20, 21 ; 0x18 - 0x1F
  2910 000014A6 1617000008090A0B            db 22, 23,  0,  0,  8,  9, 10, 11 ; 0x20 - 0x27
  2911 000014AE 0000000018191A1B            db  0,  0,  0,  0, 24, 25, 26, 27 ; 0x28 - 0x2F
  2912 000014B6 00010C0D0E0F0000            db  0,  1, 12, 13, 14, 15,  0,  0 ; 0x30 - 0x37 N
  2913 000014BE 0302                        db  3,  2                         ; 0x38 - 0x39 alt space
  2914                                  
  2915                                  ; ToDo: add a timeout to the loop
  2916                                  WaitToReceiveKey:      ; Wait until there is byte to receive from the keyboard controller
  2917                                  .back:
  2918 000014C0 E464                        in al, 0x64     ; On-board controller status read
  2919 000014C2 A801                        test al, 1      ; OBF (Output Buffer Full)
  2920 000014C4 750C                        jnz .forward    ; exit when bit 0 = 1 the On-board controller has a new character for us
  2921 000014C6 31C0                        xor _TOS_, _TOS_
  2922 000014C8 E840EFFFFF                  call pause_    ; not ready yet, so let the other task(s) have a turn
  2923 000014CD E9EEFFFFFF                  jmp  .back      ; jump back and try again
  2924                                  .forward:
  2925                                  ;    call pause_    ; not ready yet, so let the other task(s) have a turn
  2926 000014D2 C3                          ret
  2927                                  
  2928                                  v_lineOffsetTablePtr:
  2929 000014D3 00000000                    dd 0 ; times 16 dd 0
  2930                                  
  2931                                  lineOffsetZero:
  2932 000014D7 C705[E9210000]0000-         mov dword [ v_lineOffset ], 0x00
  2933 000014DF 0000               
  2934 000014E1 C3                          ret
  2935                                  
  2936                                  lineOffsetPlus:
  2937 000014E2 8105[E9210000]0C00-         add dword [ v_lineOffset ], 0x0C
  2938 000014EA 0000               
  2939 000014EC C3                          ret
  2940                                  
  2941                                  lineOffsetMinus:
  2942 000014ED 812D[E9210000]0C00-         sub dword [ v_lineOffset ], 0x0C
  2943 000014F5 0000               
  2944 000014F7 7905                        jns .forward
  2945 000014F9 E8D9FFFFFF                  call lineOffsetZero
  2946                                  .forward:
  2947 000014FE C3                          ret
  2948                                  
  2949                                  ; *****************************************************************************
  2950                                  ; F1 Help screens
  2951                                  ; *****************************************************************************
  2952                                  
  2953                                  help0:  ; save  v_blk , display the first help screen
  2954                                      _DUP_
  2955 000014FF 83EE04              <1>  sub esi, byte 0x04
  2956 00001502 8906                <1>  mov [ esi ], _TOS_
  2957 00001504 813D[10390000]FF01-         cmp dword [ v_blk ], LAST_BLOCK_NUMBER     ; we are displaying the first Help screen
  2958 0000150C 0000               
  2959 0000150E 740A                        je .forward
  2960 00001510 A1[10390000]                mov _TOS_, [ v_blk ]
  2961 00001515 A3[2C390000]                mov [ v_saved_v_blk ], _TOS_
  2962                                  .forward:
  2963 0000151A C705[10390000]FF01-         mov dword [ v_blk ], LAST_BLOCK_NUMBER
  2964 00001522 0000               
  2965                                      _DROP_
  2966 00001524 AD                  <1>  lodsd
  2967 00001525 C3                          ret
  2968                                  
  2969                                  help1:  ; display the second help screen
  2970 00001526 C705[10390000]2100-         mov dword [ v_blk ], ( START_BLOCK_NUMBER + 1 )
  2971 0000152E 0000               
  2972 00001530 C3                          ret
  2973                                  
  2974                                  help2:  ; display the second third screen
  2975 00001531 C705[10390000]2000-         mov dword [ v_blk ], ( START_BLOCK_NUMBER )
  2976 00001539 0000               
  2977 0000153B C3                          ret
  2978                                  
  2979                                  help3:  ; restore the original screen being edited
  2980                                      _DUP_
  2981 0000153C 83EE04              <1>  sub esi, byte 0x04
  2982 0000153F 8906                <1>  mov [ esi ], _TOS_
  2983 00001541 A1[2C390000]                mov _TOS_, [ v_saved_v_blk ]
  2984 00001546 A3[10390000]                mov [ v_blk ], _TOS_
  2985                                      _DROP_
  2986 0000154B AD                  <1>  lodsd
  2987 0000154C C3                          ret
  2988                                  
  2989                                  HelpTable:
  2990 0000154D [FF140000]                  dd help0
  2991 00001551 [26150000]                  dd help1
  2992 00001555 [31150000]                  dd help2
  2993 00001559 [3C150000]                  dd help3
  2994                                  
  2995                                  help:
  2996                                      _DUP_
  2997 0000155D 83EE04              <1>  sub esi, byte 0x04
  2998 00001560 8906                <1>  mov [ esi ], _TOS_
  2999 00001562 A1[28390000]                mov _TOS_, [ v_help_counter ]
  3000 00001567 2503000000                  and _TOS_, 0x03
  3001 0000156C FF1485[4D150000]            call dword [ ( _TOS_ * 4 ) + HelpTable ]
  3002                                      _DROP_
  3003 00001573 AD                  <1>  lodsd
  3004 00001574 FE05[28390000]              inc byte [ v_help_counter ]
  3005 0000157A C3                          ret
  3006                                  
  3007                                  ; *****************************************************************************
  3008                                  ; Editor
  3009                                  ; *****************************************************************************
  3010                                  
  3011                                  e_plus:
  3012 0000157B E8781B0000                  call colourBlindModeToggle
  3013 00001580 E900000000                  jmp abort_e
  3014                                  
  3015                                  abort_e:
  3016                                      ; call abort
  3017 00001585 E84FEFFFFF                  call c_
  3018                                  abort_e2:
  3019 0000158A BC00780000                  mov esp, RETURN_STACK_0
  3020 0000158F E82F130000                  call e_
  3021 00001594 C3                          ret
  3022                                  
  3023                                  executeToken:   ; ( -- )    \ action when the QWERT enter key is pressed
  3024 00001595 C605[8F390000]00            mov byte [ v_acceptMode ], 0x00     ; turn off the edit mode orange lines around the keyboard
  3025 0000159C A1[50390000]                mov _TOS_, [ v_cad ]
  3026 000015A1 2D01000000                  sub _TOS_, 1                ; step to before the token before the cursor
  3027 000015A6 C1E002                      shl _TOS_, 2                ; convert cell address to byte address
  3028 000015A9 8B00                        mov _TOS_, [ _TOS_ ]
  3029 000015AB 89C3                        mov _SCRATCH_, _TOS_
  3030 000015AD 81E30F000000                and _SCRATCH_, 0x0F         ; check the token type = 3 == red
  3031 000015B3 81FB03000000                cmp _SCRATCH_, 0x03
  3032 000015B9 740D                        je  .forward
  3033 000015BB 81FB0C000000                cmp _SCRATCH_, 0x0C         ; check the token type = 12 == magenta.  NOT WORKING YET ToDo: fix this
  3034 000015C1 7405                        je  .forward
  3035 000015C3 E905000000                  jmp .forward2
  3036                                  .forward:
  3037 000015C8 E83DF1FFFF                  call execute
  3038                                  .forward2:
  3039                                      _DROP_
  3040 000015CD AD                  <1>  lodsd
  3041 000015CE C3                          ret
  3042                                  
  3043                                  %define FirstFkey  (59)     ; F1 = 59
  3044                                  
  3045                                  FkeyTable:  ; ( c -- a )   \ function key action table
  3046                                  ;    dd nul              ; 57
  3047                                  ;    dd nul              ; 58
  3048 000015CF [5D150000]                  dd help             ; 59 F1
  3049 000015D3 [8E190000]                  dd toggleBase0      ; 60 F2 decimal/hex number display
  3050 000015D7 [F1300000]                  dd seeb             ; 61 F3 show/hide blue words
  3051 000015DB [7B150000]                  dd e_plus           ; 62 F4 editor
  3052 000015DF [2D250000]                  dd otherBlock       ; 63 F5 display the previously edited block
  3053 000015E3 [00040000]                  dd nul              ; 64 F6
  3054 000015E7 [00040000]                  dd nul              ; 65 F7
  3055 000015EB [00040000]                  dd nul              ; 66 F8
  3056 000015EF [A6190000]                  dd toggleBase       ; 67 F9
  3057 000015F3 [D9040000]                  dd c_               ; 68 F10
  3058 000015F7 [00040000]                  dd nul              ; 69 Num Lock
  3059 000015FB [00040000]                  dd nul              ; 70
  3060 000015FF [E3240000]                  dd cursorHome       ; 71 Home
  3061 00001603 [94240000]                  dd cursorUp         ; 72 Up arrow
  3062 00001607 [0A250000]                  dd nextBlock        ; 73 PgUp
  3063 0000160B [00040000]                  dd nul              ; 74 -
  3064 0000160F [F4220000]                  dd cursorLeft       ; 75 Left arrow
  3065 00001613 [2D250000]                  dd otherBlock       ; 76    display the previously edited block
  3066 00001617 [17230000]                  dd cursorRight      ; 77 Right arrow
  3067 0000161B [00040000]                  dd nul              ; 78 +
  3068 0000161F [CC240000]                  dd cursorEnd        ; 79 End
  3069 00001623 [AC240000]                  dd cursorDown       ; 80 Down arrow
  3070 00001627 [17250000]                  dd previousBlock    ; 81 PgDn
  3071 0000162B [B2270000]                  dd destack          ; 82 Insert
  3072 0000162F [CA260000]                  dd deleteAction     ; 83 Delete
  3073 00001633 [00040000]                  dd nul              ; 84
  3074 00001637 [00040000]                  dd nul              ; 85
  3075 0000163B [00040000]                  dd nul              ; 86
  3076 0000163F [8E190000]                  dd toggleBase0      ; 87 F11
  3077 00001643 [00040000]                  dd nul              ; 88 F12
  3078 00001647 [95150000]                  dd executeToken     ; 89 really 121 Enter
  3079 0000164B [85150000]                  dd abort_e          ; 90 really 123 Escape
  3080                                  
  3081                                  processFkey:    ; ( n -- )   \ process the given function key code
  3082                                  ;    cmp _TOS_, 121
  3083                                  ;    jne .forward1
  3084                                  ;    sub _TOS_, ( 121 - 89 )
  3085                                  ;.forward1:
  3086 0000164F 2D3B000000                  sub _TOS_, FirstFkey   ; convert Fn key value to index from 0
  3087 00001654 251F000000                  and _TOS_, 0x1F
  3088 00001659 FF1485[CF150000]            call dword [ ( _TOS_ * 4 ) + FkeyTable ]
  3089                                  ;    _DROP_
  3090                                      ; call e_
  3091 00001660 C3                          ret
  3092                                  
  3093                                  get_key_:    ; ( -- c )   \ waits for and returns a character from the keyboard, assumes Scan Code Set 1, set up by the BIOS
  3094                                      _DUP_
  3095 00001661 83EE04              <1>  sub esi, byte 0x04
  3096 00001664 8906                <1>  mov [ esi ], _TOS_
  3097 00001666 31C0                        xor _TOS_, _TOS_
  3098                                  .back:
  3099                                      ; check if the key is a function key
  3100 00001668 3D3B000000                  cmp _TOS_, FirstFkey  ; F1 key
  3101 0000166D 780C                        js .forward4
  3102 0000166F 3D5B000000                  cmp _TOS_, FirstFkey + 32  ; Fxx key + 1
  3103 00001674 7905                        jns .forward4
  3104                                   ;    ; jmp dword [ _TOS_ * 4 + qwertyActionTable - 0x200 ]
  3105                                   ;   xor dword [ current], ((setDecimalMode - $$) ^ (setHexMode - $$))
  3106                                   ;   xor byte [ numb0 + 18 ], ( 0x21 ^ 0x0E ) ;  0x21 = '9' , 0x0E = 'f' toggle '9' and 'f' on keypad display line
  3107                                   ;   call [ current ]
  3108                                   ;  call toggleBase
  3109 00001676 E8D4FFFFFF                  call processFkey
  3110                                  .forward4:
  3111                                      _DROP_
  3112 0000167B AD                  <1>  lodsd
  3113 0000167C E87D000000                  call get_qwerty_key_
  3114                                  ;    call WaitToReceiveKey  ; Wait until there is a byte to receive from the keyboard controller
  3115                                  ;    in   al, 0x60       ; read the key value from the Keyboard data port
  3116 00001681 A0[80000000]                mov al, [ v_scanCode ]
  3117                                  ;    test al, 0xF0       ; we are only interested in certain key codes (?)
  3118                                  ;    jz   .back
  3119 00001686 3C3A                        cmp  al, 0x3A       ; exclude keycodes greater than 0x39,  cmp  is like  sub  but only affects the flags
  3120 00001688 73DE                        jnc  .back
  3121 0000168A 8A80[86140000]              mov  al, [ key_map_table - 0x10 + EAX ] ; convert to the colorForth value using the 'key_map_table' table
  3122 00001690 C3                          ret
  3123                                  
  3124                                  ; *****************************************************************************
  3125                                  ; get qwerty keys
  3126                                  ; *****************************************************************************
  3127                                  
  3128 00001691 00<rept>                align 4, db 0   ; fill the gap with 0's
  3129                                  
  3130                                  ; times 0x40 db 0x00,
  3131                                  
  3132                                  qwerty_key_map_table:
  3133                                  ;         0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F
  3134 00001694 0B180219031A041B05-         db 0x0B, 0x18, 0x02, 0x19, 0x03, 0x1A, 0x04, 0x1B, 0x05, 0x1C, 0x06, 0x1D, 0x07, 0x1E, 0x08, 0x1F ; 0x00
  3135 0000169D 1C061D071E081F     
  3136 000016A4 09200A211E0530132E-         db 0x09, 0x20, 0x0A, 0x21, 0x1e, 0x05, 0x30, 0x13, 0x2E, 0x0A, 0x20, 0x10, 0x12, 0x04, 0x21, 0x0E ; 0x10
  3137 000016AD 0A20101204210E     
  3138 000016B4 220D23141707242225-         db 0x22, 0x0D, 0x23, 0x14, 0x17, 0x07, 0x24, 0x22, 0x25, 0x24, 0x26, 0x0C, 0x32, 0x09, 0x31, 0x06 ; 0x20
  3139 000016BD 24260C32093106     
  3140 000016C4 18031912101713011F-         db 0x18, 0x03, 0x19, 0x12, 0x10, 0x17, 0x13, 0x01, 0x1F, 0x08, 0x14, 0x02, 0x16, 0x16, 0x2F, 0x11 ; 0x30
  3141 000016CD 08140216162F11     
  3142 000016D4 110F2D15150B2C260C-         db 0x11, 0x0F, 0x2D, 0x15, 0x15, 0x0B, 0x2C, 0x26, 0x0C, 0x23, 0x34, 0x25, 0x35, 0x27, 0x27, 0x28 ; 0x40
  3143 000016DD 23342535272728     
  3144 000016E4 2829822A8D2B832C89-         db 0x28, 0x29, 0x82, 0x2A, 0x8D, 0x2B, 0x83, 0x2C, 0x89, 0x2D, 0x33, 0x2E, 0xB5, 0x2F, 0x39, 0x80 ; 0x50
  3145 000016ED 2D332EB52F3980     
  3146 000016F4 1C810E8201833B8429-         db 0x1C, 0x81, 0x0E, 0x82, 0x01, 0x83, 0x3B, 0x84, 0x29, 0x30
  3147 000016FD 30                 
  3148                                      ; test only
  3149                                  ; times 0x40 db 0x00,
  3150                                      
  3151                                  get_qwerty_key_:           ; get a qwerty key character
  3152                                      _DUP_
  3153 000016FE 83EE04              <1>  sub esi, byte 0x04
  3154 00001701 8906                <1>  mov [ esi ], _TOS_
  3155                                  .back:
  3156 00001703 E8B8FDFFFF                  call WaitToReceiveKey
  3157 00001708 E460                        in al, 0x60
  3158                                  
  3159 0000170A 3D1C000000                  cmp _TOS_, 0x1C     ; the Enter key scan code
  3160 0000170F 7505                        jne .forward1
  3161                                      ; add _TOS_, ( 89 - 0x1C ) ; convert the code for the Enter key to 89
  3162 00001711 B859000000                  mov _TOS_, 89
  3163                                  .forward1:
  3164                                  
  3165 00001716 3D81000000                  cmp _TOS_, 0x81     ; the Escape key scan code
  3166 0000171B 7505                        jne .forward2
  3167 0000171D 05D9FFFFFF                  add _TOS_, ( 90 - 0x81 ) ; convert the code for the Escape key to 90
  3168                                  .forward2:
  3169                                  
  3170                                  ;    cmp _TOS_, 0x03     ; the Left Alt key scan code
  3171                                  ;    jne .forward3
  3172                                  ;    add _TOS_, 0x02 ; convert the code for the Left Alt key to a space key
  3173                                  ; .forward3:
  3174                                  
  3175 00001722 A2[80000000]                mov [ v_scanCode ], al
  3176 00001727 89C1                        mov ecx, _TOS_              ; copy keycode into cl
  3177 00001729 80E17F                      and cl, 0x7F                ; filter out key-up bit 7
  3178 0000172C 80F92A                      cmp cl, 0x2A                ; g?
  3179 0000172F 7405                        jz .got_c_or_g
  3180 00001731 80F936                      cmp cl, 0x36                ; c?
  3181 00001734 750B                        jnz .not_c_or_g
  3182                                  .got_c_or_g:
  3183 00001736 2480                        and al, 0x80                ; extract key-up bit
  3184 00001738 3480                        xor al, 0x80                ; complement it
  3185 0000173A A3[BC390000]                mov [ v_qwerty_key ], _TOS_
  3186 0000173F EBC2                        jmp short .back
  3187                                  .not_c_or_g:
  3188 00001741 08C0                        or al, al                   ; check if key-up
  3189 00001743 78BE                        js .back                    ; if so, try again to get keydown event
  3190 00001745 247F                        and al, 0x7F                ; filter out key-up bit
  3191 00001747 0B05[BC390000]              or _TOS_, [ v_qwerty_key ]
  3192 0000174D BA[94160000]                mov edx, qwerty_key_map_table
  3193 00001752 B935000000                  mov ecx, 0x35
  3194                                  .back2:
  3195 00001757 3802                        cmp [edx], al
  3196 00001759 7408                        jz .forward
  3197 0000175B 83C202                      add edx, byte 0x02
  3198 0000175E E2F7                        loop .back2
  3199 00001760 31C0                        xor _TOS_, _TOS_
  3200 00001762 C3                          ret
  3201                                  .forward:
  3202 00001763 8A4201                      mov al, [edx+0x01]
  3203 00001766 81EA[94160000]              sub edx, qwerty_key_map_table
  3204 0000176C D1EA                        shr edx, 1
  3205 0000176E 8915[C0390000]              mov [ v_digin ], edx
  3206 00001774 3D3B000000                  cmp _TOS_, 59  ; F1 key
  3207                                  ;    jnz .forward4
  3208                                  ;    ; jmp dword [ _TOS_ * 4 + qwertyActionTable - 0x200 ]
  3209                                  ;    xor dword [ current], ((setDecimalMode - $$) ^ (setHexMode - $$))
  3210                                  ;    call toggleBase
  3211                                  ;.forward4:
  3212 00001779 C3                          ret
  3213                                  
  3214                                  ; *****************************************************************************
  3215                                  ; keyboard jump tables
  3216                                  ; *****************************************************************************
  3217                                  
  3218                                  graph0:
  3219 0000177A [B7190000]-                 dd nul0, nul0, nul0, alph0
  3220 0000177E [B7190000]-        
  3221 00001782 [B7190000]-        
  3222 00001786 [151A0000]         
  3223 0000178A 00000500                    db 0x00, 0x00, 0x05, 0x00       ; _ _ a _
  3224                                  
  3225                                  graph1:
  3226 0000178E [C0180000]-                 dd word0, x, lj, alph
  3227 00001792 [59180000]-        
  3228 00001796 [FF170000]-        
  3229 0000179A [3A1A0000]         
  3230 0000179E 15250500                    db 0x15, 0x25, 0x05, 0x00       ; x . a _
  3231                                  
  3232                                  alpha0:
  3233 000017A2 [B7190000]-                 dd nul0, nul0, number, star0
  3234 000017A6 [B7190000]-        
  3235 000017AA [F1180000]-        
  3236 000017AE [271A0000]         
  3237 000017B2 00212D00                    db 0x00, 0x21, 0x2D, 0x00       ; _ 9 * _
  3238                                  
  3239                                  alpha1:
  3240 000017B6 [C0180000]-                 dd word0, x, lj, graph
  3241 000017BA [59180000]-        
  3242 000017BE [FF170000]-        
  3243 000017C2 [4C1A0000]         
  3244 000017C6 15252D00                    db 0x15, 0x25, 0x2D, 0x00       ; x . * _
  3245                                  
  3246                                  numb0:
  3247 000017CA [B7190000]-                 dd nul0, minus, alphn, toggleBase
  3248 000017CE [E7180000]-        
  3249 000017D2 [141A0000]-        
  3250 000017D6 [A6190000]         
  3251 000017DA 23050E00                    db 0x23, 0x05, 0x0E, 0x00       ; - a f _
  3252                                  
  3253                                  numb1:
  3254 000017DE [EE180000]-                 dd number0, xn, endn, number0
  3255 000017E2 [B0190000]-        
  3256 000017E6 [44190000]-        
  3257 000017EA [EE180000]         
  3258 000017EE 15250000                    db 0x15, 0x25, 0x00, 0x00       ; x . _ _
  3259                                  
  3260                                  ; *****************************************************************************
  3261                                  ; Shannon-Fano compression
  3262                                  ; *****************************************************************************
  3263                                  
  3264                                  bits_:
  3265 000017F2 1C                          db 0x1C
  3266                                  
  3267                                  lj0:
  3268 000017F3 8A0D[F2170000]              mov cl, [ bits_ ]
  3269 000017F9 80C104                      add cl, 0x04
  3270 000017FC D326                        shl dword [ esi ],cl
  3271 000017FE C3                          ret
  3272                                  
  3273                                  lj:
  3274 000017FF E8EFFFFFFF                  call lj0
  3275                                      _DROP_
  3276 00001804 AD                  <1>  lodsd
  3277 00001805 C3                          ret
  3278                                  
  3279                                  full:
  3280 00001806 E8E8FFFFFF                  call lj0
  3281 0000180B FF05[B8390000]              inc dword [ v_words ]
  3282 00001811 C605[F2170000]1C            mov byte [ bits_ ], 0x1C
  3283 00001818 282D[F2170000]              sub [ bits_ ], ch
  3284 0000181E 89D0                        mov _TOS_, edx
  3285                                      _DUP_
  3286 00001820 83EE04              <1>  sub esi, byte 0x04
  3287 00001823 8906                <1>  mov [ esi ], _TOS_
  3288 00001825 C3                          ret
  3289                                  
  3290                                  pack0:
  3291 00001826 83C050                      add _TOS_, byte  0x50
  3292 00001829 B107                        mov cl, 0x07
  3293 0000182B EB0D                        jmp short pack1
  3294                                  
  3295                                  pack_:
  3296 0000182D 3C10                        cmp al, 0x10
  3297 0000182F 73F5                        jnc pack0
  3298 00001831 B104                        mov cl, 0x04
  3299 00001833 A808                        test al, 0x08
  3300 00001835 7403                        jz pack1
  3301 00001837 41                          inc ecx
  3302 00001838 3418                        xor al, 0x18
  3303                                  pack1:
  3304 0000183A 89C2                        mov edx, _TOS_
  3305 0000183C 88CD                        mov ch,cl
  3306                                  .back:
  3307 0000183E 380D[F2170000]              cmp [ bits_ ], cl
  3308 00001844 7308                        jnc .forward
  3309 00001846 D0E8                        shr al,1
  3310 00001848 72BC                        jc full
  3311 0000184A FEC9                        dec cl
  3312 0000184C EBF0                        jmp short .back
  3313                                  .forward:
  3314 0000184E D326                        shl dword [ esi ],cl
  3315 00001850 3106                        xor [ esi ], _TOS_
  3316 00001852 280D[F2170000]              sub [ bits_ ], cl
  3317 00001858 C3                          ret
  3318                                  
  3319                                  x:      ; eXit
  3320 00001859 E887F7FFFF                  call right
  3321 0000185E A1[B8390000]                mov _TOS_, [ v_words ]
  3322 00001863 8D3486                      lea esi, [esi+_TOS_*4]
  3323                                      _DROP_
  3324 00001866 AD                  <1>  lodsd
  3325 00001867 E95A010000                  jmp accept
  3326                                  
  3327                                  word_:
  3328 0000186C E874F7FFFF                  call right
  3329 00001871 C705[B8390000]0100-         mov dword [ v_words ], 0x01
  3330 00001879 0000               
  3331 0000187B C705[AC390000]0100-         mov dword [ chars ], 0x01
  3332 00001883 0000               
  3333                                      _DUP_
  3334 00001885 83EE04              <1>  sub esi, byte 0x04
  3335 00001888 8906                <1>  mov [ esi ], _TOS_
  3336 0000188A C70600000000                mov dword [ esi ], 0x00
  3337 00001890 C605[F2170000]1C            mov byte [ bits_ ], 0x1C
  3338                                  word1:
  3339 00001897 E8ECFBFFFF                  call letter
  3340 0000189C 7909                        jns .forward
  3341 0000189E 8B15[9C390000]              mov edx, [ shiftAction ]
  3342 000018A4 FF2482                      jmp dword [edx+_TOS_*4]
  3343                                  .forward:
  3344 000018A7 84C0                        test al,al
  3345 000018A9 7415                        jz word0
  3346                                      _DUP_
  3347 000018AB 83EE04              <1>  sub esi, byte 0x04
  3348 000018AE 8906                <1>  mov [ esi ], _TOS_
  3349 000018B0 E817F7FFFF                  call echo_
  3350 000018B5 E873FFFFFF                  call pack_
  3351 000018BA FF05[AC390000]              inc dword [ chars ]
  3352                                  word0:
  3353                                      _DROP_
  3354 000018C0 AD                  <1>  lodsd
  3355 000018C1 E89BFDFFFF                  call get_key_
  3356 000018C6 EBCF                        jmp short word1
  3357                                  
  3358                                  ; *****************************************************************************
  3359                                  ; number display
  3360                                  ; *****************************************************************************
  3361                                  
  3362                                  digitTable:
  3363 000018C8 0E0A0000                    db 14, 10,  0,  0
  3364 000018CC 00000C0000000F00            db  0,  0, 12,  0,  0,  0, 15,  0
  3365 000018D4 0D00000B00000000            db 13,  0,  0, 11,  0,  0,  0,  0
  3366 000018DC 0001020304050607            db  0,  1,  2,  3,  4,  5,  6,  7
  3367 000018E4 0809                        db  8,  9
  3368                                  
  3369                                  v_sign:
  3370 000018E6 00                          db 0x00
  3371                                  
  3372                                  minus:
  3373 000018E7 A2[E6180000]                mov [v_sign ], al
  3374 000018EC EB49                        jmp short number2
  3375                                  
  3376                                  number0:
  3377                                      _DROP_
  3378 000018EE AD                  <1>  lodsd
  3379 000018EF EB0F                        jmp short number3
  3380                                  
  3381                                  number:
  3382 000018F1 FF15[A4390000]              call [ current ]
  3383 000018F7 C605[E6180000]00            mov byte [ v_sign ] , 0x00
  3384 000018FE 31C0                        xor _TOS_, _TOS_
  3385                                  number3:
  3386 00001900 E85CFDFFFF                  call get_key_
  3387 00001905 E87EFBFFFF                  call letter
  3388 0000190A 7909                        jns .forward
  3389 0000190C 8B15[9C390000]              mov edx, [ shiftAction ]
  3390 00001912 FF2482                      jmp dword [edx+_TOS_*4]
  3391                                  
  3392                                  .forward:
  3393 00001915 84C0                        test al,al
  3394 00001917 74D5                        jz number0
  3395 00001919 8A80[C4180000]              mov al, [ _TOS_ + digitTable - 4 ]
  3396 0000191F F605[E6180000]1F            test byte [ v_sign ], 0x1F
  3397 00001926 7402                        jz .forward2
  3398 00001928 F7D8                        neg _TOS_
  3399                                  .forward2:
  3400 0000192A 8B16                        mov edx, [ esi ]
  3401 0000192C 0FAF15[A0390000]            imul edx, [ base ]
  3402 00001933 01C2                        add edx, _TOS_
  3403 00001935 8916                        mov [ esi ], edx
  3404                                  number2:
  3405                                      _DROP_
  3406 00001937 AD                  <1>  lodsd
  3407 00001938 C705[9C390000]-             mov dword [ shiftAction ], numb1
  3408 0000193E [DE170000]         
  3409 00001942 EBBC                        jmp short number3
  3410                                  
  3411                                  endn:
  3412                                      _DROP_
  3413 00001944 AD                  <1>  lodsd
  3414 00001945 FF15[B4390000]              call [ anumber]
  3415 0000194B E976000000                  jmp accept
  3416                                  
  3417                                  setDecimalMode:
  3418 00001950 C705[A0390000]0A00-         mov dword [ base ], 0x0A
  3419 00001958 0000               
  3420 0000195A C705[9C390000]-             mov dword [ shiftAction ], numb0
  3421 00001960 [CA170000]         
  3422 00001964 C705[98390000]-             mov dword [ currentKeyboardIcons], ( decimalKeyboard - 4 )
  3423 0000196A [54140000]         
  3424 0000196E C3                          ret
  3425                                  
  3426                                  setHexMode:
  3427 0000196F C705[A0390000]1000-         mov dword [ base ], 0x10
  3428 00001977 0000               
  3429 00001979 C705[9C390000]-             mov dword [ shiftAction ], numb0
  3430 0000197F [CA170000]         
  3431 00001983 C705[98390000]-             mov dword [ currentKeyboardIcons], ( hexadecimalKeyboard - 4 )
  3432 00001989 [6C140000]         
  3433 0000198D C3                          ret
  3434                                  
  3435                                  toggleBase0:
  3436 0000198E 8135[A4390000]3F00-         xor dword [ current], ((setDecimalMode - $$) ^ (setHexMode - $$))
  3437 00001996 0000               
  3438 00001998 8035[DC170000]2F            xor byte [ numb0 + 18 ], ( 0x21 ^ 0x0E ) ;  0x21 = '9' , 0x0E = 'f' toggle '9' and 'f' on keypad display line
  3439 0000199F FF15[A4390000]              call [ current ]
  3440 000019A5 C3                          ret
  3441                                  
  3442                                  toggleBase:
  3443 000019A6 E8E3FFFFFF                  call toggleBase0
  3444 000019AB E93EFFFFFF                  jmp dword number0
  3445                                  
  3446                                  ; *****************************************************************************
  3447                                  ; text entry
  3448                                  ; *****************************************************************************
  3449                                  
  3450                                  xn:
  3451                                      _DROP_
  3452 000019B0 AD                  <1>  lodsd
  3453                                      _DROP_
  3454 000019B1 AD                  <1>  lodsd
  3455 000019B2 E90F000000                  jmp accept
  3456                                  
  3457                                  nul0:
  3458                                      _DROP_
  3459 000019B7 AD                  <1>  lodsd
  3460 000019B8 EB22                        jmp short accept2
  3461                                  
  3462                                  clearHintChar:
  3463 000019BA 50                          push _TOS_
  3464 000019BB 31C0                        xor _TOS_, _TOS_
  3465 000019BD C605[90390000]00            mov byte [ v_hintChar ], 0x00   ; clear the hint character
  3466 000019C4 58                          pop _TOS_
  3467 000019C5 C3                          ret
  3468                                  
  3469                                  accept:     ; get a word from keyboard
  3470 000019C6 C705[9C390000]-             mov dword [ shiftAction ], alpha0
  3471 000019CC [A2170000]         
  3472 000019D0 8D3D[24140000]              lea edi, [ alphaKeyboard - 4]
  3473                                  accept1:
  3474 000019D6 893D[98390000]              mov [ dword currentKeyboardIcons ], edi
  3475                                  accept2:
  3476 000019DC F705[80390000]FFFF-         test dword [ x_qwerty ], 0xFFFFFFFF
  3477 000019E4 FFFF               
  3478 000019E6 7406                        jz .forward
  3479 000019E8 FF25[80390000]              jmp dword [ x_qwerty ]          ; jump to the address in x_qwerty if it is non-zero
  3480                                  .forward:
  3481 000019EE E86EFCFFFF                  call get_key_                    ; calls pause_ while waiting for a character
  3482 000019F3 3C04                        cmp al, 0x04                    ; 
  3483 000019F5 7909                        jns .forward2
  3484 000019F7 8B15[9C390000]              mov edx, [ shiftAction ]
  3485 000019FD FF2482                      jmp dword [ edx + _TOS_ * 4 ]   ; alpha0 jump table element 
  3486                                  .forward2:
  3487 00001A00 8305[9C390000]14            add dword [ shiftAction ], byte +0x14
  3488 00001A07 E860FEFFFF                  call word_
  3489 00001A0C FF15[B0390000]              call [ aword ]
  3490 00001A12 EBB2                        jmp short accept                ; endless loop
  3491                                  
  3492                                  alphn:
  3493                                   _DROP_
  3494 00001A14 AD                  <1>  lodsd
  3495                                  
  3496                                  alph0:
  3497 00001A15 C705[9C390000]-             mov dword [ shiftAction ], alpha0
  3498 00001A1B [A2170000]         
  3499 00001A1F 8D3D[24140000]              lea edi, [ alphaKeyboard - 4 ]
  3500 00001A25 EB10                        jmp short Xstar0
  3501                                  
  3502                                  star0:
  3503 00001A27 C705[9C390000]-             mov dword [ shiftAction ], graph0
  3504 00001A2D [7A170000]         
  3505 00001A31 8D3D[3C140000]              lea edi, [ ( graphicsKeyboard - 4 ) ]
  3506                                      Xstar0:
  3507                                      _DROP_
  3508 00001A37 AD                  <1>  lodsd
  3509 00001A38 EB9C                        jmp short accept1
  3510                                  
  3511                                  alph:
  3512 00001A3A C705[9C390000]-             mov dword [ shiftAction ], alpha1
  3513 00001A40 [B6170000]         
  3514 00001A44 8D3D[24140000]              lea edi, [ alphaKeyboard - 4]
  3515 00001A4A EB10                        jmp short Xgraph
  3516                                  
  3517                                  graph:
  3518 00001A4C C705[9C390000]-             mov dword [ shiftAction ], graph1
  3519 00001A52 [8E170000]         
  3520 00001A56 8D3D[3C140000]              lea edi, [ ( graphicsKeyboard - 4 ) ]
  3521                                      Xgraph:
  3522 00001A5C 893D[98390000]              mov [ currentKeyboardIcons ], edi
  3523 00001A62 E959FEFFFF                  jmp dword word0
  3524                                  
  3525                                  ; *****************************************************************************
  3526                                  ; Shannon-Fano decompression and display
  3527                                  ; *****************************************************************************
  3528                                  
  3529                                  unpack:     ; ( token -- token' nextCharacter )
  3530                                      _DUP_   ; copy TOS to our data stack SOS
  3531 00001A67 83EE04              <1>  sub esi, byte 0x04
  3532 00001A6A 8906                <1>  mov [ esi ], _TOS_
  3533 00001A6C 85C0                        test _TOS_, _TOS_
  3534 00001A6E 780A                        js .forward
  3535 00001A70 C12604                      shl dword [ esi ], 0x04
  3536 00001A73 C1C004                      rol _TOS_, 0x04
  3537 00001A76 83E007                      and _TOS_, byte 0x07
  3538 00001A79 C3                          ret
  3539                                  .forward:
  3540 00001A7A D1E0                        shl _TOS_,1
  3541 00001A7C 780C                        js .forward2
  3542 00001A7E C12605                      shl dword [ esi ], 0x05
  3543 00001A81 C1C004                      rol _TOS_, 0x04
  3544 00001A84 83E007                      and _TOS_, byte 0x07
  3545 00001A87 3408                        xor al, 0x08
  3546 00001A89 C3                          ret
  3547                                  .forward2:
  3548 00001A8A C12607                      shl dword [ esi ], 0x07
  3549 00001A8D C1C006                      rol _TOS_, 0x06
  3550 00001A90 83E03F                      and _TOS_, byte 0x3F
  3551 00001A93 2C10                        sub al, 0x10
  3552 00001A95 C3                          ret
  3553                                  
  3554                                  qring:  ; ( a cursor -- a' )  edx  contains pointer to current address to display
  3555                                      _DUP_
  3556 00001A96 83EE04              <1>  sub esi, byte 0x04
  3557 00001A99 8906                <1>  mov [ esi ], _TOS_
  3558 00001A9B FF06                        inc dword [ esi ]
  3559 00001A9D 393D[30390000]              cmp [ v_curs ], edi
  3560 00001AA3 7505                        jnz .forward                ; address to display = cursor address?
  3561 00001AA5 A3[30390000]                mov [ v_curs ], _TOS_       ; yes,
  3562                                  .forward:
  3563 00001AAA 3B05[30390000]              cmp _TOS_, [ v_curs ]       ; no
  3564 00001AB0 740A                        jz .forward2
  3565 00001AB2 7906                        jns .forward4               ; time to draw the cursor?
  3566 00001AB4 893D[54390000]              mov [ v_pcad ], edi         ; no, so exit
  3567                                  .forward4:
  3568                                  ;     _DUP_
  3569                                  ;     mov _TOS_, 0x0F
  3570                                  ;     call doColourBlind             ; display the final colourblind punctuation, set up for next call of plusList
  3571                                      _DROP_
  3572 00001ABA AD                  <1>  lodsd
  3573 00001ABB C3                          ret                             ; exit here
  3574                                  .forward2:
  3575 00001ABC 893D[50390000]              mov [ v_cad ], edi
  3576 00001AC2 53                          push _SCRATCH_
  3577 00001AC3 8B1D[7C390000]              mov _SCRATCH_, [ v_10000_iconw ]
  3578 00001AC9 291D[343A0000]              sub dword [ v_xy ], _SCRATCH_  ; move one icon's worth of horizontal pixels to the left
  3579                                      _DUP_
  3580 00001ACF 83EE04              <1>  sub esi, byte 0x04
  3581 00001AD2 8906                <1>  mov [ esi ], _TOS_
  3582 00001AD4 8B1D[483A0000]              mov _SCRATCH_, [ v_foregroundColour ]   ; save the current colour
  3583 00001ADA B800E20000                  mov _TOS_, colour_PacMan
  3584 00001ADF E830EFFFFF                  call color
  3585 00001AE4 B830000000                  mov _TOS_, 0x30   ; display the "PacMan" cursor
  3586 00001AE9 668B0D[363A0000]            mov cx, [ v_x ]
  3587 00001AF0 663B0D[3C3A0000]            cmp cx, [ v_rightMargin ]
  3588 00001AF7 7816                        js .forward5
  3589 00001AF9 E881F3FFFF                  call emit_
  3590 00001AFE 8B1D[7C390000]              mov _SCRATCH_, [ v_10000_iconw ]
  3591 00001B04 291D[343A0000]              sub dword [ v_xy ], _SCRATCH_  ; move one icon's worth of horizontal pixels to the left
  3592 00001B0A E905000000                  jmp .forward6
  3593                                  .forward5:
  3594 00001B0F E86BF3FFFF                  call emit_
  3595                                  .forward6:
  3596 00001B14 891D[483A0000]              mov dword [ v_foregroundColour ], _SCRATCH_     ; restore the current colour
  3597 00001B1A 5B                          pop _SCRATCH_
  3598 00001B1B C3                          ret
  3599                                  
  3600                                  ; *****************************************************************************
  3601                                  ; Conventional Forth display (does not require colours)
  3602                                  ; *****************************************************************************
  3603                                  
  3604                                  currentState:
  3605 00001B1C 00000000                    dd 0
  3606                                  
  3607                                  lastState:
  3608 00001B20 00000000                    dd 0
  3609                                  
  3610                                  txt0:
  3611 00001B24 E8E1EEFFFF                  call white
  3612                                      EMIT_IMM( 0x6D )
  3613                              <1> 
  3614                              <1>  _DUP_
  3615 00001B29 83EE04              <2>  sub esi, byte 0x04
  3616 00001B2C 8906                <2>  mov [ esi ], _TOS_
  3617 00001B2E B86D000000          <1>  mov _TOS_, %1
  3618 00001B33 E847F3FFFF          <1>  call emit_
  3619                              <1> 
  3620 00001B38 E854F3FFFF                  call space_
  3621 00001B3D C3                          ret
  3622                                  
  3623                                  txt1:
  3624 00001B3E E8C7EEFFFF                  call white
  3625                                      EMIT_IMM( 0x6E )
  3626                              <1> 
  3627                              <1>  _DUP_
  3628 00001B43 83EE04              <2>  sub esi, byte 0x04
  3629 00001B46 8906                <2>  mov [ esi ], _TOS_
  3630 00001B48 B86E000000          <1>  mov _TOS_, %1
  3631 00001B4D E82DF3FFFF          <1>  call emit_
  3632                              <1> 
  3633 00001B52 E83AF3FFFF                  call space_
  3634 00001B57 C3                          ret
  3635                                  
  3636                                  imm0:
  3637 00001B58 E88FEEFFFF                  call yellow
  3638                                      EMIT_IMM( 0x58 )
  3639                              <1> 
  3640                              <1>  _DUP_
  3641 00001B5D 83EE04              <2>  sub esi, byte 0x04
  3642 00001B60 8906                <2>  mov [ esi ], _TOS_
  3643 00001B62 B858000000          <1>  mov _TOS_, %1
  3644 00001B67 E813F3FFFF          <1>  call emit_
  3645                              <1> 
  3646 00001B6C E820F3FFFF                  call space_
  3647 00001B71 C3                          ret
  3648                                  
  3649                                  imm1:
  3650 00001B72 E875EEFFFF                  call yellow
  3651                                      EMIT_IMM( 0x59 )
  3652                              <1> 
  3653                              <1>  _DUP_
  3654 00001B77 83EE04              <2>  sub esi, byte 0x04
  3655 00001B7A 8906                <2>  mov [ esi ], _TOS_
  3656 00001B7C B859000000          <1>  mov _TOS_, %1
  3657 00001B81 E8F9F2FFFF          <1>  call emit_
  3658                              <1> 
  3659 00001B86 E806F3FFFF                  call space_
  3660 00001B8B C3                          ret
  3661                                  
  3662                                  mvar0:
  3663 00001B8C E85BEEFFFF                  call yellow
  3664                                      EMIT_IMM( 0x58 ) ; '['
  3665                              <1> 
  3666                              <1>  _DUP_
  3667 00001B91 83EE04              <2>  sub esi, byte 0x04
  3668 00001B94 8906                <2>  mov [ esi ], _TOS_
  3669 00001B96 B858000000          <1>  mov _TOS_, %1
  3670 00001B9B E8DFF2FFFF          <1>  call emit_
  3671                              <1> 
  3672 00001BA0 E8ECF2FFFF                  call space_
  3673                                      EMIT_IMM( 0x09 ) ; 'm'
  3674                              <1> 
  3675                              <1>  _DUP_
  3676 00001BA5 83EE04              <2>  sub esi, byte 0x04
  3677 00001BA8 8906                <2>  mov [ esi ], _TOS_
  3678 00001BAA B809000000          <1>  mov _TOS_, %1
  3679 00001BAF E8CBF2FFFF          <1>  call emit_
  3680                              <1> 
  3681                                      EMIT_IMM( 0x11 ) ; 'v'
  3682                              <1> 
  3683                              <1>  _DUP_
  3684 00001BB4 83EE04              <2>  sub esi, byte 0x04
  3685 00001BB7 8906                <2>  mov [ esi ], _TOS_
  3686 00001BB9 B811000000          <1>  mov _TOS_, %1
  3687 00001BBE E8BCF2FFFF          <1>  call emit_
  3688                              <1> 
  3689                                      EMIT_IMM( 0x05 ) ; 'a'
  3690                              <1> 
  3691                              <1>  _DUP_
  3692 00001BC3 83EE04              <2>  sub esi, byte 0x04
  3693 00001BC6 8906                <2>  mov [ esi ], _TOS_
  3694 00001BC8 B805000000          <1>  mov _TOS_, %1
  3695 00001BCD E8ADF2FFFF          <1>  call emit_
  3696                              <1> 
  3697                                      EMIT_IMM( 0x01 ) ; 'r'
  3698                              <1> 
  3699                              <1>  _DUP_
  3700 00001BD2 83EE04              <2>  sub esi, byte 0x04
  3701 00001BD5 8906                <2>  mov [ esi ], _TOS_
  3702 00001BD7 B801000000          <1>  mov _TOS_, %1
  3703 00001BDC E89EF2FFFF          <1>  call emit_
  3704                              <1> 
  3705 00001BE1 E8ABF2FFFF                  call space_
  3706 00001BE6 C3                          ret
  3707                                  
  3708                                  mvar1:
  3709 00001BE7 E800EEFFFF                  call yellow
  3710                                      EMIT_IMM( 0x59 ) ; ']'
  3711                              <1> 
  3712                              <1>  _DUP_
  3713 00001BEC 83EE04              <2>  sub esi, byte 0x04
  3714 00001BEF 8906                <2>  mov [ esi ], _TOS_
  3715 00001BF1 B859000000          <1>  mov _TOS_, %1
  3716 00001BF6 E884F2FFFF          <1>  call emit_
  3717                              <1> 
  3718 00001BFB E891F2FFFF                  call space_
  3719 00001C00 C3                          ret
  3720                                  
  3721                                  taupe0:
  3722 00001C01 E8F5EDFFFF                  call taupe
  3723                                      EMIT_IMM( 0x63 ) ; '"'
  3724                              <1> 
  3725                              <1>  _DUP_
  3726 00001C06 83EE04              <2>  sub esi, byte 0x04
  3727 00001C09 8906                <2>  mov [ esi ], _TOS_
  3728 00001C0B B863000000          <1>  mov _TOS_, %1
  3729 00001C10 E86AF2FFFF          <1>  call emit_
  3730                              <1> 
  3731 00001C15 E877F2FFFF                  call space_
  3732 00001C1A C3                          ret
  3733                                  
  3734                                  taupe1:
  3735 00001C1B E8DBEDFFFF                  call taupe
  3736                                      EMIT_IMM( 0x63 ) ; '"'
  3737                              <1> 
  3738                              <1>  _DUP_
  3739 00001C20 83EE04              <2>  sub esi, byte 0x04
  3740 00001C23 8906                <2>  mov [ esi ], _TOS_
  3741 00001C25 B863000000          <1>  mov _TOS_, %1
  3742 00001C2A E850F2FFFF          <1>  call emit_
  3743                              <1> 
  3744 00001C2F E85DF2FFFF                  call space_
  3745 00001C34 C3                          ret
  3746                                  
  3747                                  ; unfortunately we need to display the ':' after the CR, so must do this in  redWord , not here
  3748                                  ; colon0:
  3749                                  ;     call red
  3750                                  ;     EMIT_IMM( 0x59 )
  3751                                  ;     call space_
  3752                                  ;     ret
  3753                                  ;
  3754                                  ;     dd nul, imm0, nul, colon0, nul, nul, nul, nul, nul, txt0, nul, nul, mvar0, nul, nul, nul
  3755                                  
  3756                                  txts:
  3757 00001C35 000101030405060701-         db 0, 1, 1, 3, 4, 5, 6, 7, 1, 9, 9, 9, 12, 13, 14, 15
  3758 00001C3E 0909090C0D0E0F     
  3759                                  
  3760                                  tx:     ; ( c -- c )   \ return the value in the given offset in  txts
  3761 00001C45 25FF000000                  and _TOS_, 0xFF
  3762 00001C4A 8B80[351C0000]              mov _TOS_, [ _TOS_ + txts ]
  3763 00001C50 25FF000000                  and _TOS_, 0xFF
  3764 00001C55 C3                          ret
  3765                                  
  3766                                  newActions:
  3767 00001C56 [00040000]-                 dd nul, imm0, nul, nul, nul, nul, nul, nul, nul, txt0, nul, nul, mvar0, nul, nul, taupe0
  3768 00001C5A [581B0000]-        
  3769 00001C5E [00040000]-        
  3770 00001C62 [00040000]-        
  3771 00001C66 [00040000]-        
  3772 00001C6A [00040000]-        
  3773 00001C6E [00040000]-        
  3774 00001C72 [00040000]-        
  3775 00001C76 [00040000]-        
  3776 00001C7A [241B0000]-        
  3777 00001C7E [00040000]-        
  3778 00001C82 [00040000]-        
  3779 00001C86 [8C1B0000]-        
  3780 00001C8A [00040000]-        
  3781 00001C8E [00040000]-        
  3782 00001C92 [011C0000]         
  3783                                  
  3784                                  dotNew:     ; ( state -- )
  3785 00001C96 FF1485[561C0000]            call [ ( _TOS_ * 4 ) + newActions ]
  3786 00001C9D C3                          ret
  3787                                  
  3788                                  oldActions:
  3789 00001C9E [00040000]-                 dd nul, imm1, nul, nul, nul, nul, nul, nul, nul, txt1, nul, nul, mvar1, nul, nul, taupe1
  3790 00001CA2 [721B0000]-        
  3791 00001CA6 [00040000]-        
  3792 00001CAA [00040000]-        
  3793 00001CAE [00040000]-        
  3794 00001CB2 [00040000]-        
  3795 00001CB6 [00040000]-        
  3796 00001CBA [00040000]-        
  3797 00001CBE [00040000]-        
  3798 00001CC2 [3E1B0000]-        
  3799 00001CC6 [00040000]-        
  3800 00001CCA [00040000]-        
  3801 00001CCE [E71B0000]-        
  3802 00001CD2 [00040000]-        
  3803 00001CD6 [00040000]-        
  3804 00001CDA [1B1C0000]         
  3805                                  
  3806                                  dotOld:     ; ( state -- )
  3807 00001CDE FF1485[9E1C0000]            call [ ( _TOS_ * 4 ) + oldActions ]
  3808 00001CE5 C3                          ret
  3809                                  
  3810                                  colourBlindAction:  ; ( state -- state )    \ perform the required actionon change of state
  3811 00001CE6 53                          push _SCRATCH_
  3812                                      _DUP_
  3813 00001CE7 83EE04              <1>  sub esi, byte 0x04
  3814 00001CEA 8906                <1>  mov [ esi ], _TOS_
  3815 00001CEC E854FFFFFF                  call tx
  3816 00001CF1 3D00000000                  cmp _TOS_, 0x00
  3817 00001CF6 743F                        jz .end                             ; no action on extension tokens, value 0
  3818 00001CF8 8B1D[1C1B0000]              mov _SCRATCH_, [ currentState ]
  3819 00001CFE A3[1C1B0000]                mov [ currentState ], _TOS_
  3820 00001D03 3B1D[1C1B0000]              cmp _SCRATCH_, [ currentState ]     ; compare the new state on TOS to the last one saved in currentState
  3821 00001D09 742C                        jz .end                             ; exit if there has been no change of state
  3822                                      _DUP_
  3823 00001D0B 83EE04              <1>  sub esi, byte 0x04
  3824 00001D0E 8906                <1>  mov [ esi ], _TOS_
  3825 00001D10 89D8                        mov _TOS_, _SCRATCH_
  3826 00001D12 E8C7FFFFFF                  call dotOld                         ;
  3827 00001D17 A1[1C1B0000]                mov _TOS_, [ currentState ]
  3828 00001D1C E875FFFFFF                  call dotNew
  3829                                      _DROP_
  3830 00001D21 AD                  <1>  lodsd
  3831 00001D22 803D[1C1B0000]00            cmp byte [ currentState ], 0x0000
  3832 00001D29 740C                        jz .end
  3833 00001D2B 8B1D[1C1B0000]              mov _SCRATCH_, [ currentState ]
  3834 00001D31 891D[201B0000]              mov [ lastState ], _SCRATCH_
  3835                                   .end:
  3836                                      _DROP_
  3837 00001D37 AD                  <1>  lodsd
  3838 00001D38 5B                          pop _SCRATCH_
  3839 00001D39 C3                          ret
  3840                                  
  3841                                  ; \ Block 70
  3842                                  ; ( Colourblind Editor Display )
  3843                                  ; #1 MagentaV currentState $01 MagentaV lastState
  3844                                  ; : +txt white $6D emit space ;
  3845                                  ; : -txt white $6E emit space ;
  3846                                  ; : +imm yellow $58 emit space ;
  3847                                  ; : -imm yellow $59 emit space ;
  3848                                  ; : +mvar yellow $09 emit $11 emit $05 emit $01 emit space ;
  3849                                  ; : txts string $03010100 , $07060504 , $09090901 , $0F0E0D0C , ( ; )
  3850                                  ; : tx ( c-c ) $0F and txts + 1@ $0F and ;
  3851                                  ; : .new currentState @ $0F and jump nul +imm nul nul nul nul nul nul nul +txt nul nul +mvar nul nul nul ;
  3852                                  ; : .old lastState @ $0F and jump nul -imm nul nul nul nul nul nul nul -txt nul nul nul nul nul nul ;
  3853                                  ; here
  3854                                  ; : cb ( n-n ) #0 + 0if ; then tx
  3855                                  ;    currentState @ swap dup currentState ! - drop if .old .new
  3856                                  ;    currentState @ #0 + if dup lastState ! then then ;
  3857                                  ; : cbs ( -- here ) #0 + $00 + cblind ! ;
  3858                                  
  3859                                  ; colourBlind:    ; ( state -- state )    \ vectored colorForth to display colourBlind extra characters ( e.g. ':' for red words )
  3860                                  ;    call dword [ x_colourBlind ]
  3861                                  ;    ret
  3862                                  
  3863                                  ; *****************************************************************************
  3864                                  
  3865                                  lowercase:   ; display a white text word in normal lower-case letters
  3866 00001D3A E8CBECFFFF                  call white
  3867                                  type_:  ; ( -- )   \ display a Shanon-Fano encoded word pointed to by  edi  in the current colour
  3868                                      _DUP_
  3869 00001D3F 83EE04              <1>  sub esi, byte 0x04
  3870 00001D42 8906                <1>  mov [ esi ], _TOS_
  3871 00001D44 8B04BDFCFFFFFF              mov _TOS_, [ ( edi * 4 ) - 0x04 ]
  3872                                  showShannonFano:    ; ( token -- ) \ display the given Shanon-Fano encoded word in the current colour
  3873 00001D4B 83E0F0                      and _TOS_, byte -0x10
  3874                                  lowercasePrimitive:  ; ( token -- ) \ display the given Shanon-Fano encoded word in the current colour
  3875 00001D4E E814FDFFFF                  call unpack
  3876 00001D53 740A                        jz lowercasePrimitiveEnd
  3877 00001D55 E825F1FFFF                  call emit_
  3878 00001D5A E9EFFFFFFF                  jmp lowercasePrimitive
  3879                                  lowercasePrimitiveEnd:
  3880 00001D5F E82DF1FFFF                  call space_
  3881                                      _DROP_
  3882 00001D64 AD                  <1>  lodsd
  3883                                      _DROP_
  3884 00001D65 AD                  <1>  lodsd
  3885 00001D66 C3                          ret
  3886                                  
  3887                                  typeNumber32tok:     ; ( token -- ) \ display the given Shanon-Fano encoded word as a number in the current colour
  3888                                      _DROP_ ; call dotHex8
  3889 00001D67 AD                  <1>  lodsd
  3890 00001D68 C705[8C1D0000]FFFF-         mov dword [ lastTokenWasLiteral ], 0xFFFFFFF
  3891 00001D70 FF0F               
  3892 00001D72 C3                          ret
  3893                                  
  3894                                  typeNumber32:     ; ( token -- ) \ display the given Shanon-Fano encoded word as a hex number in the current colour
  3895 00001D73 E86BF3FFFF                  call dotHex8
  3896 00001D78 C705[8C1D0000]0000-         mov dword [ lastTokenWasLiteral ], 0x00000000
  3897 00001D80 0000               
  3898 00001D82 C3                          ret
  3899                                  
  3900                                  typeNumber27:     ; ( token -- ) \ display the given Shanon-Fano encoded word as a 27 bit hex number in the current colour
  3901 00001D83 C1E805                      shr _TOS_, 5
  3902 00001D86 E86BF3FFFF                  call dotHex
  3903 00001D8B C3                          ret
  3904                                  
  3905                                  lastTokenWasLiteral:
  3906 00001D8C 00000000                    dd 0x00
  3907                                  
  3908                                  lastShannonFanoToken:
  3909 00001D90 00000000                    dd 0x00
  3910                                  
  3911                                  magentaPrimitive:   ; ( token -- )
  3912 00001D94 E8B5FFFFFF                  call lowercasePrimitive
  3913 00001D99 C705[8C1D0000]FFFF-         mov dword [ lastTokenWasLiteral ], 0xFFFFFFF
  3914 00001DA1 FF0F               
  3915 00001DA3 C3                          ret
  3916                                  
  3917                                  displayOneShannonFanoActions:   ;    * = number
  3918 00001DA4 [4E1D0000]                  dd lowercasePrimitive       ; 0     extension token, remove space from previous word, do not change the colour
  3919 00001DA8 [4E1D0000]                  dd lowercasePrimitive       ; 1     yellow "immediate" word
  3920 00001DAC [671D0000]                  dd typeNumber32tok          ; 2  *  yellow "immediate" 32 bit number in the following pre-parsed cell
  3921 00001DB0 [4E1D0000]                  dd lowercasePrimitive       ; 3     red forth wordlist "colon" word
  3922 00001DB4 [4E1D0000]                  dd lowercasePrimitive       ; 4     green compiled word
  3923 00001DB8 [671D0000]                  dd typeNumber32tok          ; 5  *  green compiled 32 bit number in the following pre-parsed cell
  3924 00001DBC [831D0000]                  dd typeNumber27             ; 6  *  green compiled 27 bit number in the high bits of the token
  3925 00001DC0 [4E1D0000]                  dd lowercasePrimitive       ; 7     cyan macro wordlist "colon" word
  3926 00001DC4 [831D0000]                  dd typeNumber27             ; 8  *  yellow "immediate" 27 bit number in the high bits of the token
  3927 00001DC8 [4E1D0000]                  dd lowercasePrimitive       ; 9     white lower-case comment
  3928 00001DCC [341F0000]                  dd camelcasePrimitive       ; A     first letter capital comment
  3929 00001DD0 [591F0000]                  dd uppercasePrimitive       ; B     white upper-case comment
  3930 00001DD4 [941D0000]                  dd magentaPrimitive         ; C     magenta variable
  3931 00001DD8 [4E1D0000]                  dd lowercasePrimitive       ; D
  3932 00001DDC [4E1D0000]                  dd lowercasePrimitive       ; E     editor formatting commands
  3933 00001DE0 [4E1D0000]                  dd lowercasePrimitive       ; F
  3934                                  
  3935 00001DE4 55<rept>                times 0x20 db 0x55
  3936                                  testme:
  3937 00001E04 FF0C2475                    dd 0x75240CFF ; 0xFF, 0x0C, 0x24, 0x75
  3938 00001E08 56341200                    dd 0x123456
  3939 00001E0C C3                          ret
  3940 00001E0D 77<rept>                times 0x20 db 0x77
  3941                                  
  3942                                  leave_:     ; terminate a  for ... next  loop
  3943 00001E2D C744240401000000            mov dword [ esp + 4 ], 0x01
  3944 00001E35 C3                          ret
  3945                                  
  3946                                  dotsf_:  ; ( token -- )   \ display the given Shannon-Fano encoded word in the token's colour
  3947 00001E36 57                          push edi
  3948 00001E37 89C2                        mov edx , _TOS_
  3949 00001E39 25F0FFFFFF                  and _TOS_, 0xFFFFFFF0
  3950                                      _DUP_
  3951 00001E3E 83EE04              <1>  sub esi, byte 0x04
  3952 00001E41 8906                <1>  mov [ esi ], _TOS_
  3953 00001E43 8B3D[8C1D0000]              mov edi, [ lastTokenWasLiteral ]
  3954 00001E49 F7C700000000                test edi, 0x00000000
  3955 00001E4F 7405                        jz .forward3
  3956 00001E51 BA00000000                  mov edx, 0
  3957                                  .forward3:
  3958 00001E56 83E20F                      and edx, byte 0x0F
  3959 00001E59 7533                        jnz .forward     ; do not change the colour if this is an extension token
  3960                                          ; this is an extension token
  3961 00001E5B 8B15[901D0000]                  mov edx, [ lastShannonFanoToken ]
  3962                                          ; if the colour is Camelcase 0x0A, make it lowercase 0x09
  3963                                          ; e.g. Interrupt would be shown as InterrUpt if the exension token is displayed with an initial Capital
  3964 00001E61 89D3                            mov _SCRATCH_, edx
  3965 00001E63 81E30F000000                    and _SCRATCH_, 0x0F     ; just the colour
  3966 00001E69 81EB0A000000                    sub _SCRATCH_, 0x0A
  3967 00001E6F 750C                            jne .foward4
  3968 00001E71 81E2F0FFFFFF                        and edx, 0xFFFFFFF0     ; remove the colour
  3969 00001E77 81CA09000000                        or edx, 0x00000009      ; make it lowercase
  3970                                          .foward4:
  3971 00001E7D 8B1D[7C390000]                  mov _SCRATCH_, [ v_10000_iconw ]
  3972 00001E83 291D[343A0000]                  sub dword [ v_xy ], _SCRATCH_   ; move iconw horizontal pixels back, to remove the space at the end of the last word
  3973 00001E89 E906000000                  jmp .forward2
  3974                                      .forward:
  3975                                          ; this is not an extension token
  3976 00001E8E 8915[901D0000]                  mov [ lastShannonFanoToken ], edx
  3977                                      .forward2:
  3978 00001E94 50                          push _TOS_
  3979 00001E95 8B0495[AC220000]            mov _TOS_, [ ( edx * 4 ) + actionColourTable ]
  3980 00001E9C E873EBFFFF                  call color
  3981 00001EA1 58                          pop _TOS_
  3982 00001EA2 FF1495[A41D0000]            call [ ( edx * 4 ) + displayOneShannonFanoActions ]
  3983 00001EA9 5F                          pop edi
  3984 00001EAA C3                          ret
  3985                                  
  3986                                  redWord:     ; display a red word
  3987 00001EAB 668B0D[363A0000]            mov cx, [ v_x ]
  3988 00001EB2 663B0D[383A0000]            cmp cx, [ v_leftMargin ]
  3989 00001EB9 7410                        jz .forward     ; do not do a  cr  if we are already at the left margin
  3990 00001EBB 8A0D[8E390000]              mov cl, [ v_not_cr ]
  3991 00001EC1 80F900                      cmp cl, 0
  3992 00001EC4 7505                        jnz .forward    ; do not do a  cr  if it has been disabled by a blue  -cr  token
  3993 00001EC6 E8F4EAFFFF                  call cr_
  3994                                  .forward:
  3995 00001ECB C605[8E390000]00            mov byte [ v_not_cr ], 0
  3996 00001ED2 E89FF0FFFF                  call setRed
  3997                                  
  3998 00001ED7 803D[8D390000]00            cmp byte [ v_colourBlindMode ], 0x00
  3999 00001EDE 741D                        jz .forward2
  4000 00001EE0 F605[10390000]01            test byte [ v_blk ], 0x01   ; do not display colourblind characters in odd numbered shadow blocks
  4001 00001EE7 7514                        jnz .forward2
  4002                                      EMIT_IMM( 0x29 )    ; emit a ':' if in colourblind mode
  4003                              <1> 
  4004                              <1>  _DUP_
  4005 00001EE9 83EE04              <2>  sub esi, byte 0x04
  4006 00001EEC 8906                <2>  mov [ esi ], _TOS_
  4007 00001EEE B829000000          <1>  mov _TOS_, %1
  4008 00001EF3 E887EFFFFF          <1>  call emit_
  4009                              <1> 
  4010 00001EF8 E894EFFFFF                  call space_
  4011                                  .forward2:
  4012 00001EFD E93DFEFFFF                  jmp type_
  4013                                  
  4014                                  greenWord:     ; display a green word
  4015 00001F02 E87EF0FFFF                  call setGreen  
  4016 00001F07 E933FEFFFF                  jmp type_
  4017                                  
  4018                                  cyanWord:     ; display a cyan word
  4019 00001F0C E829F0FFFF                  call setCyan
  4020 00001F11 E929FEFFFF                  jmp type_
  4021                                  
  4022                                  yellowWord:     ; display a yellow word
  4023 00001F16 E8D1EAFFFF                  call yellow
  4024 00001F1B E91FFEFFFF                  jmp type_
  4025                                  
  4026                                  camelcase:    ; display a white word with the first letter Capitalised
  4027 00001F20 E8E5EAFFFF                  call white
  4028                                      _DUP_
  4029 00001F25 83EE04              <1>  sub esi, byte 0x04
  4030 00001F28 8906                <1>  mov [ esi ], _TOS_
  4031 00001F2A 8B04BDFCFFFFFF              mov _TOS_, [ ( edi * 4 ) - 0x04 ]
  4032 00001F31 83E0F0                      and _TOS_, byte -0x10
  4033                                  camelcasePrimitive:
  4034 00001F34 E82EFBFFFF                  call unpack
  4035 00001F39 0430                        add al, 0x30        ; make the first character upper case
  4036 00001F3B E83FEFFFFF                  call emit_           ; display it
  4037 00001F40 E909FEFFFF                  jmp lowercasePrimitive   ; display the rest of the word
  4038                                  
  4039                                  uppercase:   ; display a white word with all letters CAPITALISED
  4040 00001F45 E8C0EAFFFF                  call white
  4041                                      _DUP_
  4042 00001F4A 83EE04              <1>  sub esi, byte 0x04
  4043 00001F4D 8906                <1>  mov [ esi ], _TOS_
  4044 00001F4F 8B04BDFCFFFFFF              mov _TOS_, [ ( edi * 4 ) - 0x04 ]
  4045 00001F56 83E0F0                      and _TOS_, byte -0x10
  4046                                  uppercasePrimitive:
  4047 00001F59 E809FBFFFF                  call unpack
  4048 00001F5E 0F84FBFDFFFF                jz lowercasePrimitiveEnd
  4049 00001F64 0430                        add al, 0x30
  4050 00001F66 E814EFFFFF                  call emit_
  4051 00001F6B E9E9FFFFFF                  jmp uppercasePrimitive
  4052                                  
  4053                                  extension:  ; display an extension token, do not change the colour
  4054 00001F70 8B1D[7C390000]              mov _SCRATCH_, [ v_10000_iconw ]
  4055 00001F76 291D[343A0000]              sub dword [ v_xy ], _SCRATCH_   ; move iconw horizontal pixels back, to remove the space at the end of the last word
  4056 00001F7C F704BDFCFFFFFFF0FF-         test dword [ ( edi * 4 ) - 0x04 ], 0xFFFFFFF0
  4057 00001F85 FFFF               
  4058 00001F87 0F85B2FDFFFF                jnz type_
  4059 00001F8D 4F                          dec edi
  4060 00001F8E 893D[58390000]              mov [ v_lcad ], edi
  4061 00001F94 E8F8EEFFFF                  call space_
  4062 00001F99 E8F8FAFFFF                  call qring
  4063 00001F9E 5A                          pop edx                         ; EXIT from calling word
  4064                                      _DROP_                          ; the ret below will return to the word that called  extension
  4065 00001F9F AD                  <1>  lodsd
  4066 00001FA0 C3                          ret                             ; so it looks like it never happened
  4067                                  
  4068                                  greenShortNumber:    ; display the green compiled 27 bit number in the high bits of the token
  4069 00001FA1 8B14BDFCFFFFFF              mov edx, [ ( edi * 4 ) - 0x04 ]
  4070 00001FA8 C1FA05                      sar edx, 0x05
  4071 00001FAB EB74                        jmp short greenNumber1
  4072                                  
  4073                                  magentaVariable:    ; display a magenta variable using the 32 bit number in the following pre-parsed cell
  4074 00001FAD C705[0C390000]-             mov dword [ x_numberDisplay ], dotDecimal
  4075 00001FB3 [34110000]         
  4076 00001FB7 833D[A0390000]0A            cmp dword [ base ], byte 0x0A   ; check the current BASE value ( 10 or 16 for decimal or hex)
  4077 00001FBE 740A                        jz .forward
  4078 00001FC0 C705[0C390000]-             mov dword [ x_numberDisplay ], dotHex
  4079 00001FC6 [F6100000]         
  4080                                  .forward:
  4081 00001FCA E87AEFFFFF                  call setMagenta
  4082 00001FCF E86BFDFFFF                  call type_              ; display the name of the variable
  4083 00001FD4 8B14BD00000000              mov edx, [ ( edi * 4 ) + 0x00 ]    ; load the value of the variable from the pre-parsed source
  4084 00001FDB 47                          inc edi                 ; step over the variable value in the pre-parsed source
  4085 00001FDC E877EFFFFF                  call setMagentaData
  4086 00001FE1 EB5E                        jmp short displayNumber
  4087                                  
  4088                                  taupeString:    ; display a taupe string using the following 32 bit pre-parsed cell
  4089 00001FE3 C705[0C390000]-             mov dword [ x_numberDisplay ], dotDecimal
  4090 00001FE9 [34110000]         
  4091 00001FED 833D[A0390000]0A            cmp dword [ base ], byte 0x0A   ; check the current BASE value ( 10 or 16 for decimal or hex)
  4092 00001FF4 740A                        jz .forward
  4093 00001FF6 C705[0C390000]-             mov dword [ x_numberDisplay ], dotHex
  4094 00001FFC [F6100000]         
  4095                                  .forward:
  4096 00002000 E89EEFFFFF                  call setTaupe
  4097 00002005 E835FDFFFF                  call type_              ; display the string
  4098 0000200A 8B14BD00000000              mov edx, [ ( edi * 4 ) + 0x00 ]    ; load the value of the variable from the pre-parsed source
  4099 00002011 47                          inc edi                 ; step over the variable value in the pre-parsed source
  4100 00002012 E841EFFFFF                  call setMagentaData
  4101 00002017 EB28                        jmp short displayNumber
  4102                                  
  4103                                  greenNumber:                ; display the value of a hexadecimal/decimal number in green
  4104 00002019 8B14BD00000000              mov edx, [ ( edi * 4 ) + 0x00 ]    ; load the value of the variable from the pre-parsed source
  4105 00002020 47                          inc edi                 ; step over the variable value in the pre-parsed source
  4106                                  greenNumber1:
  4107 00002021 E8B7E9FFFF                  call green
  4108 00002026 EB19                        jmp short displayNumber
  4109                                  
  4110                                  yellowShortNumber:
  4111 00002028 8B14BDFCFFFFFF              mov edx, [ ( edi * 4 ) - 0x04 ] ; load the value of the number from the current token in the pre-parsed source
  4112 0000202F C1FA05                      sar edx, 0x05                   ; remove the token colour bits
  4113 00002032 EB08                        jmp short yellowNumber1
  4114                                  
  4115                                  yellowNumber:     ; ( -- ) display a number word, constant value following in the pre-parsed source
  4116 00002034 8B14BD00000000              mov edx, [ ( edi * 4 ) + 0x00 ]    ; load the value of the number from the pre-parsed source
  4117 0000203B 47                          inc edi                 ; step over the number value in the pre-parsed source
  4118                                  yellowNumber1:    ; ( -- ) display a yellow number word
  4119 0000203C E8ABE9FFFF                  call yellow
  4120                                  displayNumber: ; ( rgb -- )   display the number in edx  with the given colour, using the base implied in  x_numberDisplay
  4121                                      _DUP_
  4122 00002041 83EE04              <1>  sub esi, byte 0x04
  4123 00002044 8906                <1>  mov [ esi ], _TOS_
  4124 00002046 89D0                        mov _TOS_, edx
  4125                                      ; jmp qdot
  4126 00002048 FF25[0C390000]              jmp dword [ x_numberDisplay ]
  4127                                  
  4128                                  ; *****************************************************************************
  4129                                  ; Blue words - formatting the editor display
  4130                                  ; *****************************************************************************
  4131                                  
  4132                                  get_x:  ; ( -- c )  \ return the current x character position
  4133 0000204E 52                          push edx
  4134                                      _DUP_
  4135 0000204F 83EE04              <1>  sub esi, byte 0x04
  4136 00002052 8906                <1>  mov [ esi ], _TOS_
  4137 00002054 31C0                        xor _TOS_, _TOS_
  4138 00002056 66A1[363A0000]              mov ax, word [ v_x ]
  4139 0000205C 31D2                        xor edx, edx                    ; clear high 32 bits of dividend
  4140 0000205E F735[68390000]              div dword [ v_iconw ]           ; EDX:EAX divided by the icon width , EAX now contains the current character position, EDX the remainder
  4141 00002064 5A                          pop edx
  4142 00002065 C3                          ret
  4143                                  
  4144                                  set_x:  ; ( c -- )  \ set the current x character position
  4145 00002066 52                          push edx
  4146 00002067 31D2                        xor edx, edx
  4147 00002069 F725[68390000]              mul dword [ v_iconw ]
  4148 0000206F 66A3[363A0000]              mov word [ v_x ], ax
  4149 00002075 5A                          pop edx
  4150                                      _DROP_
  4151 00002076 AD                  <1>  lodsd
  4152 00002077 C3                          ret
  4153                                  
  4154                                  %define TAB_SIZE  24
  4155                                  
  4156                                  tab:    ; ( -- )    \ align to the next n character column
  4157                                  ;    _DUP_
  4158 00002078 60                          pusha
  4159 00002079 E8D0FFFFFF                  call get_x
  4160 0000207E 31D2                        xor edx, edx                    ; clear high 32 bits of dividend
  4161 00002080 BB18000000                  mov _SCRATCH_, TAB_SIZE
  4162 00002085 F7F3                        div _SCRATCH_
  4163 00002087 F7E3                        mul _SCRATCH_
  4164 00002089 0518000000                  add _TOS_, TAB_SIZE
  4165 0000208E E8D3FFFFFF                  call set_x
  4166 00002093 61                          popa
  4167 00002094 C3                          ret
  4168                                  
  4169                                  tab3:
  4170 00002095 60                          pusha
  4171 00002096 E8B3FFFFFF                  call get_x
  4172 0000209B 31D2                        xor edx, edx                    ; clear high 32 bits of dividend
  4173 0000209D BB03000000                  mov _SCRATCH_, 0x03
  4174 000020A2 F7F3                        div _SCRATCH_
  4175 000020A4 F7E3                        mul _SCRATCH_
  4176 000020A6 0503000000                  add _TOS_, 0x03
  4177 000020AB E8B6FFFFFF                  call set_x
  4178 000020B0 61                          popa
  4179 000020B1 C3                          ret
  4180                                  
  4181                                  not_cr:
  4182 000020B2 F615[8E390000]              not byte [ v_not_cr ]
  4183 000020B8 C3                          ret
  4184                                  
  4185                                  blueWord:   ; ( -- )    \ format the editor display screen using certain blue tokens
  4186                                      _DUP_
  4187 000020B9 83EE04              <1>  sub esi, byte 0x04
  4188 000020BC 8906                <1>  mov [ esi ], _TOS_
  4189 000020BE A0[8C390000]                mov al, [ v_seeb ]
  4190 000020C3 3C00                        cmp al, 0
  4191 000020C5 740A                        jz .forward
  4192 000020C7 E89BEEFFFF                  call setBlue
  4193 000020CC E86EFCFFFF                  call type_
  4194                                  .forward:
  4195 000020D1 8B04BDFCFFFFFF              mov _TOS_, [ ( edi * 4 ) - 0x04 ]
  4196 000020D8 3D0E008090                  cmp _TOS_, 0x9080000E  ; cr
  4197 000020DD 7505                        jnz .skip1
  4198 000020DF E8DBE8FFFF                  call cr_
  4199                                  .skip1:
  4200 000020E4 3D0E8C4BE6                  cmp _TOS_, 0xE64B8C0E  ; -tab
  4201 000020E9 750A                        jnz .skip2
  4202 000020EB E8C2FFFFFF                  call not_cr
  4203 000020F0 E883FFFFFF                  call tab
  4204                                  .skip2:
  4205 000020F5 3D0E00C625                  cmp _TOS_, 0x25C6000E  ; tab
  4206 000020FA 7505                        jnz .skip3
  4207 000020FC E877FFFFFF                  call tab
  4208                                  .skip3:
  4209 00002101 3D0E0020C6                  cmp _TOS_, 0xC620000E  ; br
  4210 00002106 750A                        jnz .skip4
  4211 00002108 E8B2E8FFFF                  call cr_
  4212 0000210D E8ADE8FFFF                  call cr_
  4213                                  .skip4:
  4214 00002112 3D0E0021E7                  cmp _TOS_, 0xE721000E  ; -cr
  4215 00002117 7505                        jnz .skip5
  4216 00002119 E894FFFFFF                  call not_cr
  4217                                  .skip5:
  4218 0000211E 3D0E00FB90                  cmp _TOS_, 0x90FB000E  ; cr+   cr and 3 spaces
  4219 00002123 7514                        jnz .skip6
  4220 00002125 E895E8FFFF                  call cr_
  4221 0000212A E862EDFFFF                  call space_
  4222 0000212F E85DEDFFFF                  call space_
  4223 00002134 E858EDFFFF                  call space_
  4224                                  .skip6:
  4225 00002139 3D0EACC725                  cmp _TOS_, 0x25C7AC0E  ; tab3   align to next 3 space column
  4226 0000213E 7505                        jnz .skip7
  4227 00002140 E850FFFFFF                  call tab3
  4228                                  .skip7:
  4229 00002145 3D0E0000EA                  cmp _TOS_, 0xEA00000E  ; .
  4230 0000214A 7505                        jnz .skip8
  4231 0000214C E840EDFFFF                  call space_
  4232                                  .skip8:
  4233 00002151 3D0E00D4EB                  cmp _TOS_, 0xEBD4000E  ; ..
  4234 00002156 750A                        jnz .skip9
  4235 00002158 E834EDFFFF                  call space_
  4236 0000215D E82FEDFFFF                  call space_
  4237                                  .skip9:
  4238 00002162 3D0EA8D7EB                  cmp _TOS_, 0xEBD7A80E  ; ...
  4239 00002167 750F                        jnz .skip10
  4240 00002169 E823EDFFFF                  call space_
  4241 0000216E E81EEDFFFF                  call space_
  4242 00002173 E819EDFFFF                  call space_
  4243                                  .skip10:
  4244 00002178 3D5EAFD7EB                  cmp _TOS_, 0xEBD7AF5E  ; ....
  4245 0000217D 7514                        jnz .skip11
  4246 0000217F E80DEDFFFF                  call space_
  4247 00002184 E808EDFFFF                  call space_
  4248 00002189 E803EDFFFF                  call space_
  4249 0000218E E8FEECFFFF                  call space_
  4250                                  .skip11:
  4251                                      _DROP_
  4252 00002193 AD                  <1>  lodsd
  4253 00002194 C3                          ret
  4254                                  
  4255                                  ; silverWord:   ; ( -- )    ; ToDo: document this
  4256                                  ;     mov edx, [ ( edi * 4 ) - 0x04 ] ; load the value of the action from the current token in the pre-parsed source
  4257                                  ;     sar edx, 0x05                   ; remove the token colour bits
  4258                                  ;     _DUP_
  4259                                  ;     mov _TOS_, colour_white
  4260                                  ;     cmp dword [ x_numberDisplay ], dotDecimal
  4261                                  ;     jz .forward
  4262                                  ;     mov _TOS_, colour_silver
  4263                                  ; .forward:
  4264                                  ;    jmp short displayNumber
  4265                                  ;    ret
  4266                                  
  4267                                  silverWord:     ; display a silver word
  4268 00002195 E8FAEDFFFF                  call setSilver
  4269 0000219A E9A0FBFFFF                  jmp type_
  4270                                  
  4271                                  taupeWord:     ; display a taupe word
  4272 0000219F E8FFEDFFFF                  call setTaupe
  4273 000021A4 E996FBFFFF                  jmp type_
  4274                                  
  4275                                  displayShannonFanoActions:  ;    * = number
  4276 000021A9 [701F0000]                  dd extension            ; 0     extension token, remove space from previous word, do not change the colour
  4277 000021AD [161F0000]                  dd yellowWord           ; 1     yellow "immediate" word
  4278 000021B1 [34200000]                  dd yellowNumber         ; 2  *  yellow "immediate" 32 bit number in the following pre-parsed cell
  4279 000021B5 [AB1E0000]                  dd redWord              ; 3     red forth wordlist "colon" word
  4280 000021B9 [021F0000]                  dd greenWord            ; 4     green compiled word
  4281 000021BD [19200000]                  dd greenNumber          ; 5  *  green compiled 32 bit number in the following pre-parsed cell
  4282 000021C1 [A11F0000]                  dd greenShortNumber     ; 6  *  green compiled 27 bit number in the high bits of the token
  4283 000021C5 [0C1F0000]                  dd cyanWord             ; 7     cyan macro wordlist "colon" word
  4284 000021C9 [28200000]                  dd yellowShortNumber    ; 8  *  yellow "immediate" 27 bit number in the high bits of the token
  4285 000021CD [3A1D0000]                  dd lowercase            ; 9     white lower-case comment
  4286 000021D1 [201F0000]                  dd camelcase            ; A     first letter capital comment
  4287 000021D5 [451F0000]                  dd uppercase            ; B     white upper-case comment
  4288 000021D9 [AD1F0000]                  dd magentaVariable      ; C     magenta variable
  4289 000021DD [95210000]                  dd silverWord           ; D
  4290 000021E1 [B9200000]                  dd blueWord             ; E     editor formatting commands
  4291 000021E5 [9F210000]                  dd taupeWord            ; F     new "string" token
  4292                                  
  4293                                  v_lineOffset:
  4294 000021E9 01000000                    dd 1    ; the top line of the display
  4295                                  
  4296                                  doColourBlind:  ; ( state -- )   \ add conventional Forth punctuation based on the newand last states
  4297 000021ED 803D[8D390000]00            cmp byte [ v_colourBlindMode ], 0x00
  4298 000021F4 740E                        jz .forward3
  4299 000021F6 F605[10390000]01            test byte [ v_blk ], 0x01       ; do not display colourblind characters in odd numbered shadow blocks
  4300 000021FD 7505                        jnz .forward3
  4301 000021FF E8E2FAFFFF                  call dword colourBlindAction    ; pass the new state to colourBlind so that extra characters can be added to the display
  4302                                      .forward3:
  4303                                      _DROP_
  4304 00002204 AD                  <1>  lodsd
  4305 00002205 C3                          ret
  4306                                  
  4307                                  plusList:   ; ( -- ) display the current colorForth block
  4308                                      _DUP_
  4309 00002206 83EE04              <1>  sub esi, byte 0x04
  4310 00002209 8906                <1>  mov [ esi ], _TOS_
  4311 0000220B 31C0                        xor _TOS_, _TOS_
  4312 0000220D A3[1C1B0000]                mov [ currentState ], _TOS_
  4313 00002212 A3[201B0000]                mov [ lastState ], _TOS_
  4314                                      _DROP_
  4315 00002217 AD                  <1>  lodsd
  4316                                  
  4317 00002218 E898ECFFFF                  call setupText_                 ; setup the clip window for this display
  4318                                      _DUP_
  4319 0000221D 83EE04              <1>  sub esi, byte 0x04
  4320 00002220 8906                <1>  mov [ esi ], _TOS_
  4321 00002222 A1[58390000]                mov _TOS_, [ v_lcad ]
  4322 00002227 A3[50390000]                mov [ v_cad ], _TOS_
  4323 0000222C A1[10390000]                mov _TOS_, [ v_blk ]            ; get the current block number to be edited
  4324 00002231 E86EE6FFFF                  call blockToCellAddress         ; add the RELOCATED block number offset and convert to cell address
  4325 00002236 89C7                        mov edi, _TOS_
  4326 00002238 31C0                        xor _TOS_, _TOS_
  4327 0000223A 033D[E9210000]              add edi, [ v_lineOffset ]
  4328 00002240 893D[54390000]              mov [ v_pcad ], edi
  4329                                  .back:
  4330 00002246 8B14BD00000000              mov edx, dword [ ( edi * 4 ) + 0x00 ]   ; edi is the display pointer and is a cell address
  4331 0000224D E844F8FFFF                  call qring                      ; show one Shannon-Fano encoded word pointed to by edi
  4332 00002252 47                          inc edi
  4333                                      ; adjust the number base according to bit 5 of the token value, only used by number display words
  4334 00002253 C705[0C390000]-             mov dword [ x_numberDisplay ], dotDecimal
  4335 00002259 [34110000]         
  4336 0000225D F6C210                      test dl, 0x10
  4337 00002260 740A                        jz .forward2
  4338 00002262 C705[0C390000]-             mov dword [ x_numberDisplay ], dotHex
  4339 00002268 [F6100000]         
  4340                                  .forward2:
  4341 0000226C 83E20F                      and edx, byte 0x0F
  4342                                      _DUP_
  4343 0000226F 83EE04              <1>  sub esi, byte 0x04
  4344 00002272 8906                <1>  mov [ esi ], _TOS_
  4345 00002274 89D0                        mov _TOS_, edx
  4346 00002276 E872FFFFFF                  call doColourBlind
  4347 0000227B FF1495[A9210000]            call [ ( edx * 4 ) + displayShannonFanoActions ]
  4348 00002282 EBC2                        jmp short .back
  4349                                  
  4350                                  refresh:
  4351 00002284 E8D0E1FFFF                  call show
  4352 00002289 E87CECFFFF                  call page_
  4353 0000228E E83DEFFFFF                  call displayBlockNumber
  4354 00002293 E86EFFFFFF                  call plusList
  4355                                      _DUP_
  4356 00002298 83EE04              <1>  sub esi, byte 0x04
  4357 0000229B 8906                <1>  mov [ esi ], _TOS_
  4358 0000229D B80F000000                  mov _TOS_, 0x0F
  4359 000022A2 E846FFFFFF                  call doColourBlind             ; display the final colourblind punctuation, set up for next call of plusList
  4360 000022A7 E972F0FFFF                  jmp dword displayTheKeyboard
  4361                                  
  4362                                  align 4, db 0   ; fill the gap with 0's
  4363                                  
  4364                                  actionColourTable:          ;    * = number
  4365 000022AC 00E20000                    dd colour_orange        ; 0     extension token, remove space from previous word, do not change the colour
  4366 000022B0 E0FF0000                    dd colour_yellow        ; 1     yellow "immediate" word
  4367 000022B4 E0FF0000                    dd colour_yellow        ; 2  *  yellow "immediate" 32 bit number in the following pre-parsed cell
  4368 000022B8 00F80000                    dd colour_red           ; 3     red forth wordlist "colon" word
  4369 000022BC 00060000                    dd colour_green         ; 4     green compiled word
  4370 000022C0 00060000                    dd colour_green         ; 5  *  green compiled 32 bit number in the following pre-parsed cell
  4371 000022C4 00060000                    dd colour_green         ; 6  *  green compiled 27 bit number in the high bits of the token
  4372 000022C8 FF070000                    dd colour_cyan          ; 7     cyan macro wordlist "colon" word
  4373 000022CC E0FF0000                    dd colour_yellow        ; 8  *  yellow "immediate" 27 bit number in the high bits of the token
  4374 000022D0 FFFF0000                    dd colour_white         ; 9     white lower-case comment
  4375 000022D4 FFFF0000                    dd colour_white         ; A     first letter capital comment
  4376 000022D8 FFFF0000                    dd colour_white         ; B     white upper-case comment
  4377 000022DC 1FF80000                    dd colour_magenta       ; C     magenta variable
  4378 000022E0 18C60000                    dd colour_silver        ; D
  4379 000022E4 1F000000                    dd colour_blue          ; E     editor formatting commands
  4380 000022E8 E7B20000                    dd colour_taupe         ; F     new "string" token
  4381                                  
  4382                                  vector:
  4383 000022EC 00000000                    dd 0  ; pointer to call table for keypad ( see keypd )
  4384                                  
  4385                                  action:
  4386 000022F0 01                          db 1
  4387                                  
  4388 000022F1 00<rept>                align 4, db 0   ; fill the gap with 0's
  4389                                  
  4390                                  cursorLeft:     ; ( -- )
  4391 000022F4 FF0D[30390000]              dec dword [ v_curs ]
  4392 000022FA 7906                        jns .forward
  4393 000022FC FF05[30390000]                  inc dword [ v_curs ]
  4394                                      .forward:
  4395 00002302 C3                          ret
  4396                                  
  4397                                  limitToEndOfBlock:
  4398 00002303 E8BF000000                  call countTokens
  4399 00002308 3B05[30390000]              cmp _TOS_, dword [ v_curs ]
  4400 0000230E 7905                        jns .forward
  4401 00002310 A3[30390000]                    mov dword [ v_curs ], _TOS_
  4402                                      .forward:
  4403                                      _DROP_
  4404 00002315 AD                  <1>  lodsd
  4405 00002316 C3                          ret
  4406                                  
  4407                                  cursorRight:
  4408 00002317 FF05[30390000]              inc dword [ v_curs ]
  4409 0000231D E8E1FFFFFF                  call limitToEndOfBlock
  4410 00002322 C3                          ret
  4411                                  
  4412                                  countAllTokens:     ; ( -- x ) \ counts red and magenta tokens and all tokens in the current block
  4413                                      _DUP_
  4414 00002323 83EE04              <1>  sub esi, byte 0x04
  4415 00002326 8906                <1>  mov [ esi ], _TOS_
  4416 00002328 31C0                        xor _TOS_, _TOS_
  4417 0000232A A3[40390000]                mov dword [ v_numberOfMagentas ], _TOS_
  4418 0000232F A3[48390000]                mov dword [ v_numberOfRedAndMagentas ], _TOS_   ; count up Red and Magenta tokens
  4419 00002334 A3[4C390000]                mov dword [ v_numberOfTokens ], _TOS_           ; count all tokens
  4420 00002339 A3[44390000]                mov dword [ v_numberOfBigConstants ], _TOS_     ; count of 32 bit literal tokens
  4421                                  
  4422 0000233E B900010000                  mov ecx, 0x00100      ; 256 x 4 byte cells = 1 block
  4423                                  .loop:
  4424                                  
  4425                                      _DUP_
  4426 00002343 83EE04              <1>  sub esi, byte 0x04
  4427 00002346 8906                <1>  mov [ esi ], _TOS_
  4428 00002348 A1[4C390000]                mov _TOS_, [ v_numberOfTokens ]
  4429 0000234D E82FE6FFFF                  call nth_to_token
  4430 00002352 89C3                        mov _SCRATCH_, _TOS_
  4431                                      _DROP_
  4432 00002354 AD                  <1>  lodsd
  4433 00002355 81FB00000000                cmp _SCRATCH_, 0x00
  4434 0000235B 745E                        je .forward         ; exit if the token value is 0, means end of block
  4435                                  
  4436 0000235D FF05[4C390000]              inc dword [ v_numberOfTokens ]
  4437                                  
  4438 00002363 81E30F000000                and _SCRATCH_, 0x0F     ; look at the token type
  4439                                  
  4440 00002369 81FB03000000                cmp _SCRATCH_, 0x03     ; red token
  4441 0000236F 7506                        jne .forwardRed
  4442 00002371 FF05[48390000]                  inc dword [ v_numberOfRedAndMagentas ]
  4443                                      .forwardRed:
  4444                                  
  4445 00002377 81FB0C000000                cmp _SCRATCH_, 0x0C     ; magenta token
  4446 0000237D 7512                        jne .forwardMagenta
  4447 0000237F FF05[48390000]                  inc dword [ v_numberOfRedAndMagentas ]
  4448 00002385 FF05[40390000]                  inc dword [ v_numberOfMagentas ]    ; correction for magenta variables
  4449 0000238B FF05[4C390000]                  inc dword [ v_numberOfTokens ]      ; step over the Magenta variable data cell
  4450                                      .forwardMagenta:
  4451                                  
  4452 00002391 81FB02000000                cmp _SCRATCH_, 0x02     ; yellow 32 bit literal
  4453 00002397 750C                        jne .forwardBig
  4454 00002399 FF05[44390000]                  inc dword [ v_numberOfBigConstants ]    ; correction for literal constants
  4455 0000239F FF05[4C390000]                  inc dword [ v_numberOfTokens ]          ; step over the data cell
  4456                                      .forwardBig:
  4457                                  
  4458 000023A5 81FB05000000                cmp _SCRATCH_, 0x05     ; green 32 bit literal
  4459 000023AB 750C                        jne .forwardBig2
  4460 000023AD FF05[44390000]                  inc dword [ v_numberOfBigConstants ]    ; correction for literal constants
  4461 000023B3 FF05[4C390000]                  inc dword [ v_numberOfTokens ]          ; step over the data cell
  4462                                      .forwardBig2:
  4463                                  
  4464 000023B9 E288                        loop .loop
  4465                                  .forward:               ; found the end of the block
  4466                                  ;    mov _TOS_, dword [ v_numberOfRedAndMagentas ]
  4467 000023BB C3                          ret
  4468                                  
  4469                                  countRedAndMagentaTokens:     ; ( -- n ) \ counts red and magenta tokens in the current block
  4470 000023BC E862FFFFFF                  call countAllTokens
  4471 000023C1 A1[48390000]                mov _TOS_, dword [ v_numberOfRedAndMagentas ]
  4472 000023C6 C3                          ret
  4473                                  
  4474                                  countTokens:     ; ( -- n ) \ counts all tokens up to the end of the current block
  4475 000023C7 E857FFFFFF                  call countAllTokens
  4476 000023CC A1[4C390000]                mov _TOS_, dword [ v_numberOfTokens ]
  4477 000023D1 2B05[40390000]              sub _TOS_, dword [ v_numberOfMagentas ]
  4478 000023D7 2B05[44390000]              sub _TOS_, dword [ v_numberOfBigConstants ]
  4479 000023DD C3                          ret
  4480                                  
  4481                                  ; *****************************************************************************
  4482                                  
  4483                                  cursorDownToNth:     ; ( -- ) \ step down to after the v_cursLine'th red or magenta token
  4484                                      _DUP_
  4485 000023DE 83EE04              <1>  sub esi, byte 0x04
  4486 000023E1 8906                <1>  mov [ esi ], _TOS_
  4487 000023E3 31C0                        xor _TOS_, _TOS_
  4488 000023E5 A3[40390000]                mov dword [ v_numberOfMagentas ], _TOS_
  4489 000023EA A3[30390000]                mov dword [ v_curs ], _TOS_
  4490 000023EF A3[44390000]                mov dword [ v_numberOfBigConstants ], _TOS_
  4491                                  
  4492 000023F4 A1[38390000]                mov dword _TOS_, [ v_cursLine ]
  4493 000023F9 A3[3C390000]                mov dword [ v_curs_number_down ], _TOS_
  4494                                  
  4495 000023FE B900010000                  mov ecx, 0x00100      ; 256 x 4 byte cells = 1 block
  4496                                  .loop:
  4497                                  
  4498 00002403 813D[3C390000]0000-         cmp dword [ v_curs_number_down ], 0x00  ; test for zero
  4499 0000240B 0000               
  4500 0000240D 746C                        je .forward     ; jump to the end if  v_curs_number_down  reaches zero
  4501                                  
  4502                                      _DUP_
  4503 0000240F 83EE04              <1>  sub esi, byte 0x04
  4504 00002412 8906                <1>  mov [ esi ], _TOS_
  4505 00002414 A1[30390000]                mov _TOS_, [ v_curs ]
  4506 00002419 E863E5FFFF                  call nth_to_token
  4507 0000241E 89C3                        mov _SCRATCH_, _TOS_
  4508                                      _DROP_
  4509 00002420 AD                  <1>  lodsd
  4510 00002421 81FB00000000                cmp _SCRATCH_, 0x00
  4511 00002427 7464                        je .endOfBlock         ; exit if the token value is 0, means end of block
  4512                                  
  4513 00002429 FF05[30390000]              inc dword [ v_curs ]
  4514                                  
  4515 0000242F 81E30F000000                and _SCRATCH_, 0x0F     ; look at the token type
  4516                                  
  4517 00002435 81FB03000000                cmp _SCRATCH_, 0x03     ; red token
  4518 0000243B 7506                        jne .forwardRed
  4519 0000243D FF0D[3C390000]                  dec dword [ v_curs_number_down ]
  4520                                      .forwardRed:
  4521                                  
  4522 00002443 81FB0C000000                cmp _SCRATCH_, 0x0C     ; magenta token
  4523 00002449 7512                        jne .forwardMagenta
  4524 0000244B FF0D[3C390000]                  dec dword [ v_curs_number_down ]
  4525 00002451 FF05[40390000]                  inc dword [ v_numberOfMagentas ]    ; correction for magenta variables
  4526 00002457 FF05[30390000]                  inc dword [ v_curs ]                ; step over the Magenta variable data cell
  4527                                      .forwardMagenta:
  4528                                  
  4529 0000245D 81FB02000000                cmp _SCRATCH_, 0x02     ; yellow 32 bit literal
  4530 00002463 7408                        je .forwardBig
  4531                                  
  4532 00002465 81FB05000000                cmp _SCRATCH_, 0x05     ; green 32 bit literal
  4533 0000246B 750C                        jne .forwardBig2
  4534                                      .forwardBig:
  4535 0000246D FF05[44390000]                  inc dword [ v_numberOfBigConstants ]    ; correction for literal constants
  4536 00002473 FF05[30390000]                  inc dword [ v_curs ]                    ; step over the data cell
  4537                                      .forwardBig2:
  4538                                  
  4539 00002479 E288                        loop .loop
  4540                                  .forward:               ; found the right number of red or magenta tokens, so exit
  4541 0000247B 8B1D[40390000]              mov _SCRATCH_, dword [ v_numberOfMagentas ]
  4542 00002481 031D[44390000]              add _SCRATCH_, dword [ v_numberOfBigConstants ]
  4543 00002487 291D[30390000]              sub dword [ v_curs ], _SCRATCH_  ; the correction for magenta variables
  4544                                  .endOfBlock:
  4545 0000248D E871FEFFFF                  call limitToEndOfBlock
  4546                                      _DROP_
  4547 00002492 AD                  <1>  lodsd
  4548 00002493 C3                          ret
  4549                                  
  4550                                  cursorUp:     ; ( -- ) \ step down to after the next red token, or after 0x16 steps, or until the end of the block
  4551 00002494 FF0D[38390000]              dec dword [ v_cursLine ]
  4552 0000249A 750A                        jnz .forward
  4553 0000249C C705[38390000]0000-         mov dword [ v_cursLine ], 0x00
  4554 000024A4 0000               
  4555                                  .forward:
  4556                                  ;    mov dword [ v_cursLine ], 0x03
  4557 000024A6 E833FFFFFF                  call cursorDownToNth
  4558 000024AB C3                          ret
  4559                                  
  4560                                  cursorDown:     ; ( -- ) \ step down to after the next red token, or after 0x16 steps, or until the end of the block
  4561 000024AC FF05[38390000]              inc dword [ v_cursLine ]
  4562 000024B2 E805FFFFFF                  call countRedAndMagentaTokens
  4563 000024B7 40                          inc dword _TOS_     ; add one so that we can go past the last token to the end of the block
  4564 000024B8 3905[38390000]              cmp dword [ v_cursLine ], _TOS_
  4565 000024BE 7805                        js .forward
  4566 000024C0 A3[38390000]                mov dword [ v_cursLine ], _TOS_
  4567                                  .forward:
  4568                                      _DROP_
  4569 000024C5 AD                  <1>  lodsd
  4570                                   ;   mov dword [ v_cursLine ], 0x02
  4571 000024C6 E813FFFFFF                  call cursorDownToNth
  4572 000024CB C3                          ret
  4573                                  
  4574                                  cursorEnd:     ; ( -- )
  4575 000024CC E8EBFEFFFF                  call countRedAndMagentaTokens
  4576 000024D1 40                          inc dword _TOS_     ; add one so that we can go past the last token to the end of the block
  4577 000024D2 A3[38390000]                mov dword [ v_cursLine ], _TOS_
  4578                                      _DROP_
  4579 000024D7 AD                  <1>  lodsd
  4580 000024D8 E801FFFFFF                  call cursorDownToNth
  4581 000024DD E821FEFFFF                  call limitToEndOfBlock
  4582 000024E2 C3                          ret
  4583                                  
  4584                                  cursorHome:     ; ( -- )
  4585 000024E3 31DB                        xor _SCRATCH_, _SCRATCH_
  4586 000024E5 891D[40390000]              mov dword [ v_numberOfMagentas ], _SCRATCH_
  4587 000024EB 891D[30390000]              mov dword [ v_curs ], _SCRATCH_                 ; the graphics cursor for drawing the block
  4588 000024F1 891D[E9210000]              mov dword [ v_lineOffset ], _SCRATCH_           ; the cursor position to start drawing the block
  4589 000024F7 891D[D3140000]              mov dword [ v_lineOffsetTablePtr ], _SCRATCH_   ; a pointer to the cursor for each line in the display
  4590 000024FD 891D[40390000]              mov dword [ v_numberOfMagentas ], _SCRATCH_     ; count of Magenta variables displayed so far in the edited block
  4591 00002503 891D[38390000]              mov dword [ v_cursLine ], _SCRATCH_
  4592 00002509 C3                          ret
  4593                                  
  4594                                  nextBlock:     ; ( -- )
  4595 0000250A 8305[10390000]02            add dword [ v_blk ], byte 0x02
  4596 00002511 E8C1EFFFFF                  call lineOffsetZero
  4597 00002516 C3                          ret
  4598                                  
  4599                                  previousBlock:
  4600 00002517 833D[10390000]22            cmp dword [ v_blk ], byte ( START_BLOCK_NUMBER + 2 )
  4601 0000251E 7807                        js .forward
  4602 00002520 832D[10390000]02            sub dword [ v_blk ], byte 0x02
  4603                                  .forward:
  4604 00002527 E8ABEFFFFF                  call lineOffsetZero
  4605 0000252C C3                          ret
  4606                                  
  4607                                  otherBlock:
  4608 0000252D 8B0D[10390000]              mov ecx, [ v_blk ]
  4609 00002533 870D[14390000]              xchg ecx, [ v_otherBlock ]
  4610 00002539 890D[10390000]              mov [ v_blk ], ecx
  4611 0000253F C3                          ret
  4612                                  
  4613                                  shadow:     ; alternate between source and shadow blocks
  4614 00002540 8335[10390000]01            xor dword [ v_blk ], byte 0x01
  4615 00002547 C3                          ret
  4616                                  
  4617                                  insert0:
  4618 00002548 8B0D[58390000]              mov ecx, [ v_lcad ]
  4619 0000254E 030D[B8390000]              add ecx, [ v_words ]
  4620 00002554 330D[58390000]              xor ecx, [ v_lcad ]
  4621 0000255A 81E100FFFFFF                and ecx, 0xFFFFFF00
  4622 00002560 740A                        jz insert1
  4623 00002562 8B0D[B8390000]              mov ecx, [ v_words ]
  4624                                  .back:
  4625                                      _DROP_
  4626 00002568 AD                  <1>  lodsd
  4627 00002569 E2FD                        loop .back
  4628 0000256B C3                          ret
  4629                                  
  4630                                  insert1:
  4631 0000256C 56                          push esi
  4632 0000256D 8B35[58390000]              mov esi, [ v_lcad ]
  4633 00002573 89F1                        mov ecx, esi
  4634 00002575 4E                          dec esi
  4635 00002576 89F7                        mov edi, esi
  4636 00002578 033D[B8390000]              add edi, [ v_words ]
  4637 0000257E C1E702                      shl edi, 0x02
  4638 00002581 2B0D[50390000]              sub ecx, [ v_cad ]
  4639 00002587 7807                        js .forward
  4640 00002589 C1E602                      shl esi, 0x02
  4641 0000258C FD                          std
  4642 0000258D F3A5                        rep  movsd                  ; copy ecx 32 bit words from ds:esi to es:edi
  4643 0000258F FC                          cld
  4644                                  .forward:
  4645 00002590 5E                          pop esi
  4646 00002591 C1EF02                      shr edi, 0x02
  4647 00002594 47                          inc edi
  4648 00002595 893D[30390000]              mov [ v_curs ], edi
  4649 0000259B 8B0D[B8390000]              mov ecx, [ v_words ]
  4650                                  .back:
  4651 000025A1 4F                          dec edi
  4652 000025A2 8904BD00000000              mov [ ( edi * 4 ) + 0x00 ], _TOS_
  4653                                      _DROP_
  4654 000025A9 AD                  <1>  lodsd
  4655 000025AA E2F5                        loop .back
  4656 000025AC C3                          ret
  4657                                  
  4658                                  insert:
  4659 000025AD E896FFFFFF                  call insert0
  4660 000025B2 8A0D[F0220000]              mov cl, [ action ]
  4661 000025B8 300CBD00000000              xor [ edi * 4 + 0x00 ],cl
  4662 000025BF 80F903                      cmp cl, 0x03        ; if we are a red token
  4663 000025C2 751A                        jnz .forward
  4664 000025C4 C605[F0220000]04            mov byte [ action ], 0x04   ; switch to green
  4665 000025CB C705[A8390000]0006-         mov dword [ keyboard_colour ], colour_green
  4666 000025D3 0000               
  4667 000025D5 66C705[90390000]0D-         mov word [ v_hintChar ], 0x0D    ; mark the green keypad with a 'g'
  4668 000025DD 00                 
  4669                                      .forward:
  4670 000025DE C3                          ret
  4671                                  
  4672                                  _word1:
  4673 000025DF 8F05[B0390000]              pop dword [ aword ]
  4674 000025E5 C705[B0390000]-             mov dword [ aword ], ex1
  4675 000025EB [E7060000]         
  4676 000025EF C3                          ret
  4677                                  
  4678                                  _word:
  4679 000025F0 C705[B0390000]-             mov dword [ aword ], _word1
  4680 000025F6 [DF250000]         
  4681 000025FA E9C7F3FFFF                  jmp dword accept
  4682                                  
  4683                                  tokenAction_1:
  4684                                      _DUP_
  4685 000025FF 83EE04              <1>  sub esi, byte 0x04
  4686 00002602 8906                <1>  mov [ esi ], _TOS_
  4687 00002604 B801000000                  mov _TOS_, 0x01
  4688 00002609 803D[F0220000]04            cmp byte [ action ], 0x04
  4689 00002610 7402                        jz .forward2
  4690 00002612 B003                        mov al, 0x03
  4691                                  .forward2:
  4692 00002614 833D[A0390000]0A            cmp dword [ base ], byte 0x0A
  4693 0000261B 7402                        jz .forward
  4694 0000261D 3410                        xor al, 0x10
  4695                                  .forward:
  4696                                      _SWAP_
  4697 0000261F 8706                <1>  xchg _TOS_, [ esi ]
  4698 00002621 C705[B8390000]0200-         mov dword [ v_words ], 0x02
  4699 00002629 0000               
  4700 0000262B EB80                        jmp short insert
  4701                                  
  4702                                  tokenAction:
  4703 0000262D F605[F0220000]0A            test byte [ action ], 0x0A
  4704 00002634 753C                        jnz .forward
  4705 00002636 89C2                        mov edx, _TOS_
  4706 00002638 81E2000000FC                and edx, 0xFC000000
  4707 0000263E 7408                        jz .forward2
  4708 00002640 81FA000000FC                cmp edx, 0xFC000000
  4709 00002646 75B7                        jnz tokenAction_1
  4710                                  .forward2:
  4711 00002648 C1E005                      shl _TOS_, 0x05
  4712 0000264B 3402                        xor al, 0x02
  4713 0000264D 803D[F0220000]04            cmp byte [ action ], 0x04
  4714 00002654 7402                        jz .forwardBack
  4715 00002656 340B                        xor al, 0x0B
  4716                                  .forwardBack:
  4717 00002658 833D[A0390000]0A            cmp dword [ base ], byte 0x0A
  4718 0000265F 7402                        jz .forward4
  4719 00002661 3410                        xor al, 0x10
  4720                                  .forward4:
  4721 00002663 C705[B8390000]0100-         mov dword [ v_words ], 0x01
  4722 0000266B 0000               
  4723 0000266D E93BFFFFFF                  jmp insert
  4724                                  .forward:
  4725 00002672 803D[F0220000]09            cmp byte [ action ],  0x09
  4726 00002679 750C                        jnz .forward3
  4727 0000267B 89C2                        mov edx, _TOS_
  4728 0000267D C1E205                      shl edx, 0x05
  4729 00002680 C1FA05                      sar edx, 0x05
  4730 00002683 39C2                        cmp edx, _TOS_
  4731 00002685 7402                        jz .forward5
  4732                                  .forward3:
  4733                                      _DROP_
  4734 00002687 AD                  <1>  lodsd
  4735 00002688 C3                          ret
  4736                                  .forward5:
  4737 00002689 C1E005                      shl _TOS_, 0x05
  4738 0000268C 3406                        xor al, 0x06
  4739 0000268E EBC8                        jmp short .forwardBack
  4740                                  
  4741                                  enstack:
  4742                                      _DUP_
  4743 00002690 83EE04              <1>  sub esi, byte 0x04
  4744 00002693 8906                <1>  mov [ esi ], _TOS_
  4745 00002695 A1[50390000]                mov _TOS_, [ v_cad ]
  4746 0000269A 2B05[54390000]              sub _TOS_, [ v_pcad ]
  4747 000026A0 7426                        jz .forward
  4748 000026A2 89C1                        mov ecx, _TOS_
  4749 000026A4 92                          xchg _TOS_, edx
  4750 000026A5 56                          push esi
  4751 000026A6 8B35[50390000]              mov esi, [ v_cad ]
  4752 000026AC 8D34B5FCFFFFFF              lea esi, [esi*4-0x04]
  4753 000026B3 8B3D[5C390000]              mov edi, [ v_trash ]
  4754                                  .back:
  4755 000026B9 FD                          std
  4756                                      _DROP_
  4757 000026BA AD                  <1>  lodsd
  4758 000026BB FC                          cld
  4759 000026BC AB                          stosd
  4760 000026BD E2FA                        loop .back
  4761 000026BF 92                          xchg _TOS_, edx
  4762 000026C0 AB                          stosd
  4763 000026C1 893D[5C390000]              mov [ v_trash], edi
  4764 000026C7 5E                          pop esi
  4765                                  .forward:
  4766                                      _DROP_
  4767 000026C8 AD                  <1>  lodsd
  4768 000026C9 C3                          ret
  4769                                  
  4770                                  deleteAction:
  4771 000026CA E8C1FFFFFF                  call enstack
  4772 000026CF 8B3D[54390000]              mov edi, [ v_pcad ]
  4773 000026D5 8B0D[58390000]              mov ecx, [ v_lcad ]
  4774 000026DB 29F9                        sub ecx, edi
  4775 000026DD C1E702                      shl edi, 0x02
  4776 000026E0 56                          push esi
  4777 000026E1 8B35[50390000]              mov esi, [ v_cad ]
  4778 000026E7 C1E602                      shl esi, 0x02
  4779 000026EA F3A5                        rep  movsd                  ; copy ecx 32 bit words from ds:esi to es:edi
  4780 000026EC 5E                          pop esi
  4781 000026ED E902FCFFFF                  jmp dword cursorLeft
  4782                                  
  4783                                  act0:
  4784 000026F2 E899FFFFFF                  call enstack
  4785 000026F7 E9F8FBFFFF                  jmp dword cursorLeft
  4786                                  
  4787                                  yellowAction:
  4788 000026FC B001                        mov al, 0x01
  4789 000026FE EB22                        jmp short actt
  4790                                  
  4791                                  redAction:  ; red : start creating a new definition
  4792 00002700 B003                        mov al, 0x03
  4793 00002702 EB1E                        jmp short actt
  4794                                  
  4795                                  greenAction:   ; green, start compiling an existing definition
  4796 00002704 B004                        mov al, 0x04
  4797 00002706 EB1A                        jmp short actt
  4798                                  
  4799                                  textAction:
  4800 00002708 B009                        mov al, 0x09
  4801 0000270A EB16                        jmp short actt
  4802                                  
  4803                                  CapitalAction:
  4804 0000270C B00A                        mov al, 0x0A
  4805 0000270E EB12                        jmp short actt
  4806                                  
  4807                                  capitalS_Action:
  4808 00002710 B00B                        mov al, 0x0B
  4809 00002712 EB0E                        jmp short actt
  4810                                  
  4811                                  silverAction:
  4812 00002714 B00D                        mov al, 0x0D
  4813 00002716 EB0A                        jmp short actt
  4814                                  
  4815                                  blueAction:
  4816 00002718 B00E                        mov al, 0x0E
  4817 0000271A EB06                        jmp short actt
  4818                                  
  4819                                  cyanAction:
  4820 0000271C B007                        mov al, 0x07
  4821 0000271E EB02                        jmp short actt
  4822                                  
  4823                                  taupeAction:
  4824 00002720 B00F                        mov al, 0x0F
  4825                                  ;    jmp short actt
  4826                                  
  4827                                  
  4828                                  actt:   ; ( action -- )
  4829 00002722 A2[F0220000]                mov [ action ], al
  4830 00002727 C705[B0390000]-             mov dword [ aword ], insert
  4831 0000272D [AD250000]         
  4832 00002731 8B0485[AC220000]            mov _TOS_, [ ( _TOS_ * 4 ) + actionColourTable ]
  4833                                  actn:
  4834 00002738 A3[A8390000]                mov [ keyboard_colour ], _TOS_
  4835 0000273D 58                          pop _TOS_
  4836                                      _DROP_
  4837 0000273E AD                  <1>  lodsd
  4838 0000273F E982F2FFFF                  jmp dword accept
  4839                                  
  4840                                  magentaAction:   ; magenta variable action
  4841 00002744 C605[F0220000]0C            mov byte [ action ], 0x0C
  4842 0000274B B81FF80000                  mov _TOS_, colour_magenta
  4843 00002750 C705[B0390000]-             mov dword [ aword ], .forward
  4844 00002756 [5C270000]         
  4845 0000275A EBDC                        jmp short actn
  4846                                      .forward:
  4847                                      _DUP_
  4848 0000275C 83EE04              <1>  sub esi, byte 0x04
  4849 0000275F 8906                <1>  mov [ esi ], _TOS_
  4850 00002761 31C0                        xor _TOS_, _TOS_
  4851 00002763 FF05[B8390000]              inc dword [ v_words ]
  4852 00002769 E93FFEFFFF                  jmp dword insert
  4853                                  
  4854                                  editorExit:       ; ( -- )   \ leave the editor
  4855 0000276E 58                          pop _TOS_
  4856                                      _DROP_
  4857 0000276F AD                  <1>  lodsd
  4858 00002770 C705[B0390000]-             mov dword [ aword ], ex1
  4859 00002776 [E7060000]         
  4860 0000277A C705[B4390000]-             mov dword [ anumber ], nul
  4861 00002780 [00040000]         
  4862 00002784 C605[B2170000]00            mov byte [ alpha0 + ( 4 * 4 ) ], 0x00
  4863 0000278B C705[A6170000]-             mov dword [ alpha0 + 4 ], nul0
  4864 00002791 [B7190000]         
  4865 00002795 C705[A8390000]E0FF-         mov dword [ keyboard_colour ], colour_yellow
  4866 0000279D 0000               
  4867 0000279F C605[8F390000]00            mov byte [ v_acceptMode ], 0x00
  4868 000027A6 C605[90390000]00            mov byte [ v_hintChar ], 0x00
  4869 000027AD E914F2FFFF                  jmp dword accept
  4870                                  
  4871                                  destack:
  4872 000027B2 8B15[5C390000]              mov edx, [ v_trash ]
  4873 000027B8 81FA60130000                cmp edx, TRASH_BUFFER
  4874 000027BE 7501                        jnz .forward
  4875 000027C0 C3                          ret
  4876                                  .forward:
  4877 000027C1 83EA08                      sub edx, byte 0x08
  4878 000027C4 8B4A04                      mov ecx, [edx+0x04]
  4879 000027C7 890D[B8390000]              mov [ v_words ], ecx
  4880                                  .back:
  4881                                      _DUP_
  4882 000027CD 83EE04              <1>  sub esi, byte 0x04
  4883 000027D0 8906                <1>  mov [ esi ], _TOS_
  4884 000027D2 8B02                        mov _TOS_, [edx]
  4885 000027D4 83EA04                      sub edx, byte 0x04
  4886 000027D7 E2F4                        loop .back
  4887 000027D9 83C204                      add edx, byte 0x04
  4888 000027DC 8915[5C390000]              mov [ v_trash ], edx
  4889 000027E2 E961FDFFFF                  jmp dword insert0
  4890                                  
  4891                                  editorActionTable:
  4892 000027E7 [00040000]-                 dd nul           , deleteAction    , editorExit    , destack      ;
  4893 000027EB [CA260000]-        
  4894 000027EF [6E270000]-        
  4895 000027F3 [B2270000]         
  4896 000027F7 [FC260000]-                 dd yellowAction  , redAction       , greenAction   , shadow       ; y r g *
  4897 000027FB [00270000]-        
  4898 000027FF [04270000]-        
  4899 00002803 [40250000]         
  4900 00002807 [F4220000]-                 dd cursorLeft    , cursorUp        , cursorDown    , cursorRight  ; l u d r
  4901 0000280B [94240000]-        
  4902 0000280F [AC240000]-        
  4903 00002813 [17230000]         
  4904 00002817 [17250000]-                 dd previousBlock , magentaAction   , cyanAction    , nextBlock    ; - m c +
  4905 0000281B [44270000]-        
  4906 0000281F [1C270000]-        
  4907 00002823 [0A250000]         
  4908 00002827 [00040000]-                 dd nul           , capitalS_Action , CapitalAction , textAction   ; _ S C t
  4909 0000282B [10270000]-        
  4910 0000282F [0C270000]-        
  4911 00002833 [08270000]         
  4912 00002837 [00040000]-                 dd nul           , nul             , nul           , otherBlock   ; _ _ _ j
  4913 0000283B [00040000]-        
  4914 0000283F [00040000]-        
  4915 00002843 [2D250000]         
  4916                                  ekbd0:
  4917 00002847 [14270000]-                 dd silverAction  , blueAction      , taupeAction   , act0         ; a b _ _
  4918 0000284B [18270000]-        
  4919 0000284F [20270000]-        
  4920 00002853 [F2260000]         
  4921 00002857 15250700                    db 0x15          , 0x25            , 0x07          , 0x00         ; four characters to display on the bottom line of the keyboard
  4922                                  
  4923                                  editorKeyTableHintChars:    ; display the current edit colour and mode in the bottom right hand corner of the keyboard
  4924 0000285B 00000000                    db 0x00, 0x00, 0x00, 0x00  ;
  4925 0000285F 0B010D00                    db 0x0B, 0x01, 0x0D, 0x00  ; y r g _    ; yellow red green *toggle            
  4926 00002863 00000000                    db 0x00, 0x00, 0x00, 0x00  ; l u d r    : left up down right                  
  4927 00002867 00090A00                    db 0x00, 0x09, 0x0A, 0x00  ; - m c +    ; - magenta cyan +                    
  4928 0000286B 00383A02                    db 0x00, 0x38, 0x3A, 0x02  ; _ S C t    ; ___ CAPITALS Capital text           
  4929 0000286F 00000000                    db 0x00, 0x00, 0x00, 0x00  ; _ _ _ j    ; ___ ___ ___ jump to previous block  
  4930 00002873 08130200                    db 0x08, 0x13, 0x02, 0x00  ; s b t _    ; silver blue taupe ___               
  4931                                  
  4932                                  ; Editor keypad display
  4933                                  ; _ S C t  y r g *
  4934                                  ; c d f j  l u d r
  4935                                  ; s b t k  - m c +      ; silver blue taupe change-colour
  4936                                  ;     x . i
  4937                                  
  4938                                  editorKeyboard:         ; the main editor keyboard icons
  4939 00002877 0B010D2D                    db 0x0B, 0x01, 0x0D, 0x2D  ; y r g *    ; yellow red green *toggle
  4940 0000287B 0C161001                    db 0x0C, 0x16, 0x10, 0x01  ; l u d r    : left up down right
  4941 0000287F 23090A2B                    db 0x23, 0x09, 0x0A, 0x2B  ; - m c +    ; - magenta cyan +
  4942 00002883 00383A02                    db 0x00, 0x38, 0x3A, 0x02  ; _ S C t    ; ___ CAPITALS Capital text
  4943 00002887 00000022                    db 0x00, 0x00, 0x00, 0x22  ; _ _ _ j    ; ___ ___ ___ jump to previous block  db 0x00, 0x10, 0x0E, 0x22  ; _ d f j
  4944 0000288B 08130200                    db 0x08, 0x13, 0x02, 0x00  ; s b t _    ; silver blue taupe ___
  4945                                  
  4946                                  set_e_main:
  4947 0000288F C705[9C390000]-             mov dword [ shiftAction ], ekbd0
  4948 00002895 [47280000]         
  4949 00002899 C705[98390000]-             mov dword [ currentKeyboardIcons ], ( editorKeyboard - 4 )
  4950 0000289F [73280000]         
  4951 000028A3 C705[A8390000]E0FF-         mov dword [ keyboard_colour ], colour_yellow
  4952 000028AB 0000               
  4953 000028AD C3                          ret
  4954                                  
  4955                                  edit0:
  4956                                      _DROP_
  4957 000028AE AD                  <1>  lodsd
  4958 000028AF EB39                        jmp short edit2
  4959                                  
  4960                                  edit_:   ; ( n -- )   \ edit block n
  4961 000028B1 8B0D[10390000]              mov ecx, [ v_blk ]
  4962 000028B7 890D[14390000]              mov [ v_otherBlock ], ecx
  4963 000028BD A3[10390000]                mov [ v_blk ], _TOS_              ; move TOS to blk variable
  4964                                      _DROP_
  4965 000028C2 AD                  <1>  lodsd
  4966                                  e_:
  4967 000028C3 C605[8F390000]FF            mov byte [ v_acceptMode ], 0xFF
  4968 000028CA E8B5F9FFFF                  call refresh
  4969                                  plus_e:
  4970 000028CF C705[B4390000]-             mov dword [ anumber ], tokenAction
  4971 000028D5 [2D260000]         
  4972 000028D9 C605[B2170000]25            mov byte [ alpha0+4*4 ], 0x25
  4973 000028E0 C705[A6170000]-             mov dword [ alpha0 + 4 ], edit0
  4974 000028E6 [AE280000]         
  4975                                  edit2:
  4976 000028EA E8A0FFFFFF                  call set_e_main
  4977                                      .back:
  4978 000028EF E8C6F0FFFF                  call clearHintChar
  4979 000028F4 E868EDFFFF                  call get_key_
  4980 000028F9 50                          push _TOS_
  4981 000028FA BB[5B280000]                mov _SCRATCH_, editorKeyTableHintChars
  4982 000028FF 8A0403                      mov byte al, [ _SCRATCH_ + _TOS_ ]
  4983 00002902 A3[90390000]                mov [ v_hintChar ], _TOS_
  4984 00002907 58                          pop _TOS_
  4985 00002908 FF1485[E7270000]            call [ ( _TOS_ * 4 ) + editorActionTable ]
  4986                                      _DROP_
  4987 0000290F AD                  <1>  lodsd
  4988 00002910 EBDD                        jmp short .back
  4989                                  
  4990                                  convertAddress:     ; ( a32 -- )    set up the block at the given 32 bit cell address, including the cursor position
  4991 00002912 89C3                        mov _SCRATCH_, _TOS_
  4992 00002914 81E3FF000000                and _SCRATCH_, 0x00FF
  4993 0000291A 891D[30390000]              mov [ v_curs ], _SCRATCH_   ; cell offset in block
  4994 00002920 E889DFFFFF                  call cellAddressToBlock
  4995 00002925 A3[10390000]                mov [ v_blk ], _TOS_
  4996                                      _DROP_
  4997 0000292A AD                  <1>  lodsd
  4998 0000292B C3                          ret
  4999                                  
  5000                                  editAddress:    ; ( a32 -- )    edit the block at the given 32 bit cell address, including the cursor position
  5001 0000292C E8E1FFFFFF                  call convertAddress
  5002 00002931 E854ECFFFF                  call abort_e2           ; abort and show the editor display
  5003 00002936 C3                          ret
  5004                                  
  5005                                  keypd:    ; display the keypad vectors and display characters at the address on top of the return stack
  5006 00002937 5A                          pop edx                             ; keypd is followed by call table then keymap
  5007 00002938 8915[EC220000]              mov [ vector ], edx                 ; edx points to the next colorForth word to be executed
  5008 0000293E 81C28C000000                add edx, ( 28 * 5 )                 ; 28 keys, 5 bytes per compiled call
  5009 00002944 8915[98390000]              mov [ currentKeyboardIcons ], edx
  5010 0000294A 83EA10                      sub edx, byte +16
  5011 0000294D 8915[9C390000]              mov [ shiftAction ], edx
  5012                                  .back:
  5013 00002953 E809EDFFFF                  call get_key_ ; Pause
  5014 00002958 8B15[EC220000]              mov edx, [ vector ]
  5015 0000295E 01C2                        add edx, _TOS_
  5016 00002960 8D548205                    lea edx, [ ( _TOS_ * 4 ) + edx + 0x05 ]
  5017 00002964 0352FC                      add edx, [ edx - 0x04 ]
  5018                                      _DROP_
  5019 00002967 AD                  <1>  lodsd
  5020                                  pad1:
  5021 00002968 FFD2                        call edx
  5022 0000296A EBE7                        jmp short keypd.back
  5023                                  
  5024                                  ; *****************************************************************************
  5025                                  ; QWERTY support
  5026                                  ; *****************************************************************************
  5027                                  
  5028                                  qwertyKeyboard:
  5029 0000296C 00000000                    dd 0
  5030 00002970 00000000                    dd 0
  5031 00002974 00000000                    dd 0
  5032 00002978 170F0401                    dd 0x01040f17       ; 'qwer'
  5033 0000297C 00000000                    dd 0
  5034 00002980 00000000                    dd 0
  5035                                  
  5036                                  qwertToggleBase:
  5037 00002984 8135[A4390000]3F00-         xor dword [ current ], ((setDecimalMode - $$) ^ (setHexMode - $$))
  5038 0000298C 0000               
  5039 0000298E 8035[D6170000]2F            xor byte [ ( numb0 + 12 ) ], 0x2F
  5040                                  qwertToggleBase1:
  5041                                  ;    call [ current ]
  5042                                  ;    mov dword [ qwertyKeyboard ], 0x00           ; '' => decimal
  5043                                  ;    cmp dword [ base ], byte +0x10
  5044                                  ;    jnz .forward
  5045                                  ;    mov dword [ qwertyKeyboard ], 0x00150414     ; 'hex'
  5046                                  ; .forward:
  5047                                  ;    mov dword [ currentKeyboardIcons ], pad1
  5048                                  ;    mov dword [ shiftAction ], qwertyKeyboard
  5049 00002995 C3                          ret
  5050                                  
  5051                                  qwertyAction4:
  5052 00002996 E8E9FFFFFF                  call qwertToggleBase
  5053 0000299B E979000000                  jmp qwertyAction3
  5054                                  
  5055                                  qwertyActionTable:
  5056 000029A0 [44190000]-                 dd endn, endn, xn, qwertyAction3, qwertyAction4
  5057 000029A4 [44190000]-        
  5058 000029A8 [B0190000]-        
  5059 000029AC [192A0000]-        
  5060 000029B0 [96290000]         
  5061                                  
  5062                                  qwertFunction1:
  5063 000029B4 E82CE6FFFF                  call right
  5064 000029B9 C7                          db 0xC7
  5065 000029BA 05[70290000]                add _TOS_, ( qwertyKeyboard + 4 )
  5066 000029BF 06                          push es
  5067 000029C0 16                          push ss
  5068 000029C1 0900                        or [_TOS_], _TOS_
  5069 000029C3 E8CDFFFFFF                  call qwertToggleBase1
  5070 000029C8 C605[E6180000]00            mov byte [ v_sign ], 0x00
  5071 000029CF A1[C0390000]                mov _TOS_, [ v_digin ]
  5072                                  qwertyAction5:
  5073 000029D4 E825EDFFFF                  call get_qwerty_key_
  5074 000029D9 7407                        jz .forward4
  5075 000029DB FF2485[A0270000]            jmp dword [ _TOS_ * 4 + qwertyActionTable - 0x200 ]
  5076                                  .forward4:
  5077 000029E2 85C0                        test _TOS_, _TOS_
  5078 000029E4 7E33                        jng qwertyAction3
  5079 000029E6 3C23                        cmp al, 0x23
  5080 000029E8 7427                        jz .forward3
  5081 000029EA A1[C0390000]                mov _TOS_, [ v_digin ]
  5082 000029EF 3B05[A0390000]              cmp _TOS_, [ base ]
  5083 000029F5 7918                        jns .forward2
  5084 000029F7 F605[E6180000]FF            test byte [ v_sign ], 0xFF
  5085 000029FE 7402                        jz .forward
  5086 00002A00 F7D8                        neg _TOS_
  5087                                  .forward:
  5088 00002A02 8B16                        mov edx, [ esi ]
  5089 00002A04 0FAF15[A0390000]            imul edx, [ base]
  5090 00002A0B 01C2                        add edx, _TOS_
  5091 00002A0D 8916                        mov [ esi ], edx
  5092                                  .forward2:
  5093 00002A0F EB08                        jmp short qwertyAction3
  5094                                  .forward3:
  5095 00002A11 3105[E6180000]              xor [ v_sign ], _TOS_
  5096 00002A17 F71E                        neg dword [ esi ]
  5097                                  
  5098                                  qwertyAction3:
  5099                                      _DROP_
  5100 00002A19 AD                  <1>  lodsd
  5101 00002A1A EBB8                        jmp short qwertyAction5
  5102                                  
  5103                                  qwertToggleBaseTable2:
  5104 00002A1C [FF170000]-                 dd lj, lj, x
  5105 00002A20 [FF170000]-        
  5106 00002A24 [59180000]         
  5107                                  
  5108                                  qwertyFunction2:
  5109 00002A28 C705[70290000]0204-         mov dword [ ( qwertyKeyboard + 4 ) ], 0x02150402  ; 'text'
  5110 00002A30 1502               
  5111 00002A32 E8AEE5FFFF                  call right
  5112 00002A37 C705[B8390000]0100-         mov dword [ v_words ], 0x01
  5113 00002A3F 0000               
  5114 00002A41 C705[AC390000]0100-         mov dword [ chars], 0x01
  5115 00002A49 0000               
  5116                                      _DUP_
  5117 00002A4B 83EE04              <1>  sub esi, byte 0x04
  5118 00002A4E 8906                <1>  mov [ esi ], _TOS_
  5119 00002A50 C70600000000                mov dword [ esi ], 0x00
  5120 00002A56 C605[F2170000]1C            mov byte [ bits_ ], 0x1C
  5121                                  .back:
  5122 00002A5D 740E                        jz .forward
  5123 00002A5F 3D83000000                  cmp _TOS_, 0x83
  5124 00002A64 7907                        jns .forward
  5125 00002A66 FF2485[1C280000]            jmp dword [ _TOS_*4 + qwertToggleBaseTable2 - 0x200 ]
  5126                                  .forward:
  5127 00002A6D 85C0                        test _TOS_, _TOS_
  5128 00002A6F 7E1C                        jng .forward2
  5129 00002A71 3D30000000                  cmp _TOS_, 0x30
  5130 00002A76 7915                        jns .forward2
  5131                                      _DUP_
  5132 00002A78 83EE04              <1>  sub esi, byte 0x04
  5133 00002A7B 8906                <1>  mov [ esi ], _TOS_
  5134 00002A7D E84AE5FFFF                  call echo_
  5135 00002A82 E8A6EDFFFF                  call pack_
  5136 00002A87 FF05[AC390000]              inc dword [ chars]
  5137                                  .forward2:
  5138                                      _DROP_
  5139 00002A8D AD                  <1>  lodsd
  5140 00002A8E E86BECFFFF                  call get_qwerty_key_
  5141 00002A93 EBC8                        jmp short .back
  5142                                  
  5143                                  qwertyAction2:
  5144 00002A95 E8EAFEFFFF                  call qwertToggleBase
  5145 00002A9A E918EFFFFF                  jmp dword nul0
  5146                                  
  5147                                  qwertyAction1:
  5148 00002A9F FF25[A6170000]              jmp dword [ alpha0 + 4 ]
  5149                                  
  5150                                  qwertyTable1:
  5151 00002AA5 [B7190000]                  dd nul0
  5152 00002AA9 [B7190000]                  dd nul0
  5153 00002AAD [B7190000]                  dd nul0
  5154 00002AB1 [9F2A0000]                  dd qwertyAction1
  5155 00002AB5 [952A0000]                  dd qwertyAction2
  5156                                  
  5157                                  qwertyDoAction:
  5158 00002AB9 C705[70290000]0000-         mov dword [ ( qwertyKeyboard + 4 ) ], 0x00   ; clear the 'text' string
  5159 00002AC1 0000               
  5160 00002AC3 C705[9C390000]-             mov dword [ shiftAction ], qwertyKeyboard
  5161 00002AC9 [6C290000]         
  5162 00002ACD C705[98390000]-             mov dword [ currentKeyboardIcons ], pad1
  5163 00002AD3 [68290000]         
  5164                                  
  5165                                  .back2:
  5166 00002AD7 E822ECFFFF                  call get_qwerty_key_
  5167 00002ADC 7407                        jz .forward
  5168 00002ADE FF2485[A5280000]            jmp dword [ ( _TOS_ * 4 ) + qwertyTable1 - 0x0200 ]
  5169                                  
  5170                                  .forward:
  5171 00002AE5 3C30                        cmp al, 0x30
  5172 00002AE7 750D                        jnz .back
  5173 00002AE9 C705[70290000]0204-         mov dword [ ( qwertyKeyboard + 4 ) ], 0x02150402  ; 'text'
  5174 00002AF1 1502               
  5175                                      _DROP_
  5176 00002AF3 AD                  <1>  lodsd
  5177 00002AF4 EBE1                        jmp short .back2
  5178                                  .back:
  5179 00002AF6 85C0                        test _TOS_, _TOS_
  5180 00002AF8 7E30                        jng .forward3
  5181 00002AFA F705[70290000]FFFF-         test dword [ ( qwertyKeyboard + 4 ) ], 0xFFFFFFFF
  5182 00002B02 FFFF               
  5183 00002B04 750D                        jnz .forward2
  5184 00002B06 803D[C0390000]0A            cmp byte [ v_digin ], 0x0A
  5185 00002B0D 0F88A1FEFFFF                js qwertFunction1
  5186                                  .forward2:
  5187 00002B13 3D30000000                  cmp _TOS_, 0x30
  5188 00002B18 7910                        jns .forward3
  5189 00002B1A E809FFFFFF                  call qwertyFunction2
  5190 00002B1F FF15[B0390000]              call [ aword ]
  5191                                      _DUP_
  5192 00002B25 83EE04              <1>  sub esi, byte 0x04
  5193 00002B28 8906                <1>  mov [ esi ], _TOS_
  5194                                  .forward3:
  5195                                      _DROP_
  5196 00002B2A AD                  <1>  lodsd
  5197 00002B2B E996EEFFFF                  jmp dword accept
  5198                                  
  5199                                  qwert:      ; selects QWERTY keyboard entry
  5200 00002B30 C705[80390000]-             mov dword [ x_qwerty ], qwertyDoAction
  5201 00002B36 [B92A0000]         
  5202 00002B3A C3                          ret
  5203                                  
  5204                                  ; *****************************************************************************
  5205                                  
  5206                                  abort_action:
  5207 00002B3B 81FF00400000                cmp edi, ( RELOCATED / 4 )  ; if we are compiling a block, show the location of the error
  5208                                      ; edi is a cell address, so divide by 4
  5209 00002B41 7216                        jc .forward
  5210                                      _DUP_
  5211 00002B43 83EE04              <1>  sub esi, byte 0x04
  5212 00002B46 8906                <1>  mov [ esi ], _TOS_
  5213 00002B48 A1[10390000]                mov _TOS_, [ v_blk ]
  5214 00002B4D A3[14390000]                mov [ v_otherBlock ], _TOS_ ; save the last block to be edited
  5215 00002B52 89F8                        mov _TOS_, edi
  5216 00002B54 E8B9FDFFFF                  call convertAddress
  5217                                  .forward:
  5218 00002B59 BC00780000                  mov esp, RETURN_STACK_0
  5219 00002B5E 81FE04760000                cmp esi, ( DATA_STACK_0 + 4 )
  5220 00002B64 7205                        jc .forward2
  5221 00002B66 BE04760000                  mov esi, ( DATA_STACK_0 + 4 )
  5222                                  .forward2:
  5223 00002B6B C705[003A0000]-             mov dword [ tokenActions + ( 3 * 4 ) ], forthd
  5224 00002B71 [D9050000]         
  5225 00002B75 C705[043A0000]-             mov dword [ tokenActions + ( 4 * 4 ) ], qcompile
  5226 00002B7B [20070000]         
  5227 00002B7F C705[083A0000]-             mov dword [ tokenActions + ( 5 * 4 ) ], cnum
  5228 00002B85 [C0060000]         
  5229 00002B89 C705[0C3A0000]-             mov dword [ tokenActions + ( 6 * 4 ) ], cshort
  5230 00002B8F [D0060000]         
  5231 00002B93 B82F000000                  mov _TOS_, 0x2F     ; '?' character to follow the display of the unknown word
  5232 00002B98 E82FE4FFFF                  call echo_
  5233                                  ;    jmp abort_e2
  5234 00002B9D E924EEFFFF                  jmp dword accept
  5235                                  
  5236                                  ; *****************************************************************************
  5237                                  
  5238                                  rquery: ; r?
  5239                                      _DUP_
  5240 00002BA2 83EE04              <1>  sub esi, byte 0x04
  5241 00002BA5 8906                <1>  mov [ esi ], _TOS_
  5242 00002BA7 B800780000                  mov _TOS_, RETURN_STACK_0
  5243 00002BAC 29E0                        sub _TOS_, esp
  5244 00002BAE D1E8                        shr _TOS_,1
  5245 00002BB0 D1E8                        shr _TOS_,1
  5246 00002BB2 C3                          ret
  5247                                  
  5248                                  boot:
  5249                                      ; see http://wiki.osdev.org/PS2_Keyboard#CPU_Reset
  5250 00002BB3 B0FE                        mov al, 0xFE
  5251 00002BB5 E664                        out 0x64, al
  5252 00002BB7 EBFE                        jmp short $         ; we should never get here, because the processor will be rebooted... stop here just in case
  5253                                  
  5254                                  wipe:  ; ( -- )    \ wipe the currently edited block
  5255                                      _DUP_
  5256 00002BB9 83EE04              <1>  sub esi, byte 0x04
  5257 00002BBC 8906                <1>  mov [ esi ], _TOS_
  5258 00002BBE A1[10390000]                mov _TOS_, [ v_blk ]
  5259 00002BC3 B940000000                  mov ecx, 0x40
  5260                                  wipe2:
  5261 00002BC8 57                          push edi
  5262 00002BC9 E8D6DCFFFF                  call blockToCellAddress     ; add the RELOCATED block number offset and convert to cell address
  5263 00002BCE C1E002                      shl _TOS_, 2                ; convert to byte address
  5264 00002BD1 89C7                        mov edi, _TOS_
  5265 00002BD3 31C0                        xor _TOS_, _TOS_
  5266 00002BD5 F3AB                        rep stosd
  5267 00002BD7 5F                          pop edi
  5268                                      _DROP_
  5269 00002BD8 AD                  <1>  lodsd
  5270 00002BD9 C3                          ret
  5271                                  
  5272                                  wipes:  ; ( startblock# #blocks -- )    \ wipes #blocks starting from block startblock#   ( was erase )
  5273 00002BDA 89C1                        mov ecx, _TOS_
  5274 00002BDC C1E106                      shl ecx, 0x06               ;  convert blocks to cells, multiply by 64
  5275                                      _DROP_
  5276 00002BDF AD                  <1>  lodsd
  5277 00002BE0 E9E3FFFFFF                  jmp wipe2
  5278                                  
  5279                                  copy_:   ; ( blk -- )    \ copy the given block (and shadow) to the currently displayed block (and shadow)
  5280 00002BE5 83F80C                      cmp _TOS_, byte 0x0C        ; below block 12 is machine code
  5281 00002BE8 0F826AD9FFFF                jc abort
  5282 00002BEE 57                          push edi
  5283 00002BEF 56                          push esi
  5284 00002BF0 51                          push ecx
  5285 00002BF1 E8AEDCFFFF                  call blockToCellAddress     ; source block
  5286 00002BF6 C1E002                      shl _TOS_, 0x02             ; convert cell address to byte address
  5287 00002BF9 89C6                        mov esi, _TOS_
  5288 00002BFB A1[10390000]                mov _TOS_, [ v_blk ]
  5289 00002C00 E89FDCFFFF                  call blockToCellAddress     ; destination block
  5290 00002C05 C1E002                      shl _TOS_, 0x02             ; convert cell address to byte address
  5291 00002C08 89C7                        mov edi, _TOS_
  5292 00002C0A B900020000                  mov ecx, 0x0200
  5293 00002C0F F3A5                        rep  movsd                  ; copy ecx 32 bit words from ds:esi to es:edi
  5294 00002C11 59                          pop ecx
  5295 00002C12 5E                          pop esi
  5296 00002C13 5F                          pop edi
  5297                                      _DROP_
  5298 00002C14 AD                  <1>  lodsd
  5299 00002C15 C3                          ret
  5300                                  
  5301                                  debug:
  5302 00002C16 C705[343A0000]B502-         mov dword [ v_xy ], 0x302B5
  5303 00002C1E 0300               
  5304                                      _DUP_
  5305 00002C20 83EE04              <1>  sub esi, byte 0x04
  5306 00002C23 8906                <1>  mov [ esi ], _TOS_
  5307 00002C25 A1[2F040000]                mov _TOS_, [ God ]
  5308 00002C2A FF30                        push dword [_TOS_]
  5309 00002C2C E8C5E4FFFF                  call dotHex
  5310                                      _DUP_
  5311 00002C31 83EE04              <1>  sub esi, byte 0x04
  5312 00002C34 8906                <1>  mov [ esi ], _TOS_
  5313 00002C36 58                          pop _TOS_
  5314 00002C37 E8BAE4FFFF                  call dotHex
  5315                                      _DUP_
  5316 00002C3C 83EE04              <1>  sub esi, byte 0x04
  5317 00002C3F 8906                <1>  mov [ esi ], _TOS_
  5318 00002C41 A1[38040000]                mov _TOS_, [ main ]
  5319 00002C46 E8ABE4FFFF                  call dotHex
  5320                                      _DUP_
  5321 00002C4B 83EE04              <1>  sub esi, byte 0x04
  5322 00002C4E 8906                <1>  mov [ esi ], _TOS_
  5323 00002C50 89F0                        mov _TOS_, esi
  5324 00002C52 E99FE4FFFF                  jmp dword dotHex
  5325                                  
  5326                                  ; *****************************************************************************
  5327                                  
  5328                                  tic0:
  5329 00002C57 FF0D[B8390000]              dec dword [ v_words ]
  5330 00002C5D 7403                        jz .forward
  5331                                      _DROP_
  5332 00002C5F AD                  <1>  lodsd
  5333 00002C60 EBF5                        jmp short tic0
  5334                                  .forward:
  5335 00002C62 C3                          ret
  5336                                  
  5337                                  tic_:   ; ( -- a )   \ return the byte address of the next word entered
  5338 00002C63 E888F9FFFF                  call _word          ; allow user to enter the word to  search for
  5339 00002C68 E8EAFFFFFF                  call tic0           ; remove the entered word from the stack
  5340 00002C6D E8D2D8FFFF                  call find_          ; find the word in the dictionary, return its index in  ecx
  5341 00002C72 0F85E0D8FFFF                jnz abort
  5342 00002C78 8B048D00A84600              mov _TOS_, [ ( ecx * 4 ) + ForthJumpTable ]     ; return the word's address from the jump table
  5343 00002C7F C3                          ret
  5344                                  
  5345                                  itick:
  5346 00002C80 25F0FFFFFF                  and _TOS_, 0xFFFFFFF0
  5347 00002C85 E8BAD8FFFF                  call find_
  5348 00002C8A 8B048D00A84600              mov _TOS_, [ ( ecx * 4 ) + ForthJumpTable ]
  5349 00002C91 C3                          ret
  5350                                  
  5351                                  ; *****************************************************************************
  5352                                  
  5353                                  ; ToDo: fix this!!!
  5354                                  showWords_:     ; ( -- )   \ show all words in the Forth wordlist
  5355 00002C92 E8C2D7FFFF                  call show
  5356 00002C97 57                          push edi
  5357 00002C98 E8D9E2FFFF                  call setRed
  5358 00002C9D 8D3DFC7F4600                lea edi, [ ForthNames - 4 ]   ; set edi to the bottom of the Forth name table
  5359 00002CA3 8B0D[EC390000]              mov ecx, [ v_ForthWordCount ]   ; count of Forth wordlist words
  5360                                  .loop:
  5361 00002CA9 E891F0FFFF                  call type_            ; show one Shannon-Fano encoded word
  5362 00002CAE E8DEE1FFFF                  call space_
  5363 00002CB3 47                          inc edi
  5364 00002CB4 E2F3                        loop .loop
  5365 00002CB6 5F                          pop edi
  5366 00002CB7 C3                          ret
  5367                                  
  5368                                  words_:
  5369 00002CB8 E8D5FFFFFF                  call showWords_
  5370 00002CBD C3                          ret
  5371                                  
  5372                                  ; *****************************************************************************
  5373                                  
  5374                                  ; Int 0x13 AH Return Code error type
  5375                                  ; 0x00 Success
  5376                                  ; 0x01 Invalid Command
  5377                                  ; 0x02 Cannot Find Address Mark
  5378                                  ; 0x03 Attempted Write On Write Protected Disk
  5379                                  ; 0x04 Sector Not Found
  5380                                  ; 0x05 Reset Failed
  5381                                  ; 0x06 Disk change line 'active'
  5382                                  ; 0x07 Drive parameter activity failed
  5383                                  ; 0x08 DMA overrun
  5384                                  ; 0x09 Attempt to DMA over 64kb boundary
  5385                                  ; 0x0A Bad sector detected
  5386                                  ; 0x0B Bad cylinder (track) detected
  5387                                  ; 0x0C Media type not found
  5388                                  ; 0x0D Invalid number of sectors
  5389                                  ; 0x0E Control data address mark detected
  5390                                  ; 0x0F DMA out of range
  5391                                  ; 0x10 CRC/ECC data error
  5392                                  ; 0x11 ECC corrected data error
  5393                                  ; 0x20 Controller failure
  5394                                  ; 0x40 Seek failure
  5395                                  ; 0x80 Drive timed out, assumed not ready
  5396                                  ; 0xAA Drive not ready
  5397                                  ; 0xBB Undefined error
  5398                                  ; 0xCC Write fault
  5399                                  ; 0xE0 Status error
  5400                                  ; 0xFF Sense operation failed
  5401                                  
  5402                                  ; *****************************************************************************
  5403                                  ; 16 bit BIOS disk read/write from 32 bit
  5404                                  ; *****************************************************************************
  5405                                  
  5406                                  ; set the required parameters into the DAP buffer for the LBA BIOS extended read/write calls.
  5407                                  ; Also set up the extra DAP buffer values for use by the CHS BIOS calls, if the LBA call fails.
  5408                                  ; This is to avoid returning from 16 bit mode to calculate the values.
  5409                                  setupDAP_:   ; ( sector n cmd -- )   \ setup the DAP for the given LBA sector number
  5410                                  
  5411 00002CBE 57                          push edi
  5412                                  
  5413 00002CBF 31C9                        xor ecx, ecx
  5414 00002CC1 BF687C0000                  mov edi, (data_area - $$ + BOOTOFFSET)   ; setup the data index pointer
  5415 00002CC6 66678B8D0400                mov cx, [ word di + ( driveinfo_Drive_DX - data_area ) ]  ; restore the boot drive into dl
  5416 00002CCC BFE0170000                  mov edi, DAP_BUFFER
  5417 00002CD1 66894F12                    mov word [ edi + o_Int13_DAP_saved_DX ], cx     ; setup DX value returned by the BIOS
  5418                                  
  5419 00002CD5 66894710                    mov word [ edi + o_Int13_DAP_readwrite ], ax    ; set the read/write cmd value, 0x0000 or 0x0001
  5420                                      _DROP_
  5421 00002CD9 AD                  <1>  lodsd
  5422                                  
  5423                                      ; limit the number of sectors to the size of the SECTOR_BUFFER
  5424 00002CDA 3D24000000                  cmp _TOS_, ( SECTOR_BUFFER_SIZE / 0x0200 )
  5425 00002CDF 7805                        js .forward
  5426 00002CE1 B824000000                      mov _TOS_, ( SECTOR_BUFFER_SIZE / 0x0200 )
  5427                                      .forward:
  5428 00002CE6 66894702                    mov word [ edi + o_Int13_DAP_num_sectors ], ax
  5429                                      _DROP_
  5430 00002CEA AD                  <1>  lodsd
  5431                                  
  5432 00002CEB 894708                      mov dword [ edi + o_Int13_DAP_LBA_64_lo ], eax
  5433 00002CEE 50                          push eax    ; save for later
  5434                                  
  5435 00002CEF 31C0                        xor eax, eax
  5436 00002CF1 89470C                      mov dword [ edi + o_Int13_DAP_LBA_64_hi ], eax
  5437                                  
  5438                                      ; buffer within low 16 bits of address space
  5439 00002CF4 66894706                    mov word [ edi + o_Int13_DAP_segment ], ax
  5440 00002CF8 66B80020                    mov ax, ( SECTOR_BUFFER )
  5441 00002CFC 66894704                    mov word [ edi + o_Int13_DAP_address ], ax
  5442                                  
  5443                                      ; set the configuration buffer values from the registers
  5444 00002D00 B810000000                  mov eax, 0x0010
  5445 00002D05 668907                      mov word [ edi + o_Int13_DAP_size ], ax  ; setup DAP buffer size
  5446                                  
  5447                                  ; setup values for CHS BIOS disk calls
  5448                                  
  5449 00002D08 58                          pop eax                         ; restore the start sector number
  5450 00002D09 0305687C0000                add eax, [ bootsector - $$ + BOOTOFFSET]    ; add the bootsector from the drive parameter table
  5451                                  
  5452 00002D0F 50                          push eax                        ; save it while we calculate heads*sectors-per-track
  5453 00002D10 A0717C0000                  mov al, [ driveinfo_Head - $$ + BOOTOFFSET]      ; index of highest-numbered head
  5454 00002D15 FEC0                        inc al                          ; 1-base the number to make count of heads
  5455 00002D17 F625727C0000                mul byte [ driveinfo_SectorsPertrack - $$ + BOOTOFFSET]     ; sectors per track
  5456 00002D1D 89C3                        mov ebx, eax
  5457 00002D1F 58                          pop eax
  5458 00002D20 31D2                        xor edx, edx                    ; clear high 32 bits
  5459 00002D22 F7F3                        div ebx                         ; leaves cylinder number in eax, remainder in edx
  5460 00002D24 89C1                        mov ecx, eax                    ; store cylinder number in another register
  5461 00002D26 89D0                        mov eax, edx                    ; get remainder into AX
  5462 00002D28 8A1D727C0000                mov bl, [ driveinfo_SectorsPertrack - $$ + BOOTOFFSET]      ; number of sectors per track
  5463 00002D2E F6F3                        div bl                          ; head number into AX, remainder into DX
  5464 00002D30 88C3                        mov bl, al                      ; result must be one byte, so store it in BL
  5465 00002D32 C1C108                      rol ecx, 8                      ; high 2 bits of cylinder number into high 2 bits of CL
  5466 00002D35 C0E106                      shl cl, 6                       ; makes room for sector number
  5467 00002D38 08E1                        or cl, ah                       ; merge cylinder number with sector number
  5468 00002D3A FEC1                        inc cl                          ; one-base sector number
  5469 00002D3C 66894F18                    mov word [ edi + o_Int13_DAP_saved_CHS_CX ], cx  ; also save the calculated CX value
  5470 00002D40 668B0D6C7C0000              mov cx, [ driveinfo_Drive_DX - $$ + BOOTOFFSET]    ; drive number in low 8 bits
  5471 00002D47 88DD                        mov ch, bl                      ; place head number in high bits
  5472 00002D49 66894F1A                    mov word [ edi + o_Int13_DAP_saved_CHS_DX ], cx  ; also save the calculated DX value
  5473                                  
  5474 00002D4D 5F                          pop edi
  5475                                      _DROP_
  5476 00002D4E AD                  <1>  lodsd
  5477                                  
  5478 00002D4F C3                          ret
  5479                                  
  5480                                  ; *****************************************************************************
  5481                                  ; BIOS read/write 512 byte LBA sectors
  5482                                  ; *****************************************************************************
  5483                                  
  5484                                  BIOS_ReadWrite_Sector_LBA: ; ( -- )   \ try to read or write using the extended disk BIOS calls,
  5485                                  ; \ if that fails, try the CHS BIOS call. Parameters are in the DAP buffer.
  5486                                  
  5487 00002D50 9C                         pushf   ; save the processor flags, especially interrupt enable
  5488                                  
  5489                                  %ifdef NOT_BOCHS
  5490                                      call restore_BIOS_idt_and_pic   ;
  5491                                  %endif
  5492                                  
  5493                                      _DUP_
  5494 00002D51 83EE04              <1>  sub esi, byte 0x04
  5495 00002D54 8906                <1>  mov [ esi ], _TOS_
  5496 00002D56 31C0                        xor _TOS_, _TOS_
  5497 00002D58 E83A050000                  call lidt_                      ; Load the BIOS Interrupt Descriptor Table
  5498                                  
  5499 00002D5D E8B4D5FFFF                  call setRealModeAPI
  5500                                  [BITS 16]                           ; Real Mode code (16 bit)
  5501 00002D62 BEE017                      mov si, DAP_BUFFER
  5502 00002D65 8A6410                      mov byte ah, [ si + o_Int13_DAP_readwrite ]  ; 0x00 for read, 0x01 for write
  5503 00002D68 80CC42                      or  ah, 0x42                    ; BIOS extended read/write
  5504 00002D6B B000                        mov al, 0x00
  5505 00002D6D 8B5412                      mov dx, [ si + o_Int13_DAP_saved_DX ]
  5506 00002D70 CD13                        int 0x13
  5507 00002D72 FA                          cli                             ; BIOS might have left interrupts enabled
  5508                                  
  5509 00002D73 894414                      mov word [ si + o_Int13_DAP_returned_AX ], ax  ; save the value in AX that the BIOS call returned
  5510 00002D76 7326                        jnc .forward
  5511 00002D78 BEE017                          mov si, DAP_BUFFER
  5512                                  
  5513 00002D7B 8A6410                          mov byte ah, [ si + o_Int13_DAP_readwrite ]  ; 0x00 for read, 0x01 for write
  5514 00002D7E 80CC02                          or  ah, 0x02                ; CHS BIOS mode, read  al  sectors, set above
  5515 00002D81 8A4402                          mov al, byte [ si + o_Int13_DAP_num_sectors ]   ; restore the number of sectors saved by setupDAP_
  5516                                  
  5517 00002D84 8B4C18                          mov word cx, [ si + o_Int13_DAP_saved_CHS_CX ]  ; restore the CX value calculated by sector_chs
  5518 00002D87 8B541A                          mov word dx, [ si + o_Int13_DAP_saved_CHS_DX ]  ; restore the DX value calculated by sector_chs
  5519 00002D8A 8B5C04                          mov word bx, [ si + o_Int13_DAP_address ]       ; restore the address saved by setupDAP_
  5520 00002D8D CD13                            int 0x13
  5521 00002D8F FA                              cli                         ; BIOS might have left interrupts enabled
  5522                                  
  5523 00002D90 BEE017                          mov si, DAP_BUFFER
  5524 00002D93 894414                          mov word [ si + o_Int13_DAP_returned_AX ], ax  ; the BIOS call returned AX
  5525 00002D96 B80100                          mov ax, 0x0001
  5526 00002D99 7206                            jc .forward2
  5527 00002D9B B80000                             mov ax, 0x0000
  5528                                          .forward:
  5529 00002D9E 894416                          mov [ si + o_Int13_DAP_returned_carry_flag ], ax  ; the BIOS call returned carry flag
  5530                                      .forward2:
  5531 00002DA1 894416                      mov [ si + o_Int13_DAP_returned_carry_flag ], ax  ; the BIOS call returned carry flag
  5532                                  
  5533 00002DA4 E846D5                      call setProtectedModeAPI        ; called from 16 bit code, returns to 32 bit code
  5534                                  [BITS 32]                           ; Protected Mode code (32 bit)
  5535                                  
  5536                                  %ifdef NOT_BOCHS
  5537                                      call restore_new_idt_and_pic
  5538                                  %endif
  5539                                  
  5540                                      _DUP_
  5541 00002DA7 83EE04              <1>  sub esi, byte 0x04
  5542 00002DAA 8906                <1>  mov [ esi ], _TOS_
  5543 00002DAC B8001C0000                  mov _TOS_, INTERRUPT_VECTORS
  5544 00002DB1 E8E1040000                  call lidt_                      ; Load the new Interrupt Descriptor Table
  5545                                  
  5546 00002DB6 9D                          popf   ; restore the processor flags, especially interrupt enable
  5547                                  
  5548 00002DB7 C3                          ret
  5549                                  
  5550                                  Read_Sector_LBA:    ; ( sector n -- )   "rlba"   GetFlag returns 0 for success
  5551                                      _DUP_
  5552 00002DB8 83EE04              <1>  sub esi, byte 0x04
  5553 00002DBB 8906                <1>  mov [ esi ], _TOS_
  5554 00002DBD B800000000                  mov eax, 0x0000                 ; read command
  5555 00002DC2 E8F7FEFFFF                  call setupDAP_                  ; setup up the DAP table using 3 items from the stack ( start n cmd -- )
  5556 00002DC7 FA                          cli                             ; disable interrupts
  5557 00002DC8 60                          pushad                          ; Pushes all general purpose registers onto the stack
  5558 00002DC9 E882FFFFFF                  call BIOS_ReadWrite_Sector_LBA
  5559 00002DCE 61                          popad                           ; restore the registers pushed by  pushad
  5560 00002DCF C3                          ret
  5561                                  
  5562                                  Write_Sector_LBA:   ; ( sector n -- )   "wlba"
  5563                                      _DUP_
  5564 00002DD0 83EE04              <1>  sub esi, byte 0x04
  5565 00002DD3 8906                <1>  mov [ esi ], _TOS_
  5566 00002DD5 B801000000                  mov eax, 0x0001                 ; write command
  5567 00002DDA E8DFFEFFFF                  call setupDAP_                  ; setup up the DAP table using 3 items from the stack ( start n cmd -- )
  5568 00002DDF FA                          cli                             ; disable interrupts
  5569 00002DE0 60                          pushad                          ; Pushes all general purpose registers onto the stack
  5570 00002DE1 E86AFFFFFF                  call BIOS_ReadWrite_Sector_LBA
  5571 00002DE6 61                          popad                           ; restore the registers pushed by  pushad
  5572 00002DE7 C3                          ret
  5573                                  
  5574                                  ReadSectors:    ; ( a sector n -- a' )  \ read  n  sectors from  sector  into address  a
  5575 00002DE8 E8CBFFFFFF                  call Read_Sector_LBA            ; reads  n  sectors starting from  sector  into the SECTOR_BUFFER
  5576                                  
  5577 00002DED 56                          push esi                        ; esi is changed by rep movsw
  5578                                  
  5579 00002DEE BEE0170000                  mov esi, DAP_BUFFER
  5580 00002DF3 31C9                        xor ecx, ecx
  5581 00002DF5 66678B4C02                  mov word cx, [ si + o_Int13_DAP_num_sectors ]   ; restore the number of sectors saved by setupDAP_
  5582 00002DFA 89CB                        mov ebx, ecx                    ; save number of sectors for later
  5583 00002DFC BE00200000                  mov esi, SECTOR_BUFFER          ; source address
  5584 00002E01 89C7                        mov edi, eax                    ; destination address
  5585 00002E03 C1E107                      shl ecx, 0x07                   ; 512 bytes in cells = 2 ** 7
  5586 00002E06 F3A5                        rep movsd                       ; does not change AX , it moves DS:SI to ES:DI and increments SI and DI
  5587                                  
  5588                                      ; ( a -- a' )
  5589 00002E08 89D9                        mov ecx, ebx
  5590 00002E0A C1E109                      shl ecx, 0x09                   ; 512 bytes in bytes = 2 ** 9
  5591 00002E0D 01C8                        add eax, ecx                    ; increment the address that is TOS
  5592                                  
  5593 00002E0F 5E                          pop esi
  5594                                      ; ( a -- a' sector' )
  5595                                      _DUP_
  5596 00002E10 83EE04              <1>  sub esi, byte 0x04
  5597 00002E13 8906                <1>  mov [ esi ], _TOS_
  5598 00002E15 56                          push esi
  5599 00002E16 BEE0170000                  mov esi, DAP_BUFFER             ; esi is changed by rep movsd above
  5600 00002E1B 31C9                        xor ecx, ecx
  5601 00002E1D 66678B4C08                  mov word cx, [ si + o_Int13_DAP_LBA_64_lo ]   ; restore the start sector
  5602 00002E22 5E                          pop esi
  5603 00002E23 89C8                        mov eax, ecx
  5604 00002E25 01D8                        add eax, ebx
  5605                                  
  5606                                  ;    call GetFlag
  5607 00002E27 C3                          ret
  5608                                  
  5609                                  WriteSectors:    ; ( a sector n -- a' ) \ write  n  sectors starting at  sector  from address  a
  5610                                  
  5611 00002E28 52                          push edx
  5612                                  
  5613 00002E29 8B5604                      mov edx, [ esi + 4 ]            ; save  a  from stack in  edx
  5614                                  
  5615 00002E2C 56                          push esi                        ; esi is also changed by rep movsw
  5616 00002E2D BEE0170000                  mov esi, DAP_BUFFER
  5617 00002E32 31C9                        xor ecx, ecx
  5618 00002E34 66678B4C02                  mov word cx, [ si + o_Int13_DAP_num_sectors ]   ; restore the number of sectors saved by setupDAP_
  5619 00002E39 89CB                        mov ebx, ecx                    ; save number of sectors for later
  5620                                  
  5621 00002E3B C1E107                      shl ecx, 0x07                   ; 512 bytes in cells = 2 ** 7
  5622                                  
  5623 00002E3E 89D6                        mov esi, edx                    ; source address
  5624 00002E40 BF00200000                  mov edi, SECTOR_BUFFER          ; destination address
  5625 00002E45 F3A5                        rep movsd                       ; does not change AX , it moves DS:SI to ES:DI and increments SI and DI
  5626                                  
  5627 00002E47 5E                          pop esi
  5628                                  
  5629 00002E48 53                          push ebx
  5630 00002E49 E882FFFFFF                  call Write_Sector_LBA    ; writes  n  sectors starting from  sector  from the SECTOR_BUFFER
  5631 00002E4E 5B                          pop ebx
  5632                                  ;    push esi                        ; esi is also changed by rep movsw
  5633                                  
  5634                                      ; ( a -- a' )
  5635 00002E4F 89D9                        mov ecx, ebx
  5636 00002E51 C1E109                      shl ecx, 0x09                   ; 512 bytes in bytes = 2 ** 9
  5637 00002E54 01C8                        add eax, ecx                    ; increment the address that is TOS
  5638                                  
  5639                                  ;    pop esi
  5640                                      ; ( a -- a' sector' )
  5641                                      _DUP_
  5642 00002E56 83EE04              <1>  sub esi, byte 0x04
  5643 00002E59 8906                <1>  mov [ esi ], _TOS_
  5644 00002E5B 56                          push esi
  5645 00002E5C BEE0170000                  mov esi, DAP_BUFFER             ; esi is changed by rep movsd above
  5646 00002E61 31C9                        xor ecx, ecx
  5647 00002E63 66678B4C08                  mov word cx, [ si + o_Int13_DAP_LBA_64_lo ]   ; restore the start sector
  5648 00002E68 5E                          pop esi
  5649 00002E69 89C8                        mov eax, ecx
  5650 00002E6B 01D8                        add eax, ebx
  5651                                  
  5652 00002E6D 5A                          pop edx
  5653                                  
  5654                                  ;    call GetFlag
  5655 00002E6E C3                          ret
  5656                                  
  5657                                  SaveAll_:    ; ( -- ) "sss"
  5658 00002E6F 9C                          pushf   ; save the processor flags, especially interrupt enable
  5659 00002E70 FA                          cli
  5660                                  
  5661                                      _DUP_
  5662 00002E71 83EE04              <1>  sub esi, byte 0x04
  5663 00002E74 8906                <1>  mov [ esi ], _TOS_
  5664 00002E76 31C0                        xor eax, eax
  5665 00002E78 E80B020000                  call block_
  5666                                      _DUP_
  5667 00002E7D 83EE04              <1>  sub esi, byte 0x04
  5668 00002E80 8906                <1>  mov [ esi ], _TOS_
  5669 00002E82 31C0                        xor eax, eax
  5670 00002E84 B920000000                  mov ecx, 0x20   ; 32 x 16 Kbytes= 512 Kbytes
  5671                                      .back:
  5672                                      _DUP_
  5673 00002E89 83EE04              <1>  sub esi, byte 0x04
  5674 00002E8C 8906                <1>  mov [ esi ], _TOS_
  5675 00002E8E B820000000                  mov eax, 0x20   ; 32 x 512 byte sectors = 16 Kbytes
  5676                                      ; ( a sector n -- )
  5677                                      ; ( 0block 0 0x20 --)
  5678 00002E93 51                          push ecx
  5679 00002E94 E88FFFFFFF                  call WriteSectors
  5680 00002E99 59                          pop ecx
  5681 00002E9A E2ED                        loop .back
  5682                                      _DROP_
  5683 00002E9C AD                  <1>  lodsd
  5684                                      _DROP_
  5685 00002E9D AD                  <1>  lodsd
  5686                                  
  5687 00002E9E 9D                          popf   ; restore the processor flags, especially interrupt enable
  5688 00002E9F C3                      ret
  5689                                  
  5690                                  GetFlag: ; ( -- error | 0 )   0 for success, else the error type ( eax == 0x100 is Invalid Command )
  5691                                      _DUP_
  5692 00002EA0 83EE04              <1>  sub esi, byte 0x04
  5693 00002EA3 8906                <1>  mov [ esi ], _TOS_
  5694 00002EA5 31C0                        xor eax, eax
  5695 00002EA7 57                          push edi
  5696 00002EA8 BFE0170000                  mov edi, DAP_BUFFER
  5697 00002EAD 668B4716                    mov ax, [ edi + o_Int13_DAP_returned_carry_flag ]  ; the BIOS call returned carry flag
  5698 00002EB1 66050000                    add ax, 0
  5699 00002EB5 7404                        jz .forward
  5700 00002EB7 668B4714                        mov ax, [ edi + o_Int13_DAP_returned_AX ]  ; the BIOS call returned error value in ax
  5701                                      .forward:
  5702 00002EBB 5F                          pop edi
  5703 00002EBC C3                          ret
  5704                                  
  5705                                  %if 0
  5706                                  BIOS_Read_Sector_CHS:
  5707                                      call setRealModeAPI
  5708                                  [BITS 16]                           ; Real Mode code (16 bit)
  5709                                      mov si, DAP_BUFFER
  5710                                      mov al, byte [ si + o_Int13_DAP_num_sectors ]   ; setup the number of sectors saved by setupDAP_
  5711                                  ;    and al, 0x0F        ; limit to 16 sectors
  5712                                      mov ah, 0x02        ; CHT BIOS mode, read  al  sectors, set above
  5713                                      mov word cx, [ si + o_Int13_DAP_saved_CHS_CX ]  ; setup the CX value calculated by sector_chs
  5714                                      mov word dx, [ si + o_Int13_DAP_saved_CHS_DX ]  ; setup the DX value calculated by sector_chs
  5715                                      mov word bx, [ si + o_Int13_DAP_address ]       ; setup the address saved by setupDAP_
  5716                                      int 0x13
  5717                                      cli                             ; BIOS might have left interrupts enabled
  5718                                  
  5719                                      mov si, DAP_BUFFER
  5720                                      mov word [ si + o_Int13_DAP_returned_AX ], ax  ; the BIOS call returned AX
  5721                                      mov ax, 0x0001
  5722                                      jc .forward
  5723                                         mov ax, 0x0000
  5724                                      .forward:
  5725                                      mov [ si + o_Int13_DAP_returned_carry_flag ], ax  ; the BIOS call returned carry flag
  5726                                  
  5727                                      call setProtectedModeAPI        ; called from 16 bit code, returns to 32 bit code
  5728                                  [BITS 32]                           ; Protected Mode code (32 bit)
  5729                                      ret
  5730                                  
  5731                                  ; rchs:
  5732                                  Read_Sector_CHS:    ; ( sector n -- f )   "rchs"  returns 0 for success
  5733                                      call setupDAP_              ; ( start n -- ) store the sector number into the Disk Address Packet
  5734                                      cli                         ; disable interrupts
  5735                                      pushad                      ; Pushes all general purpose registers onto the stack
  5736                                      call BIOS_Read_Sector_CHS
  5737                                      popad                       ; restore the registers pushed by  pushad
  5738                                  ;    _DROP_
  5739                                      jmp GetFlag
  5740                                  
  5741                                  ; wcht:
  5742                                  Write_Sector_CHS:   ; ( sector -- )   "wcht"
  5743                                      call setupDAP_              ; store the sector number into the Disk Address Packet
  5744                                      cli                         ; disable interrupts
  5745                                      pushad                      ; Pushes all general purpose registers onto the stack
  5746                                      call BIOS_Read_Sector_CHS
  5747                                      popad                       ; restore the registers pushed by  pushad
  5748                                      ret
  5749                                  
  5750                                  %endif
  5751                                  
  5752                                  ; *****************************************************************************
  5753                                  ; *****************************************************************************
  5754                                  
  5755                                  %if 0
  5756                                  [BITS 16]                           ; Real Mode code (16 bit)
  5757                                  storeBefore:    ; ( -- )   \ store registers to the V_REGS array
  5758                                      mov word [ V_REGS + 0x00 ], ax
  5759                                      mov word [ V_REGS + 0x04 ], bx
  5760                                      mov word [ V_REGS + 0x08 ], cx
  5761                                      mov word [ V_REGS + 0x0C ], dx
  5762                                      mov word [ V_REGS + 0x10 ], si
  5763                                      mov word [ V_REGS + 0x14 ], di
  5764                                      mov word [ V_REGS + 0x18 ], bp
  5765                                      push ax                         ; save eax
  5766                                      pushfd                          ; push the 32 bit eflags register onto the stack
  5767                                      pop ax                          ; and pop it off into eax
  5768                                      mov word [ V_REGS + 0x1C ], ax  ; eflags
  5769                                      pop ax
  5770                                      mov word [ V_REGS + 0x1E ], ax  ; eflags top 16 bits
  5771                                      pop ax                          ; restore eax
  5772                                      ret
  5773                                  
  5774                                  storeAfter:     ; ( -- )   \ store registers to the V_REGS array
  5775                                      mov word [ V_REGS + 0x20 ], ax
  5776                                      mov word [ V_REGS + 0x24 ], bx
  5777                                      mov word [ V_REGS + 0x28 ], cx
  5778                                      mov word [ V_REGS + 0x2C ], dx
  5779                                      mov word [ V_REGS + 0x30 ], si
  5780                                      mov word [ V_REGS + 0x34 ], di
  5781                                      mov word [ V_REGS + 0x38 ], bp
  5782                                      push ax                         ; save eax
  5783                                      pushfd                          ; push the 32 bit eflags register onto the stack
  5784                                      pop ax                          ; and pop it off into eax
  5785                                      mov word [ V_REGS + 0x3C ], ax  ; eflags
  5786                                      pop ax
  5787                                      mov word [ V_REGS + 0x3E ], ax  ; eflags top 16 bits
  5788                                      pop ax                          ; restore eax
  5789                                      ret
  5790                                  [BITS 32]                           ; Protected Mode code (32 bit)
  5791                                  
  5792                                  BIOS_thunk:     ; ( -- )   \ call the BIOS - registers will have previously been setup
  5793                                      call setRealModeAPI
  5794                                  [BITS 16]                           ; Real Mode code (16 bit)
  5795                                      push ax
  5796                                      push es                         ; this operation messes with ES
  5797                                      push di                         ; and DI
  5798                                      call storeBefore
  5799                                      int 0x13
  5800                                      jc $                            ; stop here on error
  5801                                      call storeAfter
  5802                                      pop di
  5803                                      pop es
  5804                                      pop ax
  5805                                      cli                             ; BIOS might have left interrupts enabled
  5806                                      call setProtectedModeAPI        ; called from 16 bit code, returns to 32 bit code
  5807                                  [BITS 32]                           ; Protected Mode code (32 bit)
  5808                                      ret
  5809                                  
  5810                                  %endif
  5811                                  
  5812                                  %if 0
  5813                                  th_:        ; ( ax bx cx dx si di es -- w )   \ th ( thunk to BIOS Int 0x13 )
  5814                                              ; eax = 0x DH DL AH AL , returns in same order
  5815                                      cli                             ; disable interrupts
  5816                                      pushad  ; Pushes all general purpose registers onto the stack in the following order:
  5817                                              ; EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI. The value of ESP is the value before the actual push of ESP
  5818                                              ;  7    6    5    4    3    2    1    0   offset in cells from ESP
  5819                                  
  5820                                  ;    call setupDAP_
  5821                                  
  5822                                      push edi
  5823                                      mov di, (data_area - $$ + BOOTOFFSET)   ; setup the data index pointer
  5824                                      mov dx, [ byte di + ( driveinfo_Drive_DX - data_area) ]  ; restore the boot drive from dx (and head? )
  5825                                  ;    mov dl, 0x80
  5826                                      mov ebx, SECTOR_BUFFER
  5827                                      mov eax, ( 0x0200 + ( ( SECTOR_BUFFER_SIZE / 512 ) & 0xFF ) ) ; read n sectors to fill the buffer
  5828                                      mov ecx, 0x0201                  ; cylinder | sector
  5829                                  
  5830                                      call BIOS_thunk
  5831                                  
  5832                                      pop edi
  5833                                      popad   ; restore the stack values pushed by  pushad
  5834                                      ret
  5835                                  %endif
  5836                                  %if 0
  5837                                  XXXrsect_:     ; ( sector -- ax )       pushad  ; Pushes all general purpose registers onto the stack
  5838                                      push edi
  5839                                  
  5840                                  ;    call sector_chs                 ; store th sector number into the Disk Address Packet
  5841                                  
  5842                                      mov di, (data_area - $$ + BOOTOFFSET)   ; setup the data index pointer
  5843                                      mov dx, [ byte di + ( driveinfo_Drive_DX - data_area) ]  ; restore the boot drive from dx (and head? )
  5844                                  ;    mov dl, 0x80
  5845                                  
  5846                                      cli                             ; disable interrupts
  5847                                  ;    mov esi, DAP_BUFFER
  5848                                  ;    _DUP_
  5849                                      mov eax, 0x0201     ; BIOS read, one sector
  5850                                      mov bx, SECTOR_BUFFER
  5851                                      call BIOS_thunk
  5852                                  
  5853                                      pop edi
  5854                                      popad   ; restore the stack values pushed by  pushad
  5855                                      ret
  5856                                  %endif
  5857                                  
  5858                                  ; *****************************************************************************
  5859                                  ; *****************************************************************************
  5860                                  
  5861                                  %define FORTH_INITIAL_WORD_COUNT  ( ( ForthJumpTableROM_end - ForthJumpTableROM ) / 4 )     ; in cells
  5862                                  %define MACRO_INITIAL_WORD_COUNT  ( ( MacroJumpTableROM_end - MacroJumpTableROM ) / 4 )     ; in cells
  5863                                  
  5864                                  warm:   ; warm start
  5865 00002EBD BB006C0000                  mov _SCRATCH_, STACK_MEMORY_START ; start of stack memory area
  5866 00002EC2 B900030000                  mov ecx, ( TOTAL_STACK_SIZE >> 2 )  ; number of 32 bit cells to fill with the pattern
  5867                                  .back:
  5868 00002EC7 C70355555555                mov dword [ _SCRATCH_ ], 0x55555555             ; fill with this pattern
  5869 00002ECD 81C304000000                add _SCRATCH_, 0x04
  5870 00002ED3 E2F2                        loop .back
  5871                                  
  5872 00002ED5 31C9                        xor ecx, ecx                       ; assumed by initshow to have been previously zeroed
  5873                                  
  5874 00002ED7 E8A9D5FFFF                  call initshow                       ; sets up do-nothing "show" process
  5875                                  ;    call initserve                      ; sets up do-nothing "serve" process
  5876                                  ;    call stop_                           ; turn off floppy motor and point trash to floppy buffer
  5877                                  ;    mov byte [ dma_ready ], 0x01        ; not ready
  5878 00002EDC C705[EC390000]9C00-         mov dword [ v_ForthWordCount ], FORTH_INITIAL_WORD_COUNT ; initial #words
  5879 00002EE4 0000               
  5880 00002EE6 C705[F0390000]0600-         mov dword [ v_MacroWordCount ], MACRO_INITIAL_WORD_COUNT ; initial #macros
  5881 00002EEE 0000               
  5882 00002EF0 C705[5C390000]6013-         mov dword [ v_trash], TRASH_BUFFER
  5883 00002EF8 0000               
  5884 00002EFA 56                          push esi
  5885                                  ;Forth wordlist
  5886 00002EFB 8D35[843A0000]              lea esi, [ ForthNamesROM ]
  5887 00002F01 BF00804600                  mov edi, ForthNames
  5888 00002F06 8B0D[EC390000]              mov ecx, [ v_ForthWordCount ]
  5889 00002F0C F3A5                        rep  movsd                  ; copy ecx 32 bit words from ds:esi to es:edi
  5890 00002F0E 8D35[F83C0000]              lea esi, [ ForthJumpTableROM ]
  5891 00002F14 BF00A84600                  mov edi, ForthJumpTable
  5892 00002F19 8B0D[EC390000]              mov ecx, [ v_ForthWordCount ]
  5893 00002F1F F3A5                        rep  movsd                  ; copy ecx 32 bit words from ds:esi to es:edi
  5894                                  ; Macro wordlist
  5895 00002F21 8D35[543A0000]              lea esi, [ MacroNamesROM ]
  5896 00002F27 BF00D04600                  mov edi, MacroNames
  5897 00002F2C 8B0D[F0390000]              mov ecx, [ v_MacroWordCount ]
  5898 00002F32 F3A5                        rep  movsd                  ; copy ecx 32 bit words from ds:esi to es:edi
  5899 00002F34 8D35[6C3A0000]              lea esi, [ MacroJumpTableROM ]
  5900 00002F3A BF00F84600                  mov edi, MacroJumpTable
  5901 00002F3F 8B0D[F0390000]              mov ecx, [ v_MacroWordCount ]
  5902 00002F45 F3A5                        rep  movsd                  ; copy ecx 32 bit words from ds:esi to es:edi
  5903                                  
  5904 00002F47 5E                          pop esi
  5905 00002F48 C705[D8390000]0020-         mov dword [ v_H ], H0
  5906 00002F50 4700               
  5907 00002F52 C705[80390000]0000-         mov dword [ x_qwerty ], 0x00        ; select non-qwerty mode
  5908 00002F5A 0000               
  5909 00002F5C C705[60390000]4000-         mov dword [ v_offset ], ( RELOCATED >> ( 2 + 8 ) ) ; 0x10000 >> 2 >> 8, offset of RELOCATED block 0 as 1024 byte block number
  5910 00002F64 0000               
  5911                                  
  5912                                      ; setup  v_bytesPerLine
  5913 00002F66 A112180000                  mov _TOS_, [ vesa_XResolution ]
  5914 00002F6B 25FFFF0000                  and _TOS_, 0xFFFF
  5915 00002F70 69C002000000                imul _TOS_, BYTES_PER_PIXEL
  5916 00002F76 A3[7C000100]                mov [ v_bytesPerLine + RELOCATED ], _TOS_
  5917                                  
  5918                                      ; set up  fov
  5919 00002F7B A114180000                  mov _TOS_, [ vesa_YResolution ]
  5920 00002F80 25FFFF0000                  and _TOS_, 0x0000FFFF
  5921 00002F85 89C3                        mov _SCRATCH_, _TOS_
  5922 00002F87 D1E3                        shl _SCRATCH_, 1
  5923 00002F89 D1E8                        shr _TOS_, 1
  5924 00002F8B 01D8                        add _TOS_, _SCRATCH_
  5925 00002F8D 69C00A000000                imul _TOS_, 10
  5926 00002F93 A3[403A0100]                mov [ v_fov + RELOCATED ], _TOS_
  5927                                  
  5928                                      ; select which code to use, depending on the display mode
  5929 00002F98 C605[450E0000]00            mov byte [ displayMode ], 0
  5930 00002F9F 66813D121800000004          cmp word [ vesa_XResolution ], scrnw1
  5931 00002FA8 7407                        jz .forward
  5932 00002FAA C605[450E0000]01            mov byte [ displayMode ], 1
  5933                                  .forward:
  5934                                  
  5935 00002FB1 E888040000                  call randInit_      ; initialise the Marsaglia Pseudo Random Number Generator
  5936                                  
  5937 00002FB6 E88EDEFFFF                  call initIconSize
  5938                                  
  5939 00002FBB E823F5FFFF                  call cursorHome     ; setup the initial display
  5940                                  
  5941 00002FC0 E814D5FFFF                  call c_         ; clear the stack
  5942                                      _DUP_           ;
  5943 00002FC5 83EE04              <1>  sub esi, byte 0x04
  5944 00002FC8 8906                <1>  mov [ esi ], _TOS_
  5945                                  
  5946                                  ; *****************************************************************************
  5947                                  ; erase the DAP buffer
  5948                                  ; *****************************************************************************
  5949                                      _DUP_
  5950 00002FCA 83EE04              <1>  sub esi, byte 0x04
  5951 00002FCD 8906                <1>  mov [ esi ], _TOS_
  5952 00002FCF B800200000                  mov _TOS_, SECTOR_BUFFER
  5953                                      _DUP_
  5954 00002FD4 83EE04              <1>  sub esi, byte 0x04
  5955 00002FD7 8906                <1>  mov [ esi ], _TOS_
  5956 00002FD9 B800480000                  mov _TOS_, SECTOR_BUFFER_SIZE
  5957 00002FDE E882D9FFFF                  call erase_
  5958                                  
  5959                                  ; *****************************************************************************
  5960                                  ; load the colorForth source starting at the first block
  5961                                  ; *****************************************************************************
  5962 00002FE3 B820000000                  mov _TOS_, START_BLOCK_NUMBER
  5963 00002FE8 E8CBD8FFFF                  call _load_
  5964 00002FED E9D4E9FFFF                  jmp dword accept
  5965                                  
  5966                                  ; *****************************************************************************
  5967                                  ; *****************************************************************************
  5968                                  
  5969 00002FF2 00<rept>                    align 4, db 0  ; must be on dword boundary for variables
  5970                                  
  5971                                  hsvv:    ; the start address of the pre-assembled high level Forth words
  5972 00002FF4 00000000                    dd 0
  5973 00002FF8 00<rept>                    times 0x28 db 0
  5974                                  
  5975                                  xy_:   ; ( -- a )
  5976                                      _DUP_
  5977 00003020 83EE04              <1>  sub esi, byte 0x04
  5978 00003023 8906                <1>  mov [ esi ], _TOS_
  5979                                      LOAD_RELATIVE_ADDRESS v_xy
  5980 00003025 B8343A0100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  5981 0000302A C3                          ret
  5982                                  
  5983                                  fov_:   ; ( -- a )
  5984                                      _DUP_
  5985 0000302B 83EE04              <1>  sub esi, byte 0x04
  5986 0000302E 8906                <1>  mov [ esi ], _TOS_
  5987                                      LOAD_RELATIVE_ADDRESS v_fov
  5988 00003030 B8403A0100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  5989 00003035 C3                          ret
  5990                                  
  5991                                  tokenActions_:   ; ( -- a )
  5992                                      _DUP_
  5993 00003036 83EE04              <1>  sub esi, byte 0x04
  5994 00003039 8906                <1>  mov [ esi ], _TOS_
  5995                                      LOAD_RELATIVE_ADDRESS tokenActions
  5996 0000303B B8F4390100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  5997 00003040 C3                          ret
  5998                                  
  5999                                  last_:   ; ( -- a )
  6000                                      _DUP_
  6001 00003041 83EE04              <1>  sub esi, byte 0x04
  6002 00003044 8906                <1>  mov [ esi ], _TOS_
  6003                                      LOAD_RELATIVE_ADDRESS last
  6004 00003046 B8DB300100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6005 0000304B C3                          ret
  6006                                  
  6007                                  version_:   ; ( -- a )
  6008                                      _DUP_
  6009 0000304C 83EE04              <1>  sub esi, byte 0x04
  6010 0000304F 8906                <1>  mov [ esi ], _TOS_
  6011                                      LOAD_RELATIVE_ADDRESS version
  6012 00003051 B8C0670100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6013 00003056 C3                          ret
  6014                                  
  6015                                  vframe_:     ; ( -- a )  \ return the video frame address, where we create the image to be displayed
  6016                                      _DUP_
  6017 00003057 83EE04              <1>  sub esi, byte 0x04
  6018 0000305A 8906                <1>  mov [ esi ], _TOS_
  6019 0000305C A1[443A0000]                mov _TOS_, [ vframe ]
  6020 00003061 C3                          ret
  6021                                  
  6022                                  vars_:
  6023                                      _DUP_
  6024 00003062 83EE04              <1>  sub esi, byte 0x04
  6025 00003065 8906                <1>  mov [ esi ], _TOS_
  6026                                      LOAD_RELATIVE_ADDRESS vars
  6027 00003067 B8A0390100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6028 0000306C C3                          ret
  6029                                  
  6030                                  base_:
  6031                                      _DUP_
  6032 0000306D 83EE04              <1>  sub esi, byte 0x04
  6033 00003070 8906                <1>  mov [ esi ], _TOS_
  6034                                      LOAD_RELATIVE_ADDRESS base
  6035 00003072 B8A0390100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6036 00003077 C3                          ret
  6037                                  
  6038                                  hex_:
  6039 00003078 C605[A0390000]10            mov byte [ base ], 16
  6040 0000307F C3                          ret
  6041                                  
  6042                                  decimal_:
  6043 00003080 C605[A0390000]0A            mov byte [ base ], 10
  6044 00003087 C3                          ret
  6045                                  
  6046                                  block_: ; ( block -- address )   \ : block ( n -- n ) $400 * ; address is in bytes
  6047 00003088 C1E00A                      shl _TOS_, 0x0A
  6048 0000308B 0500000100                  add _TOS_, RELOCATED
  6049 00003090 C3                          ret
  6050                                  
  6051                                  scrnw_:    ; ( -- n )   screen width ( number of horizontal pixels )
  6052                                      _DUP_
  6053 00003091 83EE04              <1>  sub esi, byte 0x04
  6054 00003094 8906                <1>  mov [ esi ], _TOS_
  6055 00003096 31C0                        xor _TOS_, _TOS_
  6056 00003098 66A112180000                mov word ax, [ vesa_XResolution ]
  6057 0000309E C3                          ret
  6058                                  
  6059                                  scrnh_:    ; ( -- n )    screen height ( number of vertical pixels )
  6060                                      _DUP_
  6061 0000309F 83EE04              <1>  sub esi, byte 0x04
  6062 000030A2 8906                <1>  mov [ esi ], _TOS_
  6063 000030A4 31C0                        xor _TOS_, _TOS_
  6064 000030A6 66A114180000                mov word ax, [ vesa_YResolution ]     ; v_scrnh
  6065 000030AC C3                          ret
  6066                                  
  6067                                  bpp_:    ; ( -- n )    bits per pixel
  6068                                      _DUP_
  6069 000030AD 83EE04              <1>  sub esi, byte 0x04
  6070 000030B0 8906                <1>  mov [ esi ], _TOS_
  6071 000030B2 31C0                        xor _TOS_, _TOS_
  6072 000030B4 A019180000                  mov byte al, [ vesa_BitsPerPixel ]     ; v_bitsPerPixel
  6073 000030B9 C3                          ret
  6074                                  
  6075                                  iconw_:    ; ( -- n )    icon width ( number of pixels between characters, fixed font width )
  6076                                      _DUP_
  6077 000030BA 83EE04              <1>  sub esi, byte 0x04
  6078 000030BD 8906                <1>  mov [ esi ], _TOS_
  6079 000030BF A1[68390000]                mov _TOS_, [ v_iconw ]
  6080 000030C4 C3                          ret
  6081                                  
  6082                                  iconh_:    ; ( -- n )    icon height ( number of pixels between lines )
  6083                                      _DUP_
  6084 000030C5 83EE04              <1>  sub esi, byte 0x04
  6085 000030C8 8906                <1>  mov [ esi ], _TOS_
  6086 000030CA A1[6C390000]                mov _TOS_, [ v_iconh ]
  6087 000030CF C3                          ret
  6088                                  
  6089                                  font_:    ; ( -- n )    font16x24 font address
  6090                                      _DUP_
  6091 000030D0 83EE04              <1>  sub esi, byte 0x04
  6092 000030D3 8906                <1>  mov [ esi ], _TOS_
  6093                                      LOAD_RELATIVE_ADDRESS font16x24
  6094 000030D5 B800680100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6095 000030DA C3                          ret
  6096                                  
  6097                                  last:   ; ( -- a )
  6098                                      _DUP_
  6099 000030DB 83EE04              <1>  sub esi, byte 0x04
  6100 000030DE 8906                <1>  mov [ esi ], _TOS_
  6101                                      LOAD_RELATIVE_ADDRESS v_last
  6102 000030E0 B8DC390100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6103 000030E5 C3                          ret
  6104                                  
  6105                                  blk_:   ; ( -- a )
  6106                                      _DUP_
  6107 000030E6 83EE04              <1>  sub esi, byte 0x04
  6108 000030E9 8906                <1>  mov [ esi ], _TOS_
  6109                                      LOAD_RELATIVE_ADDRESS v_blk
  6110 000030EB B810390100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6111 000030F0 C3                          ret
  6112                                  
  6113                                  seeb:   ; ( -- )    \ toggle the display of blue words in the editor
  6114 000030F1 F615[8C390000]              not byte [ v_seeb ]
  6115 000030F7 C3                          ret
  6116                                  
  6117                                  colourBlindModeToggle:   ; ( -- )    \ toggle the editor display colorForth / ANS style
  6118 000030F8 F615[8D390000]              not byte [ v_colourBlindMode ]
  6119 000030FE C3                          ret
  6120                                  
  6121                                  curs:   ; ( -- a )
  6122                                      _DUP_
  6123 000030FF 83EE04              <1>  sub esi, byte 0x04
  6124 00003102 8906                <1>  mov [ esi ], _TOS_
  6125                                      LOAD_RELATIVE_ADDRESS v_curs
  6126 00003104 B830390100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6127 00003109 C3                          ret
  6128                                  
  6129                                  %if 0
  6130                                  stacks_:   ;  ( -- a )   \ return the address of the stack memory information ( see v_stack_info for details )
  6131                                  ;RETURN_STACK_SIZE
  6132                                  ;DATA_STACK_SIZE
  6133                                  ;STACK_MEMORY_START       ; bottom of stack memory
  6134                                  ;TOTAL_STACK_SIZE
  6135                                      _DUP_
  6136                                      mov _TOS_, RETURN_STACK_0 - 0x3C           ; top of task 0 return stack
  6137                                      _DUP_
  6138                                      mov _TOS_, DATA_STACK_0   - 0x3C           ; top of task 0 data stack
  6139                                      _DUP_
  6140                                      mov _TOS_, RETURN_STACK_1 - 0x3C           ; top of task 1 return stack
  6141                                      _DUP_
  6142                                      mov _TOS_, DATA_STACK_1   - 0x3C           ; top of task 1 data stack
  6143                                      _DUP_
  6144                                      mov _TOS_, RETURN_STACK_2 - 0x3C           ; top of task 2 return stack
  6145                                  ;    _DUP_
  6146                                  ;    mov _TOS_, DATA_STACK_2   - 0x3C           ; top of task 2 data stack
  6147                                  ;    LOAD_RELATIVE_ADDRESS v_stack_info
  6148                                      ret
  6149                                  %endif
  6150                                  
  6151                                  ekt:   ; ( -- a ) ; editor key table - variable containing vectors for editor keys beginning with null
  6152                                      ; and the shift keys.  Then follows right hand top, middle, bottom rows,
  6153                                      ; and left hand top, middle, bottom rows. (from ColorForth2.0a.doc)
  6154                                      _DUP_
  6155 0000310A 83EE04              <1>  sub esi, byte 0x04
  6156 0000310D 8906                <1>  mov [ esi ], _TOS_
  6157                                      LOAD_RELATIVE_ADDRESS editorActionTable
  6158 0000310F B8E7270100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6159 00003114 C3                          ret
  6160                                  
  6161                                  vword_:   ; ( -- a )
  6162                                      _DUP_
  6163 00003115 83EE04              <1>  sub esi, byte 0x04
  6164 00003118 8906                <1>  mov [ esi ], _TOS_
  6165                                      LOAD_RELATIVE_ADDRESS v_words
  6166 0000311A B8B8390100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6167 0000311F C3                          ret
  6168                                  
  6169                                  ;vregs_:   ; ( -- a )
  6170                                  ;    _DUP_
  6171                                  ;    mov eax, V_REGS
  6172                                  ;    ret
  6173                                  
  6174                                  ivec_:   ; ( -- a )
  6175                                      _DUP_
  6176 00003120 83EE04              <1>  sub esi, byte 0x04
  6177 00003123 8906                <1>  mov [ esi ], _TOS_
  6178 00003125 B8001C0000                  mov eax, INTERRUPT_VECTORS
  6179 0000312A C3                          ret
  6180                                  
  6181                                  pic_:   ; ( -- a )
  6182                                      _DUP_
  6183 0000312B 83EE04              <1>  sub esi, byte 0x04
  6184 0000312E 8906                <1>  mov [ esi ], _TOS_
  6185 00003130 B880170000                  mov eax, IDT_AND_PIC_SETTINGS
  6186 00003135 C3                          ret
  6187                                  
  6188                                  %if 0
  6189                                  
  6190                                  From : https://pdos.csail.mit.edu/6.828/2014/readings/hardware/8259A.pdf
  6191                                  
  6192                                  The following registers can be read via OCW3 (IRR and ISR or OCW1 [IMR]).
  6193                                  
  6194                                  Interrupt Request Register (IRR):
  6195                                  8-bit register which contains the levels requesting an interrupt to be acknowledged.
  6196                                  The highest request level is reset from the IRR when an interrupt is acknowledged. (Not affected by IMR.)
  6197                                  
  6198                                  In-Service Register (ISR):
  6199                                  8-bit register which contains the priority levels that are being serviced.
  6200                                  The ISR is updated when an End of Interrupt Command is issued.
  6201                                  
  6202                                  Interrupt Mask Register:
  6203                                  8-bit register which contains the interrupt request lines which are masked.
  6204                                      The IRR can be read when, prior to the RD pulse, a Read Register Command is issued with OCW3 (RR = 1, RIS = 0.)
  6205                                      The ISR can be read, when, prior to the RD pulse, a Read Register Command is issued with OCW3 (RR = 1, RIS = 1).
  6206                                  There is no need to write an OCW3 before every status read operation,
  6207                                     as long as the status read corresponds with the previous one; i.e., the 8259A remembers whether the IRR or ISR
  6208                                     has been previously selected by the OCW3.
  6209                                     This is not true when poll is used.
  6210                                      After initialization the 8259A is set to IRR.
  6211                                  
  6212                                  For reading the IMR, no OCW3 is needed.
  6213                                  The output data bus will contain the IMR whenever RD is active and A0 = 1 (OCW1).
  6214                                  Polling overrides status read when P = 1, RR = 1 in OCW3.
  6215                                  
  6216                                  From : https://en.wikibooks.org/wiki/X86_Assembly/Programmable_Interrupt_Controller
  6217                                  
  6218                                  Remapping
  6219                                  Another common task, often performed during the initialization of an operating system, is remapping the PICs.
  6220                                  That is, changing their internal vector offsets, thereby altering the interrupt numbers they send.
  6221                                  The initial vector offset of PIC1 is 8, so it raises interrupt numbers 8 to 15.
  6222                                  Unfortunately, some of the low 32 interrupts are used by the CPU for exceptions
  6223                                  (divide-by-zero, page fault, etc.), causing a conflict between hardware and software interrupts.
  6224                                  The usual solution to this is remapping the PIC1 to start at 32, and often the PIC2 right after it at 40.
  6225                                  This requires a complete restart of the PICs, but is not actually too difficult, requiring just eight 'out's.
  6226                                  
  6227                                  mov al, 0x11
  6228                                  out 0x20, al     ;restart PIC1
  6229                                  out 0xA0, al     ;restart PIC2
  6230                                  
  6231                                  mov al, 0x20
  6232                                  out 0x21, al     ;PIC1 now starts at 32
  6233                                  mov al, 0x28
  6234                                  out 0xA1, al     ;PIC2 now starts at 40
  6235                                  
  6236                                  mov al, 0x04
  6237                                  out 0x21, al     ;setup cascading
  6238                                  mov al, 0x02
  6239                                  out 0xA1, al
  6240                                  
  6241                                  mov al, 0x01
  6242                                  out 0x21, al
  6243                                  out 0xA1, al     ;done!
  6244                                  
  6245                                  From: cf2019 Forth block 244
  6246                                  : p!   pc! ;  \ 8 bit port store
  6247                                  : pic1! $21 p! ;
  6248                                  : pic2! $A1 p! ;
  6249                                  
  6250                                  : !pic cli
  6251                                  ( init )       $11 dup $20 p! $A0 p!
  6252                                  ( irq )        $20 pic1! $28 pic2!
  6253                                  ( master )     #4 pic1!
  6254                                  ( slave )      #2 pic2!
  6255                                  ( 8086 mode )  #1 dup pic1! pic2!
  6256                                  ( mask irqs )  $FF pic2! $FA pic1! ;
  6257                                  
  6258                                  Re-factored :
  6259                                  : !pic cli
  6260                                  \ PIC1
  6261                                  ( init )     $11 $20 p!
  6262                                  ( irq )      $20 $21 p!
  6263                                  ( master )   $04 $21 p!
  6264                                  ( 8086 mode) $01 $21 p!
  6265                                  ( mask irqs) $FA $21 p!
  6266                                  \ PIC2
  6267                                  ( init )     $11 $A0 p!
  6268                                  ( irq )      $28 $A1 p!
  6269                                  ( slave )    $02 $A1 p!
  6270                                  ( 8086 mode) $01 $A1 p!
  6271                                  ( mask irqs) $FF $A1 p!
  6272                                  ;
  6273                                  
  6274                                  %endif
  6275                                  
  6276                                  dap_:   ; ( -- a )
  6277                                      _DUP_
  6278 00003136 83EE04              <1>  sub esi, byte 0x04
  6279 00003139 8906                <1>  mov [ esi ], _TOS_
  6280 0000313B B8E0170000                  mov eax, DAP_BUFFER
  6281 00003140 C3                          ret
  6282                                  
  6283                                  sect_:   ; ( -- a )
  6284                                      _DUP_
  6285 00003141 83EE04              <1>  sub esi, byte 0x04
  6286 00003144 8906                <1>  mov [ esi ], _TOS_
  6287 00003146 B800200000                  mov eax, SECTOR_BUFFER
  6288 0000314B C3                          ret
  6289                                  
  6290                                  digin:   ; ( -- a )
  6291                                      _DUP_
  6292 0000314C 83EE04              <1>  sub esi, byte 0x04
  6293 0000314F 8906                <1>  mov [ esi ], _TOS_
  6294                                      LOAD_RELATIVE_ADDRESS v_digin
  6295 00003151 B8C0390100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6296 00003156 C3                          ret
  6297                                  
  6298                                  actc:   ; ( -- a )
  6299                                      _DUP_
  6300 00003157 83EE04              <1>  sub esi, byte 0x04
  6301 0000315A 8906                <1>  mov [ esi ], _TOS_
  6302                                      LOAD_RELATIVE_ADDRESS actionColourTable
  6303 0000315C B8AC220100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6304 00003161 C3                          ret
  6305                                  
  6306                                  tickh:   ; ( -- a )    HERE variable address
  6307                                      _DUP_
  6308 00003162 83EE04              <1>  sub esi, byte 0x04
  6309 00003165 8906                <1>  mov [ esi ], _TOS_
  6310                                      LOAD_RELATIVE_ADDRESS v_H
  6311 00003167 B8D8390100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6312 0000316C C3                          ret
  6313                                  
  6314                                  forths_:   ; ( -- a )
  6315                                      _DUP_
  6316 0000316D 83EE04              <1>  sub esi, byte 0x04
  6317 00003170 8906                <1>  mov [ esi ], _TOS_
  6318                                      LOAD_RELATIVE_ADDRESS v_ForthWordCount
  6319 00003172 B8EC390100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6320 00003177 C3                          ret
  6321                                  
  6322                                  macros_:   ; ( -- a )
  6323                                      _DUP_
  6324 00003178 83EE04              <1>  sub esi, byte 0x04
  6325 0000317B 8906                <1>  mov [ esi ], _TOS_
  6326                                      LOAD_RELATIVE_ADDRESS v_MacroWordCount
  6327 0000317D B8F0390100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6328 00003182 C3                          ret
  6329                                  
  6330                                  offset_:   ; ( -- a )
  6331                                      _DUP_
  6332 00003183 83EE04              <1>  sub esi, byte 0x04
  6333 00003186 8906                <1>  mov [ esi ], _TOS_
  6334                                      LOAD_RELATIVE_ADDRESS v_offset
  6335 00003188 B860390100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6336 0000318D C3                          ret
  6337                                  
  6338                                  vesa:   ; ( -- a )
  6339                                      _DUP_
  6340 0000318E 83EE04              <1>  sub esi, byte 0x04
  6341 00003191 8906                <1>  mov [ esi ], _TOS_
  6342 00003193 B800180000                  mov _TOS_, VESA_BUFFER
  6343 00003198 C3                          ret
  6344                                  
  6345                                  vesamode_:   ; ( -- u )
  6346                                      _DUP_
  6347 00003199 83EE04              <1>  sub esi, byte 0x04
  6348 0000319C 8906                <1>  mov [ esi ], _TOS_
  6349 0000319E 31C0                        xor _TOS_, _TOS_
  6350 000031A0 66A11E180000                mov word ax, [ vesa_SavedMode ]     ; the saved  VESA video mode value
  6351 000031A6 C3                          ret
  6352                                  
  6353                                  fetchDX_:   ; ( -- c )
  6354                                      _DUP_
  6355 000031A7 83EE04              <1>  sub esi, byte 0x04
  6356 000031AA 8906                <1>  mov [ esi ], _TOS_
  6357 000031AC 31C0                        xor _TOS_, _TOS_
  6358 000031AE 57                          push edi
  6359 000031AF BFE0170000                  mov edi, DAP_BUFFER
  6360 000031B4 8A4712                      mov _TOS_l_, [ edi + o_Int13_DAP_saved_DX ]     ; setup DX value returned by the BIOS
  6361 000031B7 5F                          pop edi
  6362 000031B8 C3                          ret
  6363                                  
  6364                                  trash_:   ; ( -- a )
  6365                                      _DUP_
  6366 000031B9 83EE04              <1>  sub esi, byte 0x04
  6367 000031BC 8906                <1>  mov [ esi ], _TOS_
  6368                                      LOAD_RELATIVE_ADDRESS v_trash
  6369 000031BE B85C390100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6370 000031C3 C3                          ret
  6371                                  
  6372                                  buffer_:   ; ( -- a )
  6373                                      _DUP_
  6374 000031C4 83EE04              <1>  sub esi, byte 0x04
  6375 000031C7 8906                <1>  mov [ esi ], _TOS_
  6376 000031C9 B800200000                  mov _TOS_, SECTOR_BUFFER ;0x25300
  6377 000031CE C3                          ret
  6378                                  
  6379                                  cad:   ; ( -- a )   , the address of the cursor as an offset from the start of the currently displayed block
  6380                                      _DUP_
  6381 000031CF 83EE04              <1>  sub esi, byte 0x04
  6382 000031D2 8906                <1>  mov [ esi ], _TOS_
  6383                                      LOAD_RELATIVE_ADDRESS v_cad
  6384 000031D4 B850390100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6385 000031D9 C3                          ret
  6386                                  
  6387                                  pcad:   ; ( -- a )
  6388                                      _DUP_
  6389 000031DA 83EE04              <1>  sub esi, byte 0x04
  6390 000031DD 8906                <1>  mov [ esi ], _TOS_
  6391                                      LOAD_RELATIVE_ADDRESS v_pcad
  6392 000031DF B854390100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6393 000031E4 C3                          ret
  6394                                  
  6395                                  hsvv_:   ; ( -- a )
  6396                                      _DUP_
  6397 000031E5 83EE04              <1>  sub esi, byte 0x04
  6398 000031E8 8906                <1>  mov [ esi ], _TOS_
  6399                                      LOAD_RELATIVE_ADDRESS hsvv
  6400 000031EA B8F42F0100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6401 000031EF C3                          ret
  6402                                  
  6403                                  displ:   ; ( -- a )
  6404                                      _DUP_
  6405 000031F0 83EE04              <1>  sub esi, byte 0x04
  6406 000031F3 8906                <1>  mov [ esi ], _TOS_
  6407                                      LOAD_RELATIVE_ADDRESS displayShannonFanoActions
  6408 000031F5 B8A9210100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6409 000031FA C3                          ret
  6410                                  
  6411                                  cBlindAddr_:   ; ( -- a )
  6412                                      _DUP_
  6413 000031FB 83EE04              <1>  sub esi, byte 0x04
  6414 000031FE 8906                <1>  mov [ esi ], _TOS_
  6415                                      LOAD_RELATIVE_ADDRESS x_colourBlind
  6416 00003200 B888390100          <1>  mov _TOS_, ( ( ( %1 - $$ ) + RELOCATED ) )
  6417 00003205 C3                          ret
  6418                                  
  6419                                  ; *****************************************************************************
  6420                                  ; memory operators
  6421                                  ; *****************************************************************************
  6422                                  
  6423                                  cFetch_:      ; ( a -- c ) \ c@
  6424 00003206 31DB                        xor _SCRATCH_, _SCRATCH_
  6425 00003208 8A18                        mov byte _SCRATCH_l_, [ _TOS_ ] ;
  6426 0000320A 89D8                        mov _TOS_, _SCRATCH_
  6427 0000320C C3                          ret
  6428                                  
  6429                                  wFetch_:      ; ( a -- w ) \ w@
  6430 0000320D 31DB                        xor _SCRATCH_, _SCRATCH_
  6431 0000320F 668B18                      mov word _SCRATCH_x_, [ _TOS_ ] ;
  6432 00003212 89D8                        mov _TOS_, _SCRATCH_
  6433 00003214 C3                          ret
  6434                                  
  6435                                  fetch_:       ; ( a -- u ) \ @
  6436 00003215 8B00                        mov dword _TOS_, [ _TOS_ ] ;
  6437 00003217 C3                          ret
  6438                                  
  6439                                  cStore_:      ; ( c a -- ) \ c!
  6440 00003218 8B1E                        mov _SCRATCH_, [ esi ]
  6441 0000321A 8818                        mov byte [ _TOS_ ], _SCRATCH_l_
  6442 0000321C C3                          ret
  6443                                  
  6444                                  wStore_:      ; ( w a -- ) \ w!
  6445 0000321D 8B1E                        mov _SCRATCH_, [ esi ]
  6446 0000321F 668918                      mov word [ _TOS_ ], _SCRATCH_x_
  6447 00003222 C3                          ret
  6448                                  
  6449                                  store_:       ; ( u a -- ) \ !
  6450 00003223 8B1E                        mov _SCRATCH_, [ esi ]
  6451 00003225 8918                        mov dword [ _TOS_ ], _SCRATCH_
  6452 00003227 C3                          ret
  6453                                  
  6454                                  ; *****************************************************************************
  6455                                  ; stack operators
  6456                                  ; *****************************************************************************
  6457                                  
  6458                                  two_dup_:       ; ( a b -- a b a b )
  6459 00003228 83EE08                      sub esi, byte 0x08 ; lea esi, [ esi - 0x08 ]    ; pre-decrement the stack pointer, adding 2 cells
  6460 0000322B 894604                      mov [ esi + 4 ], _TOS_  ; copy x2 to Third On Stack ( second on the real stack )
  6461 0000322E 8B5E08                      mov _SCRATCH_, [ esi + 8 ]    ; copy x1 to register ebx
  6462 00003231 891E                        mov [ esi ], _SCRATCH_        ; copy register ebx to Fourth On Stack
  6463 00003233 C3                          ret
  6464                                  
  6465                                  two_drop_:      ; ( a b -- )
  6466                                      _DROP_
  6467 00003234 AD                  <1>  lodsd
  6468                                      _DROP_
  6469 00003235 AD                  <1>  lodsd
  6470 00003236 C3                          ret
  6471                                  
  6472                                  two_swap_:      ; ( a b c d -- c d a b )
  6473 00003237 8B5E08                      mov _SCRATCH_, [ esi + 8 ]
  6474 0000323A 871E                        xchg _SCRATCH_, [ esi ]
  6475 0000323C 895E08                      mov  [ esi + 8 ], _SCRATCH_
  6476 0000323F 874604                      xchg _TOS_, [ esi + 4 ]
  6477 00003242 C3                          ret
  6478                                  
  6479                                  two_over_:      ; ( a b c d -- a b c d a b )
  6480 00003243 8D76F8                      lea esi, [ esi - 8 ]
  6481 00003246 894604                      mov [ esi + 4 ], _TOS_
  6482 00003249 8B5E10                      mov _SCRATCH_, [ esi + 0x10 ]
  6483 0000324C 891E                        mov [esi], _SCRATCH_
  6484 0000324E 8B460C                      mov _TOS_, [ esi + 0x0C ]
  6485 00003251 C3                          ret
  6486                                  
  6487                                  rot_:           ; ( a b c -- b c a)
  6488 00003252 8B5E04                      mov _SCRATCH_,[ esi + 4 ]
  6489 00003255 8B2E                        mov ebp, [ esi ]
  6490 00003257 896E04                      mov [ esi + 4 ], ebp
  6491 0000325A 8906                        mov [ esi ],_TOS_
  6492 0000325C 89D8                        mov _TOS_, _SCRATCH_
  6493 0000325E C3                          ret
  6494                                  
  6495                                  minus_rot_:     ; -rot ( a b c -- c b a)
  6496 0000325F 8B5E04                      mov _SCRATCH_, [ esi + 4 ]
  6497 00003262 8B2E                        mov ebp, [ esi ]
  6498 00003264 894604                      mov [ esi + 4 ], _TOS_
  6499 00003267 891E                        mov [esi], _SCRATCH_
  6500 00003269 89E8                        mov _TOS_, ebp
  6501 0000326B C3                          ret
  6502                                  
  6503                                  tuck_:          ; ( a b -- b a b )
  6504                                      _SWAP_
  6505 0000326C 8706                <1>  xchg _TOS_, [ esi ]
  6506                                      _OVER_
  6507 0000326E 83EE04              <1>  sub esi, byte 0x04
  6508 00003271 8906                <1>  mov [ esi ], _TOS_
  6509 00003273 8B4604              <1>  mov _TOS_, [ esi + 4 ]
  6510 00003276 C3                          ret
  6511                                  
  6512                                  pick_:          ; ( ... n -- ... u ) where u is the n'th stack item
  6513 00003277 8B0486                      mov eax, [ esi + ( eax * 4 ) ]
  6514 0000327A C3                          ret
  6515                                  
  6516                                  %define CELL_WIDTH  0x04    ; this is a 32 bit wide system = 4 bytes
  6517                                  
  6518                                  cell_:          ; ( -- c )
  6519                                      _DUP_
  6520 0000327B 83EE04              <1>  sub esi, byte 0x04
  6521 0000327E 8906                <1>  mov [ esi ], _TOS_
  6522 00003280 B804000000                  mov _TOS_, CELL_WIDTH
  6523 00003285 C3                          ret
  6524                                  
  6525                                  cell_minus_:    ; ( u -- u' )
  6526 00003286 2D04000000                  sub _TOS_, CELL_WIDTH
  6527 0000328B C3                          ret
  6528                                  
  6529                                  cell_plus_:    ; ( u -- u' )
  6530 0000328C 0504000000                  add _TOS_, CELL_WIDTH
  6531 00003291 C3                          ret
  6532                                  
  6533                                  cells_:         ; ( u -- u' )
  6534 00003292 01C0                        add _TOS_, _TOS_    ; this code must be changed if CELL_WIDTH is changed
  6535 00003294 01C0                        add _TOS_, _TOS_
  6536 00003296 C3                          ret
  6537                                  
  6538                                  ; *****************************************************************************
  6539                                  ; save and restore the Interrupt Descriptor Table and Interrupt Mask Registers
  6540                                  ; *****************************************************************************
  6541                                  
  6542                                  lidt_:  ; ( a -- )  \ set a into the Interrupt Descriptor Table (IDT) register
  6543 00003297 FA                          cli
  6544 00003298 55                          push ebp
  6545 00003299 BD80170000                  mov ebp, ( PIC_BIOS_IDT_SETTINGS )   ; 6 bytes of RAM used to store the IDT info
  6546 0000329E 66C74500B703                mov word [ ebp ], 0x03B7
  6547 000032A4 894502                      mov [ ebp + 2 ], _TOS_   ; save IDT base address from eax
  6548 000032A7 0F015D00                    lidt [ ebp ]  ; db 0x0F, 0x01, 0x18
  6549                                      _DROP_
  6550 000032AB AD                  <1>  lodsd
  6551 000032AC 5D                          pop ebp
  6552 000032AD C3                          ret
  6553                                  
  6554                                  sidt_:  ; ( -- a )  \ return the address contained in the Interrupt Descriptor Table (IDT) register
  6555 000032AE FA                          cli
  6556                                      _DUP_
  6557 000032AF 83EE04              <1>  sub esi, byte 0x04
  6558 000032B2 8906                <1>  mov [ esi ], _TOS_
  6559 000032B4 55                          push ebp
  6560 000032B5 BDA0170000                  mov ebp, ( IDT_AND_PIC_SETTINGS_PAD )   ; 6 bytes of RAM used to interface to the stack
  6561 000032BA 0F014D00                    sidt [ ebp ]        ; write the 6-byte IDT to memory location pointed to by  ebp
  6562 000032BE 8B4502                      mov _TOS_, [ ebp + 2 ]   ; save IDT base address to eax
  6563 000032C1 5D                          pop ebp
  6564 000032C2 C3                          ret
  6565                                  
  6566                                  save_BIOS_idt:  ; ( -- )  \ save the Interrupt Descriptor Table (IDT) register value
  6567 000032C3 FA                          cli
  6568 000032C4 55                          push ebp
  6569 000032C5 BD80170000                  mov ebp, ( PIC_BIOS_IDT_SETTINGS )   ; 6 bytes of RAM used to save the values in
  6570 000032CA 0F014D00                    sidt [ ebp ]        ; write the 6-byte IDT to memory location pointed to by  ebp
  6571 000032CE 5D                          pop ebp
  6572 000032CF C3                          ret
  6573                                  
  6574                                  restore_BIOS_idt:  ; ( -- )  \ restore the saved IDT value into the Interrupt Descriptor Table (IDT) register
  6575 000032D0 FA                          cli
  6576 000032D1 55                          push ebp
  6577 000032D2 BD80170000                  mov ebp, ( PIC_BIOS_IDT_SETTINGS )   ; 6 bytes of RAM used to restore from
  6578 000032D7 0F015D00                    lidt [ ebp ]  ; db 0x0F, 0x01, 0x18
  6579 000032DB 5D                          pop ebp
  6580 000032DC C3                          ret
  6581                                  
  6582                                  save_BIOS_idt_and_pic: ; ( -- )   \ save the PIC1 and PIC2 IMR values into IDT_AND_PIC_SETTINGS at startup
  6583 000032DD FA                          cli
  6584 000032DE E8E0FFFFFF                  call save_BIOS_idt
  6585 000032E3 55                          push ebp
  6586 000032E4 BD86170000                  mov ebp, ( PIC_BIOS_IMR_SETTINGS )   ; 2 bytes of RAM used to save the IMR for PIC1 and PIC2
  6587                                  ; PIC1
  6588 000032E9 E421                        in al, 0x21     ; read PIC1's IMR value
  6589 000032EB 884500                      mov [ ebp ], al
  6590                                  ; PIC2
  6591 000032EE 45                          inc ebp
  6592 000032EF E4A1                        in al, 0xA1     ; read PIC 2's IMR value
  6593 000032F1 884500                      mov [ ebp ], al
  6594 000032F4 5D                          pop ebp
  6595 000032F5 C3                          ret
  6596                                  
  6597                                  restore_BIOS_idt_and_pic: ; ( -- )   \ restore the saved BIOS PIC and IMR values into PIC1 and PIC2
  6598 000032F6 FA                          cli
  6599 000032F7 E8D4FFFFFF                  call restore_BIOS_idt
  6600 000032FC 55                          push ebp
  6601 000032FD BD86170000                  mov ebp, ( PIC_BIOS_IMR_SETTINGS )   ; 2 bytes of RAM used to save the IMR for PIC1 and PIC2
  6602                                  ; PIC1
  6603 00003302 B011                        mov al, 0x11    ; init command
  6604 00003304 E620                        out 0x20, al    ; init PIC1                 ( $11 $20 p! )
  6605 00003306 B000                        mov al, 0x00    ; PIC1 Interrupt Vector table start address
  6606 00003308 E621                        out 0x21, al    ; PIC1 now starts at 0x00   ( $00 $21 p! )
  6607 0000330A B004                        mov al, 0x04    ; master mode command
  6608 0000330C E621                        out 0x21, al    ; set PIC1 as master, sets up cascading of PIC1 and PIC2 ( $04 $21 p! )
  6609 0000330E B001                        mov al, 0x01    ; 8086 command
  6610 00003310 E621                        out 0x21, al    ; set 8086 mode         ( $01 $21 p! )
  6611 00003312 8A4500                      mov al, [ ebp ] ; Interrupt Mask Register ( IMR )
  6612 00003315 E621                        out 0x21, al    ; set PIC1's IMR, BIOS = 0xB8 ( $xx $21 p! )
  6613                                  ; PIC2
  6614 00003317 45                          inc ebp
  6615 00003318 B011                        mov al, 0x11    ; init command
  6616 0000331A E6A0                        out 0xA0, al    ; init PIC2
  6617 0000331C B008                        mov al, 0x08    ; PIC2 Interrupt Vector table start address
  6618 0000331E E6A1                        out 0xA1, al    ; PIC2 now starts at 0x08   $08 $A1 p!
  6619 00003320 B002                        mov al, 0x02    ; slave mode command
  6620 00003322 E6A1                        out 0xA1, al    ; set PIC2 as slave     ( $02 $A1 p! )
  6621 00003324 B001                        mov al, 0x01    ; 8086 command
  6622 00003326 E6A1                        out 0xA1, al    ; set 8086 mode         ( $01 $A1 p! )
  6623 00003328 8A4500                      mov al, [ ebp ] ; Interrupt Mask Register ( IMR )
  6624 0000332B E6A1                        out 0xA1, al    ; set PIC2's IMR, BIOS = 0x8F ( $xx $A1 p! )
  6625 0000332D 5D                          pop ebp
  6626 0000332E C3                          ret
  6627                                  
  6628                                  restore_new_idt_and_pic: ; ( -- )   \ restore the new IDT and PIC IMR values
  6629 0000332F FA                          cli
  6630 00003330 55                          push ebp
  6631 00003331 BD96170000                  mov ebp, ( PIC_NEW_IMR_SETTINGS )   ; 2 bytes of RAM used to save the IMR for PIC1 and PIC2
  6632                                  ; PIC1
  6633 00003336 B011                        mov al, 0x11    ; init command
  6634 00003338 E620                        out 0x20, al    ; init PIC1                 ( $11 $20 p! )
  6635 0000333A B020                        mov al, 0x20    ; PIC1 Interrupt Vector table start address
  6636 0000333C E621                        out 0x21, al    ; PIC1 now starts at 0x20   ( $20 $21 p! )
  6637 0000333E B004                        mov al, 0x04    ; master mode command
  6638 00003340 E621                        out 0x21, al    ; set PIC1 as master, sets up cascading of PIC1 and PIC2 ( $04 $21 p! )
  6639 00003342 B001                        mov al, 0x01    ; 8086 command
  6640 00003344 E621                        out 0x21, al    ; set 8086 mode         ( $01 $21 p! )
  6641 00003346 8A4500                      mov al, [ ebp ] ; Interrupt Mask Register ( IMR )
  6642 00003349 E621                        out 0x21, al    ; set PIC1's IMR, BIOS = 0xB8 ( $xx $21 p! )
  6643                                  ; PIC2
  6644 0000334B 45                          inc ebp
  6645 0000334C B011                        mov al, 0x11    ; init command
  6646 0000334E E6A0                        out 0xA0, al    ; init PIC2
  6647 00003350 B028                        mov al, 0x28    ; PIC2 Interrupt Vector table start address
  6648 00003352 E6A1                        out 0xA1, al    ; PIC2 now starts at 0x28   $28 $A1 p!
  6649 00003354 B002                        mov al, 0x02    ; slave mode command
  6650 00003356 E6A1                        out 0xA1, al    ; set PIC2 as slave     ( $02 $A1 p! )
  6651 00003358 B001                        mov al, 0x01    ; 8086 command
  6652 0000335A E6A1                        out 0xA1, al    ; set 8086 mode         ( $01 $A1 p! )
  6653 0000335C 8A4500                      mov al, [ ebp ] ; Interrupt Mask Register ( IMR )
  6654 0000335F E6A1                        out 0xA1, al    ; set PIC2's IMR, BIOS = 0x8F ( $xx $A1 p! )
  6655 00003361 5D                          pop ebp
  6656 00003362 C3                          ret
  6657                                  
  6658                                  init_default_PIC_IMRs:  ; ( -- )
  6659 00003363 9C                          pushf
  6660 00003364 FA                          cli
  6661                                  
  6662 00003365 60                          pusha
  6663 00003366 BE00000000                  mov esi, 0x0000                 ; source address = the BIOS interrupt vector table
  6664 0000336B BF001C0000                  mov edi, INTERRUPT_VECTORS      ; destination address
  6665 00003370 B900010000                  mov ecx, ( 1024 / 4 )           ; 1024 bytes in cells
  6666 00003375 F3A5                        rep movsd                       ; does not change AX , it moves DS:SI to ES:DI and increments SI and DI
  6667                                      ; now copy Interrupts 0x00 to 0x0F up to 0x20 to 0x2F
  6668 00003377 BE00000000                  mov esi, 0x0000                 ; source address = the BIOS interrupt vector table
  6669 0000337C BF801C0000                  mov edi, ( INTERRUPT_VECTORS + ( 0x20 * 4 ) )  ; destination address
  6670 00003381 B910000000                  mov ecx, ( 0x10 )               ; 16 vectors in cells
  6671 00003386 F3A5                        rep movsd                       ; does not change AX , it moves DS:SI to ES:DI and increments SI and DI
  6672                                  
  6673 00003388 61                          popa
  6674                                  
  6675 00003389 55                          push ebp
  6676 0000338A BD96170000                  mov ebp, ( PIC_NEW_IMR_SETTINGS )   ; 2 bytes of RAM used to save the IMR for PIC1 and PIC2
  6677 0000338F C64500FA                    mov byte [ ebp ] , 0xFA   ; Interrupt Mask Register ( IMR ) saved value for PIC1
  6678 00003393 45                          inc ebp
  6679 00003394 C64500FF                    mov byte [ ebp ] , 0xFF   ; Interrupt Mask Register ( IMR ) saved value for PIC2
  6680 00003398 5D                          pop ebp
  6681 00003399 9D                          popf
  6682 0000339A C3                          ret
  6683                                  
  6684                                  set_PIC1_IMR:   ; ( c -- )   \ set the Interrupt Mask Register for PIC1 and copy to PIC_NEW_IMR_SETTINGS
  6685 0000339B 9C                          pushf
  6686 0000339C FA                          cli
  6687 0000339D 55                          push ebp
  6688 0000339E BD96170000                  mov ebp, ( PIC_NEW_IMR_SETTINGS )   ; 1 byte of RAM used to save the IMR for PIC1
  6689 000033A3 884500                      mov [ ebp ] , al    ; Interrupt Mask Register ( IMR )
  6690 000033A6 E621                        out 0x21, al        ; set PIC1's IMR ( $xx $21 p! )
  6691 000033A8 5D                          pop ebp
  6692 000033A9 9D                          popf
  6693                                      _DROP_
  6694 000033AA AD                  <1>  lodsd
  6695 000033AB C3                          ret
  6696                                  
  6697                                  set_PIC2_IMR:   ; ( c -- )   \ set the Interrupt Mask Register for PIC2 and copy to PIC_NEW_IMR_SETTINGS+1
  6698 000033AC 9C                          pushf
  6699 000033AD FA                          cli
  6700 000033AE 55                          push ebp
  6701 000033AF BD97170000                  mov ebp, ( PIC_NEW_IMR_SETTINGS + 1 )   ; 1 byte of RAM used to save the IMR for PIC1
  6702 000033B4 884500                      mov [ ebp ] , al    ; Interrupt Mask Register ( IMR )
  6703 000033B7 E6A1                        out 0xA1, al        ; set PIC2's IMR ( $xx $A1 p! )
  6704 000033B9 5D                          pop ebp
  6705 000033BA 9D                          popf
  6706                                      _DROP_
  6707 000033BB AD                  <1>  lodsd
  6708 000033BC C3                          ret
  6709                                  
  6710                                  ; *****************************************************************************
  6711                                  ; lp support for GRaphics demo
  6712                                  ; *****************************************************************************
  6713                                  
  6714                                  lp_:
  6715 000033BD 90                          nop
  6716 000033BE 90                          nop
  6717 000033BF 90                          nop
  6718 000033C0 8BE8                        db 0x8B , 0xE8 ; mov ebp,eax
  6719 000033C2 AD                          lodsd
  6720 000033C3 8BC8                        db 0x8B , 0xC8 ; mov ecx,eax
  6721 000033C5 AD                          lodsd
  6722 000033C6 8B5A20                      mov ebx,[edx+0x20]
  6723                                      .back:
  6724 000033C9 66892B                      mov [ebx],bp
  6725 000033CC 23C0                        db 0x23 , 0xC0 ; and eax,eax   21C0                        and eax,eax
  6726 000033CE 7805                        js .forward
  6727 000033D0 0302                        add eax,[edx]
  6728 000033D2 035A18                      add ebx,[edx+0x18]
  6729                                      .forward:
  6730 000033D5 034208                      add eax,[edx+0x8]
  6731 000033D8 035A10                      add ebx,[edx+0x10]
  6732 000033DB E2EC                        loop .back
  6733                                  ;    dd 0x8B909090 , 0xC88BADE8 , 0x205A8BAD , 0x232B8966
  6734                                  ;    dd 0x030578C0 , 0x185A0302 , 0x03084203 , 0xECE2105A
  6735 000033DD C3                          ret
  6736                                  
  6737                                  ; *****************************************************************************
  6738                                  ; maths operators
  6739                                  ; The ANSI/ISO Forth Standard (adopted in 1994) mandates the minimal set
  6740                                  ; of arithmetic operators +  -  *  /  MOD  */  /MOD  */MOD and  M* .
  6741                                  ; *****************************************************************************
  6742                                  
  6743                                  two_slash_:     ;  "2/" arithmetic divide by 2
  6744 000033DE D1F8                        sar _TOS_, 0x01
  6745 000033E0 C3                          ret
  6746                                  
  6747                                  cmove_:  ; ( from to count -- )
  6748 000033E1 85C0                        test _TOS_, _TOS_
  6749 000033E3 7410                        jz .forward
  6750 000033E5 89C3                            mov _SCRATCH_, _TOS_
  6751 000033E7 8B16                            mov edx, [ esi + 0 ]
  6752 000033E9 8B4E04                          mov ecx, [ esi + 0x04 ]
  6753                                          .back:
  6754 000033EC 8A01                                mov byte al, [ ecx + 0 ]
  6755 000033EE 8802                                mov byte [ edx + 0 ], al
  6756 000033F0 41                                  inc ecx
  6757 000033F1 42                                  inc edx
  6758 000033F2 4B                                  dec _SCRATCH_
  6759 000033F3 75F7                            jnz .back
  6760                                      .forward:
  6761 000033F5 8B4608                      mov _TOS_, [ esi + 0x08 ]
  6762 000033F8 81C60C000000                add esi, 0x0C
  6763 000033FE C3                          ret
  6764                                  
  6765                                  two_star_:  ; ( u -- u' )    u' = 2 * u
  6766 000033FF D1E0                        shl _TOS_, 1
  6767 00003401 C3                          ret
  6768                                  
  6769                                  two_star_star_:     ; ( c -- u )  u  = 2 ** c
  6770 00003402 89C1                        mov ecx, _TOS_
  6771 00003404 B801000000                  mov eax, 0x00000001
  6772 00003409 D3E0                        shl _TOS_, cl
  6773 0000340B C3                          ret
  6774                                  
  6775                                  ; *****************************************************************************
  6776                                  ; Random and Pseudo Random Number Generators
  6777                                  ; *****************************************************************************
  6778                                  
  6779                                  GetCPUIDsupport:    ; ( -- )  equal flag is set if no CPUID support
  6780                                      ; check to see if CPUID is supported
  6781 0000340C 9C                          pushfd              ; save EFLAGS
  6782 0000340D 58                          pop eax             ; store EFLAGS in EAX
  6783 0000340E 89C3                        mov ebx, eax        ; save in EBX for later testing
  6784 00003410 3500002000                  xor eax, 00200000h  ; toggle bit 21
  6785 00003415 50                          push eax            ; push to stack
  6786 00003416 9D                          popfd               ; save changed EAX to EFLAGS
  6787 00003417 9C                          pushfd              ; push EFLAGS to TOS
  6788 00003418 58                          pop eax             ; store EFLAGS in EAX
  6789 00003419 39D8                        cmp eax, ebx        ; see if bit 21 has changed
  6790 0000341B C3                          ret
  6791                                  
  6792                                  GetRDRANDsupport:   ; zero flag is set if no support for RDRAND, the hardware Random Number generator
  6793 0000341C B801000000                  mov eax, 0x00000001     ; select the 'features' CPU information
  6794 00003421 0FA2                        CPUID           ; get CPU information into eax, ebx, ecx and edx
  6795 00003423 A900000040                  test eax, 0x40000000 ; Bit 30 of ECX returned by CPUID => RDRAND present if true
  6796 00003428 C3                          ret
  6797                                  
  6798                                  GetCPUID_:   ; ( -- u )
  6799                                      _DUP_
  6800 00003429 83EE04              <1>  sub esi, byte 0x04
  6801 0000342C 8906                <1>  mov [ esi ], _TOS_
  6802 0000342E B801000000                  mov eax, 0x00000001     ; select the 'features' CPU information
  6803 00003433 0FA2                        CPUID           ; get CPU information into eax, ebx, ecx and edx
  6804 00003435 C3                          ret
  6805                                  
  6806                                  rdtsc_:  ; ( -- u )   \ return the current processor instruction counter
  6807                                      _DUP_
  6808 00003436 83EE04              <1>  sub esi, byte 0x04
  6809 00003439 8906                <1>  mov [ esi ], _TOS_
  6810 0000343B 0F31                        rdtsc ; db 0x0F, 0x31
  6811 0000343D C3                          ret
  6812                                  
  6813                                  randInit_:
  6814 0000343E E8F3FFFFFF                  call rdtsc_
  6815 00003443 55                          push ebp
  6816 00003444 BD[94390000]                mov ebp, v_random
  6817 00003449 314500                      xor [ ebp ], _TOS_      ; vRandom ! , if the value was 0
  6818 0000344C 5D                          pop ebp
  6819                                      _DROP_
  6820 0000344D AD                  <1>  lodsd
  6821 0000344E C3                          ret
  6822                                  
  6823                                  %if 0
  6824                                  \ Marsaglia, "Xorshift RNGs".  http://www.jstatsoft.org/v08/i14/paper
  6825                                  : Random32 ( -- u )
  6826                                      vRandom @
  6827                                      dup 0= or
  6828                                      dup 6 lshift xor
  6829                                      dup 21 rshift xor
  6830                                      dup 7 lshift xor
  6831                                      dup vRandom ! ;
  6832                                  %endif
  6833                                  
  6834                                  ; \ Marsaglia, "Xorshift RNGs".  http://www.jstatsoft.org/v08/i14/paper
  6835                                  getRandMarsaglia: ; ( -- u )   \ load a 32 bit pseudo random number into TOS
  6836                                      _DUP_
  6837 0000344F 83EE04              <1>  sub esi, byte 0x04
  6838 00003452 8906                <1>  mov [ esi ], _TOS_
  6839 00003454 55                          push ebp
  6840 00003455 BD[94390000]                mov ebp, v_random
  6841 0000345A 8B4500                      mov _TOS_, [ ebp ]      ; vRandom @
  6842 0000345D 85C0                        test _TOS_, _TOS_
  6843 0000345F 7505                        jnz .forward            ; dup 0= or
  6844 00003461 B8FFFFFFFF                      mov _TOS_, 0xFFFFFFFF
  6845                                      .forward:
  6846                                  
  6847 00003466 89C3                        mov _SCRATCH_, _TOS_    ; dup 6 lshift xor
  6848 00003468 C1E306                      shl _SCRATCH_, 0x06
  6849 0000346B 31D8                        xor _TOS_, _SCRATCH_
  6850                                  
  6851 0000346D 89C3                        mov _SCRATCH_, _TOS_    ; dup 21 rshift xor
  6852 0000346F C1EB15                      shr _SCRATCH_, 0x15
  6853 00003472 31D8                        xor _TOS_, _SCRATCH_
  6854                                  
  6855 00003474 89C3                        mov _SCRATCH_, _TOS_    ; dup 7 lshift xor
  6856 00003476 C1E307                      shl _SCRATCH_, 0x07
  6857 00003479 31D8                        xor _TOS_, _SCRATCH_
  6858                                  
  6859 0000347B 894500                      mov [ ebp ], _TOS_      ; vRandom !
  6860                                  
  6861 0000347E 5D                          pop ebp
  6862 0000347F C3                          ret
  6863                                  
  6864                                  rand_:  ; ( -- u )   \ load a 32 bit true random number into TOS
  6865                                      _DUP_
  6866 00003480 83EE04              <1>  sub esi, byte 0x04
  6867 00003483 8906                <1>  mov [ esi ], _TOS_
  6868 00003485 E882FFFFFF                  call GetCPUIDsupport
  6869 0000348A 740B                        je .NO_CPUID             ; if no change to bit 21, no CPUID
  6870                                          ; CPUID is supported, so check if RDRAND is supported
  6871 0000348C E88BFFFFFF                      call GetRDRANDsupport
  6872 00003491 7404                            jz .NO_CPUID         ; test for RDRAND support
  6873 00003493 0FC7F0                              RDRAND _TOS_    ; supported, so call the instruction
  6874 00003496 C3                                  ret
  6875                                      .NO_CPUID:
  6876                                      _DROP_
  6877 00003497 AD                  <1>  lodsd
  6878 00003498 E8B2FFFFFF                  call getRandMarsaglia
  6879 0000349D C3                          ret
  6880                                  
  6881                                  randq_:     ; ( -- f )   \ returns true if the processor supports the RDRAND random number instruction
  6882                                      _DUP_
  6883 0000349E 83EE04              <1>  sub esi, byte 0x04
  6884 000034A1 8906                <1>  mov [ esi ], _TOS_
  6885 000034A3 E864FFFFFF                  call GetCPUIDsupport
  6886 000034A8 740D                        jz .NO_CPUID             ; if no change, no CPUID
  6887                                          ; CPUID is supported, so check if RDRAND is supported
  6888 000034AA E86DFFFFFF                      call GetRDRANDsupport
  6889 000034AF 7406                            jz .NO_CPUID         ; test for RDRAND support
  6890 000034B1 B8FFFFFFFF                          mov _TOS_, 0xFFFFFFFF
  6891 000034B6 C3                              ret
  6892                                      .NO_CPUID:
  6893 000034B7 31C0                        xor _TOS_, _TOS_
  6894 000034B9 C3                          ret
  6895                                  
  6896                                  ; *****************************************************************************
  6897                                  ; CRC32 Cyclic Redundancy Checksum (32 bit)
  6898                                  ; The International Standard 32-bit cyclical redundancy check defined by :
  6899                                  ; [ITU-T-V42] International Telecommunications Union, "Error-correcting
  6900                                  ; Procedures for DCEs Using Asynchronous-to-Synchronous Conversion",
  6901                                  ; ITU-T Recommendation V.42, 1994, Rev. 1.
  6902                                  ; and
  6903                                  ; [ISO-3309]
  6904                                  ; International Organization for Standardization,
  6905                                  ; "Information Processing Systems--Data Communication High-Level Data Link
  6906                                  ; Control Procedure--Frame Structure", IS 3309, October 1984, 3rd Edition.
  6907                                  ; *****************************************************************************
  6908                                  
  6909                                  crc32_table:
  6910 000034BA 00000000963007772C-         dd 000000000h, 077073096h, 0EE0E612Ch, 0990951BAh, 0076DC419h, 0706AF48Fh, 0E963A535h, 09E6495A3h, 00EDB8832h, 079DCB8A4h
  6911 000034C3 610EEEBA51099919C4-
  6912 000034CC 6D078FF46A7035A563-
  6913 000034D5 E9A395649E3288DB0E-
  6914 000034DE A4B8DC79           
  6915 000034E2 1EE9D5E088D9D2972B-         dd 0E0D5E91Eh, 097D2D988h, 009B64C2Bh, 07EB17CBDh, 0E7B82D07h, 090BF1D91h, 01DB71064h, 06AB020F2h, 0F3B97148h, 084BE41DEh
  6916 000034EB 4CB609BD7CB17E072D-
  6917 000034F4 B8E7911DBF906410B7-
  6918 000034FD 1DF220B06A4871B9F3-
  6919 00003506 DE41BE84           
  6920 0000350A 7DD4DA1AEBE4DD6D51-         dd 01ADAD47Dh, 06DDDE4EBh, 0F4D4B551h, 083D385C7h, 0136C9856h, 0646BA8C0h, 0FD62F97Ah, 08A65C9ECh, 014015C4Fh, 063066CD9h
  6921 00003513 B5D4F4C785D3835698-
  6922 0000351C 6C13C0A86B647AF962-
  6923 00003525 FDECC9658A4F5C0114-
  6924 0000352E D96C0663           
  6925 00003532 633D0FFAF50D088DC8-         dd 0FA0F3D63h, 08D080DF5h, 03B6E20C8h, 04C69105Eh, 0D56041E4h, 0A2677172h, 03C03E4D1h, 04B04D447h, 0D20D85FDh, 0A50AB56Bh
  6926 0000353B 206E3B5E10694CE441-
  6927 00003544 60D5727167A2D1E403-
  6928 0000354D 3C47D4044BFD850DD2-
  6929 00003556 6BB50AA5           
  6930 0000355A FAA8B5356C98B242D6-         dd 035B5A8FAh, 042B2986Ch, 0DBBBC9D6h, 0ACBCF940h, 032D86CE3h, 045DF5C75h, 0DCD60DCFh, 0ABD13D59h, 026D930ACh, 051DE003Ah
  6931 00003563 C9BBDB40F9BCACE36C-
  6932 0000356C D832755CDF45CF0DD6-
  6933 00003575 DC593DD1ABAC30D926-
  6934 0000357E 3A00DE51           
  6935 00003582 8051D7C81661D0BFB5-         dd 0C8D75180h, 0BFD06116h, 021B4F4B5h, 056B3C423h, 0CFBA9599h, 0B8BDA50Fh, 02802B89Eh, 05F058808h, 0C60CD9B2h, 0B10BE924h
  6936 0000358B F4B42123C4B3569995-
  6937 00003594 BACF0FA5BDB89EB802-
  6938 0000359D 280888055FB2D90CC6-
  6939 000035A6 24E90BB1           
  6940 000035AA 877C6F2F114C6858AB-         dd 02F6F7C87h, 058684C11h, 0C1611DABh, 0B6662D3Dh, 076DC4190h, 001DB7106h, 098D220BCh, 0EFD5102Ah, 071B18589h, 006B6B51Fh
  6941 000035B3 1D61C13D2D66B69041-
  6942 000035BC DC760671DB01BC20D2-
  6943 000035C5 982A10D5EF8985B171-
  6944 000035CE 1FB5B606           
  6945 000035D2 A5E4BF9F33D4B8E8A2-         dd 09FBFE4A5h, 0E8B8D433h, 07807C9A2h, 00F00F934h, 09609A88Eh, 0E10E9818h, 07F6A0DBBh, 0086D3D2Dh, 091646C97h, 0E6635C01h
  6946 000035DB C9077834F9000F8EA8-
  6947 000035E4 099618980EE1BB0D6A-
  6948 000035ED 7F2D3D6D08976C6491-
  6949 000035F6 015C63E6           
  6950 000035FA F4516B6B62616C1CD8-         dd 06B6B51F4h, 01C6C6162h, 0856530D8h, 0F262004Eh, 06C0695EDh, 01B01A57Bh, 08208F4C1h, 0F50FC457h, 065B0D9C6h, 012B7E950h
  6951 00003603 3065854E0062F2ED95-
  6952 0000360C 066C7BA5011BC1F408-
  6953 00003615 8257C40FF5C6D9B065-
  6954 0000361E 50E9B712           
  6955 00003622 EAB8BE8B7C88B9FCDF-         dd 08BBEB8EAh, 0FCB9887Ch, 062DD1DDFh, 015DA2D49h, 08CD37CF3h, 0FBD44C65h, 04DB26158h, 03AB551CEh, 0A3BC0074h, 0D4BB30E2h
  6956 0000362B 1DDD62492DDA15F37C-
  6957 00003634 D38C654CD4FB5861B2-
  6958 0000363D 4DCE51B53A7400BCA3-
  6959 00003646 E230BBD4           
  6960 0000364A 41A5DF4AD795D83D6D-         dd 04ADFA541h, 03DD895D7h, 0A4D1C46Dh, 0D3D6F4FBh, 04369E96Ah, 0346ED9FCh, 0AD678846h, 0DA60B8D0h, 044042D73h, 033031DE5h
  6961 00003653 C4D1A4FBF4D6D36AE9-
  6962 0000365C 6943FCD96E34468867-
  6963 00003665 ADD0B860DA732D0444-
  6964 0000366E E51D0333           
  6965 00003672 5F4C0AAAC97C0DDD3C-         dd 0AA0A4C5Fh, 0DD0D7CC9h, 05005713Ch, 0270241AAh, 0BE0B1010h, 0C90C2086h, 05768B525h, 0206F85B3h, 0B966D409h, 0CE61E49Fh
  6966 0000367B 710550AA4102271010-
  6967 00003684 0BBE86200CC925B568-
  6968 0000368D 57B3856F2009D466B9-
  6969 00003696 9FE461CE           
  6970 0000369A 0EF9DE5E98C9D92922-         dd 05EDEF90Eh, 029D9C998h, 0B0D09822h, 0C7D7A8B4h, 059B33D17h, 02EB40D81h, 0B7BD5C3Bh, 0C0BA6CADh, 0EDB88320h, 09ABFB3B6h
  6971 000036A3 98D0B0B4A8D7C7173D-
  6972 000036AC B359810DB42E3B5CBD-
  6973 000036B5 B7AD6CBAC02083B8ED-
  6974 000036BE B6B3BF9A           
  6975 000036C2 0CE2B6039AD2B17439-         dd 003B6E20Ch, 074B1D29Ah, 0EAD54739h, 09DD277AFh, 004DB2615h, 073DC1683h, 0E3630B12h, 094643B84h, 00D6D6A3Eh, 07A6A5AA8h
  6976 000036CB 47D5EAAF77D29D1526-
  6977 000036D4 DB048316DC73120B63-
  6978 000036DD E3843B64943E6A6D0D-
  6979 000036E6 A85A6A7A           
  6980 000036EA 0BCF0EE49DFF099327-         dd 0E40ECF0Bh, 09309FF9Dh, 00A00AE27h, 07D079EB1h, 0F00F9344h, 08708A3D2h, 01E01F268h, 06906C2FEh, 0F762575Dh, 0806567CBh
  6981 000036F3 AE000AB19E077D4493-
  6982 000036FC 0FF0D2A3088768F201-
  6983 00003705 1EFEC206695D5762F7-
  6984 0000370E CB676580           
  6985 00003712 71366C19E7066B6E76-         dd 0196C3671h, 06E6B06E7h, 0FED41B76h, 089D32BE0h, 010DA7A5Ah, 067DD4ACCh, 0F9B9DF6Fh, 08EBEEFF9h, 017B7BE43h, 060B08ED5h
  6986 0000371B 1BD4FEE02BD3895A7A-
  6987 00003724 DA10CC4ADD676FDFB9-
  6988 0000372D F9F9EFBE8E43BEB717-
  6989 00003736 D58EB060           
  6990 0000373A E8A3D6D67E93D1A1C4-         dd 0D6D6A3E8h, 0A1D1937Eh, 038D8C2C4h, 04FDFF252h, 0D1BB67F1h, 0A6BC5767h, 03FB506DDh, 048B2364Bh, 0D80D2BDAh, 0AF0A1B4Ch
  6991 00003743 C2D83852F2DF4FF167-
  6992 0000374C BBD16757BCA6DD06B5-
  6993 00003755 3F4B36B248DA2B0DD8-
  6994 0000375E 4C1B0AAF           
  6995 00003762 F64A0336607A0441C3-         dd 036034AF6h, 041047A60h, 0DF60EFC3h, 0A867DF55h, 0316E8EEFh, 04669BE79h, 0CB61B38Ch, 0BC66831Ah, 0256FD2A0h, 05268E236h
  6996 0000376B EF60DF55DF67A8EF8E-
  6997 00003774 6E3179BE69468CB361-
  6998 0000377D CB1A8366BCA0D26F25-
  6999 00003786 36E26852           
  7000 0000378A 95770CCC03470BBBB9-         dd 0CC0C7795h, 0BB0B4703h, 0220216B9h, 05505262Fh, 0C5BA3BBEh, 0B2BD0B28h, 02BB45A92h, 05CB36A04h, 0C2D7FFA7h, 0B5D0CF31h
  7001 00003793 1602222F260555BE3B-
  7002 0000379C BAC5280BBDB2925AB4-
  7003 000037A5 2B046AB35CA7FFD7C2-
  7004 000037AE 31CFD0B5           
  7005 000037B2 8B9ED92C1DAEDE5BB0-         dd 02CD99E8Bh, 05BDEAE1Dh, 09B64C2B0h, 0EC63F226h, 0756AA39Ch, 0026D930Ah, 09C0906A9h, 0EB0E363Fh, 072076785h, 005005713h
  7006 000037BB C2649B26F263EC9CA3-
  7007 000037C4 6A750A936D02A90609-
  7008 000037CD 9C3F360EEB85670772-
  7009 000037D6 13570005           
  7010 000037DA 824ABF95147AB8E2AE-         dd 095BF4A82h, 0E2B87A14h, 07BB12BAEh, 00CB61B38h, 092D28E9Bh, 0E5D5BE0Dh, 07CDCEFB7h, 00BDBDF21h, 086D3D2D4h, 0F1D4E242h
  7011 000037E3 2BB17B381BB60C9B8E-
  7012 000037EC D2920DBED5E5B7EFDC-
  7013 000037F5 7C21DFDB0BD4D2D386-
  7014 000037FE 42E2D4F1           
  7015 00003802 F8B3DD686E83DA1FCD-         dd 068DDB3F8h, 01FDA836Eh, 081BE16CDh, 0F6B9265Bh, 06FB077E1h, 018B74777h, 088085AE6h, 0FF0F6A70h, 066063BCAh, 011010B5Ch
  7016 0000380B 16BE815B26B9F6E177-
  7017 00003814 B06F7747B718E65A08-
  7018 0000381D 88706A0FFFCA3B0666-
  7019 00003826 5C0B0111           
  7020 0000382A FF9E658F69AE62F8D3-         dd 08F659EFFh, 0F862AE69h, 0616BFFD3h, 0166CCF45h, 0A00AE278h, 0D70DD2EEh, 04E048354h, 03903B3C2h, 0A7672661h, 0D06016F7h
  7021 00003833 FF6B6145CF6C1678E2-
  7022 0000383C 0AA0EED20DD7548304-
  7023 00003845 4EC2B30339612667A7-
  7024 0000384E F71660D0           
  7025 00003852 4D476949DB776E3E4A-         dd 04969474Dh, 03E6E77DBh, 0AED16A4Ah, 0D9D65ADCh, 040DF0B66h, 037D83BF0h, 0A9BCAE53h, 0DEBB9EC5h, 047B2CF7Fh, 030B5FFE9h
  7026 0000385B 6AD1AEDC5AD6D9660B-
  7027 00003864 DF40F03BD83753AEBC-
  7028 0000386D A9C59EBBDE7FCFB247-
  7029 00003876 E9FFB530           
  7030 0000387A 1CF2BDBD8AC2BACA30-         dd 0BDBDF21Ch, 0CABAC28Ah, 053B39330h, 024B4A3A6h, 0BAD03605h, 0CDD70693h, 054DE5729h, 023D967BFh, 0B3667A2Eh, 0C4614AB8h
  7031 00003883 93B353A6A3B4240536-
  7032 0000388C D0BA9306D7CD2957DE-
  7033 00003895 54BF67D9232E7A66B3-
  7034 0000389E B84A61C4           
  7035 000038A2 021B685D942B6F2A37-         dd 05D681B02h, 02A6F2B94h, 0B40BBE37h, 0C30C8EA1h, 05A05DF1Bh, 02D02EF8Dh
  7036 000038AB BE0BB4A18E0CC31BDF-
  7037 000038B4 055A8DEF022D       
  7038                                  
  7039                                  ; CRC-32 with polynomial $04c11db7, as specified in IEEE 802.3 ( Ethernet )
  7040                                   crc32_:    ; ( a n -- u )   \ CRC32 Cyclic Redundancy Checksum
  7041 000038BA 53                          push    _SCRATCH_
  7042 000038BB 51                          push    ecx
  7043 000038BC 52                          push    edx
  7044                                  
  7045 000038BD 89C1                        mov ecx, _TOS_
  7046                                      _DROP_
  7047 000038BF AD                  <1>  lodsd
  7048 000038C0 89C3                        mov _SCRATCH_, _TOS_
  7049                                      ; address in ebx, count in ecx, result in eax
  7050                                  
  7051 000038C2 31D2                        xor edx, edx
  7052                                  
  7053 000038C4 B8FFFFFFFF                  mov  _TOS_, 0xFFFFFFFF     ; initial CRC value
  7054                                  
  7055 000038C9 85C9                        test ecx, ecx
  7056 000038CB 7414                        jz .forward
  7057                                  
  7058                                          .back:
  7059 000038CD 8A13                            mov dl, byte [_SCRATCH_]
  7060 000038CF 30C2                            xor dl, al
  7061 000038D1 C1E808                          shr _TOS_, 8
  7062 000038D4 330495[BA340000]                xor _TOS_, dword [ crc32_table + ( 4 * edx ) ]
  7063 000038DB 43                              inc _SCRATCH_
  7064 000038DC 49                              dec ecx
  7065 000038DD 75EE                            jnz .back
  7066                                  
  7067 000038DF F7D0                            not _TOS_     ; invert the final CRC value
  7068                                      .forward:
  7069                                  
  7070 000038E1 5A                          pop edx
  7071 000038E2 59                          pop ecx
  7072 000038E3 5B                          pop _SCRATCH_
  7073 000038E4 C3                          ret
  7074                                  
  7075                                  ; *****************************************************************************
  7076                                  ; *****************************************************************************
  7077                                  
  7078 000038E5 90<rept>                align 4, nop
  7079                                  
  7080                                  tens:
  7081 000038E8 0A000000                    dd 10
  7082 000038EC 64000000                    dd 100
  7083 000038F0 E8030000                    dd 1000
  7084 000038F4 10270000                    dd 10000
  7085 000038F8 A0860100                    dd 100000
  7086 000038FC 40420F00                    dd 1000000
  7087 00003900 80969800                    dd 10000000
  7088 00003904 00E1F505                    dd 100000000
  7089 00003908 00CA9A3B                    dd 1000000000
  7090                                  
  7091                                  x_numberDisplay:    ; either dotDecimal or dotHex , depending on the BASE to use to display numbers
  7092 0000390C [34110000]                  dd dotDecimal
  7093                                  
  7094                                  v_blk:          ; the currently edited block
  7095 00003910 20000000                    dd START_BLOCK_NUMBER           ; the default edited block
  7096                                  
  7097                                  v_otherBlock:   ; the previously edited block
  7098 00003914 21000000                    dd START_BLOCK_NUMBER + 1       ; the default other block is the shadow of the default edited block
  7099                                  
  7100                                  v_otherBlocks:   ; the previously edited block array
  7101 00003918 20000000                    dd START_BLOCK_NUMBER           ; the default edited block
  7102 0000391C 21000000                    dd START_BLOCK_NUMBER + 1       ; the default other block is the shadow of the default edited block
  7103 00003920 22000000                    dd START_BLOCK_NUMBER + 2       ; the default other block is the shadow of the default edited block
  7104 00003924 23000000                    dd START_BLOCK_NUMBER + 3       ; the default other block is the shadow of the default edited block
  7105                                  
  7106                                  v_help_counter:     ; cycles through the help screens used by "help" ( F1 key )
  7107 00003928 00000000                    dd 0
  7108                                  
  7109                                  v_saved_v_blk:      ; the block number saved by "help"
  7110 0000392C FF000000                    dd 0xFF
  7111                                  
  7112                                  v_curs:             ; the offset in cells of the cursor within a block
  7113 00003930 00000000                    dd 0
  7114                                  
  7115                                  v_cursPtr:          ; variable to count the cursor offset from the start of the block
  7116 00003934 00000000                    dd 0
  7117                                  
  7118                                  v_cursLine:         ; which line we want to display the cursor on
  7119 00003938 00000000                    dd 0
  7120                                  
  7121                                  v_curs_number_down: ; to limit the steps down
  7122 0000393C 00000000                    dd 0
  7123                                  
  7124                                  v_numberOfMagentas:
  7125 00003940 00000000                    dd 0
  7126                                  
  7127                                  v_numberOfBigConstants:
  7128 00003944 00000000                    dd 0
  7129                                  
  7130                                  v_numberOfRedAndMagentas:
  7131 00003948 00000000                    dd 0
  7132                                  
  7133                                  v_numberOfTokens:   ; in the current block
  7134 0000394C 00000000                    dd 0
  7135                                  
  7136                                  v_cad:
  7137 00003950 00000000                    dd 0
  7138                                  
  7139                                  v_pcad:
  7140 00003954 00000000                    dd 0
  7141                                  
  7142                                  v_lcad:
  7143 00003958 00000000                    dd 0
  7144                                  
  7145                                  v_trash:                            ; pointer to "trash" buffer, saves words deleted while editing
  7146 0000395C 60130000                    dd TRASH_BUFFER
  7147                                  
  7148                                  v_offset:
  7149 00003960 40000000                    dd ( RELOCATED >> ( 2 + 8 ) )
  7150                                  
  7151                                  v_bitsPerPixel:
  7152 00003964 10000000                    dd 16   ; default, set using VESA info
  7153                                  
  7154                                  v_iconw:
  7155 00003968 00000000                    dd 0 ; iconw
  7156                                  
  7157                                  v_iconh:
  7158 0000396C 00000000                    dd 0 ; iconh
  7159                                  
  7160                                  v_keypadY_iconh:
  7161 00003970 00000000                    dd 0    ; keypadY * iconh
  7162                                  
  7163                                  v_nine_iconw:
  7164 00003974 00000000                    dd 0
  7165                                  
  7166                                  v_twentytwo_iconw:  ; width of 12 history characters, 1 space and 9 keypad characters
  7167 00003978 00000000                    dd 0            ; to calculate the start of the history display, subtracted from the right edge of the screen
  7168                                  
  7169                                  v_10000_iconw:
  7170 0000397C 00000000                    dd 0    ; iconw*0x10000
  7171                                  
  7172                                  x_qwerty:           ; selects non-QWERTY if set to 0, else jumps to the address
  7173 00003980 FFFFFFFF                    dd 0xFFFFFFFF   ;
  7174                                  
  7175                                  x_abort:
  7176 00003984 [3B2B0000]                  dd abort_action
  7177                                  
  7178                                  x_colourBlind:  ; ( state -- state )
  7179 00003988 [E61C0000]                  dd colourBlindAction
  7180                                  
  7181                                  ; byte variables
  7182                                  v_seeb:             ; if = 255, show blue words in editor
  7183 0000398C 00                          db 0            ; 255 enable, 0 disable
  7184                                  
  7185                                  v_colourBlindMode:  ; if = 255, select ANS style editor display
  7186 0000398D 00                          db 0            ; 255 enable, 0 disable
  7187                                  
  7188                                  v_not_cr:   ; true to disable the  cr  before a red word is displayed in the editor
  7189 0000398E 00                          db 0
  7190                                  
  7191                                  v_acceptMode:       ; if non zero, the keypad is in Edit mode, else  TIB mode
  7192 0000398F 00                          db 0            ; 255 enable, 0 disable
  7193                                  
  7194                                  v_hintChar:   ; the character to display in the bottom right hand corner of the keyboard as a hint to the colour being used
  7195 00003990 00000000                    dd 0
  7196                                  
  7197                                  v_random:       ; the current Marsaglia Pseudo Random Number Generator state
  7198 00003994 00000000                    dd 0
  7199                                  
  7200                                  align 4
  7201                                  
  7202                                  currentKeyboardIcons:
  7203 00003998 [24140000]                  dd ( alphaKeyboard - 4 )
  7204                                  
  7205                                  shiftAction:
  7206 0000399C [A2170000]                  dd alpha0
  7207                                  
  7208                                  vars:       ; colorForth system variables start here
  7209                                  base:
  7210 000039A0 0A000000                    dd 10
  7211                                  
  7212                                  current:
  7213 000039A4 [50190000]                  dd setDecimalMode
  7214                                  
  7215                                  keyboard_colour:
  7216 000039A8 E0FF0000                    dd colour_yellow   ; current key colour for displaying key presses
  7217                                  
  7218                                  chars:
  7219 000039AC 01000000                    dd 1
  7220                                  
  7221                                  aword:
  7222 000039B0 [E7060000]                  dd ex1
  7223                                  
  7224                                  anumber:
  7225 000039B4 [00040000]                  dd nul
  7226                                  
  7227                                  v_words:
  7228 000039B8 01000000                    dd 1
  7229                                  
  7230                                  v_qwerty_key:
  7231 000039BC 00000000                    dd 0
  7232                                  
  7233                                  v_digin:
  7234 000039C0 00000000                    dd 0
  7235                                  
  7236                                  lit:
  7237 000039C4 [A7050000]                  dd adup
  7238                                  
  7239                                  v_washColour:
  7240 000039C8 00000000                    dd colour_background
  7241                                  
  7242                                  mark_MacroWordCount:
  7243 000039CC 06000000                    dd MACRO_INITIAL_WORD_COUNT ; initial #macros
  7244                                      ; number of Macro words, saved by  mark , empty restores to this value
  7245                                  mark_v_ForthWordCount:
  7246 000039D0 9C000000                    dd FORTH_INITIAL_WORD_COUNT ; initial #words
  7247                                      ; number of Forth words, saved by  mark , empty restores to this value
  7248                                  
  7249                                  mark_H:
  7250 000039D4 00204700                    dd H0   ; 0x100000     ; top of dictionary pointer H , saved by  mark , empty restores to this value
  7251                                  
  7252                                  v_H:
  7253 000039D8 00204700                    dd H0   ; 0x40000*4    ; variable H , dictionary pointer HERE, where new definitions go
  7254                                  
  7255                                  v_last:
  7256 000039DC 00000000                    dd 0
  7257                                  
  7258                                  class:
  7259 000039E0 00000000                    dd 0
  7260                                  
  7261                                  list:
  7262 000039E4 00000000                    dd 0
  7263                                  ; ( list + 4 )
  7264 000039E8 00000000                    dd 0
  7265                                  
  7266                                  v_ForthWordCount:
  7267 000039EC 9C000000                 dd FORTH_INITIAL_WORD_COUNT ; initial #words  ; number of words in the Forth wordlist, empty resets this value
  7268                                  
  7269                                  v_MacroWordCount:
  7270 000039F0 06000000                 dd MACRO_INITIAL_WORD_COUNT ; initial #macros  ; number of words in the Macro wordlist, empty resets this value
  7271                                  
  7272                                  tokenActions:       ;
  7273 000039F4 [87080000]                  dd qignore      ; 0  extension token
  7274 000039F8 [F4060000]                  dd execute_lit  ; 1
  7275 000039FC [A8070000]                  dd num          ; 2
  7276                                  adefine: ; where definitions go, either in the Macro Dictionary or Forth Dictionary
  7277 00003A00 [D9050000]                  dd forthd       ; 3
  7278 00003A04 [20070000]                  dd qcompile     ; 4
  7279 00003A08 [C0060000]                  dd cnum         ; 5
  7280 00003A0C [D0060000]                  dd cshort       ; 6
  7281 00003A10 [70070000]                  dd compile      ; 7
  7282 00003A14 [8E070000]                  dd short_       ; 8
  7283 00003A18 [00040000]                  dd nul          ; 9
  7284 00003A1C [00040000]                  dd nul          ; A
  7285 00003A20 [00040000]                  dd nul          ; B
  7286 00003A24 [47060000]                  dd m_variable   ; C magenta variable
  7287 00003A28 [00040000]                  dd nul          ; D
  7288 00003A2C [00040000]                  dd nul          ; E
  7289 00003A30 [00040000]                  dd nul          ; F
  7290                                  
  7291                                  v_xy:  ; variable that holds the XY position for drawing characters, ( 0, 0 ) is top left
  7292                                  v_y:
  7293 00003A34 0300                        dw 0x0003
  7294                                  v_x:
  7295 00003A36 0300                        dw 0x0003
  7296                                  
  7297                                  v_leftMargin:
  7298 00003A38 03000000                    dd 0x00000003  ; left margin
  7299                                  
  7300                                  v_rightMargin:
  7301 00003A3C 00000000                    dd 0           ; right margin
  7302                                  
  7303                                  ; xycr:
  7304                                      ; dd 0
  7305                                  
  7306                                  v_fov:  ; abstract display scale
  7307 00003A40 00000000                    dd 0    ; 10 * ( 2 * scrnh + scrnh / 2 )
  7308                                  
  7309                                  vframe:  ; pointer to display frame buffer where we create our image, down from top of 32 Mbytes RAM ( 0x2000000 )
  7310 00003A44 0000E801                    dd 0x2000000 - ( MAX_SCREEN_WIDTH * MAX_SCREEN_HEIGHT * BYTES_PER_PIXEL )
  7311                                  
  7312                                  ; v_frameBuffer:          ; framebuffer address
  7313                                  ;    dd 0x00000000       ;
  7314                                  
  7315                                  v_foregroundColour:
  7316 00003A48 00000000                    dd 0x00000000       ; the display foreground colour, set by  color
  7317                                  
  7318                                  v_xc:
  7319 00003A4C 00000000                    dd 0x00000000       ;
  7320                                  v_yc:
  7321 00003A50 00000000                    dd 0x00000000          ;
  7322                                  
  7323                                  MacroNamesROM:
  7324 00003A54 000000F0                    dd 0xF0000000       ; semicolon ";"
  7325 00003A58 00109BC1                    dd 0xC19B1000       ; dup
  7326 00003A5C 203683CF                    dd 0xCF833620       ; qdup
  7327                                  ;    dd 0xFF833620       ; ?dup
  7328 00003A60 008827C0                    dd 0xC0278800       ; drop
  7329 00003A64 00C0882C                    dd 0x2C88C000       ; then
  7330 00003A68 007695C6                    dd 0xC6957600       ; begin_
  7331                                  ; MacroNamesROM_end:
  7332                                  
  7333                                  MacroJumpTableROM:         ; jump table for the macro wordlist
  7334 00003A6C [F1070000]                  dd semicolon        ; ;
  7335 00003A70 [8F050000]                  dd cdup             ; compile dup
  7336 00003A74 [74050000]                  dd qdup             ; qdup
  7337                                  ;    dd qdup             ; ?dup
  7338 00003A78 [5E050000]                  dd cdrop            ; compile drop
  7339 00003A7C [15080000]                  dd then             ;
  7340 00003A80 [28080000]                  dd begin_           ;
  7341                                  MacroJumpTableROM_end:
  7342                                  
  7343                                  ForthNamesROM:      ; displayed using cf2ansi
  7344 00003A84 004066C6                    dd 0xC6664000   ; boot
  7345 00003A88 00408CBA                    dd 0xBA8C4000   ; warm
  7346 00003A8C 80A0B9C4                    dd 0xC4B9A080   ; pause
  7347 00003A90 004CC88A                    dd 0x8AC84C00   ; macro
  7348 00003A94 006489B1                    dd 0xB1896400   ; forth
  7349 00003A98 00000090                    dd 0x90000000   ; c
  7350 00003A9C 0050631A                    dd 0x1A635000   ; rlba      Read_Sector_LBA
  7351 00003AA0 00A831BD                    dd 0xBD31A800   ; wlba      Write_Sector_LBA
  7352 00003AA4 00105C14                    dd 0x145C1000   ; reads     ReadSectors
  7353 00003AA8 0024B9B8                    dd 0xB8B92400   ; writes    WriteSectors
  7354 00003AAC 00002084                    dd 0x84200000   ; sss       SaveAll_
  7355                                  ;    dd 0x2C800000   ; th        th_ ( thunk to BIOS Int 0x13 )
  7356 00003AB0 00005C14                    dd 0x145C0000   ; read      bios_read
  7357 00003AB4 0020B9B8                    dd 0xB8B92000   ; write     bios_write
  7358                                  ;    dd 0x18248800   ; rsect
  7359 00003AB8 002883F9                    dd 0xF9832800   ; @dx       fetchDX_
  7360 00003ABC 007181F5                    dd 0xF5817100   ; !dap
  7361 00003AC0 00001059                    dd 0x59100000   ; act(tivate)
  7362 00003AC4 00B84386                    dd 0x8643B800   ; show
  7363 00003AC8 0000AEA1                    dd 0xA1AE0000   ; load
  7364 00003ACC 00E01A6A                    dd 0x6A1AE000   ; nload
  7365 00003AD0 005C43F7                    dd 0xF7435C00   ; +load
  7366 00003AD4 0098832C                    dd 0x2C839800   ; thru
  7367 00003AD8 300759F6                    dd 0xF6590730   ; +thru
  7368 00003ADC 00743A96                    dd 0x963A7400   ; cblk      return the block number currently being compiled, calculated from  edi
  7369 00003AE0 00E8741C                    dd 0x1C74E800   ; rblk      return the block number offset of the RELOCATED address
  7370 00003AE4 00E8745C                    dd 0x5C74E800   ; ablk      4 / cellAddressToBlock
  7371 00003AE8 00205841                    dd 0x41582000   ; erase
  7372 00003AEC 008082C8                    dd 0xC8828000   ; here
  7373 00003AF0 002047FF                    dd 0xFF472000   ; ?lit
  7374 00003AF4 0000F8D7                    dd 0xD7F80000   ; 3,
  7375 00003AF8 0000F8D5                    dd 0xD5F80000   ; 2,
  7376 00003AFC 0000F8D3                    dd 0xD3F80000   ; 1,
  7377 00003B00 000000FC                    dd 0xFC000000   ; ,
  7378 00003B04 000042A2                    dd 0xA2420000   ; less
  7379 00003B08 80389AE5                    dd 0xE59A3880   ; jump
  7380 00003B0C 10314959                    dd 0x59493110   ; accept
  7381 00003B10 0000B8C4                    dd 0xC4B80000   ; pad
  7382 00003B14 80C593E8                    dd 0xE893C580   ; keypd
  7383 00003B18 0040E2BB                    dd 0xBBE24000   ; wipe
  7384 00003B1C 0048E2BB                    dd 0xBBE24800   ; wipes     was erase
  7385 00003B20 0098E291                    dd 0x91E29800   ; copy
  7386 00003B24 00408F8A                    dd 0x8A8F4000   ; mark
  7387 00003B28 8029E248                    dd 0x48E22980   ; empty
  7388 00003B2C 0000B948                    dd 0x48B90000   ; emit
  7389 00003B30 0072F5C0                    dd 0xC0F57200   ; digit
  7390 00003B34 007291D4                    dd 0xD4917200   ; 2emit
  7391 00003B38 000000EA                    dd 0xEA000000   ; .
  7392 00003B3C 0000D4C9                    dd 0xC9D40000   ; h.
  7393 00003B40 0080D5C9                    dd 0xC9D58000   ; h.n
  7394 00003B44 00008090                    dd 0x90800000   ; cr
  7395 00003B48 00922586                    dd 0x86259200   ; space
  7396 00003B4C 006077C0                    dd 0xC0776000   ; down
  7397 00003B50 00400E4C                    dd 0x4C0E4000   ; edit
  7398 00003B54 00000040                    dd 0x40000000   ; e
  7399 00003B58 000040A4                    dd 0xA4400000   ; lm
  7400 00003B5C 00008018                    dd 0x18800000   ; rm
  7401 00003B60 802CAEA8                    dd 0xA8AE2C80   ; graph
  7402 00003B64 0040CA24                    dd 0x24CA4000   ; text
  7403 00003B68 60C693E8                    dd 0xE893C660   ; keybo(ard)
  7404 00003B6C 00F398C0                    dd 0xC098F300   ; debu(g)
  7405 00003B70 00000052                    dd 0x52000000   ; at
  7406 00003B74 0000A4F6                    dd 0xF6A40000   ; +at
  7407 00003B78 000030CB                    dd 0xCB300000   ; xy
  7408 00003B7C 0040B5C4                    dd 0xC4B54000   ; page
  7409 00003B80 80118584                    dd 0x84851180   ; screen
  7410 00003B84 0000E1B1                    dd 0xB1E10000   ; fov
  7411                                  ;    dd 0xB3D8C000   ; fifo
  7412 00003B88 004079C6                    dd 0xC6794000   ; box
  7413 00003B8C 0000B2A3                    dd 0xA3B20000   ; line
  7414 00003B90 00C4D091                    dd 0x91D0C400   ; color
  7415 00003B94 00B11239                    dd 0x3912B100   ; octant
  7416 00003B98 00002086                    dd 0x86200000   ; sp
  7417 00003B9C 0080C0A2                    dd 0xA2C08000   ; last
  7418 00003BA0 4096D8CC                    dd 0xCCD89640   ; unpac(k)
  7419 00003BA4 00E8B2C4                    dd 0xC4B2E800   ; pack
  7420 00003BA8 00804EC7                    dd 0xC74E8000   ; blk
  7421 00003BAC 00AE8584                    dd 0x8485AE00   ; scrnw  screen width in pixels
  7422 00003BB0 00B28584                    dd 0x8485B200   ; scrnh  screen height in pixels
  7423 00003BB4 00108BC7                    dd 0xC78B1000   ; bpp    bits per pixel
  7424 00003BB8 0000B1B1                    dd 0xB1B10000   ; font   address of font16x24
  7425 00003BBC 005C1B79                    dd 0x791B5C00   ; iconw  icon width in pixels
  7426 00003BC0 00641B79                    dd 0x791B6400   ; iconh  icon height in pixels
  7427 00003BC4 000082C2                    dd 0xC2820000   ; ver
  7428 00003BC8 00806196                    dd 0x96618000   ; curs
  7429 00003BCC 409743C7                    dd 0xC7439740   ; block
  7430 00003BD0 A05861C3                    dd 0xC36158A0   ; vframe  video frame address, where we create the image to be displayed
  7431 00003BD4 0000A3C2                    dd 0xC2A30000   ; vars
  7432                                  ; new words
  7433 00003BD8 00302682                    dd 0x82263000   ; seeb      ( see blue words, toggle )
  7434                                  ;    dd 0x812CBA40   ; stacks_
  7435 00003BDC 000B65C0                    dd 0xC0650B00   ; dotsf     type a ShannonFano token
  7436 00003BE0 00142EA2                    dd 0xA22E1400   ; leave
  7437                                  ;    dd 0x12312310   ; txtq
  7438 00003BE4 0000E31A                    dd 0x1AE30000   ; rgb
  7439 00003BE8 000034C7                    dd 0xC7340000   ; bye
  7440 00003BEC 00008EB9                    dd 0xB98E0000   ; word
  7441 00003BF0 0000844E                    dd 0x4E840000   ; ekt
  7442 00003BF4 0024665C                    dd 0x5C662400   ; abort
  7443 00003BF8 804C9727                    dd 0x27974C80   ; tickh  HERE variable address
  7444 00003BFC 40D69AC7                    dd 0xC79AD640   ; buffe(r)  buffer_
  7445 00003C00 40085A3B                    dd 0x3B5A0840   ; offset
  7446 00003C04 00009027                    dd 0x27900000   ; tic   tic_
  7447 00003C08 005090C2                    dd 0xC2905000   ; vesa
  7448 00003C0C 805890C2                    dd 0xC2905880   ; vesam
  7449 00003C10 00645821                    dd 0x21586400   ; trash trash_
  7450                                  ;    dd 0xC90C3840   ; hsvv_
  7451 00003C14 001C73C3                    dd 0xC3731C00   ; vword
  7452                                  ;    dd 0xC2295800   ; vregs
  7453 00003C18 0020297C                    dd 0x7C292000   ; ivec
  7454 00003C1C 00308614                    dd 0x14863000   ; resb  restore_BIOS_idt_and_pic
  7455 00003C20 0000F2C4                    dd 0xC4F20000   ; pic
  7456 00003C24 0080B8C0                    dd 0xC0B88000   ; dap
  7457 00003C28 00804882                    dd 0x82488000   ; sect
  7458 00003C2C 00088EB9                    dd 0xB98E0800   ; words
  7459 00003C30 000093E8                    dd 0xE8930000   ; key
  7460 00003C34 0026D1CF                    dd 0xCFD12600   ; qkey
  7461 00003C38 0076F5C0                    dd 0xC0F57600   ; digin
  7462 00003C3C 001274CF                    dd 0xCF741200   ; qwert
  7463 00003C40 0000E01F                    dd 0x1FE00000   ; r?
  7464 00003C44 0000D46C                    dd 0x6CD40000   ; nul
  7465 00003C48 0000E092                    dd 0x92E00000   ; cad
  7466 00003C4C 00C025C5                    dd 0xC525C000   ; pcad
  7467 00003C50 40C5F0C0                    dd 0xC0F0C540   ; displ(ay)
  7468 00003C54 00801459                    dd 0x59148000   ; actc
  7469 00003C58 008147F7                    dd 0xF7478100   ; +list
  7470 00003C5C 00747972                    dd 0x72797400   ; itick
  7471 00003C60 0000C0A3                    dd 0xA3C00000   ; lis
  7472 00003C64 000080F6                    dd 0xF6800000   ; +e
  7473 00003C68 00140E82                    dd 0x820E1400   ; serve
  7474 00003C6C 004A0E4C                    dd 0x4C0E4A00   ; edita     editAddress
  7475 00003C70 603B3A96                    dd 0x963A3B60   ; cblind
  7476                                  
  7477 00003C74 0000C097                    dd 0x97C00000   ; c@        cFetch_
  7478 00003C78 0000C0BF                    dd 0xBFC00000   ; w@        wFetch_
  7479                                   ;   dd 0xF8000000   ; @         fetch_     replaced by optimising verson in block 24
  7480 00003C7C 0000A097                    dd 0x97A00000   ; c!        cStore_
  7481 00003C80 0000A0BF                    dd 0xBFA00000   ; w!        wStore_
  7482                                   ;   dd 0xF4000000   ; !         store_     replaced by optimising verson in block 24
  7483                                  
  7484 00003C84 203683D5                    dd 0xD5833620   ; 2dup      two_dup_
  7485                                  
  7486 00003C88 203683D5                    dd 0xD5833620   ; 2drop     two_drop_
  7487 00003C8C 20AE0BD5                    dd 0xD50BAE20   ; 2swap     two_swap_
  7488 00003C90 405078D4                    dd 0xD4785040   ; 2over     two_over_
  7489 00003C94 00002013                    dd 0x13200000   ; rot       rot_
  7490 00003C98 004026E6                    dd 0xE6264000   ; -rot      minus_rot_
  7491 00003C9C 00E8D22C                    dd 0x2CD2E800   ; tuck      tuck_
  7492 00003CA0 00E8F2C4                    dd 0xC4F2E800   ; pick      pick_
  7493                                  
  7494 00003CA4 00805292                    dd 0x92528000   ; cell      cell_
  7495 00003CA8 C09C5292                    dd 0x92529CC0   ; cell-     cell_minus_
  7496 00003CAC C09E5292                    dd 0x92529EC0   ; cell+     cell_plus_
  7497 00003CB0 00905292                    dd 0x92529000   ; cells     cells_
  7498                                  
  7499 00003CB4 000020A6                    dd 0xA6200000   ; lp        lp_
  7500                                  
  7501 00003CB8 0020E0A3                    dd 0xA3E02000   ; lidt      lidt_
  7502 00003CBC 0020E083                    dd 0x83E02000   ; sidt      sidt_
  7503                                  
  7504 00003CC0 0000DCD5                    dd 0xD5DC0000   ; 2/        two_slash_
  7505 00003CC4 000A4F94                    dd 0x944F0A00   ; cmove_
  7506 00003CC8 0000F4D5                    dd 0xD5F40000   ; 2*        two_star_
  7507 00003CCC 00E8F7D5                    dd 0xD5F7E800   ; 2**       two_star_star_
  7508                                  ;    dd 0xD5DC0000  ; u/        u/_
  7509 00003CD0 80CF2C96                    dd 0x962CCF80   ; cpuid     GetCPUID_
  7510 00003CD4 0009051C                    dd 0x1C050900   ; rdtsc
  7511 00003CD8 00006C15                    dd 0x156C0000   ; rand
  7512 00003CDC C01D6C15                    dd 0x156C1DC0   ; rand/     randInit_
  7513 00003CE0 C0196C15                    dd 0x156C19C0   ; randq
  7514 00003CE4 A05ECB90                    dd 0x90CB5EA0   ; crc32
  7515                                  
  7516                                  ;    dd 0xB18C5480   ; format
  7517                                  ;    dd 0xC5270000   ; pci
  7518                                  ;    dd 0x68248000   ; nsec      was devic(e)
  7519 00003CE8 90A5DC85                    dd 0x85DCA590   ; switch
  7520 00003CEC 4076A2B0                    dd 0xB0A27640   ; freeze
  7521 00003CF0 0000C423                    dd 0x23C40000   ; top
  7522                                  ;    dd 0xB1896480   ; forths
  7523                                  ;    dd 0x8AC84E00   ; macros
  7524 00003CF4 00000000                    dd 0
  7525                                  
  7526                                  ForthJumpTableROM:  ; jumptable:
  7527 00003CF8 [B32B0000]                  dd boot         ;
  7528 00003CFC [BD2E0000]                  dd warm         ;
  7529 00003D00 [0D040000]                  dd pause_       ; pause
  7530 00003D04 [B4050000]                  dd macro        ;
  7531 00003D08 [D4050000]                  dd forth        ;
  7532 00003D0C [D9040000]                  dd c_           ; c
  7533 00003D10 B8A90000                    dd Read_Sector_LBA   - $$ + BOOTOFFSET  ; jmp Read_Sector_LBA
  7534 00003D14 D0A90000                    dd Write_Sector_LBA  - $$ + BOOTOFFSET  ; jmp Write_Sector_LBA
  7535 00003D18 E8A90000                    dd ReadSectors  - $$ + BOOTOFFSET  ; jmp ReadSectors    reads
  7536 00003D1C 28AA0000                    dd WriteSectors - $$ + BOOTOFFSET  ; jmp WriteSectors   writes
  7537 00003D20 6FAA0000                    dd SaveAll_     - $$ + BOOTOFFSET  ; jmp SaveAll_
  7538                                  ;    dd th_        - $$ + BOOTOFFSET ; jmp th_ ( thunk to BIOS Int 0x13 )
  7539 00003D24 497F0000                    dd bios_read  - $$ + BOOTOFFSET ; jmp bios_read   'read'
  7540 00003D28 917F0000                    dd bios_write - $$ + BOOTOFFSET ; jmp bios_write  'write'
  7541                                  ;    dd XXXrsect_  - $$ + BOOTOFFSET ; jmp rsect_  'rsect'
  7542 00003D2C [A7310000]                  dd fetchDX_     ; @dx
  7543 00003D30 [BE2C0000]                  dd setupDAP_    ; !dap
  7544 00003D34 [3E040000]                  dd activate     ; act
  7545 00003D38 [59040000]                  dd show         ;
  7546 00003D3C [B8080000]                  dd _load_       ;
  7547 00003D40 [D8080000]                  dd nload        ; nload
  7548 00003D44 [E7080000]                  dd plusLoad     ; +load
  7549 00003D48 [F6080000]                  dd thru_        ; thru
  7550 00003D4C [29090000]                  dd plusThru_    ; +thru
  7551 00003D50 [44090000]                  dd cblk_        ;           return the block number currently being compiled, calculated from  edi
  7552 00003D54 [51090000]                  dd rblk_        ;           return the block number offset of the RELOCATED address
  7553 00003D58 [5C090000]                  dd ablk_        ;           convert byte address to block number
  7554 00003D5C [65090000]                  dd erase_       ;
  7555 00003D60 [2E080000]                  dd here         ;
  7556 00003D64 [39080000]                  dd qlit         ;
  7557 00003D68 [EA070000]                  dd comma3_      ;
  7558 00003D6C [E3070000]                  dd comma2_      ;
  7559 00003D70 [DC070000]                  dd comma1_      ;
  7560 00003D74 [C0070000]                  dd comma_       ;
  7561 00003D78 [80080000]                  dd less         ;
  7562 00003D7C [97080000]                  dd jump         ;
  7563 00003D80 [C6190000]                  dd accept       ;
  7564 00003D84 [37290000]                  dd keypd        ;
  7565 00003D88 [37290000]                  dd keypd        ;
  7566 00003D8C [B92B0000]                  dd wipe         ;
  7567 00003D90 [DA2B0000]                  dd wipes        ;
  7568 00003D94 [E52B0000]                  dd copy_        ; copy
  7569 00003D98 [DF040000]                  dd mark         ;
  7570 00003D9C [04050000]                  dd empty_       ; empty
  7571 00003DA0 [7F0E0000]                  dd emit_        ; emit
  7572 00003DA4 [B7100000]                  dd digit        ;
  7573 00003DA8 [A30E0000]                  dd two_emit     ; 2emit
  7574 00003DAC [34110000]                  dd dotDecimal   ; .
  7575 00003DB0 [E3100000]                  dd dotHex8      ; h.
  7576 00003DB4 [D1100000]                  dd h_dot_n      ; h.n
  7577 00003DB8 [BF090000]                  dd cr_          ; cr
  7578 00003DBC [910E0000]                  dd space_       ; space
  7579 00003DC0 [FB0F0000]                  dd down         ;
  7580 00003DC4 [B1280000]                  dd edit_        ;
  7581 00003DC8 [C3280000]                  dd e_           ; e
  7582 00003DCC [29100000]                  dd lm           ;
  7583 00003DD0 [30100000]                  dd rm           ;
  7584 00003DD4 [3D0A0000]                  dd graphAction  ; graph
  7585 00003DD8 [B50E0000]                  dd setupText_   ; text
  7586 00003DDC [1E130000]                  dd displayTheKeyboard ;
  7587 00003DE0 [162C0000]                  dd debug        ;
  7588 00003DE4 [37100000]                  dd _at          ; at
  7589 00003DE8 [46100000]                  dd plus_at      ; +at
  7590 00003DEC [20300000]                  dd xy_          ;
  7591 00003DF0 [0A0F0000]                  dd page_        ; page
  7592 00003DF4 [190F0000]                  dd screen_      ; screen
  7593 00003DF8 [2B300000]                  dd fov_         ;
  7594                                  ;    dd fifo         ;
  7595 00003DFC [F80E0000]                  dd box_         ; box
  7596 00003E00 [C70E0000]                  dd line_        ; line
  7597 00003E04 [140A0000]                  dd color        ;
  7598 00003E08 [83100000]                  dd octant       ;
  7599 00003E0C [36300000]                  dd tokenActions_ ; tokenActions table
  7600 00003E10 [DB300000]                  dd last         ;
  7601 00003E14 [671A0000]                  dd unpack       ;
  7602 00003E18 [2D180000]                  dd pack_        ;
  7603 00003E1C [E6300000]                  dd blk_         ;
  7604 00003E20 [91300000]                  dd scrnw_       ; scrnw  screen width in pixels
  7605 00003E24 [9F300000]                  dd scrnh_       ; scrnh  screen height in pixels
  7606 00003E28 [AD300000]                  dd bpp_         ; bpp    bits per pixel
  7607 00003E2C [D0300000]                  dd font_        ; font   address of font16x24
  7608 00003E30 [BA300000]                  dd iconw_       ; iconw  icon width in pixels
  7609 00003E34 [C5300000]                  dd iconh_       ; iconh  icon height in pixels
  7610 00003E38 [4C300000]                  dd version_     ; ver
  7611 00003E3C [FF300000]                  dd curs         ; curs
  7612 00003E40 [88300000]                  dd block_       ; block
  7613 00003E44 [57300000]                  dd vframe_      ; vframe
  7614 00003E48 [62300000]                  dd vars_        ; vars
  7615                                  ; new words
  7616 00003E4C [F1300000]                  dd seeb         ; seeb
  7617                                  ;    dd stacks_      ;
  7618 00003E50 [361E0000]                  dd dotsf_       ; dotsf
  7619 00003E54 [2D1E0000]                  dd leave_       ; leave
  7620                                  ;    dd txtq_        ;
  7621 00003E58 [1B0A0000]                  dd rgb          ; rgb
  7622 00003E5C [310A0000]                  dd bye_         ; bye
  7623 00003E60 [F0250000]                  dd _word        ;
  7624 00003E64 [0A310000]                  dd ekt          ;
  7625 00003E68 [58050000]                  dd abort        ;
  7626 00003E6C [62310000]                  dd tickh        ;
  7627 00003E70 [C4310000]                  dd buffer_      ; buffe(r)
  7628 00003E74 [83310000]                  dd offset_      ;
  7629 00003E78 [632C0000]                  dd tic_         ; tic
  7630 00003E7C [8E310000]                  dd vesa         ;
  7631 00003E80 [99310000]                  dd vesamode_    ;
  7632 00003E84 [B9310000]                  dd trash_       ; trash
  7633                                  ;    dd hsvv_        ; hsvv
  7634 00003E88 [15310000]                  dd vword_       ; ('%s')", DB_NAME,
  7635                                  ;    dd vregs_       ; vregs
  7636 00003E8C [20310000]                  dd ivec_         ; ivec
  7637 00003E90 [F6320000]                  dd restore_BIOS_idt_and_pic ; resb
  7638 00003E94 [2B310000]                  dd pic_         ; pic  Programmable Interrupt Controller settings, as set by the BIOS
  7639 00003E98 [36310000]                  dd dap_         ; dap
  7640 00003E9C [41310000]                  dd sect_        ; sect
  7641 00003EA0 [B82C0000]                  dd words_       ; words
  7642 00003EA4 [61160000]                  dd get_key_     ; key
  7643 00003EA8 [FE160000]                  dd get_qwerty_key_ ; qkey
  7644 00003EAC [4C310000]                  dd digin        ;
  7645 00003EB0 [302B0000]                  dd qwert        ;
  7646 00003EB4 [A22B0000]                  dd rquery       ; r?
  7647 00003EB8 [00040000]                  dd nul          ;
  7648 00003EBC [CF310000]                  dd cad          ;
  7649 00003EC0 [DA310000]                  dd pcad         ;
  7650 00003EC4 [F0310000]                  dd displ        ;
  7651 00003EC8 [57310000]                  dd actc         ;
  7652 00003ECC [06220000]                  dd plusList     ; +list
  7653 00003ED0 [802C0000]                  dd itick        ;
  7654 00003ED4 [84220000]                  dd refresh      ; lis
  7655 00003ED8 [CF280000]                  dd plus_e       ; +e
  7656 00003EDC [B9040000]                  dd serve        ;
  7657 00003EE0 [2C290000]                  dd editAddress  ; edita
  7658 00003EE4 [FB310000]                  dd cBlindAddr_  ; cblind
  7659                                  
  7660 00003EE8 [06320000]                  dd cFetch_      ; c@
  7661 00003EEC [0D320000]                  dd wFetch_      ; w@
  7662                                  ;    dd fetch_       ; @    replaced by optimising verson in block 24
  7663 00003EF0 [18320000]                  dd cStore_      ; c!
  7664 00003EF4 [1D320000]                  dd wStore_      ; w!
  7665                                  ;    dd store_       ; !    replaced by optimising verson in block 24
  7666                                  
  7667 00003EF8 [28320000]                  dd two_dup_     ; 2dup
  7668 00003EFC [34320000]                  dd two_drop_    ; 2drop
  7669 00003F00 [37320000]                  dd two_swap_    ; 2swap
  7670 00003F04 [43320000]                  dd two_over_    ; 2over
  7671 00003F08 [52320000]                  dd rot_         ; rot
  7672 00003F0C [5F320000]                  dd minus_rot_   ; -rot
  7673 00003F10 [6C320000]                  dd tuck_        ; tuck
  7674 00003F14 [77320000]                  dd pick_        ; pick
  7675                                  
  7676 00003F18 [7B320000]                  dd cell_        ; cell
  7677 00003F1C [86320000]                  dd cell_minus_  ; cell-
  7678 00003F20 [8C320000]                  dd cell_plus_   ; cell+
  7679 00003F24 [92320000]                  dd cells_       ; cells
  7680 00003F28 [BD330000]                  dd lp_          ; lp
  7681 00003F2C [97320000]                  dd lidt_        ; lidt
  7682 00003F30 [AE320000]                  dd sidt_        ; sidt
  7683 00003F34 [DE330000]                  dd two_slash_   ; 2/        two_slash_
  7684 00003F38 [E1330000]                  dd cmove_       ; cmove
  7685 00003F3C [FF330000]                  dd two_star_    ; 2*        two_star_
  7686 00003F40 [02340000]                  dd two_star_star_ ; 2**     two_star_star_
  7687                                  ;    dd u/_          ; u/        u/_
  7688                                  
  7689 00003F44 [29340000]                  dd GetCPUID_    ; cpuid
  7690 00003F48 [36340000]                  dd rdtsc_       ; rdtsc
  7691 00003F4C [80340000]                  dd rand_        ; rand
  7692 00003F50 [3E340000]                  dd randInit_    ; rand/
  7693 00003F54 [9E340000]                  dd randq_       ; randq
  7694 00003F58 [BA380000]                  dd crc32_       ; crc32
  7695                                  
  7696                                  ;    dd format       ;
  7697                                  ;    dd pci          ;
  7698                                  ;    dd device       ;
  7699 00003F5C [5B0E0000]                  dd switch       ;
  7700 00003F60 [A6040000]                  dd freeze       ;
  7701 00003F64 [9C090000]                  dd top_         ;
  7702                                  ;    dd forths_      ;
  7703                                  ;    dd macros_      ;
  7704                                  
  7705                                  ForthJumpTableROM_end:
  7706                                  
  7707                                  ; times 200 NOP   ;  enable this line to see how much space is left. If NASM reports :
  7708                                  ; "cf2019.nasm:6282: error: TIMES value -28 is negative" with "times 200" you have (200 - 28) bytes left
  7709                                  
  7710                                  ; fill with no-ops to 55AA at end of boot sector, less $40 for the info string
  7711 00003F68 90<rept>                times ( ( START_BLOCK_NUMBER - SIZE_OF_FONT_IN_BLOCKS ) * 0x400 ) - 0x40 - ($ - $$)  NOP
  7712                                  
  7713                                  version:
  7714 000067C0 636632303139203176-         db 'cf2019 1v0 2019Sep14 Chuck Moore' , 0x00    ; 0x20 + 1 bytes
  7715 000067C9 302032303139536570-
  7716 000067D2 313420436875636B20-
  7717 000067DB 4D6F6F726500       
  7718 000067E1 20486F77657264204F-         db ' Howerd Oakford inventio.co.uk' ,  0x00     ; 0x1E + 1 bytes, total 0x40
  7719 000067EA 616B666F726420696E-
  7720 000067F3 76656E74696F2E636F-
  7721 000067FC 2E756B00           
  7722                                  
  7723                                  ; the above produces a 22K boot image, we then add :
  7724                                  font16x24:
  7725                                  ; colorForth:                         ; the colorForth source blocks
  7726 00006800 <incbin>                incbin "cf2019Ref.img",OFFSET_OF_FONT, ( 512 * 1024 ) ; append the font and colorForth source blocks from the reference image, skip the kernel code
  7727                                  
  7728                                  ; end of file
